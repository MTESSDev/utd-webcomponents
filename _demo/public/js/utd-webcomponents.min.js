var utd = (function (exports) {
  'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }

    return _get.apply(this, arguments);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _createSuper$i(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$j(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$j() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /*! Wrapper pour les customElements afin de supporter les attributs kebab case avec les customElements de svelte. 
      Référence : https://github.com/sveltejs/svelte/issues/3852
  */
  var customElements = {
    define: function define(tagName, CustomElement) {
      var CustomElementWrapper = /*#__PURE__*/function (_CustomElement) {
        _inherits(CustomElementWrapper, _CustomElement);

        var _super = _createSuper$i(CustomElementWrapper);

        function CustomElementWrapper() {
          _classCallCheck(this, CustomElementWrapper);

          return _super.apply(this, arguments);
        }

        _createClass(CustomElementWrapper, [{
          key: "attributeChangedCallback",
          value: function attributeChangedCallback(attrName, oldValue, newValue) {
            _get(_getPrototypeOf(CustomElementWrapper.prototype), "attributeChangedCallback", this).call(this, attrName.replace(/-([a-z])/g, function (_, up) {
              return up.toUpperCase();
            }), oldValue, newValue === '' ? true : newValue // [Tweaked] Value of omitted value attribute will be true
            );
          }
        }], [{
          key: "observedAttributes",
          get: function get() {
            return (_get(_getPrototypeOf(CustomElementWrapper), "observedAttributes", this) || []).map(function (attr) {
              return attr.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();
            });
          }
        }]);

        return CustomElementWrapper;
      }(CustomElement);

      window.customElements.define(tagName, CustomElementWrapper); // <--- Call the actual customElements.define with our wrapper
    }
  };

  /*! utd-webcomponents v1.11.0 */
  //TODO ajouter possibilité que utd reçoive les textes de langue requis. De quelle façon?
  //A- En paramètre des méthodes qui en ont besoin
  //B- Globalement via une initialisation de texte UTD qui serait faite une fois.
  //IMPORTANT! Laisser ce commentaire, une fois le build terminé, il sera remplacé par une condition permettant de ne pas réexécuter le script (afin d'éviter les erreurs de custom elements dejà définis qui se produisent parfois. On suppose rechargement d'un onglet ou autre.)

  /*!_VerifierSiDejaCharge_*/

  /*======================================================================================================================*/

  /* -10- FENÊTRES DE MESSAGE
  /*======================================================================================================================*/
  var message = function () {
    var elementsPublics = {};
    /**
     * Affiche une fenêtre de message (dialog).
     * @param {Object} parametres Paramètres.
     * @param {Object} parametres.type Type de message ("erreur", "information", "avertissement", "succes"  pour l'instant, autres types à venir). Défaut "avertissement".
     * @param {Object} parametres.titre Titre du message. Texte brut ou HTML (ex. Annuler les modifications) Défaut "". 
     * @param {Object} parametres.corps Corps du message. Texte brut ou HTML (ex. Désirez-vous annuler les modifications ou poursuivre?.) Défaut "".
     * @param {Object} parametres.texteBoutonPrimaire Texte du bouton primaire. (Celui le plus à droite). Si vide n'est pas affiché.
     * @param {Object} parametres.texteBoutonSecondaire Texte du bouton secondaire. (Situé à la gauche du bouton primaire). Si vide n'est pas affiché.
     * @param {Object} parametres.texteBoutonFermer Texte du bouton de fermeture du message. Défaut "Fermer" ou "Close en anglais".
     * @param {Object} parametres.afficherBoutonFermer Afficher le bouton pour fermer la fenêtre de message. Défaut true.
     * @param {Object} parametres.idControleFocusFermeture Id du contrôle auquel on redonne le focus à la fermeture de la fenêtre de message. Si non spécifié, focus redonné à l'élément actif avant l'affichage du message.
     * @returns {Object} Une promesse jQuery qui contiendra éventuellement un objet contenant la raison de fermeture. (ex. objet.primaire ou objet.secondaire)
     * @example afficherMessage(parametres)
                .done(function (resultat) {
                    if (resultat.primaire) {
                        alert("Très bon choix! Poursuivre aurait pu causer une rupture du continuum espace temps!");
                    } else if (resultat.secondaire) {
                        alert("Mauvais choix! Vous auriez-du poursuivre. À cause de vous le continuum espace temps risque de se briser!");
                    } else {
                        alert("Vous vous êtes contenté de fermer la fenêtre sans faire de choix... La prochaine fois assumez-vous! L'avenir du monde est entre vos mains!");
                    }
                });
    * @references https://www.w3.org/TR/wai-aria-practices/examples/dialog-modal/alertdialog.html
    * @notes Le titre et les boutons sont lus 2 fois dans NVDA... ça semble faire partie du pattern (voir lien ci-dessus). 
    */

    elementsPublics.afficher = function (parametres) {
      var valeursDefaut = {
        type: "",
        titre: "",
        corps: "",
        texteBoutonPrimaire: "",
        texteBoutonSecondaire: "",
        texteBoutonFermer: obtenirLanguePage() === 'fr' ? "Fermer" : "Close",
        afficherBoutonFermer: false,
        estBoutonsTexteLong: false,
        idControleFocusFermeture: null
      };
      parametres = extend(valeursDefaut, parametres);
      parametres.idControleFocusFermeture = parametres.idControleFocusFermeture || obtenirIdControleActif();
      var conteneurFenetreMessage = ajouterControle(parametres);
      var fenetreMessage = conteneurFenetreMessage.querySelector('utd-dialog');
      var boutons = conteneurFenetreMessage.querySelectorAll('[slot="pied"] > button');
      boutons.forEach(function (btn) {
        btn.addEventListener("click", function () {
          var raison = this.getAttribute('raison-fermeture');
          fenetreMessage.setAttribute('raison-fermeture', raison);
          fenetreMessage.setAttribute('afficher', 'false');
        });
      }); //Définir une promesse qui sera résolue à la fermeture de la fenêtre.

      return new Promise(function (resolve) {
        definirEvenementFermeture(fenetreMessage, resolve);
        fenetreMessage.setAttribute('afficher', 'true');
      });
    };
    /**
     * (Privée)
     * Ajoute le contrôle de fenêtre de message au DOM.
     * @param {Object} parametres Paramètres de la function afficherMessage.
     * @returns Object correspondant au conteneur de la fenêtre de message.
     */


    function ajouterControle(parametres) {
      //    var classeIcone = obtenirClasseIcone(parametres.type);
      var type = parametres.type ? " type=\"".concat(parametres.type, "\" ") : '';
      var html = "\n        <utd-dialog titre=\"".concat(parametres.titre, "\" id-focus-fermeture=\"").concat(parametres.idControleFocusFermeture, "\" estfenetremessage=\"true\" boutons-texte-long=\"").concat(parametres.estBoutonsTexteLong, "\" ").concat(type, ">\n            <div slot=\"contenu\">\n                ").concat(parametres.corps, "\n            </div>\n            <div slot=\"pied\">");
      var htmlBoutonPrimaire = "<button type=\"button\" class=\"utd-btn primaire compact\" raison-fermeture=\"primaire\" data-ga-action=\"".concat(parametres.titre, "\">").concat(parametres.texteBoutonPrimaire, "</button>");
      var htmlBoutonSecondaire = parametres.texteBoutonSecondaire ? "<button type=\"button\" class=\"utd-btn secondaire compact\" raison-fermeture=\"secondaire\" data-ga-action=\"".concat(parametres.titre, "\">").concat(parametres.texteBoutonSecondaire, "</button>") : '';
      html += "\n                ".concat(htmlBoutonSecondaire).concat(htmlBoutonPrimaire, "                        \n            </div>\n        </utd-dialog>");
      var id = genererId();
      var conteneurFenetreMessage = document.createElement('div');
      conteneurFenetreMessage.id = id;
      conteneurFenetreMessage.innerHTML = html;
      document.body.appendChild(conteneurFenetreMessage);
      return conteneurFenetreMessage;
    }
    /**
     * (Privéee)
     * Compléter la promesse indiquant de quelle façon la fenêtre s'est fermée et supprimer l'élément du DOM une fois qu'il n'est plus affiché.
     * @param {Object} fenetreMessage Objet correspondant à la fenêtre de message.
     * @param {Promise} resolve Résolution de promesse.
     */


    function definirEvenementFermeture(fenetreMessage, resolve) {
      fenetreMessage.addEventListener("fermeture", function (e) {
        resolve(e.detail.raisonFermeture); //setTimeout ici afin de s'assurer que svelte a terminé son traitement avant de retirer le compsant du DOM

        setTimeout(function () {
          fenetreMessage.parentElement.remove();
        });
      });
    }

    return elementsPublics;
  }();
  /*======================================================================================================================*/

  /* -11- DIALOGUE
  /*======================================================================================================================*/

  var dialogue = function () {
    var elementsPublics = {};
    /**
    * Affiche une fenêtre de dialogue modal.
    * @param {Object} parametres Paramètres.
    * @param {Object} parametres.idDialogue Id du contrôle utd-dialog à afficher.
    * @param {Object} parametres.idControleFocusFermeture Id du contrôle auquel on redonne le focus à la fermeture du dialogue. Si non spécifié, focus redonné à l'élément actif avant l'affichage du message.
    */

    elementsPublics.afficher = function (idDialogue, idControleFocusFermeture) {
      if (!idDialogue) {
        console.error('utd.dialogue.afficher -> Aucun id de dialogue spécifié.');
        return;
      }

      idControleFocusFermeture = idControleFocusFermeture || obtenirIdControleActif();
      var dialogue = document.getElementById(idDialogue);

      if (dialogue) {
        dialogue.setAttribute('afficher', 'true');

        if (idControleFocusFermeture) {
          dialogue.setAttribute('id-focus-fermeture', idControleFocusFermeture);
        }
      } else {
        console.error("utd.dialogue.afficher -> Contr\xF4le utd-dialog \"".concat(dialogue, "\" non trouv\xE9."));
      }
    };

    elementsPublics.masquer = function (idDialogue) {
      if (!idDialogue) {
        console.error('utd.dialogue.masquer -> Aucun id de dialogue spécifié.');
        return;
      }

      var dialogue = document.getElementById(idDialogue);

      if (dialogue) {
        dialogue.setAttribute('afficher', 'false');
        var idFocus = dialogue.getAttribute('id-focus-fermeture');

        if (idFocus) {
          var controleFocus = document.getElementById(idFocus);

          if (controleFocus) {
            controleFocus.focus();
          } else {
            console.log("utd.dialogue.masquer -> Contr\xF4le \"".concat(idFocus, "\" \xE0 qui redonner le focus non trouv\xE9."));
          }
        }
      } else {
        console.error("utd.dialogue.masquer -> Contr\xF4le utd-dialog \"".concat(dialogue, "\" non trouv\xE9."));
      }
    };

    return elementsPublics;
  }();
  /*======================================================================================================================*/

  /* -20- TRAITEMENT EN COURS
  /*======================================================================================================================*/

  var traitementEnCours = function () {
    var elementsPublics = {};

    elementsPublics.debuter = function (element, avecOverlay) {
      avecOverlay = avecOverlay !== undefined ? avecOverlay : true;

      if (element && !element.getAttribute('overlay')) {
        //Ajouter un overlay global pendant le traitement en cours s'il y a lieu (défaut oui)  
        if (avecOverlay) {
          var overlay = document.createElement("div"); //Si un overlay est déjà présent, on ajoute le nouveau mais on le masque (il sera peut-être éventuellement réaffiché dans le traitement terminer du traitement en cours)

          if (document.getElementsByClassName('utd-overlay').length > 0) {
            overlay.classList.add('utd-d-none');
          }

          overlay.classList.add('utd-overlay');
          document.body.appendChild(overlay);
        }

        element.setAttribute('overlay', avecOverlay ? 'true' : 'false');

        if (element.tagName.toLowerCase() === 'button' || element.tagName.toLowerCase() === 'input' && element.type.toLowerCase() === 'submit') {
          element.classList.add("utd-traitement-en-cours");
          var htmlTraitementEnCours = '<div class="utd-spinner"></div>';

          if (element.getElementsByClassName('utd-spinner').length === 0) {
            element.innerHTML += htmlTraitementEnCours;
          }

          element.disabled = true;
        }

        notifierTraitementEnCoursLecteurEcran(element);
      }
    };

    elementsPublics.terminer = function (element) {
      if (element) {
        var spinner = element.querySelector('.utd-spinner');

        if (spinner) {
          spinner.remove();
        }

        element.classList.remove("utd-traitement-en-cours");
        element.disabled = false;
        supprimerOverlay(element);
        element.removeAttribute('overlay');
        notifierTraitementEnCoursLecteurEcran(element, true);
      }
    };

    function supprimerOverlay(element) {
      //Si le traitement en cours sur l'élément avait un overlay on le retire.
      var avecOverlay = element.getAttribute('overlay');

      if (avecOverlay === 'true') {
        //Retrait du overlay 
        var overlayTraitementEnCours = document.getElementsByClassName('utd-overlay');

        if (overlayTraitementEnCours.length > 1) {
          //On enlève 1 overlay, si un masqué existe c'est lui qu'on enlève. S'il y en a d'autres ils seront fermés éventuellement.
          var overlayInvisibles = document.getElementsByClassName('utd-overlay utd-d-none');

          if (overlayInvisibles.length > 0) {
            overlayInvisibles[0].remove();
          } else {
            //Si aucun overlay invisible, on enlève le 1er trouvé.
            overlayTraitementEnCours[0].remove();
          }
        } else if (overlayTraitementEnCours.length === 1) {
          overlayTraitementEnCours[0].remove();
        }
      }
    }

    function notifierTraitementEnCoursLecteurEcran(element, estTraitementTermine) {
      //Générer un id à l'élément qui va contenir le spinner de traitement en cours
      if (!element.id) {
        element.id = genererId();
      }

      var idZoneNotification = "zoneNotification_".concat(element.id); //Ajouter la zone de notification hors écran si elle n'existe pas déjà.

      var zoneNotificationsLecteurEcran = document.getElementById(idZoneNotification);

      if (!zoneNotificationsLecteurEcran) {
        zoneNotificationsLecteurEcran = document.createElement("div");
        zoneNotificationsLecteurEcran.id = idZoneNotification;
        zoneNotificationsLecteurEcran.classList.add('utd-sr-only');
        document.body.appendChild(zoneNotificationsLecteurEcran);
      }

      var texte = "";

      if (estTraitementTermine) {
        texte = obtenirLanguePage() === 'fr' ? "Traitement terminé." : "Processing complete.";
      } else {
        texte = obtenirLanguePage() === 'fr' ? "Traitement en cours." : "Processing...";
      }

      zoneNotificationsLecteurEcran.innerHTML = texte;
    }

    return elementsPublics;
  }();
  /*======================================================================================================================*/

  /* -30- NOTIFICATIONS
  /*======================================================================================================================*/

  var notification = function () {
    var elementsPublics = {};
    /**
     * Affiche une notification (toast).
     * @param {Object} parametres Paramètres.
     * @param {Object} parametres.type Type de notification (positif, negatif ou neutre). Défaut "positif".
     * @param {Object} parametres.titre Titre de la notification (ex. Succès) Défaut "Succès" ou "Échec".
     * @param {Object} parametres.message Message de la notification (ex. Enregistrement effectué avec succès.) Défaut "".
     * @param {Object} parametres.texteBoutonFermer Texte du bouton de fermeture de la notification. Défaut "Fermer".
     * @param {Object} parametres.delaiFermeture Délai (en ms) de fermeture automatique de la notification. Défaut 5000.
     */

    elementsPublics.emettre = function (parametres) {
      var valeursDefaut = {
        type: "positif",
        titre: "",
        //parametres.type == "echec" ? "Échec" : "Succès",
        message: "",
        texteBoutonFermer: obtenirLanguePage() === 'fr' ? "Fermer" : "Close",
        delaiFermeture: 5000
      };
      parametres = extend(valeursDefaut, parametres);
      var zoneNotifications = obtenirZoneNotifications();
      var notification = ajouterNotification(zoneNotifications, parametres);
      retirerNotificationApresDelai(notification, parametres);
    };
    /**
     * Obtient la node correspondant à la zone de notifications utd.
     * @returns {object} La zone de notifications utd.
     */


    function obtenirZoneNotifications() {
      var zoneNotifications = document.getElementById('utdZoneNotifications');

      if (!zoneNotifications) {
        zoneNotifications = document.createElement('div');
        zoneNotifications.id = 'utdZoneNotifications';
        zoneNotifications.classList.add('utd-notifications');
        document.body.appendChild(zoneNotifications);
      }

      return zoneNotifications;
    }
    /**
     * (Privée)
     * Ajoute une notification dans la zone des notifications.
     * @param {Object} zoneNotifications Node correspondant à la zone de notifications.
     * @param {Object} parametres Paramètres de la méthode emettre (qui permet d'émettre une notification).
     * @returns {Object} Node correspondant à la notification ajoutée.
     */


    function ajouterNotification(zoneNotifications, parametres) {
      var notification = document.createElement('div');
      notification.classList.add("notification", parametres.type);
      var possedeTitre = !!parametres.titre;

      if (!possedeTitre) {
        notification.classList.add("sans-titre");
      }

      notification.innerHTML = obtenirHtmlNotification(parametres, possedeTitre);
      definirEvenementClick(notification);
      zoneNotifications.appendChild(notification);
      afficherNotification(notification);
      return notification;
    }
    /**
     * 
     * @param {Object} parametres Paramètres de la méthode emettre (qui permet d'émettre une notification).
     * @param {Boolean} possedeTitre Indique si la notification possède un titre ou non.
     * @returns 
     */


    function obtenirHtmlNotification(parametres, possedeTitre) {
      var html = "\n            <button type=\"button\">\n                <span class=\"utd-sr-only\">".concat(parametres.texteBoutonFermer, "</span>\n                <span class=\"utd-icone-svg x-fermer-blanc\" aria-hidden=\"true\"></span>\n            </button>\n            <div role=\"alert\">");

      if (possedeTitre) {
        var classeIcone = obtenirClasseIcone(parametres.type);
        html += "\n                <div class=\"titre\">\n                    <span class=\"utd-icone-svg ".concat(classeIcone, " md\" aria-hidden=\"true\"></span>\n                    <span class=\"texte\">").concat(parametres.titre, "&nbsp;</span>\n                </div>            \n            ");
      }

      html += "\n            <div class=\"texte-message\">\n                ".concat(parametres.message, "\n            </div></div>");
      return html;
    }
    /**
     * Obtient la classe de l'icône de titre.
     * @param {string} type Type de notification
     * @returns {string} Classe de l'icône de titre pour le type spécifié.
     */


    function obtenirClasseIcone(type) {
      switch (type) {
        case "negatif":
          return "erreur-blanc";

        case "neutre":
          return "information-blanc";

        default:
          return "succes-blanc";
      }
    }
    /**
     * Affiche la notification en effectuant un fade in.
     * @param {Object} notification Node notification à afficher.
     */


    function afficherNotification(notification) {
      setTimeout(function () {
        notification.classList.add('visible');
      }, 10);
    }
    /**
     * Retire la notification après le délai prévu.
     * @param {Object} notification Node correspondant à la notification à retirer.
     * @param {Object} parametres Paramètres de la méthode emettre (qui permet d'émettre une notification).
     */


    function retirerNotificationApresDelai(notification, parametres) {
      setTimeout(function () {
        retirerNotification(notification);
      }, parametres.delaiFermeture);
    }
    /**
     * Retire la notification du dom et en effectuant un fade out.
     * @param {Object} notification Node correspondant à la notification à retirer.
     */


    function retirerNotification(notification) {
      var dureeAnimationMs = 500;
      notification.classList.remove('visible');
      setTimeout(function () {
        notification.remove();
      }, dureeAnimationMs);
    }
    /**
     * (Privéee)
     * Définit le traitement à effectuer sur le click d'une notification.
     * @param {Object} notification Node de notification sur laquelle on doit appliquer l'événement.
     */


    function definirEvenementClick(notification) {
      notification.addEventListener("click", function (e) {
        retirerNotification(notification);
      });
    }

    return elementsPublics;
  }();
  /* ============================================================= */

  /* ======================== UTILITAIRES ======================== */

  /* ============================================================= */

  /**
   * Obtient l'id du contrôle actif. Si le contrôle actif n'a pas d'id, on lui en assigne un.
   * @returns L'id du contrôle actif.
   */

  function obtenirIdControleActif() {
    if (document.activeElement) {
      var id = document.activeElement.id;

      if (!id) {
        id = genererId();
        document.activeElement.id = id;
      }

      return id;
    }

    return null;
  }
  /**
   * 
   * @param {Object} cible Objet dans lequel on doit copier les données. 
   * @param {Object} source Objet contenant les infos à copier dans l'objet cible. 
   * @returns 
   */

  function extend(cible, source) {
    for (var sourceProp in source) {
      var sourceVal = source[sourceProp]; // Is this value an object?  If so, iterate over its properties, copying them over

      if (sourceVal && Object.prototype.toString.call(sourceVal) === "[object Object]") {
        cible[sourceProp] = cible[sourceProp] || {};
        extend(cible[sourceProp], sourceVal);
      } else {
        cible[sourceProp] = sourceVal;
      }
    }

    return cible;
  }
  /**
   * Génère un id unique.
   * @returns Un id unique.
   */

  function genererId() {
    return Date.now().toString(36) + '-' + Math.random().toString(36).substr(2, 9);
  }
  /**
   * Normalise une chaîne de caractères pour utilisation insensible à la case et aux accents.
   * @param {string} chaineCaracteres Chaîne de caractères.
   * */

  function normaliserChaineCaracteres(chaineCaracteres) {
    return normaliserApostrophes(remplacerAccents(chaineCaracteres).toLowerCase());
  }
  /**
  * Normaliser les apostrophes d'une chaîne de caractères.
  * @param {string} chaineCaracteres Chaîne de caractères.
  **/

  function normaliserApostrophes(chaineCaracteres) {
    return chaineCaracteres.replace(/[\u2018-\u2019]/g, "'");
  }
  /**
   * Remplace les accents d'une chaîne de caractères.
   * @param {string} chaineCaracteres Chaîne de caractères.
   * */

  function remplacerAccents(chaineCaracteres) {
    return chaineCaracteres.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  }
  /**
   * Génère un id à partir du texte spécifié. Le texte est normalisé, puis tous les caractères non textuels sont remplacés par des underscore "_".
   * @param {string} texte Texte à partir duquel il faut créer un id.
   * @returns Un id généré à partir du texte.
   */

  function obtenirIdSelonTexte(texte) {
    var texteNormalise = normaliserChaineCaracteres(texte);
    return texteNormalise.replace(/\W/g, '_');
  }
  /**
   * Obtient la langue de la page courante.
   * @returns {string} Code de langue de la page courante (fr/en).
   */

  function obtenirLanguePage() {
    return document.getElementsByTagName("html")[0].getAttribute("lang") || "fr";
  }
  function ajusterAccessibiliteLiens(texteAccessibilite) {
    texteAccessibilite = texteAccessibilite || obtenirLanguePage() === 'fr' ? ". Ce lien sera ouvert dans un nouvel onglet." : ". This link will open in a new tab.";
    document.querySelectorAll('main a[target="_blank"]').forEach(function (lien) {
      //Ne pas traiter les liens sans href et les liens
      if (!lien.getAttribute('href')) {
        return;
      } //Ne pas traiter les liens vers des fichiers pdf ou les liens ayant explicitement une classe indiquant de ne pas les considérer comme lien externe(sans-lien-externe).  TODO éventuellement rafiner la condition afin de traiter uniquement les liens vers des pages web...


      if (lien.getAttribute('href').endsWith(".pdf") || lien.classList.contains("utd-sans-lien-externe")) {
        return;
      } //Ajouter la classe lien-externe afin d'afficher l'icône d'ouverture dans une nouvelle fenêtre.


      if (!lien.classList.contains("utd-lien-externe") && !lien.querySelector('.utd-lien-externe')) {
        lien.classList.add("utd-lien-externe");
      } //Ajouter le texte pour accessibilité nouvelle fenêtre si on détecte qu'il n'est pas là. TODO rafiner cette vérification éventuellement au besoin, il pourrait arriver qu'un .sr-only soit là pour autre chose dans le lien (très peu probable)


      if (!lien.querySelector(".utd-sr-only")) {
        lien.innerHTML = lien.innerHTML + "<span class=\"utd-sr-only\">".concat(texteAccessibilite, "</span>");
      }
    });
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _unsupportedIterableToArray$1(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _isNativeReflectConstruct$i() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct$i()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
  }

  function _createSuper$h(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$h(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$h() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function noop() {}

  var identity = function identity(x) {
    return x;
  };

  function assign(tar, src) {
    // @ts-ignore
    for (var k in src) {
      tar[k] = src[k];
    }

    return tar;
  }

  function add_location(element, file, line, column, char) {
    element.__svelte_meta = {
      loc: {
        file: file,
        line: line,
        column: column,
        char: char
      }
    };
  }

  function run(fn) {
    return fn();
  }

  function blank_object() {
    return Object.create(null);
  }

  function run_all(fns) {
    fns.forEach(run);
  }

  function is_function(thing) {
    return typeof thing === 'function';
  }

  function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || a && _typeof(a) === 'object' || typeof a === 'function';
  }

  var src_url_equal_anchor;

  function src_url_equal(element_src, url) {
    if (!src_url_equal_anchor) {
      src_url_equal_anchor = document.createElement('a');
    }

    src_url_equal_anchor.href = url;
    return element_src === src_url_equal_anchor.href;
  }

  function is_empty(obj) {
    return Object.keys(obj).length === 0;
  }

  function compute_slots(slots) {
    var result = {};

    for (var key in slots) {
      result[key] = true;
    }

    return result;
  }

  var is_client = typeof window !== 'undefined';
  var now = is_client ? function () {
    return window.performance.now();
  } : function () {
    return Date.now();
  };
  var raf = is_client ? function (cb) {
    return requestAnimationFrame(cb);
  } : noop; // used internally for testing

  var tasks = new Set();

  function run_tasks(now) {
    tasks.forEach(function (task) {
      if (!task.c(now)) {
        tasks.delete(task);
        task.f();
      }
    });
    if (tasks.size !== 0) raf(run_tasks);
  }
  /**
   * Creates a new task that runs on each raf frame
   * until it returns a falsy value or is aborted
   */


  function loop(callback) {
    var task;
    if (tasks.size === 0) raf(run_tasks);
    return {
      promise: new Promise(function (fulfill) {
        tasks.add(task = {
          c: callback,
          f: fulfill
        });
      }),
      abort: function abort() {
        tasks.delete(task);
      }
    };
  } // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM

  function append(target, node) {
    target.appendChild(node);
  }

  function get_root_for_style(node) {
    if (!node) return document;
    var root = node.getRootNode ? node.getRootNode() : node.ownerDocument;

    if (root && root.host) {
      return root;
    }

    return node.ownerDocument;
  }

  function append_empty_stylesheet(node) {
    var style_element = element('style');
    append_stylesheet(get_root_for_style(node), style_element);
    return style_element.sheet;
  }

  function append_stylesheet(node, style) {
    append(node.head || node, style);
    return style.sheet;
  }

  function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
  }

  function detach(node) {
    node.parentNode.removeChild(node);
  }

  function destroy_each(iterations, detaching) {
    for (var i = 0; i < iterations.length; i += 1) {
      if (iterations[i]) iterations[i].d(detaching);
    }
  }

  function element(name) {
    return document.createElement(name);
  }

  function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
  }

  function text(data) {
    return document.createTextNode(data);
  }

  function space() {
    return text(' ');
  }

  function empty() {
    return text('');
  }

  function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return function () {
      return node.removeEventListener(event, handler, options);
    };
  }

  function prevent_default(fn) {
    return function (event) {
      event.preventDefault(); // @ts-ignore

      return fn.call(this, event);
    };
  }

  function attr(node, attribute, value) {
    if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
  }

  function set_attributes(node, attributes) {
    // @ts-ignore
    var descriptors = Object.getOwnPropertyDescriptors(node.__proto__);

    for (var key in attributes) {
      if (attributes[key] == null) {
        node.removeAttribute(key);
      } else if (key === 'style') {
        node.style.cssText = attributes[key];
      } else if (key === '__value') {
        node.value = node[key] = attributes[key];
      } else if (descriptors[key] && descriptors[key].set) {
        node[key] = attributes[key];
      } else {
        attr(node, key, attributes[key]);
      }
    }
  }

  function children(element) {
    return Array.from(element.childNodes);
  }

  function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
  }

  function custom_event(type, detail) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref$bubbles = _ref.bubbles,
        bubbles = _ref$bubbles === void 0 ? false : _ref$bubbles,
        _ref$cancelable = _ref.cancelable,
        cancelable = _ref$cancelable === void 0 ? false : _ref$cancelable;

    var e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, bubbles, cancelable, detail);
    return e;
  }

  var HtmlTag = /*#__PURE__*/function () {
    function HtmlTag() {
      var is_svg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      _classCallCheck(this, HtmlTag);

      this.is_svg = false;
      this.is_svg = is_svg;
      this.e = this.n = null;
    }

    _createClass(HtmlTag, [{
      key: "c",
      value: function c(html) {
        this.h(html);
      }
    }, {
      key: "m",
      value: function m(html, target) {
        var anchor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        if (!this.e) {
          if (this.is_svg) this.e = svg_element(target.nodeName);else this.e = element(target.nodeName);
          this.t = target;
          this.c(html);
        }

        this.i(anchor);
      }
    }, {
      key: "h",
      value: function h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
      }
    }, {
      key: "i",
      value: function i(anchor) {
        for (var i = 0; i < this.n.length; i += 1) {
          insert(this.t, this.n[i], anchor);
        }
      }
    }, {
      key: "p",
      value: function p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
      }
    }, {
      key: "d",
      value: function d() {
        this.n.forEach(detach);
      }
    }]);

    return HtmlTag;
  }();

  function attribute_to_object(attributes) {
    var result = {};

    var _iterator2 = _createForOfIteratorHelper(attributes),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var attribute = _step2.value;
        result[attribute.name] = attribute.value;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return result;
  }

  function get_custom_elements_slots(element) {
    var result = {};
    element.childNodes.forEach(function (node) {
      result[node.slot || 'default'] = true;
    });
    return result;
  } // we need to store the information for multiple documents because a Svelte application could also contain iframes
  // https://github.com/sveltejs/svelte/issues/3624


  var managed_styles = new Map();
  var active = 0; // https://github.com/darkskyapp/string-hash/blob/master/index.js

  function hash(str) {
    var hash = 5381;
    var i = str.length;

    while (i--) {
      hash = (hash << 5) - hash ^ str.charCodeAt(i);
    }

    return hash >>> 0;
  }

  function create_style_information(doc, node) {
    var info = {
      stylesheet: append_empty_stylesheet(node),
      rules: {}
    };
    managed_styles.set(doc, info);
    return info;
  }

  function create_rule(node, a, b, duration, delay, ease, fn) {
    var uid = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
    var step = 16.666 / duration;
    var keyframes = '{\n';

    for (var p = 0; p <= 1; p += step) {
      var t = a + (b - a) * ease(p);
      keyframes += p * 100 + "%{".concat(fn(t, 1 - t), "}\n");
    }

    var rule = keyframes + "100% {".concat(fn(b, 1 - b), "}\n}");
    var name = "__svelte_".concat(hash(rule), "_").concat(uid);
    var doc = get_root_for_style(node);

    var _ref2 = managed_styles.get(doc) || create_style_information(doc, node),
        stylesheet = _ref2.stylesheet,
        rules = _ref2.rules;

    if (!rules[name]) {
      rules[name] = true;
      stylesheet.insertRule("@keyframes ".concat(name, " ").concat(rule), stylesheet.cssRules.length);
    }

    var animation = node.style.animation || '';
    node.style.animation = "".concat(animation ? "".concat(animation, ", ") : '').concat(name, " ").concat(duration, "ms linear ").concat(delay, "ms 1 both");
    active += 1;
    return name;
  }

  function delete_rule(node, name) {
    var previous = (node.style.animation || '').split(', ');
    var next = previous.filter(name ? function (anim) {
      return anim.indexOf(name) < 0;
    } // remove specific animation
    : function (anim) {
      return anim.indexOf('__svelte') === -1;
    } // remove all Svelte animations
    );
    var deleted = previous.length - next.length;

    if (deleted) {
      node.style.animation = next.join(', ');
      active -= deleted;
      if (!active) clear_rules();
    }
  }

  function clear_rules() {
    raf(function () {
      if (active) return;
      managed_styles.forEach(function (info) {
        var ownerNode = info.stylesheet.ownerNode; // there is no ownerNode if it runs on jsdom.

        if (ownerNode) detach(ownerNode);
      });
      managed_styles.clear();
    });
  }

  var current_component;

  function set_current_component(component) {
    current_component = component;
  }

  function get_current_component() {
    if (!current_component) throw new Error('Function called outside component initialization');
    return current_component;
  }

  function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
  }

  var dirty_components = [];
  var binding_callbacks = [];
  var render_callbacks = [];
  var flush_callbacks = [];
  var resolved_promise = Promise.resolve();
  var update_scheduled = false;

  function schedule_update() {
    if (!update_scheduled) {
      update_scheduled = true;
      resolved_promise.then(flush);
    }
  }

  function add_render_callback(fn) {
    render_callbacks.push(fn);
  }
  // 1. All beforeUpdate callbacks, in order: parents before children
  // 2. All bind:this callbacks, in reverse order: children before parents.
  // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
  //    for afterUpdates called during the initial onMount, which are called in
  //    reverse order: children before parents.
  // Since callbacks might update component values, which could trigger another
  // call to flush(), the following steps guard against this:
  // 1. During beforeUpdate, any updated components will be added to the
  //    dirty_components array and will cause a reentrant call to flush(). Because
  //    the flush index is kept outside the function, the reentrant call will pick
  //    up where the earlier call left off and go through all dirty components. The
  //    current_component value is saved and restored so that the reentrant call will
  //    not interfere with the "parent" flush() call.
  // 2. bind:this callbacks cannot trigger new flush() calls.
  // 3. During afterUpdate, any updated components will NOT have their afterUpdate
  //    callback called a second time; the seen_callbacks set, outside the flush()
  //    function, guarantees this behavior.


  var seen_callbacks = new Set();
  var flushidx = 0; // Do *not* move this inside the flush() function

  function flush() {
    var saved_component = current_component;

    do {
      // first, call beforeUpdate functions
      // and update components
      while (flushidx < dirty_components.length) {
        var component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }

      set_current_component(null);
      dirty_components.length = 0;
      flushidx = 0;

      while (binding_callbacks.length) {
        binding_callbacks.pop()();
      } // then, once components are updated, call
      // afterUpdate functions. This may cause
      // subsequent updates...


      for (var i = 0; i < render_callbacks.length; i += 1) {
        var callback = render_callbacks[i];

        if (!seen_callbacks.has(callback)) {
          // ...so guard against infinite loops
          seen_callbacks.add(callback);
          callback();
        }
      }

      render_callbacks.length = 0;
    } while (dirty_components.length);

    while (flush_callbacks.length) {
      flush_callbacks.pop()();
    }

    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
  }

  function update($$) {
    if ($$.fragment !== null) {
      $$.update();
      run_all($$.before_update);
      var dirty = $$.dirty;
      $$.dirty = [-1];
      $$.fragment && $$.fragment.p($$.ctx, dirty);
      $$.after_update.forEach(add_render_callback);
    }
  }

  var promise;

  function wait() {
    if (!promise) {
      promise = Promise.resolve();
      promise.then(function () {
        promise = null;
      });
    }

    return promise;
  }

  function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event("".concat(direction ? 'intro' : 'outro').concat(kind)));
  }

  var outroing = new Set();
  var outros;

  function group_outros() {
    outros = {
      r: 0,
      c: [],
      p: outros // parent group

    };
  }

  function check_outros() {
    if (!outros.r) {
      run_all(outros.c);
    }

    outros = outros.p;
  }

  function transition_in(block, local) {
    if (block && block.i) {
      outroing.delete(block);
      block.i(local);
    }
  }

  function transition_out(block, local, detach, callback) {
    if (block && block.o) {
      if (outroing.has(block)) return;
      outroing.add(block);
      outros.c.push(function () {
        outroing.delete(block);

        if (callback) {
          if (detach) block.d(1);
          callback();
        }
      });
      block.o(local);
    } else if (callback) {
      callback();
    }
  }

  var null_transition = {
    duration: 0
  };

  function create_in_transition(node, fn, params) {
    var config = fn(node, params);
    var running = false;
    var animation_name;
    var task;
    var uid = 0;

    function cleanup() {
      if (animation_name) delete_rule(node, animation_name);
    }

    function go() {
      var _ref4 = config || null_transition,
          _ref4$delay = _ref4.delay,
          delay = _ref4$delay === void 0 ? 0 : _ref4$delay,
          _ref4$duration = _ref4.duration,
          duration = _ref4$duration === void 0 ? 300 : _ref4$duration,
          _ref4$easing = _ref4.easing,
          easing = _ref4$easing === void 0 ? identity : _ref4$easing,
          _ref4$tick = _ref4.tick,
          tick = _ref4$tick === void 0 ? noop : _ref4$tick,
          css = _ref4.css;

      if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
      tick(0, 1);
      var start_time = now() + delay;
      var end_time = start_time + duration;
      if (task) task.abort();
      running = true;
      add_render_callback(function () {
        return dispatch(node, true, 'start');
      });
      task = loop(function (now) {
        if (running) {
          if (now >= end_time) {
            tick(1, 0);
            dispatch(node, true, 'end');
            cleanup();
            return running = false;
          }

          if (now >= start_time) {
            var t = easing((now - start_time) / duration);
            tick(t, 1 - t);
          }
        }

        return running;
      });
    }

    var started = false;
    return {
      start: function start() {
        if (started) return;
        started = true;
        delete_rule(node);

        if (is_function(config)) {
          config = config();
          wait().then(go);
        } else {
          go();
        }
      },
      invalidate: function invalidate() {
        started = false;
      },
      end: function end() {
        if (running) {
          cleanup();
          running = false;
        }
      }
    };
  }

  function create_out_transition(node, fn, params) {
    var config = fn(node, params);
    var running = true;
    var animation_name;
    var group = outros;
    group.r += 1;

    function go() {
      var _ref5 = config || null_transition,
          _ref5$delay = _ref5.delay,
          delay = _ref5$delay === void 0 ? 0 : _ref5$delay,
          _ref5$duration = _ref5.duration,
          duration = _ref5$duration === void 0 ? 300 : _ref5$duration,
          _ref5$easing = _ref5.easing,
          easing = _ref5$easing === void 0 ? identity : _ref5$easing,
          _ref5$tick = _ref5.tick,
          tick = _ref5$tick === void 0 ? noop : _ref5$tick,
          css = _ref5.css;

      if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
      var start_time = now() + delay;
      var end_time = start_time + duration;
      add_render_callback(function () {
        return dispatch(node, false, 'start');
      });
      loop(function (now) {
        if (running) {
          if (now >= end_time) {
            tick(0, 1);
            dispatch(node, false, 'end');

            if (! --group.r) {
              // this will result in `end()` being called,
              // so we don't need to clean up here
              run_all(group.c);
            }

            return false;
          }

          if (now >= start_time) {
            var t = easing((now - start_time) / duration);
            tick(1 - t, t);
          }
        }

        return running;
      });
    }

    if (is_function(config)) {
      wait().then(function () {
        // @ts-ignore
        config = config();
        go();
      });
    } else {
      go();
    }

    return {
      end: function end(reset) {
        if (reset && config.tick) {
          config.tick(1, 0);
        }

        if (running) {
          if (animation_name) delete_rule(node, animation_name);
          running = false;
        }
      }
    };
  }

  function create_bidirectional_transition(node, fn, params, intro) {
    var config = fn(node, params);
    var t = intro ? 0 : 1;
    var running_program = null;
    var pending_program = null;
    var animation_name = null;

    function clear_animation() {
      if (animation_name) delete_rule(node, animation_name);
    }

    function init(program, duration) {
      var d = program.b - t;
      duration *= Math.abs(d);
      return {
        a: t,
        b: program.b,
        d: d,
        duration: duration,
        start: program.start,
        end: program.start + duration,
        group: program.group
      };
    }

    function go(b) {
      var _ref6 = config || null_transition,
          _ref6$delay = _ref6.delay,
          delay = _ref6$delay === void 0 ? 0 : _ref6$delay,
          _ref6$duration = _ref6.duration,
          duration = _ref6$duration === void 0 ? 300 : _ref6$duration,
          _ref6$easing = _ref6.easing,
          easing = _ref6$easing === void 0 ? identity : _ref6$easing,
          _ref6$tick = _ref6.tick,
          tick = _ref6$tick === void 0 ? noop : _ref6$tick,
          css = _ref6.css;

      var program = {
        start: now() + delay,
        b: b
      };

      if (!b) {
        // @ts-ignore todo: improve typings
        program.group = outros;
        outros.r += 1;
      }

      if (running_program || pending_program) {
        pending_program = program;
      } else {
        // if this is an intro, and there's a delay, we need to do
        // an initial tick and/or apply CSS animation immediately
        if (css) {
          clear_animation();
          animation_name = create_rule(node, t, b, duration, delay, easing, css);
        }

        if (b) tick(0, 1);
        running_program = init(program, duration);
        add_render_callback(function () {
          return dispatch(node, b, 'start');
        });
        loop(function (now) {
          if (pending_program && now > pending_program.start) {
            running_program = init(pending_program, duration);
            pending_program = null;
            dispatch(node, running_program.b, 'start');

            if (css) {
              clear_animation();
              animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
            }
          }

          if (running_program) {
            if (now >= running_program.end) {
              tick(t = running_program.b, 1 - t);
              dispatch(node, running_program.b, 'end');

              if (!pending_program) {
                // we're done
                if (running_program.b) {
                  // intro — we can tidy up immediately
                  clear_animation();
                } else {
                  // outro — needs to be coordinated
                  if (! --running_program.group.r) run_all(running_program.group.c);
                }
              }

              running_program = null;
            } else if (now >= running_program.start) {
              var p = now - running_program.start;
              t = running_program.a + running_program.d * easing(p / running_program.duration);
              tick(t, 1 - t);
            }
          }

          return !!(running_program || pending_program);
        });
      }
    }

    return {
      run: function run(b) {
        if (is_function(config)) {
          wait().then(function () {
            // @ts-ignore
            config = config();
            go(b);
          });
        } else {
          go(b);
        }
      },
      end: function end() {
        clear_animation();
        running_program = pending_program = null;
      }
    };
  }

  var globals = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : global;

  function get_spread_update(levels, updates) {
    var update = {};
    var to_null_out = {};
    var accounted_for = {
      $$scope: 1
    };
    var i = levels.length;

    while (i--) {
      var o = levels[i];
      var n = updates[i];

      if (n) {
        for (var key in o) {
          if (!(key in n)) to_null_out[key] = 1;
        }

        for (var _key3 in n) {
          if (!accounted_for[_key3]) {
            update[_key3] = n[_key3];
            accounted_for[_key3] = 1;
          }
        }

        levels[i] = n;
      } else {
        for (var _key4 in o) {
          accounted_for[_key4] = 1;
        }
      }
    }

    for (var _key5 in to_null_out) {
      if (!(_key5 in update)) update[_key5] = undefined;
    }

    return update;
  }
  /** regex of all html void element names */

  var void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;

  function is_void(name) {
    return void_element_names.test(name) || name.toLowerCase() === '!doctype';
  }

  function mount_component(component, target, anchor, customElement) {
    var _component$$$ = component.$$,
        fragment = _component$$$.fragment,
        on_mount = _component$$$.on_mount,
        on_destroy = _component$$$.on_destroy,
        after_update = _component$$$.after_update;
    fragment && fragment.m(target, anchor);

    if (!customElement) {
      // onMount happens before the initial afterUpdate
      add_render_callback(function () {
        var new_on_destroy = on_mount.map(run).filter(is_function);

        if (on_destroy) {
          on_destroy.push.apply(on_destroy, _toConsumableArray(new_on_destroy));
        } else {
          // Edge case - component was destroyed immediately,
          // most likely as a result of a binding initialising
          run_all(new_on_destroy);
        }

        component.$$.on_mount = [];
      });
    }

    after_update.forEach(add_render_callback);
  }

  function destroy_component(component, detaching) {
    var $$ = component.$$;

    if ($$.fragment !== null) {
      run_all($$.on_destroy);
      $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to
      // preserve final state?)

      $$.on_destroy = $$.fragment = null;
      $$.ctx = [];
    }
  }

  function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
      dirty_components.push(component);
      schedule_update();
      component.$$.dirty.fill(0);
    }

    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
  }

  function init(component, options, instance, create_fragment, not_equal, props, append_styles) {
    var dirty = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [-1];
    var parent_component = current_component;
    set_current_component(component);
    var $$ = component.$$ = {
      fragment: null,
      ctx: null,
      // state
      props: props,
      update: noop,
      not_equal: not_equal,
      bound: blank_object(),
      // lifecycle
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
      // everything else
      callbacks: blank_object(),
      dirty: dirty,
      skip_bound: false,
      root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    var ready = false;
    $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {
      var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;

      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
        if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
        if (ready) make_dirty(component, i);
      }

      return ret;
    }) : [];
    $$.update();
    ready = true;
    run_all($$.before_update); // `false` as a special case of no DOM component

    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;

    if (options.target) {
      if (options.hydrate) {
        var nodes = children(options.target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

        $$.fragment && $$.fragment.l(nodes);
        nodes.forEach(detach);
      } else {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        $$.fragment && $$.fragment.c();
      }

      if (options.intro) transition_in(component.$$.fragment);
      mount_component(component, options.target, options.anchor, options.customElement);
      flush();
    }

    set_current_component(parent_component);
  }

  var SvelteElement;

  if (typeof HTMLElement === 'function') {
    SvelteElement = /*#__PURE__*/function (_HTMLElement) {
      _inherits(SvelteElement, _HTMLElement);

      var _super2 = _createSuper$h(SvelteElement);

      function SvelteElement() {
        var _this3;

        _classCallCheck(this, SvelteElement);

        _this3 = _super2.call(this);

        _this3.attachShadow({
          mode: 'open'
        });

        return _this3;
      }

      _createClass(SvelteElement, [{
        key: "connectedCallback",
        value: function connectedCallback() {
          var on_mount = this.$$.on_mount;
          this.$$.on_disconnect = on_mount.map(run).filter(is_function); // @ts-ignore todo: improve typings

          for (var key in this.$$.slotted) {
            // @ts-ignore todo: improve typings
            this.appendChild(this.$$.slotted[key]);
          }
        }
      }, {
        key: "attributeChangedCallback",
        value: function attributeChangedCallback(attr, _oldValue, newValue) {
          this[attr] = newValue;
        }
      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          run_all(this.$$.on_disconnect);
        }
      }, {
        key: "$destroy",
        value: function $destroy() {
          destroy_component(this, 1);
          this.$destroy = noop;
        }
      }, {
        key: "$on",
        value: function $on(type, callback) {
          // TODO should this delegate to addEventListener?
          var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
          callbacks.push(callback);
          return function () {
            var index = callbacks.indexOf(callback);
            if (index !== -1) callbacks.splice(index, 1);
          };
        }
      }, {
        key: "$set",
        value: function $set($$props) {
          if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
          }
        }
      }]);

      return SvelteElement;
    }( /*#__PURE__*/_wrapNativeSuper(HTMLElement));
  }

  function dispatch_dev(type, detail) {
    document.dispatchEvent(custom_event(type, Object.assign({
      version: '3.50.1'
    }, detail), {
      bubbles: true
    }));
  }

  function append_dev(target, node) {
    dispatch_dev('SvelteDOMInsert', {
      target: target,
      node: node
    });
    append(target, node);
  }

  function insert_dev(target, node, anchor) {
    dispatch_dev('SvelteDOMInsert', {
      target: target,
      node: node,
      anchor: anchor
    });
    insert(target, node, anchor);
  }

  function detach_dev(node) {
    dispatch_dev('SvelteDOMRemove', {
      node: node
    });
    detach(node);
  }

  function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
    var modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
    if (has_prevent_default) modifiers.push('preventDefault');
    if (has_stop_propagation) modifiers.push('stopPropagation');
    dispatch_dev('SvelteDOMAddEventListener', {
      node: node,
      event: event,
      handler: handler,
      modifiers: modifiers
    });
    var dispose = listen(node, event, handler, options);
    return function () {
      dispatch_dev('SvelteDOMRemoveEventListener', {
        node: node,
        event: event,
        handler: handler,
        modifiers: modifiers
      });
      dispose();
    };
  }

  function attr_dev(node, attribute, value) {
    attr(node, attribute, value);
    if (value == null) dispatch_dev('SvelteDOMRemoveAttribute', {
      node: node,
      attribute: attribute
    });else dispatch_dev('SvelteDOMSetAttribute', {
      node: node,
      attribute: attribute,
      value: value
    });
  }

  function prop_dev(node, property, value) {
    node[property] = value;
    dispatch_dev('SvelteDOMSetProperty', {
      node: node,
      property: property,
      value: value
    });
  }

  function set_data_dev(text, data) {
    data = '' + data;
    if (text.wholeText === data) return;
    dispatch_dev('SvelteDOMSetData', {
      node: text,
      data: data
    });
    text.data = data;
  }

  function validate_each_argument(arg) {
    if (typeof arg !== 'string' && !(arg && _typeof(arg) === 'object' && 'length' in arg)) {
      var msg = '{#each} only iterates over array-like objects.';

      if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
        msg += ' You can use a spread to convert this iterable into an array.';
      }

      throw new Error(msg);
    }
  }

  function validate_slots(name, slot, keys) {
    for (var _i4 = 0, _Object$keys = Object.keys(slot); _i4 < _Object$keys.length; _i4++) {
      var slot_key = _Object$keys[_i4];

      if (!~keys.indexOf(slot_key)) {
        console.warn("<".concat(name, "> received an unexpected slot \"").concat(slot_key, "\"."));
      }
    }
  }

  function validate_dynamic_element(tag) {
    var is_string = typeof tag === 'string';

    if (tag && !is_string) {
      throw new Error('<svelte:element> expects "this" attribute to be a string.');
    }
  }

  function validate_void_dynamic_element(tag) {
    if (tag && is_void(tag)) {
      throw new Error("<svelte:element this=\"".concat(tag, "\"> is self-closing and cannot have content."));
    }
  }

  function cubicOut(t) {
    var f = t - 1.0;
    return f * f * f + 1.0;
  }

  function fade(node) {
    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === void 0 ? 0 : _ref2$delay,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === void 0 ? 400 : _ref2$duration,
        _ref2$easing = _ref2.easing,
        easing = _ref2$easing === void 0 ? identity : _ref2$easing;

    var o = +getComputedStyle(node).opacity;
    return {
      delay: delay,
      duration: duration,
      easing: easing,
      css: function css(t) {
        return "opacity: ".concat(t * o);
      }
    };
  }

  function fly(node) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref3$delay = _ref3.delay,
        delay = _ref3$delay === void 0 ? 0 : _ref3$delay,
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === void 0 ? 400 : _ref3$duration,
        _ref3$easing = _ref3.easing,
        easing = _ref3$easing === void 0 ? cubicOut : _ref3$easing,
        _ref3$x = _ref3.x,
        x = _ref3$x === void 0 ? 0 : _ref3$x,
        _ref3$y = _ref3.y,
        y = _ref3$y === void 0 ? 0 : _ref3$y,
        _ref3$opacity = _ref3.opacity,
        opacity = _ref3$opacity === void 0 ? 0 : _ref3$opacity;

    var style = getComputedStyle(node);
    var target_opacity = +style.opacity;
    var transform = style.transform === 'none' ? '' : style.transform;
    var od = target_opacity * (1 - opacity);
    return {
      delay: delay,
      duration: duration,
      easing: easing,
      css: function css(t, u) {
        return "\n\t\t\ttransform: ".concat(transform, " translate(").concat((1 - t) * x, "px, ").concat((1 - t) * y, "px);\n\t\t\topacity: ").concat(target_opacity - od * u);
      }
    };
  }

  function slide(node) {
    var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref4$delay = _ref4.delay,
        delay = _ref4$delay === void 0 ? 0 : _ref4$delay,
        _ref4$duration = _ref4.duration,
        duration = _ref4$duration === void 0 ? 400 : _ref4$duration,
        _ref4$easing = _ref4.easing,
        easing = _ref4$easing === void 0 ? cubicOut : _ref4$easing;

    var style = getComputedStyle(node);
    var opacity = +style.opacity;
    var height = parseFloat(style.height);
    var padding_top = parseFloat(style.paddingTop);
    var padding_bottom = parseFloat(style.paddingBottom);
    var margin_top = parseFloat(style.marginTop);
    var margin_bottom = parseFloat(style.marginBottom);
    var border_top_width = parseFloat(style.borderTopWidth);
    var border_bottom_width = parseFloat(style.borderBottomWidth);
    return {
      delay: delay,
      duration: duration,
      easing: easing,
      css: function css(t) {
        return 'overflow: hidden;' + "opacity: ".concat(Math.min(t * 20, 1) * opacity, ";") + "height: ".concat(t * height, "px;") + "padding-top: ".concat(t * padding_top, "px;") + "padding-bottom: ".concat(t * padding_bottom, "px;") + "margin-top: ".concat(t * margin_top, "px;") + "margin-bottom: ".concat(t * margin_bottom, "px;") + "border-top-width: ".concat(t * border_top_width, "px;") + "border-bottom-width: ".concat(t * border_bottom_width, "px;");
      }
    };
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var Utils = /*#__PURE__*/function () {
    function Utils() {
      _classCallCheck(this, Utils);
    }

    _createClass(Utils, null, [{
      key: "conserverFocusElement",
      value: function conserverFocusElement(componentShadow, componentRoot) {
        var elementsFocusablesShadow = Array.from(this.obtenirElementsFocusables(componentShadow));
        var elementsFocusablesRoot = Array.from(this.obtenirElementsFocusables(componentRoot));
        var elementsFocusables = elementsFocusablesShadow.concat(elementsFocusablesRoot);
        var premierElementFocusable = elementsFocusables[0];
        var dernierElementFocusable = elementsFocusables[elementsFocusables.length - 1];
        var KEYCODE_TAB = 9;
        componentShadow.addEventListener('keydown', function (e) {
          var estToucheTab = e.key === 'Tab' || e.keyCode === KEYCODE_TAB;

          if (!estToucheTab) {
            return;
          }

          var elementActif = document.activeElement.shadowRoot ? document.activeElement.shadowRoot.activeElement : document.activeElement;

          if (e.shiftKey)
            /* shift + tab */
            {
              if (elementActif === premierElementFocusable) {
                dernierElementFocusable.focus();
                e.preventDefault();
              }
            } else
            /* tab */
            {
              if (elementsFocusables.length === 1 || elementActif === dernierElementFocusable) {
                premierElementFocusable.focus();
                e.preventDefault();
              }
            }
        });
      }
    }, {
      key: "obtenirElementsFocusables",
      value: function obtenirElementsFocusables(element) {
        return element.querySelectorAll('a[href]:not([disabled]), button:not([disabled]), textarea:not([disabled]), input:not([type="hidden"]):not([disabled]), select:not([disabled])');
      }
      /**
       * Génère un id unique.
       * @returns L'id unique généré.
       */

    }, {
      key: "genererId",
      value: function genererId() {
        return Date.now().toString(36) + '-' + Math.random().toString(36).substr(2, 9);
      }
      /**
       * Créé un événement custom pour un webComponent.
       * @param {*} component Objet associé à notre composant (objet DOM).
       * @param {*} nomEvenement Nom de l'événement. 
       * @param {*} detailsEvenement Détails de l'événement.
       */

    }, {
      key: "estMobile",
      value: function estMobile() {
        return navigator.maxTouchPoints || 'ontouchstart' in document.documentElement;
      }
    }, {
      key: "ajusterInterfaceAvantAffichageModale",
      value: function ajusterInterfaceAvantAffichageModale(html, body) {
        if (!this.estMobile()) {
          var largeurScrollbarHtml = window.innerWidth - html.offsetWidth;

          if (largeurScrollbarHtml > 0) {
            html.style['padding-right'] = largeurScrollbarHtml + 'px';
          } else {
            var largeurScrollbarBody = window.innerWidth - body.offsetWidth;

            if (largeurScrollbarBody > 0) {
              body.style['padding-right'] = largeurScrollbarBody + 'px';
            }
          }
        }
        /* On s'assure que le scroll ne changera pas une fois le body modifié avec position fixe */


        var scrollY = window.scrollY;
        html.classList.add("utd-modale-ouverte");
        document.body.style.top = "-".concat(scrollY, "px");
      }
    }, {
      key: "ajusterInterfacePendantAffichageModale",
      value: function ajusterInterfacePendantAffichageModale(body, modale) {
        if (!this.estMobile()) {
          var largeurScrollbarModale = window.innerWidth - modale.offsetWidth;

          if (largeurScrollbarModale > 0) {
            body.style['padding-right'] = largeurScrollbarModale + 'px';
          }
        }
      }
    }, {
      key: "ajusterInterfaceApresFermetureModale",
      value: function ajusterInterfaceApresFermetureModale(html, body) {
        html.style.removeProperty('padding-right');
        body.style.removeProperty('padding-right');
        html.classList.remove("utd-modale-ouverte");
        /* Repositionner l'écran où il était avant l'affichage de la modale. */

        var scrollY = document.body.style.top;
        document.body.style.position = '';
        document.body.style.top = '';
        window.scrollTo(0, parseInt(scrollY || '0') * -1);
      }
    }, {
      key: "slotExiste",
      value: function slotExiste(slots, nomSlot) {
        return slots.some(function (s) {
          return s.slot === nomSlot;
        });
      }
    }, {
      key: "obtenirSlot",
      value: function obtenirSlot(slots, nomSlot) {
        return slots.find(function (s) {
          return s.slot === nomSlot;
        });
      }
    }, {
      key: "obtenirTextesDefaut",
      value: function obtenirTextesDefaut() {
        var textes = {
          texteSrOuvertureNouvelOnglet: this.obtenirLanguePage() === 'fr' ? ". Ce lien sera ouvert dans un nouvel onglet." : ". This link will open in a new tab."
        };
        return textes;
      }
      /**
       * Obtient la langue de la page courante.
       * @returns {string} Code de langue de la page courante (fr/en).
       */

    }, {
      key: "obtenirLanguePage",
      value: function obtenirLanguePage() {
        return document.getElementsByTagName("html")[0].getAttribute("lang") || "fr";
      }
      /**
       * Permet de palier au fait que svelte converti en booleen la valeur d'un attribut si celui-ci est vide (ex. titre="", la valeur considérée par svelte est true, alors que nous c'est une attribut vide, qu'on ne devrait pas traiter. Nos if ne fonctionnent pas comme prévu dans cette situation)
       * On considère donc qu'un attribut est absent, si l'attribut n'est pas spécifié, vide ou true (valeur booléenne que svelte utilise si attribut est vide, et ça ne peut jamais arriver sauf dans cette circonstance car normalement les attributs sont toujours des strings)
       * @param {*} attribut Valeur de l'attribut à vérifier
       * @returns Booléen indiquant si l'attribut doit être considéré comme présent ou non
       */

    }, {
      key: "estAttributPresent",
      value: function estAttributPresent(attribut) {
        return attribut && attribut !== true;
      }
      /**
       * Permet de debouncer une fonction.
       * @param {Object} func Fonction à debouncer.
       * @param {Number} timeout Délai du debounce.
       */

    }, {
      key: "debounce",
      value: function debounce(func) {
        var _this = this;

        var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 400;
        var timer;
        return function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          clearTimeout(timer);
          timer = setTimeout(function () {
            func.apply(_this, args);
          }, timeout);
        };
      }
    }, {
      key: "extend",
      value: function extend(first, second) {
        for (var secondProp in second) {
          var secondVal = second[secondProp]; // Is this value an object?  If so, iterate over its properties, copying them over

          if (secondVal && Object.prototype.toString.call(secondVal) === "[object Object]") {
            first[secondProp] = first[secondProp] || {};
            this.extend(first[secondProp], secondVal);
          } else {
            first[secondProp] = secondVal;
          }
        }

        return first;
      }
    }, {
      key: "reafficherApresChargement",
      value: function reafficherApresChargement(composant) {
        setTimeout(function () {
          composant.classList.add('mounted');
        });
      }
      /**
       * Normalise une chaîne de caractères pour utilisation insensible à la case et aux accents.
       * @param {string} chaineCaracteres Chaîne de caractères.
       * */

    }, {
      key: "normaliserChaineCaracteres",
      value: function normaliserChaineCaracteres(chaineCaracteres) {
        return this.normaliserApostrophes(this.remplacerAccents(chaineCaracteres).toLowerCase());
      }
      /**
      * Normaliser les apostrophes d'une chaîne de caractères.
      * @param {string} chaineCaracteres Chaîne de caractères.
      **/

    }, {
      key: "normaliserApostrophes",
      value: function normaliserApostrophes(chaineCaracteres) {
        return chaineCaracteres.replace(/[\u2018-\u2019]/g, "'");
      }
      /**
       * Remplace les accents d'une chaîne de caractères.
       * @param {string} chaineCaracteres Chaîne de caractères.
       * */

    }, {
      key: "remplacerAccents",
      value: function remplacerAccents(chaineCaracteres) {
        return chaineCaracteres.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
      }
      /**
       * Génère un id à partir du texte spécifié. Le texte est normalisé, puis tous les caractères non textuels sont remplacés par des underscore "_".
       * @param {string} texte Texte à partir duquel il faut créer un id.
       * @returns Un id généré à partir du texte.
       */

    }, {
      key: "obtenirIdSelonTexte",
      value: function obtenirIdSelonTexte(texte) {
        var texteNormalise = this.normaliserChaineCaracteres(texte);
        return texteNormalise.replace(/\W/g, '_');
      }
    }]);

    return Utils;
  }();

  _defineProperty(Utils, "relativeBasePath", document.currentScript.getAttribute('relative-base-path') || '');

  _defineProperty(Utils, "cssRelativePath", "".concat(Utils.relativeBasePath.replace(/\/$/, ''), "/css/"));

  _defineProperty(Utils, "imagesRelativePath", "".concat(Utils.relativeBasePath.replace(/\/$/, ''), "/images/"));

  _defineProperty(Utils, "cssFullPath", "".concat(Utils.cssRelativePath, "utd-webcomponents.min.css?v=1.11.0"));

  _defineProperty(Utils, "dispatchWcEvent", function (component, nomEvenement, detailsEvenement) {
    component.dispatchEvent(new CustomEvent(nomEvenement, {
      detail: detailsEvenement,
      composed: true // propage l'événement à travers le shadow DOM (Remonte au document)

    }));
  });

  function _createSuper$g(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$g(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$g() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$g = "src\\components\\accordeon.svelte"; // (83:10) {#if titre}


  function create_if_block_2$7(ctx) {
    var t;
    var block = {
      c: function create() {
        t = text(
        /*titre*/
        ctx[0]);
      },
      m: function mount(target, anchor) {
        insert_dev(target, t, anchor);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*titre*/
        1) set_data_dev(t,
        /*titre*/
        ctx[0]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(t);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_2$7.name,
      type: "if",
      source: "(83:10) {#if titre}",
      ctx: ctx
    });
    return block;
  } // (80:4) <svelte:element this={tagTitre} class="titre">


  function create_dynamic_element$1(ctx) {
    var svelte_element;
    var button;
    var span0;
    var t0;
    var slot;
    var t1;
    var span1;
    var span1_class_value;
    var button_aria_expanded_value;
    var mounted;
    var dispose;
    var if_block =
    /*titre*/
    ctx[0] && create_if_block_2$7(ctx);
    var svelte_element_levels = [{
      class: "titre"
    }];
    var svelte_element_data = {};

    for (var i = 0; i < svelte_element_levels.length; i += 1) {
      svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
    }

    var block = {
      c: function create() {
        svelte_element = element(
        /*tagTitre*/
        ctx[2]);
        button = element("button");
        span0 = element("span");
        if (if_block) if_block.c();
        t0 = space();
        slot = element("slot");
        t1 = space();
        span1 = element("span");
        attr_dev(slot, "name", "titre");
        add_location(slot, file$g, 85, 10, 2618);
        attr_dev(span0, "class", "titre");
        add_location(span0, file$g, 81, 8, 2525);
        attr_dev(span1, "class", span1_class_value = "utd-icone-svg " + (!
        /*estReduit*/
        ctx[3] ? 'moins' : 'plus'));
        add_location(span1, file$g, 87, 8, 2672);
        attr_dev(button, "type", "button");
        attr_dev(button, "class", "");
        attr_dev(button, "aria-controls",
        /*idContenu*/
        ctx[4]);
        attr_dev(button, "aria-expanded", button_aria_expanded_value = !
        /*estReduit*/
        ctx[3]);
        add_location(button, file$g, 80, 6, 2393);
        set_attributes(svelte_element, svelte_element_data);
        add_location(svelte_element, file$g, 79, 4, 2338);
      },
      m: function mount(target, anchor) {
        insert_dev(target, svelte_element, anchor);
        append_dev(svelte_element, button);
        append_dev(button, span0);
        if (if_block) if_block.m(span0, null);
        append_dev(span0, t0);
        append_dev(span0, slot);
        append_dev(button, t1);
        append_dev(button, span1);

        if (!mounted) {
          dispose = listen_dev(button, "click",
          /*toggleAffichageContenu*/
          ctx[5], false, false, false);
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (
        /*titre*/
        ctx[0]) {
          if (if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block = create_if_block_2$7(ctx);
            if_block.c();
            if_block.m(span0, t0);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }

        if (dirty &
        /*estReduit*/
        8 && span1_class_value !== (span1_class_value = "utd-icone-svg " + (!
        /*estReduit*/
        ctx[3] ? 'moins' : 'plus'))) {
          attr_dev(span1, "class", span1_class_value);
        }

        if (dirty &
        /*estReduit*/
        8 && button_aria_expanded_value !== (button_aria_expanded_value = !
        /*estReduit*/
        ctx[3])) {
          attr_dev(button, "aria-expanded", button_aria_expanded_value);
        }

        set_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [{
          class: "titre"
        }]));
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(svelte_element);
        if (if_block) if_block.d();
        mounted = false;
        dispose();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_dynamic_element$1.name,
      type: "child_dynamic_element",
      source: "(80:4) <svelte:element this={tagTitre} class=\\\"titre\\\">",
      ctx: ctx
    });
    return block;
  } // (94:6) {#if !estReduit}


  function create_if_block$c(ctx) {
    var div;
    var div_transition;
    var current;

    function select_block_type(ctx, dirty) {
      if (
      /*contenu*/
      ctx[1]) return create_if_block_1$8;
      return create_else_block$5;
    }

    var current_block_type = select_block_type(ctx);
    var if_block = current_block_type(ctx);
    var block = {
      c: function create() {
        div = element("div");
        if_block.c();
        attr_dev(div, "class", "conteneur");
        add_location(div, file$g, 94, 8, 2877);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        if_block.m(div, null);
        current = true;
      },
      p: function update(ctx, dirty) {
        if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block.d(1);
          if_block = current_block_type(ctx);

          if (if_block) {
            if_block.c();
            if_block.m(div, null);
          }
        }
      },
      i: function intro(local) {
        if (current) return;
        add_render_callback(function () {
          if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {
            duration: 250
          }, true);
          div_transition.run(1);
        });
        current = true;
      },
      o: function outro(local) {
        if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {
          duration: 250
        }, false);
        div_transition.run(0);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
        if_block.d();
        if (detaching && div_transition) div_transition.end();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block$c.name,
      type: "if",
      source: "(94:6) {#if !estReduit}",
      ctx: ctx
    });
    return block;
  } // (98:10) {:else}


  function create_else_block$5(ctx) {
    var slot0;
    var t;
    var slot1;
    var block = {
      c: function create() {
        slot0 = element("slot");
        t = space();
        slot1 = element("slot");
        add_location(slot0, file$g, 98, 12, 3023);
        attr_dev(slot1, "name", "contenu");
        add_location(slot1, file$g, 99, 12, 3046);
      },
      m: function mount(target, anchor) {
        insert_dev(target, slot0, anchor);
        insert_dev(target, t, anchor);
        insert_dev(target, slot1, anchor);
      },
      p: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(slot0);
        if (detaching) detach_dev(t);
        if (detaching) detach_dev(slot1);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_else_block$5.name,
      type: "else",
      source: "(98:10) {:else}",
      ctx: ctx
    });
    return block;
  } // (96:10) {#if contenu}


  function create_if_block_1$8(ctx) {
    var html_tag;
    var html_anchor;
    var block = {
      c: function create() {
        html_tag = new HtmlTag(false);
        html_anchor = empty();
        html_tag.a = html_anchor;
      },
      m: function mount(target, anchor) {
        html_tag.m(
        /*contenu*/
        ctx[1], target, anchor);
        insert_dev(target, html_anchor, anchor);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*contenu*/
        2) html_tag.p(
        /*contenu*/
        ctx[1]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(html_anchor);
        if (detaching) html_tag.d();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_1$8.name,
      type: "if",
      source: "(96:10) {#if contenu}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment$g(ctx) {
    var div2;
    var div0;
    var previous_tag =
    /*tagTitre*/
    ctx[2];
    var t2;
    var div1;
    var div2_class_value;
    var t3;
    var link;
    var current;
    validate_dynamic_element(
    /*tagTitre*/
    ctx[2]);
    validate_void_dynamic_element(
    /*tagTitre*/
    ctx[2]);
    var svelte_element =
    /*tagTitre*/
    ctx[2] && create_dynamic_element$1(ctx);
    var if_block1 = !
    /*estReduit*/
    ctx[3] && create_if_block$c(ctx);
    var block = {
      c: function create() {
        div2 = element("div");
        div0 = element("div");
        if (svelte_element) svelte_element.c();
        t2 = space();
        div1 = element("div");
        if (if_block1) if_block1.c();
        t3 = space();
        link = element("link");
        this.c = noop;
        attr_dev(div0, "class", "entete");
        add_location(div0, file$g, 78, 2, 2312);
        attr_dev(div1, "id",
        /*idContenu*/
        ctx[4]);
        attr_dev(div1, "class", "contenu");
        add_location(div1, file$g, 92, 4, 2804);
        attr_dev(div2, "class", div2_class_value = "utd-component utd-accordeon " + (!
        /*estReduit*/
        ctx[3] ? 'ouvert' : ''));
        add_location(div2, file$g, 77, 0, 2237);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", Utils.cssFullPath);
        add_location(link, file$g, 107, 0, 3141);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div2, anchor);
        append_dev(div2, div0);
        if (svelte_element) svelte_element.m(div0, null);
        append_dev(div2, t2);
        append_dev(div2, div1);
        if (if_block1) if_block1.m(div1, null);
        insert_dev(target, t3, anchor);
        insert_dev(target, link, anchor);
        current = true;
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        if (
        /*tagTitre*/
        ctx[2]) {
          if (!previous_tag) {
            svelte_element = create_dynamic_element$1(ctx);
            svelte_element.c();
            svelte_element.m(div0, null);
          } else if (safe_not_equal(previous_tag,
          /*tagTitre*/
          ctx[2])) {
            svelte_element.d(1);
            validate_dynamic_element(
            /*tagTitre*/
            ctx[2]);
            validate_void_dynamic_element(
            /*tagTitre*/
            ctx[2]);
            svelte_element = create_dynamic_element$1(ctx);
            svelte_element.c();
            svelte_element.m(div0, null);
          } else {
            svelte_element.p(ctx, dirty);
          }
        } else if (previous_tag) {
          svelte_element.d(1);
          svelte_element = null;
        }

        previous_tag =
        /*tagTitre*/
        ctx[2];

        if (!
        /*estReduit*/
        ctx[3]) {
          if (if_block1) {
            if_block1.p(ctx, dirty);

            if (dirty &
            /*estReduit*/
            8) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block$c(ctx);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(div1, null);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, function () {
            if_block1 = null;
          });
          check_outros();
        }

        if (!current || dirty &
        /*estReduit*/
        8 && div2_class_value !== (div2_class_value = "utd-component utd-accordeon " + (!
        /*estReduit*/
        ctx[3] ? 'ouvert' : ''))) {
          attr_dev(div2, "class", div2_class_value);
        }
      },
      i: function intro(local) {
        if (current) return;
        transition_in(if_block1);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block1);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div2);
        if (svelte_element) svelte_element.d(detaching);
        if (if_block1) if_block1.d();
        if (detaching) detach_dev(t3);
        if (detaching) detach_dev(link);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$g.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function instance$g($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-accordeon', slots, []);
    var _$$props$reduit = $$props.reduit,
        reduit = _$$props$reduit === void 0 ? "true" : _$$props$reduit;
    var _$$props$titre = $$props.titre,
        titre = _$$props$titre === void 0 ? "" : _$$props$titre;
    var _$$props$contenu = $$props.contenu,
        contenu = _$$props$contenu === void 0 ? "" : _$$props$contenu;
    var _$$props$tagTitre = $$props.tagTitre,
        tagTitre = _$$props$tagTitre === void 0 ? "h2" : _$$props$tagTitre;
    var _$$props$conserverEta = $$props.conserverEtatAffichage,
        conserverEtatAffichage = _$$props$conserverEta === void 0 ? "false" : _$$props$conserverEta;
    var idEntete = Utils.genererId();
    var idContenu = 'corps' + idEntete;
    var thisComponent = get_current_component();
    var estReduit = reduit === 'true' ? true : false;
    var mounted = false;
    onMount(function () {
      definirEtatAffichageInitial();
      Utils.reafficherApresChargement(thisComponent);
      mounted = true;
    });

    function definirEtatAffichageInitial() {
      if (conserverEtatAffichage === 'true') {
        if (thisComponent.id) {
          var valeur = sessionStorage.getItem(thisComponent.id); //Si null (clé non trouvée dans le session storage, on va utiliser la valeur par défaut reçue en paramètre, sinon on l'écrase avec celle du session storage)

          if (valeur !== null) {
            if (valeur === '1') {
              thisComponent.setAttribute('reduit', 'false');
            } else {
              thisComponent.setAttribute('reduit', 'true');
            }
          }
        }
      }

      $$invalidate(3, estReduit = reduit === 'true' ? true : false);
      conserverEtatAffichageSession();
    }

    function conserverEtatAffichageSession() {
      if (conserverEtatAffichage === 'true' && thisComponent.id) {
        sessionStorage.setItem(thisComponent.id, estReduit ? '0' : '1');
      }
    }

    function gererEtatAffichage() {
      if (!mounted) {
        return;
      }

      $$invalidate(3, estReduit = reduit === 'true' ? true : false);
      conserverEtatAffichageSession();
      Utils.dispatchWcEvent(thisComponent, "changementEtat", {
        reduit: estReduit
      });
    }

    function toggleAffichageContenu() {
      thisComponent.setAttribute('reduit', estReduit ? 'false' : 'true');
    }

    var writable_props = ['reduit', 'titre', 'contenu', 'tagTitre', 'conserverEtatAffichage'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-accordeon> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('reduit' in $$props) $$invalidate(6, reduit = $$props.reduit);
      if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
      if ('contenu' in $$props) $$invalidate(1, contenu = $$props.contenu);
      if ('tagTitre' in $$props) $$invalidate(2, tagTitre = $$props.tagTitre);
      if ('conserverEtatAffichage' in $$props) $$invalidate(7, conserverEtatAffichage = $$props.conserverEtatAffichage);
    };

    $$self.$capture_state = function () {
      return {
        onMount: onMount,
        slide: slide,
        Utils: Utils,
        get_current_component: get_current_component,
        reduit: reduit,
        titre: titre,
        contenu: contenu,
        tagTitre: tagTitre,
        conserverEtatAffichage: conserverEtatAffichage,
        idEntete: idEntete,
        idContenu: idContenu,
        thisComponent: thisComponent,
        estReduit: estReduit,
        mounted: mounted,
        definirEtatAffichageInitial: definirEtatAffichageInitial,
        conserverEtatAffichageSession: conserverEtatAffichageSession,
        gererEtatAffichage: gererEtatAffichage,
        toggleAffichageContenu: toggleAffichageContenu
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('reduit' in $$props) $$invalidate(6, reduit = $$props.reduit);
      if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
      if ('contenu' in $$props) $$invalidate(1, contenu = $$props.contenu);
      if ('tagTitre' in $$props) $$invalidate(2, tagTitre = $$props.tagTitre);
      if ('conserverEtatAffichage' in $$props) $$invalidate(7, conserverEtatAffichage = $$props.conserverEtatAffichage);
      if ('estReduit' in $$props) $$invalidate(3, estReduit = $$props.estReduit);
      if ('mounted' in $$props) mounted = $$props.mounted;
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    $$self.$$.update = function () {
      if ($$self.$$.dirty &
      /*reduit*/
      64) {
        gererEtatAffichage();
      }
    };

    return [titre, contenu, tagTitre, estReduit, idContenu, toggleAffichageContenu, reduit, conserverEtatAffichage];
  }

  var Accordeon = /*#__PURE__*/function (_SvelteElement) {
    _inherits(Accordeon, _SvelteElement);

    var _super = _createSuper$g(Accordeon);

    function Accordeon(options) {
      var _this;

      _classCallCheck(this, Accordeon);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$g, create_fragment$g, safe_not_equal, {
        reduit: 6,
        titre: 0,
        contenu: 1,
        tagTitre: 2,
        conserverEtatAffichage: 7
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(Accordeon, [{
      key: "reduit",
      get: function get() {
        return this.$$.ctx[6];
      },
      set: function set(reduit) {
        this.$$set({
          reduit: reduit
        });
        flush();
      }
    }, {
      key: "titre",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(titre) {
        this.$$set({
          titre: titre
        });
        flush();
      }
    }, {
      key: "contenu",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(contenu) {
        this.$$set({
          contenu: contenu
        });
        flush();
      }
    }, {
      key: "tagTitre",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(tagTitre) {
        this.$$set({
          tagTitre: tagTitre
        });
        flush();
      }
    }, {
      key: "conserverEtatAffichage",
      get: function get() {
        return this.$$.ctx[7];
      },
      set: function set(conserverEtatAffichage) {
        this.$$set({
          conserverEtatAffichage: conserverEtatAffichage
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["reduit", "titre", "contenu", "tagTitre", "conserverEtatAffichage"];
      }
    }]);

    return Accordeon;
  }(SvelteElement);

  customElements.define("utd-accordeon", Accordeon);

  function _createSuper$f(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$f(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$f() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$f = "src\\components\\avis.svelte"; // (32:6) {#if contenu}

  function create_if_block$b(ctx) {
    var html_tag;
    var html_anchor;
    var block = {
      c: function create() {
        html_tag = new HtmlTag(false);
        html_anchor = empty();
        html_tag.a = html_anchor;
      },
      m: function mount(target, anchor) {
        html_tag.m(
        /*contenu*/
        ctx[2], target, anchor);
        insert_dev(target, html_anchor, anchor);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*contenu*/
        4) html_tag.p(
        /*contenu*/
        ctx[2]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(html_anchor);
        if (detaching) html_tag.d();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block$b.name,
      type: "if",
      source: "(32:6) {#if contenu}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment$f(ctx) {
    var div4;
    var div1;
    var div0;
    var div0_class_value;
    var t0;
    var div3;
    var h2;
    var t1;
    var t2;
    var div2;
    var t3;
    var slot0;
    var t4;
    var slot1;
    var div4_class_value;
    var t5;
    var link;
    var if_block =
    /*contenu*/
    ctx[2] && create_if_block$b(ctx);
    var block = {
      c: function create() {
        div4 = element("div");
        div1 = element("div");
        div0 = element("div");
        t0 = space();
        div3 = element("div");
        h2 = element("h2");
        t1 = text(
        /*titre*/
        ctx[0]);
        t2 = space();
        div2 = element("div");
        if (if_block) if_block.c();
        t3 = space();
        slot0 = element("slot");
        t4 = space();
        slot1 = element("slot");
        t5 = space();
        link = element("link");
        this.c = noop;
        attr_dev(div0, "aria-hidden", "true");
        attr_dev(div0, "class", div0_class_value = "utd-icone-svg " +
        /*type*/
        ctx[1]);
        add_location(div0, file$f, 24, 4, 617);
        attr_dev(div1, "class", "zone-icone");
        add_location(div1, file$f, 23, 2, 587);
        attr_dev(h2, "class", "titre");
        add_location(h2, file$f, 27, 4, 727);
        add_location(slot0, file$f, 34, 6, 869);
        attr_dev(slot1, "name", "contenu");
        add_location(slot1, file$f, 35, 6, 885);
        attr_dev(div2, "class", "texte");
        add_location(div2, file$f, 30, 4, 777);
        attr_dev(div3, "class", "contenu zone-html");
        add_location(div3, file$f, 26, 2, 690);
        attr_dev(div4, "class", div4_class_value = "utd-component utd-avis " +
        /*type*/
        ctx[1]);
        attr_dev(div4, "tabindex", "0");
        add_location(div4, file$f, 22, 0, 527);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", Utils.cssFullPath);
        add_location(link, file$f, 40, 0, 942);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div4, anchor);
        append_dev(div4, div1);
        append_dev(div1, div0);
        append_dev(div4, t0);
        append_dev(div4, div3);
        append_dev(div3, h2);
        append_dev(h2, t1);
        append_dev(div3, t2);
        append_dev(div3, div2);
        if (if_block) if_block.m(div2, null);
        append_dev(div2, t3);
        append_dev(div2, slot0);
        append_dev(div2, t4);
        append_dev(div2, slot1);
        insert_dev(target, t5, anchor);
        insert_dev(target, link, anchor);
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        if (dirty &
        /*type*/
        2 && div0_class_value !== (div0_class_value = "utd-icone-svg " +
        /*type*/
        ctx[1])) {
          attr_dev(div0, "class", div0_class_value);
        }

        if (dirty &
        /*titre*/
        1) set_data_dev(t1,
        /*titre*/
        ctx[0]);

        if (
        /*contenu*/
        ctx[2]) {
          if (if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block = create_if_block$b(ctx);
            if_block.c();
            if_block.m(div2, t3);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }

        if (dirty &
        /*type*/
        2 && div4_class_value !== (div4_class_value = "utd-component utd-avis " +
        /*type*/
        ctx[1])) {
          attr_dev(div4, "class", div4_class_value);
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(div4);
        if (if_block) if_block.d();
        if (detaching) detach_dev(t5);
        if (detaching) detach_dev(link);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$f.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function instance$f($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-avis', slots, []);
    var _$$props$titre = $$props.titre,
        titre = _$$props$titre === void 0 ? "" : _$$props$titre;
    var _$$props$type = $$props.type,
        type = _$$props$type === void 0 ? "information" : _$$props$type;
    var _$$props$contenu = $$props.contenu,
        contenu = _$$props$contenu === void 0 ? "" : _$$props$contenu;
    var thisComponent = get_current_component();
    onMount(function () {
      Utils.reafficherApresChargement(thisComponent);
    });
    var writable_props = ['titre', 'type', 'contenu'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-avis> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
      if ('type' in $$props) $$invalidate(1, type = $$props.type);
      if ('contenu' in $$props) $$invalidate(2, contenu = $$props.contenu);
    };

    $$self.$capture_state = function () {
      return {
        Utils: Utils,
        onMount: onMount,
        get_current_component: get_current_component,
        titre: titre,
        type: type,
        contenu: contenu,
        thisComponent: thisComponent
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
      if ('type' in $$props) $$invalidate(1, type = $$props.type);
      if ('contenu' in $$props) $$invalidate(2, contenu = $$props.contenu);
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    return [titre, type, contenu];
  }

  var Avis = /*#__PURE__*/function (_SvelteElement) {
    _inherits(Avis, _SvelteElement);

    var _super = _createSuper$f(Avis);

    function Avis(options) {
      var _this;

      _classCallCheck(this, Avis);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$f, create_fragment$f, safe_not_equal, {
        titre: 0,
        type: 1,
        contenu: 2
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(Avis, [{
      key: "titre",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(titre) {
        this.$$set({
          titre: titre
        });
        flush();
      }
    }, {
      key: "type",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(type) {
        this.$$set({
          type: type
        });
        flush();
      }
    }, {
      key: "contenu",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(contenu) {
        this.$$set({
          contenu: contenu
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["titre", "type", "contenu"];
      }
    }]);

    return Avis;
  }(SvelteElement);

  customElements.define("utd-avis", Avis);

  function _createSuper$e(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$e(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$e() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$e = "src\\components\\champForm.svelte";

  function create_fragment$e(ctx) {
    var slot;
    var t;
    var link;
    var block = {
      c: function create() {
        slot = element("slot");
        t = space();
        link = element("link");
        this.c = noop;
        add_location(slot, file$e, 402, 0, 11895);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", Utils.cssFullPath);
        add_location(link, file$e, 404, 0, 11906);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, slot, anchor);
        insert_dev(target, t, anchor);
        insert_dev(target, link, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(slot);
        if (detaching) detach_dev(t);
        if (detaching) detach_dev(link);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$e.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function instance$e($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-champ-form', slots, []);
    var _$$props$obligatoire = $$props.obligatoire,
        obligatoire = _$$props$obligatoire === void 0 ? "false" : _$$props$obligatoire;
    var _$$props$invalide = $$props.invalide,
        invalide = _$$props$invalide === void 0 ? "false" : _$$props$invalide;
    var _$$props$format = $$props.format,
        format = _$$props$format === void 0 ? null : _$$props$format;
    var _$$props$libelle = $$props.libelle,
        libelle = _$$props$libelle === void 0 ? "" : _$$props$libelle;
    var _$$props$precision = $$props.precision,
        precision = _$$props$precision === void 0 ? "" : _$$props$precision;
    var _$$props$messageErreu = $$props.messageErreur,
        messageErreur = _$$props$messageErreu === void 0 ? "" : _$$props$messageErreu;
    var mounted = false;
    var typeChamp = null;
    var elementLabel = null;
    var elementWrapper = null;
    var elementIndicateurObligatoire = null;
    var elementObligatoireTexte = null;
    var elementChamp = null;
    var elementPrecision = null;
    var elementErreur = null;
    var idElementErreur = null;
    var idChamp = Utils.genererId();
    var idParentUtd = Utils.genererId();
    var idLabelInitial = Utils.genererId();
    var idPrecisionInitial = Utils.genererId();
    var idErreurInitial = Utils.genererId();
    var thisComponent = get_current_component();
    var texteSrChampObligatoire = Utils.obtenirLanguePage() === 'fr' ? ' obligatoire ' : ' required ';
    /* ===========================================================================================
     RÉFÉRENCES
    
     - Liste de boutons radio et checkbox
       https://blog.tenon.io/accessible-validation-of-checkbox-and-radiobutton-groups/
    
    =============================================================================================*/

    onMount(function () {
      typeChamp = obtenirTypeChamp();
      mounted = true;

      if (typeChamp) {
        wrapperControles();
        gererChamp();
        gererLabel();
        gererChampObligatoire();

        if (typeChamp !== 'checkbox-seul') {
          gererPrecision();
        }

        gererErreur();
      }
    });

    function wrapperControles() {
      var wrapper = thisComponent.querySelector('.utd-wrapper');

      if (wrapper) {
        elementWrapper = wrapper;
        return;
      }

      elementWrapper = document.createElement('div');
      var classeType = typeChamp === 'checkbox-seul' ? 'checkbox' : typeChamp;
      elementWrapper.classList.add('utd-form-group', 'utd-wrapper', classeType);
      var nbEnfants = thisComponent.childNodes.length;

      for (var i = 0; i < nbEnfants; i++) {
        var _element = thisComponent.childNodes[0];
        elementWrapper.append(_element);
      }

      if (typeChamp === 'radio') {
        elementWrapper.setAttribute('role', 'radiogroup');
      }

      if (typeChamp === 'checkbox') {
        elementWrapper.setAttribute('role', 'group');
      }

      if (format) {
        elementWrapper.classList.add(format);
      }

      thisComponent.prepend(elementWrapper);
    }

    function gererChamp() {
      elementChamp.id = elementChamp.id || idChamp;
      var idUtd = thisComponent.id || idParentUtd;
      elementChamp.setAttribute('idutd', idUtd);
      thisComponent.id = idUtd;

      if (typeChamp === 'standard' || typeChamp === 'select' || typeChamp === 'textarea') {
        elementChamp.classList.add('utd-form-control');

        if (format) {
          elementChamp.classList.add(format);
        }
      }
    }

    function obtenirTypeChamp() {
      var input = thisComponent.querySelector("input");

      if (input) {
        elementChamp = input;
        var type = input.getAttribute("type");

        if (type === 'radio') {
          return type;
        } else if (type === 'checkbox') {
          return thisComponent.querySelectorAll("input").length > 1 ? 'checkbox' : 'checkbox-seul';
        } else if (type === 'button' || type === 'submit') {
          return null;
        } else {
          return 'standard';
        }
      } else if (thisComponent.querySelector("textarea")) {
        elementChamp = thisComponent.querySelector("textarea");
        return 'standard';
      } else if (thisComponent.querySelector("select")) {
        elementChamp = thisComponent.querySelector("select");
        return 'select';
      } else {
        return null;
      }
    }

    function gererLabel() {
      if (!mounted) {
        return;
      }

      if (estGroupeControles()) {
        elementLabel = thisComponent.querySelector(".label");
      } else {
        elementLabel = thisComponent.querySelector("label");
      }

      if (elementLabel) {
        //Le label existe déjà. On s'assure qu'il est bien lié au champ.
        if (estGroupeControles()) {
          if (!elementLabel.id) {
            elementLabel.id = idLabelInitial;
          }

          ajusterChampAriaDescribedBy('ajout', elementLabel.id);
        } else {
          elementLabel.setAttribute('for', elementChamp.id);
        }

        if (libelle) {
          elementLabel.innerText = libelle;
        }
      } else if (libelle) {
        //Le contrôle label n'existe pas      
        var _element2;

        if (estGroupeControles()) {
          _element2 = document.createElement('span');

          _element2.classList.add('label');

          _element2.id = idLabelInitial;
          ajusterChampAriaDescribedBy('ajout', _element2.id, typeChamp === 'radio' ? 'aria-labelledby' : null);
        } else {
          _element2 = document.createElement('label');

          _element2.setAttribute('for', elementChamp.id);
        }

        _element2.innerText = libelle;
        elementWrapper.prepend(_element2);
        elementLabel = _element2;
      }
    }

    function gererPrecision() {
      if (!mounted) {
        return;
      }

      if (elementLabel) {
        elementPrecision = thisComponent.querySelector(".utd-precision");

        if (precision) {
          if (elementPrecision) {
            elementPrecision.id = elementPrecision.id || idPrecisionInitial;
          } else {
            var span = document.createElement('span');
            span.classList.add("utd-precision");
            span.id = idPrecisionInitial;
            elementPrecision = span;
            elementLabel.after(elementPrecision);
          }

          elementPrecision.innerText = precision;
          ajusterChampAriaDescribedBy('ajout', elementPrecision.id);
        } else {
          //Pas de précision en paramètre
          if (elementPrecision) {
            //Contrôle précision dans le HTML
            elementPrecision.id = elementPrecision.id || idPrecisionInitial;
            ajusterChampAriaDescribedBy('ajout', elementPrecision.id);
          } else {
            //Pas de contrôle de précision dans le html, on retire la précision du aria-describedby
            ajusterChampAriaDescribedBy('retrait', idPrecisionInitial);
          }
        }
      }
    }

    function ajusterChampAriaDescribedBy() {
      var operation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'ajout';
      var valeur = arguments.length > 1 ? arguments[1] : undefined;
      var aria = arguments.length > 2 ? arguments[2] : undefined;
      var attribut;

      if (aria) {
        attribut = aria;
      } else {
        attribut = typeChamp === 'checkbox' ? 'aria-labelledby' : 'aria-describedby';
      }

      var controle = elementChamp;

      if (estGroupeControles()) {
        controle = elementWrapper;
      }

      var valeurActuelle = controle.getAttribute(attribut) || '';
      var nouvelleValeur = '';

      if (operation === 'ajout') {
        nouvelleValeur = valeurActuelle + (valeurActuelle.indexOf(valeur) >= 0 ? '' : ' ' + valeur);
      } else {
        nouvelleValeur = valeurActuelle.replace(valeur, '');
      }

      if (nouvelleValeur.trim()) {
        controle.setAttribute(attribut, nouvelleValeur.trim());
      } else {
        controle.removeAttribute(attribut);
      }
    }

    function gererChampObligatoire() {
      if (!mounted) {
        return;
      }

      if (elementLabel) {
        elementIndicateurObligatoire = thisComponent.querySelector(".utd-icone-champ-requis");
        elementObligatoireTexte = thisComponent.querySelector(".texte-obligatoire");

        if (obligatoire === 'true') {
          if (typeChamp === 'checkbox') {
            //Pour les listes de checkbox, on doit ajouter un texte hors écran afin d'indiquer que le champ est obligatoire (aria-required ne fonctionne pas pour ces types de champs).
            elementObligatoireTexte = thisComponent.querySelector(".texte-obligatoire");

            if (!elementObligatoireTexte) {
              elementObligatoireTexte = document.createElement('span');
              elementObligatoireTexte.classList.add("texte-obligatoire", "utd-sr-only");
              elementObligatoireTexte.innerHTML = texteSrChampObligatoire;
              elementLabel.append(elementObligatoireTexte);
            }
          }

          if (!elementIndicateurObligatoire) {
            elementIndicateurObligatoire = document.createElement('span');
            elementIndicateurObligatoire.classList.add("utd-icone-champ-requis");
            elementIndicateurObligatoire.innerHTML = "*";
            elementLabel.append(elementIndicateurObligatoire);
          }

          elementIndicateurObligatoire.setAttribute('aria-hidden', 'true');
        } else {
          if (elementIndicateurObligatoire) {
            elementIndicateurObligatoire.remove();
          }

          if (elementObligatoireTexte) {
            elementObligatoireTexte.remove();
          }
        }
      }

      if (obligatoire === 'true' && typeChamp !== 'checkbox') {
        if (typeChamp === 'radio') {
          elementWrapper.setAttribute('aria-required', 'true');
        } else {
          elementChamp.setAttribute('aria-required', 'true');
        }
      } else {
        if (typeChamp === 'radio') {
          elementWrapper.removeAttribute('aria-required');
        } else {
          elementChamp.removeAttribute('aria-required');
        }
      }
    }

    function gererErreur() {
      if (!mounted) {
        return;
      }

      var controle = elementChamp;

      if (estGroupeControles()) {
        controle = elementWrapper;
      }

      elementErreur = thisComponent.querySelector(".utd-erreur-champ");

      if (invalide === 'true') {
        if (elementErreur) {
          elementErreur.id = elementErreur.id || idErreurInitial;
        } else {
          var span = document.createElement('span');
          span.classList.add("utd-erreur-champ");
          span.id = idErreurInitial;
          elementErreur = span;

          if (typeChamp === 'checkbox-seul') {
            elementLabel.after(elementErreur);
          } else {
            if (estGroupeControles()) {
              elementWrapper.append(elementErreur);
            } else {
              var listeDeroulante = thisComponent.querySelector("utd-liste-deroulante");

              if (listeDeroulante) {
                listeDeroulante.after(elementErreur);
              } else {
                elementChamp.after(elementErreur);
              }
            }
          }
        }

        if (messageErreur) {
          elementErreur.innerText = messageErreur;
        }

        idElementErreur = elementErreur.id;
        var attribut = typeChamp === 'checkbox' ? 'aria-labelledby' : 'aria-describedby';
        var descByAvant = controle.getAttribute(attribut);
        controle.setAttribute(attribut, elementErreur.id);

        if (typeChamp !== 'checkbox') {
          controle.setAttribute('aria-invalid', 'true');
        } //setTimeout nécessaire pour lecteur écran


        if (descByAvant) {
          setTimeout(function () {
            controle.setAttribute(attribut, "".concat(descByAvant, " ").concat(idElementErreur));
          }, 100);
        }

        elementErreur.classList.remove('utd-d-none');
      } else {
        controle.removeAttribute('aria-invalid');

        if (elementErreur) {
          elementErreur.classList.add('utd-d-none');

          if (messageErreur) {
            elementErreur.innerText = messageErreur;
          }
        }

        if (idElementErreur) {
          setTimeout(function () {
            ajusterChampAriaDescribedBy('retrait', idElementErreur);
          }, 100);
        }
      }
    }

    function estGroupeControles() {
      return typeChamp === 'checkbox' || typeChamp === 'radio';
    }

    var writable_props = ['obligatoire', 'invalide', 'format', 'libelle', 'precision', 'messageErreur'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-champ-form> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('obligatoire' in $$props) $$invalidate(0, obligatoire = $$props.obligatoire);
      if ('invalide' in $$props) $$invalidate(1, invalide = $$props.invalide);
      if ('format' in $$props) $$invalidate(2, format = $$props.format);
      if ('libelle' in $$props) $$invalidate(3, libelle = $$props.libelle);
      if ('precision' in $$props) $$invalidate(4, precision = $$props.precision);
      if ('messageErreur' in $$props) $$invalidate(5, messageErreur = $$props.messageErreur);
    };

    $$self.$capture_state = function () {
      return {
        Utils: Utils,
        get_current_component: get_current_component,
        onMount: onMount,
        obligatoire: obligatoire,
        invalide: invalide,
        format: format,
        libelle: libelle,
        precision: precision,
        messageErreur: messageErreur,
        mounted: mounted,
        typeChamp: typeChamp,
        elementLabel: elementLabel,
        elementWrapper: elementWrapper,
        elementIndicateurObligatoire: elementIndicateurObligatoire,
        elementObligatoireTexte: elementObligatoireTexte,
        elementChamp: elementChamp,
        elementPrecision: elementPrecision,
        elementErreur: elementErreur,
        idElementErreur: idElementErreur,
        idChamp: idChamp,
        idParentUtd: idParentUtd,
        idLabelInitial: idLabelInitial,
        idPrecisionInitial: idPrecisionInitial,
        idErreurInitial: idErreurInitial,
        thisComponent: thisComponent,
        texteSrChampObligatoire: texteSrChampObligatoire,
        wrapperControles: wrapperControles,
        gererChamp: gererChamp,
        obtenirTypeChamp: obtenirTypeChamp,
        gererLabel: gererLabel,
        gererPrecision: gererPrecision,
        ajusterChampAriaDescribedBy: ajusterChampAriaDescribedBy,
        gererChampObligatoire: gererChampObligatoire,
        gererErreur: gererErreur,
        estGroupeControles: estGroupeControles
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('obligatoire' in $$props) $$invalidate(0, obligatoire = $$props.obligatoire);
      if ('invalide' in $$props) $$invalidate(1, invalide = $$props.invalide);
      if ('format' in $$props) $$invalidate(2, format = $$props.format);
      if ('libelle' in $$props) $$invalidate(3, libelle = $$props.libelle);
      if ('precision' in $$props) $$invalidate(4, precision = $$props.precision);
      if ('messageErreur' in $$props) $$invalidate(5, messageErreur = $$props.messageErreur);
      if ('mounted' in $$props) mounted = $$props.mounted;
      if ('typeChamp' in $$props) typeChamp = $$props.typeChamp;
      if ('elementLabel' in $$props) elementLabel = $$props.elementLabel;
      if ('elementWrapper' in $$props) elementWrapper = $$props.elementWrapper;
      if ('elementIndicateurObligatoire' in $$props) elementIndicateurObligatoire = $$props.elementIndicateurObligatoire;
      if ('elementObligatoireTexte' in $$props) elementObligatoireTexte = $$props.elementObligatoireTexte;
      if ('elementChamp' in $$props) elementChamp = $$props.elementChamp;
      if ('elementPrecision' in $$props) elementPrecision = $$props.elementPrecision;
      if ('elementErreur' in $$props) elementErreur = $$props.elementErreur;
      if ('idElementErreur' in $$props) idElementErreur = $$props.idElementErreur;
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    $$self.$$.update = function () {
      if ($$self.$$.dirty[0] &
      /*libelle*/
      8) {
        gererLabel();
      }

      if ($$self.$$.dirty[0] &
      /*obligatoire*/
      1) {
        gererChampObligatoire();
      }

      if ($$self.$$.dirty[0] &
      /*precision*/
      16) {
        gererPrecision();
      }

      if ($$self.$$.dirty[0] &
      /*messageErreur*/
      32) {
        gererErreur();
      }

      if ($$self.$$.dirty[0] &
      /*invalide*/
      2) {
        gererErreur();
      }
    };

    return [obligatoire, invalide, format, libelle, precision, messageErreur];
  }

  var ChampForm = /*#__PURE__*/function (_SvelteElement) {
    _inherits(ChampForm, _SvelteElement);

    var _super = _createSuper$e(ChampForm);

    function ChampForm(options) {
      var _this;

      _classCallCheck(this, ChampForm);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$e, create_fragment$e, safe_not_equal, {
        obligatoire: 0,
        invalide: 1,
        format: 2,
        libelle: 3,
        precision: 4,
        messageErreur: 5
      }, null, [-1, -1]);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(ChampForm, [{
      key: "obligatoire",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(obligatoire) {
        this.$$set({
          obligatoire: obligatoire
        });
        flush();
      }
    }, {
      key: "invalide",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(invalide) {
        this.$$set({
          invalide: invalide
        });
        flush();
      }
    }, {
      key: "format",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(format) {
        this.$$set({
          format: format
        });
        flush();
      }
    }, {
      key: "libelle",
      get: function get() {
        return this.$$.ctx[3];
      },
      set: function set(libelle) {
        this.$$set({
          libelle: libelle
        });
        flush();
      }
    }, {
      key: "precision",
      get: function get() {
        return this.$$.ctx[4];
      },
      set: function set(precision) {
        this.$$set({
          precision: precision
        });
        flush();
      }
    }, {
      key: "messageErreur",
      get: function get() {
        return this.$$.ctx[5];
      },
      set: function set(messageErreur) {
        this.$$set({
          messageErreur: messageErreur
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["obligatoire", "invalide", "format", "libelle", "precision", "messageErreur"];
      }
    }]);

    return ChampForm;
  }(SvelteElement);

  customElements.define("utd-champ-form", ChampForm);

  function _createSuper$d(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$d(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$d() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$d = "src\\components\\dialogueModal.svelte"; // (171:0) {#if estModaleAffichee}

  function create_if_block$a(ctx) {
    var div0;
    var t0;
    var div5;
    var div4;
    var button;
    var span;
    var t1;
    var div3;
    var div1;
    var t2;
    var h1;
    var t3;
    var div1_class_value;
    var t4;
    var div2;
    var slot0;
    var t5;
    var slot1;
    var t6;
    var show_if = Utils.slotExiste(
    /*slots*/
    ctx[8], 'pied');
    var div5_aria_describedby_value;
    var div5_class_value;
    var div5_intro;
    var div5_outro;
    var current;
    var mounted;
    var dispose;
    var if_block0 =
    /*type*/
    ctx[1] && create_if_block_2$6(ctx);
    var if_block1 = show_if && create_if_block_1$7(ctx);
    var block = {
      c: function create() {
        div0 = element("div");
        t0 = space();
        div5 = element("div");
        div4 = element("div");
        button = element("button");
        span = element("span");
        t1 = space();
        div3 = element("div");
        div1 = element("div");
        if (if_block0) if_block0.c();
        t2 = space();
        h1 = element("h1");
        t3 = text(
        /*titre*/
        ctx[2]);
        t4 = space();
        div2 = element("div");
        slot0 = element("slot");
        t5 = space();
        slot1 = element("slot");
        t6 = space();
        if (if_block1) if_block1.c();
        attr_dev(div0, "class", "utd-backdrop");
        add_location(div0, file$d, 171, 2, 6200);
        attr_dev(span, "aria-hidden", "true");
        attr_dev(span, "class", "utd-icone-svg x-fermer-bleu");
        add_location(span, file$d, 195, 8, 7186);
        attr_dev(button, "type", "button");
        attr_dev(button, "class", "close");
        attr_dev(button, "aria-label",
        /*srBoutonFermer*/
        ctx[3]);
        add_location(button, file$d, 189, 8, 7021);
        attr_dev(h1, "id",
        /*idEntete*/
        ctx[10]);
        attr_dev(h1, "class", "titre-dialog");
        add_location(h1, file$d, 205, 10, 7513);
        attr_dev(div1, "class", div1_class_value = "entete " + (
        /*type*/
        ctx[1] ? 'avec-type' : ''));
        add_location(div1, file$d, 201, 8, 7338);
        add_location(slot0, file$d, 210, 10, 7661);
        attr_dev(slot1, "name", "contenu");
        add_location(slot1, file$d, 211, 10, 7680);
        attr_dev(div2, "class", "corps");
        attr_dev(div2, "id",
        /*idCorps*/
        ctx[11]);
        add_location(div2, file$d, 209, 8, 7617);
        attr_dev(div3, "class", "principal");
        add_location(div3, file$d, 200, 6, 7305);
        attr_dev(div4, "class", "conteneur");
        add_location(div4, file$d, 188, 4, 6988);
        attr_dev(div5, "aria-labelledby",
        /*idEntete*/
        ctx[10]);
        attr_dev(div5, "aria-describedby", div5_aria_describedby_value =
        /*estfenetremessage*/
        ctx[0] === 'true' ?
        /*idCorps*/
        ctx[11] : null);
        attr_dev(div5, "class", div5_class_value = "utd-component utd-dialog " + (
        /*estfenetremessage*/
        ctx[0] === 'true' ? 'fenetre-message' : '') + " " + (
        /*boutonsTexteLong*/
        ctx[4] === 'true' ? 'boutons-texte-long' : '') + " " + (
        /*affichageLateral*/
        ctx[6] === 'true' ? 'affichage-lateral' : '') + " " + (
        /*forcerBoutonsInline*/
        ctx[5] === 'true' ? 'boutons-inline' : ''));
        attr_dev(div5, "id",
        /*idModale*/
        ctx[9]);
        attr_dev(div5, "aria-modal", "true");
        attr_dev(div5, "role", "dialog");
        add_location(div5, file$d, 172, 2, 6280);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div0, anchor);
        insert_dev(target, t0, anchor);
        insert_dev(target, div5, anchor);
        append_dev(div5, div4);
        append_dev(div4, button);
        append_dev(button, span);
        append_dev(div4, t1);
        append_dev(div4, div3);
        append_dev(div3, div1);
        if (if_block0) if_block0.m(div1, null);
        append_dev(div1, t2);
        append_dev(div1, h1);
        append_dev(h1, t3);
        append_dev(div3, t4);
        append_dev(div3, div2);
        append_dev(div2, slot0);
        append_dev(div2, t5);
        append_dev(div2, slot1);
        append_dev(div3, t6);
        if (if_block1) if_block1.m(div3, null);
        current = true;

        if (!mounted) {
          dispose = [listen_dev(div0, "click",
          /*click_handler*/
          ctx[24], false, false, false), listen_dev(button, "click",
          /*click_handler_1*/
          ctx[25], false, false, false), listen_dev(div5, "click",
          /*clickModale*/
          ctx[16], false, false, false), listen_dev(div5, "keydown",
          /*keydown*/
          ctx[15], false, false, false), listen_dev(div5, "introstart",
          /*ajusterModaleDebutAffichage*/
          ctx[18], false, false, false), listen_dev(div5, "introend",
          /*ajusterModaleFinAffichage*/
          ctx[19], false, false, false), listen_dev(div5, "outroend",
          /*finAnimationFermeture*/
          ctx[17], false, false, false)];
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (!current || dirty[0] &
        /*srBoutonFermer*/
        8) {
          attr_dev(button, "aria-label",
          /*srBoutonFermer*/
          ctx[3]);
        }

        if (
        /*type*/
        ctx[1]) {
          if (if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0 = create_if_block_2$6(ctx);
            if_block0.c();
            if_block0.m(div1, t2);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }

        if (!current || dirty[0] &
        /*titre*/
        4) set_data_dev(t3,
        /*titre*/
        ctx[2]);

        if (!current || dirty[0] &
        /*type*/
        2 && div1_class_value !== (div1_class_value = "entete " + (
        /*type*/
        ctx[1] ? 'avec-type' : ''))) {
          attr_dev(div1, "class", div1_class_value);
        }

        if (dirty[0] &
        /*slots*/
        256) show_if = Utils.slotExiste(
        /*slots*/
        ctx[8], 'pied');

        if (show_if) {
          if (if_block1) ; else {
            if_block1 = create_if_block_1$7(ctx);
            if_block1.c();
            if_block1.m(div3, null);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }

        if (!current || dirty[0] &
        /*estfenetremessage*/
        1 && div5_aria_describedby_value !== (div5_aria_describedby_value =
        /*estfenetremessage*/
        ctx[0] === 'true' ?
        /*idCorps*/
        ctx[11] : null)) {
          attr_dev(div5, "aria-describedby", div5_aria_describedby_value);
        }

        if (!current || dirty[0] &
        /*estfenetremessage, boutonsTexteLong, affichageLateral, forcerBoutonsInline*/
        113 && div5_class_value !== (div5_class_value = "utd-component utd-dialog " + (
        /*estfenetremessage*/
        ctx[0] === 'true' ? 'fenetre-message' : '') + " " + (
        /*boutonsTexteLong*/
        ctx[4] === 'true' ? 'boutons-texte-long' : '') + " " + (
        /*affichageLateral*/
        ctx[6] === 'true' ? 'affichage-lateral' : '') + " " + (
        /*forcerBoutonsInline*/
        ctx[5] === 'true' ? 'boutons-inline' : ''))) {
          attr_dev(div5, "class", div5_class_value);
        }
      },
      i: function intro(local) {
        if (current) return;
        add_render_callback(function () {
          if (div5_outro) div5_outro.end(1);
          div5_intro = create_in_transition(div5,
          /*animationAffichageOuverture*/
          ctx[13], {});
          div5_intro.start();
        });
        current = true;
      },
      o: function outro(local) {
        if (div5_intro) div5_intro.invalidate();
        div5_outro = create_out_transition(div5,
        /*animationAffichageFermeture*/
        ctx[14], {});
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div0);
        if (detaching) detach_dev(t0);
        if (detaching) detach_dev(div5);
        if (if_block0) if_block0.d();
        if (if_block1) if_block1.d();
        if (detaching && div5_outro) div5_outro.end();
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block$a.name,
      type: "if",
      source: "(171:0) {#if estModaleAffichee}",
      ctx: ctx
    });
    return block;
  } // (203:10) {#if type}


  function create_if_block_2$6(ctx) {
    var span;
    var span_class_value;
    var block = {
      c: function create() {
        span = element("span");
        attr_dev(span, "class", span_class_value = "utd-icone-svg " +
        /*type*/
        ctx[1]);
        attr_dev(span, "aria-hidden", "true");
        add_location(span, file$d, 203, 12, 7420);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
      },
      p: function update(ctx, dirty) {
        if (dirty[0] &
        /*type*/
        2 && span_class_value !== (span_class_value = "utd-icone-svg " +
        /*type*/
        ctx[1])) {
          attr_dev(span, "class", span_class_value);
        }
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(span);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_2$6.name,
      type: "if",
      source: "(203:10) {#if type}",
      ctx: ctx
    });
    return block;
  } // (214:8) {#if Utils.slotExiste(slots, 'pied')}


  function create_if_block_1$7(ctx) {
    var div;
    var slot;
    var block = {
      c: function create() {
        div = element("div");
        slot = element("slot");
        attr_dev(slot, "name", "pied");
        add_location(slot, file$d, 215, 12, 7810);
        attr_dev(div, "class", "pied");
        add_location(div, file$d, 214, 10, 7778);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        append_dev(div, slot);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_1$7.name,
      type: "if",
      source: "(214:8) {#if Utils.slotExiste(slots, 'pied')}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment$d(ctx) {
    var t;
    var link;
    var current;
    var if_block =
    /*estModaleAffichee*/
    ctx[7] && create_if_block$a(ctx);
    var block = {
      c: function create() {
        if (if_block) if_block.c();
        t = space();
        link = element("link");
        this.c = noop;
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", Utils.cssFullPath);
        add_location(link, file$d, 223, 0, 7920);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (if_block) if_block.m(target, anchor);
        insert_dev(target, t, anchor);
        insert_dev(target, link, anchor);
        current = true;
      },
      p: function update(ctx, dirty) {
        if (
        /*estModaleAffichee*/
        ctx[7]) {
          if (if_block) {
            if_block.p(ctx, dirty);

            if (dirty[0] &
            /*estModaleAffichee*/
            128) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block$a(ctx);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(t.parentNode, t);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, function () {
            if_block = null;
          });
          check_outros();
        }
      },
      i: function intro(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block);
        current = false;
      },
      d: function destroy(detaching) {
        if (if_block) if_block.d(detaching);
        if (detaching) detach_dev(t);
        if (detaching) detach_dev(link);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$d.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function estBouton(element) {
    var tag = element.tagName.toLowerCase();
    return tag === 'button' || element.getAttribute('type') === 'submit';
  }

  function instance$d($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots$1 = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-dialog', slots$1, []);
    var _$$props$afficher = $$props.afficher,
        afficher = _$$props$afficher === void 0 ? 'false' : _$$props$afficher;
    var _$$props$type = $$props.type,
        type = _$$props$type === void 0 ? '' : _$$props$type;
    var _$$props$estfenetreme = $$props.estfenetremessage,
        estfenetremessage = _$$props$estfenetreme === void 0 ? 'false' : _$$props$estfenetreme; //Privée (utilisée dans notre plugin message)

    var _$$props$raisonFermet = $$props.raisonFermeture,
        raisonFermeture = _$$props$raisonFermet === void 0 ? '' : _$$props$raisonFermet; //Privée (utilisée dans notre plugin message)

    var _$$props$titre = $$props.titre,
        titre = _$$props$titre === void 0 ? '' : _$$props$titre;
    var _$$props$srBoutonFerm = $$props.srBoutonFermer,
        srBoutonFermer = _$$props$srBoutonFerm === void 0 ? Utils.obtenirLanguePage() === "fr" ? "Fermer" : "Close" : _$$props$srBoutonFerm;
    var _$$props$idFocusOuver = $$props.idFocusOuverture,
        idFocusOuverture = _$$props$idFocusOuver === void 0 ? '' : _$$props$idFocusOuver;
    var _$$props$idFocusFerme = $$props.idFocusFermeture,
        idFocusFermeture = _$$props$idFocusFerme === void 0 ? '' : _$$props$idFocusFerme;
    var _$$props$boutonsTexte = $$props.boutonsTexteLong,
        boutonsTexteLong = _$$props$boutonsTexte === void 0 ? 'false' : _$$props$boutonsTexte;
    var _$$props$forcerBouton = $$props.forcerBoutonsInline,
        forcerBoutonsInline = _$$props$forcerBouton === void 0 ? 'false' : _$$props$forcerBouton;
    var _$$props$affichageLat = $$props.affichageLateral,
        affichageLateral = _$$props$affichageLat === void 0 ? 'false' : _$$props$affichageLat;
    var idModale = Utils.genererId();
    var idEntete = Utils.genererId();
    var idCorps = Utils.genererId();
    var estModaleAffichee = afficher === 'true';
    var thisComponent = get_current_component();
    var html;
    var body;
    var slots = [];
    var mounted = false;
    onMount(function () {
      html = thisComponent.getRootNode().getElementsByTagName("html")[0];
      body = thisComponent.getRootNode().getElementsByTagName("body")[0];
      $$invalidate(8, slots = Array.from(thisComponent.querySelectorAll('[slot]')));
      mounted = true;

      if (Utils.estMobile()) {
        html.classList.add("est-mobile");
      }
    });

    function masquerModale(raisonFermetureModale) {
      $$invalidate(7, estModaleAffichee = false);
      $$invalidate(20, afficher = 'false'); //Si une raison de fermeture est reçue en param, on l'utilise sinon on prend la raison de fermeture qui est sur la modale "raisonFermeture" qui va contenir une raison de fermeture externe à la modale (ex. clic sur bouton primaire ou secondaire)

      var raison = raisonFermetureModale || raisonFermeture; //On redonne le focus au contrôle spécifié (normalement celui qui a initié l'affichage de la fenêtre modale)

      var controleFocus = thisComponent.getRootNode().getElementById(idFocusFermeture);

      if (controleFocus) {
        controleFocus.focus();
      }

      Utils.dispatchWcEvent(thisComponent, "fermeture", {
        raisonFermeture: raison
      });
    }

    function animationAffichageOuverture(node) {
      return affichageLateral === 'false' ? fade(node, {
        duration: 250
      }) : fly(node, {
        x: 200,
        duration: 250
      });
    }

    function animationAffichageFermeture(node) {
      return affichageLateral === 'false' ? fade(node, {
        y: 200,
        duration: 250
      }) : fly(node, {
        x: 200,
        duration: 250
      });
    } // Exécuté lorsque la valeur de la prop "afficher" change


    function toggleAfficher() {
      if (mounted) {
        if (afficher === 'true') {
          $$invalidate(21, raisonFermeture = '');
          Utils.ajusterInterfaceAvantAffichageModale(html, body);
          $$invalidate(7, estModaleAffichee = true);
        } else {
          if (estModaleAffichee) {
            masquerModale();
          }
        }
      }
    }

    function keydown(e) {
      if (e.key === "Escape") {
        masquerModale('escape');
      }
    }

    function clickModale(e) {
      if (e.target === e.currentTarget) {
        masquerModale('clickBackdrop');
      }
    }

    function finAnimationFermeture(e) {
      Utils.ajusterInterfaceApresFermetureModale(html, body, thisComponent.shadowRoot.getElementById(idModale));
      Utils.dispatchWcEvent(thisComponent, "apresFermeture");
    }

    function ajusterModaleDebutAffichage(e) {
      var modale = thisComponent.shadowRoot.getElementById(idModale);
      donnerfocusPremierElementFocusable(modale);
      Utils.conserverFocusElement(modale, thisComponent);
    }

    function ajusterModaleFinAffichage(e) {
      var modale = thisComponent.shadowRoot.getElementById(idModale);
      Utils.ajusterInterfacePendantAffichageModale(body, modale); //On force un scrollTop ici car Android ne semble pas supporter le preventScroll de la méthode focus (mais selon la doc il devrait). SOLUTION EN ATTENDANT MIEUX.

      modale.scrollTop = 0;
    }

    function donnerfocusPremierElementFocusable(modale) {
      var premierElementFocusable = null;

      if (estfenetremessage === 'true') {
        premierElementFocusable = thisComponent.querySelector('.utd-btn.primaire');
      } else {
        if (idFocusOuverture) {
          var controleFocusOuverture = document.getElementById(idFocusOuverture);

          if (controleFocusOuverture) {
            premierElementFocusable = controleFocusOuverture;
          }
        }

        if (!premierElementFocusable) {
          var elementsFocusablesShadow = Array.from(Utils.obtenirElementsFocusables(modale));
          var elementsFocusablesRoot = Array.from(Utils.obtenirElementsFocusables(thisComponent));
          var elementsFocusables = elementsFocusablesRoot.concat(elementsFocusablesShadow);
          premierElementFocusable = elementsFocusables[0]; //On force le mode "fenêtre de message" si le premier élément focusable est un bouton de la slot "pied"

          if (estBouton(premierElementFocusable)) {
            var slotPied = Utils.obtenirSlot(slots, 'pied');

            if (slotPied) {
              var boutonsSlotPied = slotPied.querySelectorAll('button, input[type="submit"]');

              if (boutonsSlotPied.length) {
                for (var i = 0; i < boutonsSlotPied.length - 1; i++) {
                  if (boutonsSlotPied[i] === premierElementFocusable) {
                    premierElementFocusable = thisComponent.querySelector('.utd-btn.primaire') || premierElementFocusable;
                    $$invalidate(0, estfenetremessage = 'true');
                    break;
                  }
                }
              }
            }
          }
        }
      }

      premierElementFocusable.focus({
        preventScroll: true
      });
    } //premierElementFocusable.focus()    


    var writable_props = ['afficher', 'type', 'estfenetremessage', 'raisonFermeture', 'titre', 'srBoutonFermer', 'idFocusOuverture', 'idFocusFermeture', 'boutonsTexteLong', 'forcerBoutonsInline', 'affichageLateral'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-dialog> was created with unknown prop '".concat(key, "'"));
    });

    var click_handler = function click_handler() {
      return masquerModale('clickBackdrop');
    };

    var click_handler_1 = function click_handler_1() {
      return masquerModale('boutonFermer');
    };

    $$self.$$set = function ($$props) {
      if ('afficher' in $$props) $$invalidate(20, afficher = $$props.afficher);
      if ('type' in $$props) $$invalidate(1, type = $$props.type);
      if ('estfenetremessage' in $$props) $$invalidate(0, estfenetremessage = $$props.estfenetremessage);
      if ('raisonFermeture' in $$props) $$invalidate(21, raisonFermeture = $$props.raisonFermeture);
      if ('titre' in $$props) $$invalidate(2, titre = $$props.titre);
      if ('srBoutonFermer' in $$props) $$invalidate(3, srBoutonFermer = $$props.srBoutonFermer);
      if ('idFocusOuverture' in $$props) $$invalidate(22, idFocusOuverture = $$props.idFocusOuverture);
      if ('idFocusFermeture' in $$props) $$invalidate(23, idFocusFermeture = $$props.idFocusFermeture);
      if ('boutonsTexteLong' in $$props) $$invalidate(4, boutonsTexteLong = $$props.boutonsTexteLong);
      if ('forcerBoutonsInline' in $$props) $$invalidate(5, forcerBoutonsInline = $$props.forcerBoutonsInline);
      if ('affichageLateral' in $$props) $$invalidate(6, affichageLateral = $$props.affichageLateral);
    };

    $$self.$capture_state = function () {
      return {
        onMount: onMount,
        fly: fly,
        fade: fade,
        get_current_component: get_current_component,
        Utils: Utils,
        afficher: afficher,
        type: type,
        estfenetremessage: estfenetremessage,
        raisonFermeture: raisonFermeture,
        titre: titre,
        srBoutonFermer: srBoutonFermer,
        idFocusOuverture: idFocusOuverture,
        idFocusFermeture: idFocusFermeture,
        boutonsTexteLong: boutonsTexteLong,
        forcerBoutonsInline: forcerBoutonsInline,
        affichageLateral: affichageLateral,
        idModale: idModale,
        idEntete: idEntete,
        idCorps: idCorps,
        estModaleAffichee: estModaleAffichee,
        thisComponent: thisComponent,
        html: html,
        body: body,
        slots: slots,
        mounted: mounted,
        masquerModale: masquerModale,
        animationAffichageOuverture: animationAffichageOuverture,
        animationAffichageFermeture: animationAffichageFermeture,
        toggleAfficher: toggleAfficher,
        keydown: keydown,
        clickModale: clickModale,
        finAnimationFermeture: finAnimationFermeture,
        ajusterModaleDebutAffichage: ajusterModaleDebutAffichage,
        ajusterModaleFinAffichage: ajusterModaleFinAffichage,
        estBouton: estBouton,
        donnerfocusPremierElementFocusable: donnerfocusPremierElementFocusable
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('afficher' in $$props) $$invalidate(20, afficher = $$props.afficher);
      if ('type' in $$props) $$invalidate(1, type = $$props.type);
      if ('estfenetremessage' in $$props) $$invalidate(0, estfenetremessage = $$props.estfenetremessage);
      if ('raisonFermeture' in $$props) $$invalidate(21, raisonFermeture = $$props.raisonFermeture);
      if ('titre' in $$props) $$invalidate(2, titre = $$props.titre);
      if ('srBoutonFermer' in $$props) $$invalidate(3, srBoutonFermer = $$props.srBoutonFermer);
      if ('idFocusOuverture' in $$props) $$invalidate(22, idFocusOuverture = $$props.idFocusOuverture);
      if ('idFocusFermeture' in $$props) $$invalidate(23, idFocusFermeture = $$props.idFocusFermeture);
      if ('boutonsTexteLong' in $$props) $$invalidate(4, boutonsTexteLong = $$props.boutonsTexteLong);
      if ('forcerBoutonsInline' in $$props) $$invalidate(5, forcerBoutonsInline = $$props.forcerBoutonsInline);
      if ('affichageLateral' in $$props) $$invalidate(6, affichageLateral = $$props.affichageLateral);
      if ('estModaleAffichee' in $$props) $$invalidate(7, estModaleAffichee = $$props.estModaleAffichee);
      if ('html' in $$props) html = $$props.html;
      if ('body' in $$props) body = $$props.body;
      if ('slots' in $$props) $$invalidate(8, slots = $$props.slots);
      if ('mounted' in $$props) mounted = $$props.mounted;
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    $$self.$$.update = function () {
      if ($$self.$$.dirty[0] &
      /*afficher*/
      1048576) {
        // Watch sur la prop afficher
        toggleAfficher();
      }
    };

    return [estfenetremessage, type, titre, srBoutonFermer, boutonsTexteLong, forcerBoutonsInline, affichageLateral, estModaleAffichee, slots, idModale, idEntete, idCorps, masquerModale, animationAffichageOuverture, animationAffichageFermeture, keydown, clickModale, finAnimationFermeture, ajusterModaleDebutAffichage, ajusterModaleFinAffichage, afficher, raisonFermeture, idFocusOuverture, idFocusFermeture, click_handler, click_handler_1];
  }

  var DialogueModal = /*#__PURE__*/function (_SvelteElement) {
    _inherits(DialogueModal, _SvelteElement);

    var _super = _createSuper$d(DialogueModal);

    function DialogueModal(options) {
      var _this;

      _classCallCheck(this, DialogueModal);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$d, create_fragment$d, safe_not_equal, {
        afficher: 20,
        type: 1,
        estfenetremessage: 0,
        raisonFermeture: 21,
        titre: 2,
        srBoutonFermer: 3,
        idFocusOuverture: 22,
        idFocusFermeture: 23,
        boutonsTexteLong: 4,
        forcerBoutonsInline: 5,
        affichageLateral: 6
      }, null, [-1, -1]);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(DialogueModal, [{
      key: "afficher",
      get: function get() {
        return this.$$.ctx[20];
      },
      set: function set(afficher) {
        this.$$set({
          afficher: afficher
        });
        flush();
      }
    }, {
      key: "type",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(type) {
        this.$$set({
          type: type
        });
        flush();
      }
    }, {
      key: "estfenetremessage",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(estfenetremessage) {
        this.$$set({
          estfenetremessage: estfenetremessage
        });
        flush();
      }
    }, {
      key: "raisonFermeture",
      get: function get() {
        return this.$$.ctx[21];
      },
      set: function set(raisonFermeture) {
        this.$$set({
          raisonFermeture: raisonFermeture
        });
        flush();
      }
    }, {
      key: "titre",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(titre) {
        this.$$set({
          titre: titre
        });
        flush();
      }
    }, {
      key: "srBoutonFermer",
      get: function get() {
        return this.$$.ctx[3];
      },
      set: function set(srBoutonFermer) {
        this.$$set({
          srBoutonFermer: srBoutonFermer
        });
        flush();
      }
    }, {
      key: "idFocusOuverture",
      get: function get() {
        return this.$$.ctx[22];
      },
      set: function set(idFocusOuverture) {
        this.$$set({
          idFocusOuverture: idFocusOuverture
        });
        flush();
      }
    }, {
      key: "idFocusFermeture",
      get: function get() {
        return this.$$.ctx[23];
      },
      set: function set(idFocusFermeture) {
        this.$$set({
          idFocusFermeture: idFocusFermeture
        });
        flush();
      }
    }, {
      key: "boutonsTexteLong",
      get: function get() {
        return this.$$.ctx[4];
      },
      set: function set(boutonsTexteLong) {
        this.$$set({
          boutonsTexteLong: boutonsTexteLong
        });
        flush();
      }
    }, {
      key: "forcerBoutonsInline",
      get: function get() {
        return this.$$.ctx[5];
      },
      set: function set(forcerBoutonsInline) {
        this.$$set({
          forcerBoutonsInline: forcerBoutonsInline
        });
        flush();
      }
    }, {
      key: "affichageLateral",
      get: function get() {
        return this.$$.ctx[6];
      },
      set: function set(affichageLateral) {
        this.$$set({
          affichageLateral: affichageLateral
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["afficher", "type", "estfenetremessage", "raisonFermeture", "titre", "srBoutonFermer", "idFocusOuverture", "idFocusFermeture", "boutonsTexteLong", "forcerBoutonsInline", "affichageLateral"];
      }
    }]);

    return DialogueModal;
  }(SvelteElement);

  customElements.define("utd-dialog", DialogueModal);

  function _createSuper$c(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$c(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$c() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$c = "src\\components\\hautPage.svelte";

  function create_fragment$c(ctx) {
    var div1;
    var button;
    var div0;
    var span;
    var t;
    var link;
    var mounted;
    var dispose;
    var block = {
      c: function create() {
        div1 = element("div");
        button = element("button");
        div0 = element("div");
        span = element("span");
        t = space();
        link = element("link");
        this.c = noop;
        attr_dev(span, "aria-hidden", "true");
        attr_dev(span, "class", "utd-icone-svg fleche-haut-blanche");
        add_location(span, file$c, 74, 6, 2197);
        attr_dev(div0, "class", "contenu");
        add_location(div0, file$c, 73, 4, 2168);
        attr_dev(button, "type", "button");
        attr_dev(button, "class", "utd-btn primaire");
        attr_dev(button, "title",
        /*title*/
        ctx[0]);
        add_location(button, file$c, 72, 2, 2071);
        attr_dev(div1, "class", "utd-component utd-hautpage");
        add_location(div1, file$c, 71, 0, 2027);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", Utils.cssFullPath);
        add_location(link, file$c, 79, 0, 2311);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div1, anchor);
        append_dev(div1, button);
        append_dev(button, div0);
        append_dev(div0, span);
        insert_dev(target, t, anchor);
        insert_dev(target, link, anchor);

        if (!mounted) {
          dispose = listen_dev(button, "click", scrollerHautPage, false, false, false);
          mounted = true;
        }
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        if (dirty &
        /*title*/
        1) {
          attr_dev(button, "title",
          /*title*/
          ctx[0]);
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(div1);
        if (detaching) detach_dev(t);
        if (detaching) detach_dev(link);
        mounted = false;
        dispose();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$c.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function scrollerHautPage(e) {
    window.scrollTo({
      top: 0,
      behavior: 'smooth'
    });
  }

  function instance$c($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-hautpage', slots, []);
    var _$$props$title = $$props.title,
        title = _$$props$title === void 0 ? Utils.obtenirLanguePage() === 'fr' ? "Retour en haut de page." : "Return to the top of the page." : _$$props$title;
    var _$$props$hauteurMinim = $$props.hauteurMinimaleSroll,
        hauteurMinimaleSroll = _$$props$hauteurMinim === void 0 ? 555 : _$$props$hauteurMinim;
    var thisComponent = get_current_component();
    var html;
    var controle;
    var ticking = false;
    onMount(function () {
      html = thisComponent.getRootNode().getElementsByTagName("html")[0];
      controle = thisComponent.shadowRoot.querySelector('.utd-hautpage');
      controle.classList.add("utd-d-none");
      Utils.reafficherApresChargement(thisComponent);
    });
    window.addEventListener('scroll', function (e) {
      if (!ticking) {
        window.requestAnimationFrame(function () {
          gererAffichageBouton();
          ticking = false;
        });
      }

      ticking = true;
    });

    function gererAffichageBouton() {
      var dureeAnimationMs = 500;

      if (html.classList.contains('utd-modale-ouverte')) {
        //Si une fenêtre modale est ouverte, on ne fait rien pour le bouton de retour haut de page
        return;
      }

      if (document.body.scrollTop > hauteurMinimaleSroll || document.documentElement.scrollTop > hauteurMinimaleSroll) {
        if (controle.classList.contains('utd-d-none')) {
          controle.classList.remove('utd-d-none');
          setTimeout(function () {
            html.setAttribute('retourhautpagevisible', 'true');
            controle.classList.add('visible');
          }, 10);
        }
      } else {
        if (controle.classList.contains("visible")) {
          setTimeout(function () {
            controle.classList.add('utd-d-none');
            html.setAttribute('retourhautpagevisible', 'false');
          }, dureeAnimationMs);
        }

        controle.classList.remove('visible');
      }
    }

    var writable_props = ['title', 'hauteurMinimaleSroll'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-hautpage> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('title' in $$props) $$invalidate(0, title = $$props.title);
      if ('hauteurMinimaleSroll' in $$props) $$invalidate(1, hauteurMinimaleSroll = $$props.hauteurMinimaleSroll);
    };

    $$self.$capture_state = function () {
      return {
        onMount: onMount,
        Utils: Utils,
        get_current_component: get_current_component,
        title: title,
        hauteurMinimaleSroll: hauteurMinimaleSroll,
        thisComponent: thisComponent,
        html: html,
        controle: controle,
        ticking: ticking,
        gererAffichageBouton: gererAffichageBouton,
        scrollerHautPage: scrollerHautPage
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('title' in $$props) $$invalidate(0, title = $$props.title);
      if ('hauteurMinimaleSroll' in $$props) $$invalidate(1, hauteurMinimaleSroll = $$props.hauteurMinimaleSroll);
      if ('html' in $$props) html = $$props.html;
      if ('controle' in $$props) controle = $$props.controle;
      if ('ticking' in $$props) ticking = $$props.ticking;
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    return [title, hauteurMinimaleSroll];
  }

  var HautPage = /*#__PURE__*/function (_SvelteElement) {
    _inherits(HautPage, _SvelteElement);

    var _super = _createSuper$c(HautPage);

    function HautPage(options) {
      var _this;

      _classCallCheck(this, HautPage);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$c, create_fragment$c, safe_not_equal, {
        title: 0,
        hauteurMinimaleSroll: 1
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(HautPage, [{
      key: "title",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(title) {
        this.$$set({
          title: title
        });
        flush();
      }
    }, {
      key: "hauteurMinimaleSroll",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(hauteurMinimaleSroll) {
        this.$$set({
          hauteurMinimaleSroll: hauteurMinimaleSroll
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["title", "hauteurMinimaleSroll"];
      }
    }]);

    return HautPage;
  }(SvelteElement);

  customElements.define("utd-hautpage", HautPage);

  function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _createSuper$b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$b(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$b() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$b = "src\\components\\infobulle.svelte"; // (100:2) {#if $$slots["texte-lie"]}

  function create_if_block_4$3(ctx) {
    var span;
    var slot;
    var mounted;
    var dispose;
    var block = {
      c: function create() {
        span = element("span");
        slot = element("slot");
        attr_dev(slot, "name", "texte-lie");
        add_location(slot, file$b, 100, 54, 3787);
        attr_dev(span, "class", "texte-lie");
        add_location(span, file$b, 100, 4, 3737);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
        append_dev(span, slot);

        if (!mounted) {
          dispose = listen_dev(span, "click",
          /*afficherModale*/
          ctx[13], false, false, false);
          mounted = true;
        }
      },
      p: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(span);
        mounted = false;
        dispose();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_4$3.name,
      type: "if",
      source: "(100:2) {#if $$slots[\\\"texte-lie\\\"]}",
      ctx: ctx
    });
    return block;
  } // (115:2) {#if afficher}


  function create_if_block$9(ctx) {
    var div;
    var t0;
    var span7;
    var span3;
    var h1;
    var span0;
    var t1;
    var span1;
    var t2;
    var button;
    var span2;
    var t3;
    var span6;
    var span4;
    var t4;
    var t5;
    var span5;
    var show_if;
    var span7_intro;
    var span7_outro;
    var current;
    var mounted;
    var dispose;
    var if_block0 =
    /*titre*/
    ctx[1] && create_if_block_3$3(ctx);

    function select_block_type(ctx, dirty) {
      if (dirty &
      /*slots*/
      128) show_if = null;
      if (show_if == null) show_if = !!Utils.slotExiste(
      /*slots*/
      ctx[7], 'contenu');
      if (show_if) return create_if_block_1$6;
      if (
      /*contenu*/
      ctx[6]) return create_if_block_2$5;
    }

    var current_block_type = select_block_type(ctx, -1);
    var if_block1 = current_block_type && current_block_type(ctx);
    var block = {
      c: function create() {
        div = element("div");
        t0 = space();
        span7 = element("span");
        span3 = element("span");
        h1 = element("h1");
        span0 = element("span");
        t1 = space();
        span1 = element("span");
        if (if_block0) if_block0.c();
        t2 = space();
        button = element("button");
        span2 = element("span");
        t3 = space();
        span6 = element("span");
        span4 = element("span");
        t4 = text(
        /*srPrefixeContenu*/
        ctx[3]);
        t5 = space();
        span5 = element("span");
        if (if_block1) if_block1.c();
        attr_dev(div, "class", "utd-backdrop");
        add_location(div, file$b, 115, 4, 4267);
        attr_dev(span0, "class", "utd-sr-only");
        add_location(span0, file$b, 130, 10, 4745);
        add_location(span1, file$b, 131, 10, 4805);
        attr_dev(h1, "id",
        /*idEntete*/
        ctx[11]);
        add_location(h1, file$b, 129, 8, 4715);
        attr_dev(span2, "aria-hidden", "true");
        attr_dev(span2, "class", "utd-icone-svg x-fermer-bleu");
        add_location(span2, file$b, 143, 10, 5077);
        attr_dev(button, "type", "button");
        attr_dev(button, "class", "close");
        attr_dev(button, "aria-label",
        /*srBoutonFermer*/
        ctx[5]);
        add_location(button, file$b, 137, 8, 4922);
        attr_dev(span3, "class", "utd-container entete");
        add_location(span3, file$b, 128, 6, 4670);
        attr_dev(span4, "class", "utd-sr-only");
        attr_dev(span4, "id",
        /*idPrefixeContenu*/
        ctx[12]);
        attr_dev(span4, "tabindex", "-1");
        add_location(span4, file$b, 150, 8, 5273);
        attr_dev(span5, "class", "corps");
        add_location(span5, file$b, 151, 8, 5372);
        attr_dev(span6, "class", "utd-container conteneur-corps");
        add_location(span6, file$b, 149, 6, 5219);
        attr_dev(span7, "aria-labelledby",
        /*idEntete*/
        ctx[11]);
        attr_dev(span7, "class", "modale");
        attr_dev(span7, "id",
        /*idModale*/
        ctx[10]);
        attr_dev(span7, "aria-modal", "true");
        attr_dev(span7, "role", "dialog");
        add_location(span7, file$b, 116, 4, 4326);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        insert_dev(target, t0, anchor);
        insert_dev(target, span7, anchor);
        append_dev(span7, span3);
        append_dev(span3, h1);
        append_dev(h1, span0);
        span0.innerHTML =
        /*srTitre*/
        ctx[2];
        append_dev(h1, t1);
        append_dev(h1, span1);
        if (if_block0) if_block0.m(span1, null);
        append_dev(span3, t2);
        append_dev(span3, button);
        append_dev(button, span2);
        append_dev(span7, t3);
        append_dev(span7, span6);
        append_dev(span6, span4);
        append_dev(span4, t4);
        append_dev(span6, t5);
        append_dev(span6, span5);
        if (if_block1) if_block1.m(span5, null);
        current = true;

        if (!mounted) {
          dispose = [listen_dev(div, "click",
          /*masquerModale*/
          ctx[14], false, false, false), listen_dev(button, "click",
          /*masquerModale*/
          ctx[14], false, false, false), listen_dev(span7, "keydown",
          /*keydown*/
          ctx[15], false, false, false), listen_dev(span7, "introend",
          /*conserverFocusInfobulle*/
          ctx[17], false, false, false), listen_dev(span7, "outroend",
          /*finAnimationFermeture*/
          ctx[16], false, false, false)];
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (!current || dirty &
        /*srTitre*/
        4) span0.innerHTML =
        /*srTitre*/
        ctx[2];

        if (
        /*titre*/
        ctx[1]) {
          if (if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0 = create_if_block_3$3(ctx);
            if_block0.c();
            if_block0.m(span1, null);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }

        if (!current || dirty &
        /*srBoutonFermer*/
        32) {
          attr_dev(button, "aria-label",
          /*srBoutonFermer*/
          ctx[5]);
        }

        if (!current || dirty &
        /*srPrefixeContenu*/
        8) set_data_dev(t4,
        /*srPrefixeContenu*/
        ctx[3]);

        if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if (if_block1) if_block1.d(1);
          if_block1 = current_block_type && current_block_type(ctx);

          if (if_block1) {
            if_block1.c();
            if_block1.m(span5, null);
          }
        }
      },
      i: function intro(local) {
        if (current) return;
        add_render_callback(function () {
          if (span7_outro) span7_outro.end(1);
          span7_intro = create_in_transition(span7, fly, {
            y: 200,
            duration: 500
          });
          span7_intro.start();
        });
        current = true;
      },
      o: function outro(local) {
        if (span7_intro) span7_intro.invalidate();
        span7_outro = create_out_transition(span7, fly, {
          y: 200,
          duration: 250
        });
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
        if (detaching) detach_dev(t0);
        if (detaching) detach_dev(span7);
        if (if_block0) if_block0.d();

        if (if_block1) {
          if_block1.d();
        }

        if (detaching && span7_outro) span7_outro.end();
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block$9.name,
      type: "if",
      source: "(115:2) {#if afficher}",
      ctx: ctx
    });
    return block;
  } // (133:12) {#if titre}


  function create_if_block_3$3(ctx) {
    var t;
    var block = {
      c: function create() {
        t = text(
        /*titre*/
        ctx[1]);
      },
      m: function mount(target, anchor) {
        insert_dev(target, t, anchor);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*titre*/
        2) set_data_dev(t,
        /*titre*/
        ctx[1]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(t);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_3$3.name,
      type: "if",
      source: "(133:12) {#if titre}",
      ctx: ctx
    });
    return block;
  } // (159:14) {#if contenu}


  function create_if_block_2$5(ctx) {
    var html_tag;
    var html_anchor;
    var block = {
      c: function create() {
        html_tag = new HtmlTag(false);
        html_anchor = empty();
        html_tag.a = html_anchor;
      },
      m: function mount(target, anchor) {
        html_tag.m(
        /*contenu*/
        ctx[6], target, anchor);
        insert_dev(target, html_anchor, anchor);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*contenu*/
        64) html_tag.p(
        /*contenu*/
        ctx[6]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(html_anchor);
        if (detaching) html_tag.d();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_2$5.name,
      type: "if",
      source: "(159:14) {#if contenu}",
      ctx: ctx
    });
    return block;
  } // (153:12) {#if Utils.slotExiste(slots, 'contenu')}


  function create_if_block_1$6(ctx) {
    var slot;
    var t;
    var span;
    var block = {
      c: function create() {
        slot = element("slot");
        t = space();
        span = element("span");
        attr_dev(slot, "name", "contenu");
        attr_dev(slot, "class", "utd-d-none");
        add_location(slot, file$b, 153, 14, 5462);
        add_location(span, file$b, 154, 14, 5519);
      },
      m: function mount(target, anchor) {
        insert_dev(target, slot, anchor);
        insert_dev(target, t, anchor);
        insert_dev(target, span, anchor);
        span.innerHTML =
        /*htmlSlotContenu*/
        ctx[8];
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*htmlSlotContenu*/
        256) span.innerHTML =
        /*htmlSlotContenu*/
        ctx[8];
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(slot);
        if (detaching) detach_dev(t);
        if (detaching) detach_dev(span);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_1$6.name,
      type: "if",
      source: "(153:12) {#if Utils.slotExiste(slots, 'contenu')}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment$b(ctx) {
    var span4;
    var t0;
    var span3;
    var t1;
    var button;
    var span2;
    var span1;
    var span0;
    var t2;
    var t3;
    var link;
    var current;
    var mounted;
    var dispose;
    var if_block0 =
    /*$$slots*/
    ctx[18]["texte-lie"] && create_if_block_4$3(ctx);
    var if_block1 =
    /*afficher*/
    ctx[0] && create_if_block$9(ctx);
    var block = {
      c: function create() {
        span4 = element("span");
        if (if_block0) if_block0.c();
        t0 = space();
        span3 = element("span");
        t1 = space();
        button = element("button");
        span2 = element("span");
        span1 = element("span");
        span0 = element("span");
        t2 = space();
        if (if_block1) if_block1.c();
        t3 = space();
        link = element("link");
        this.c = noop;
        attr_dev(span0, "aria-hidden", "true");
        attr_dev(span0, "class", "utd-icone-svg question");
        add_location(span0, file$b, 105, 10, 4088);
        attr_dev(span1, "aria-hidden", "true");
        attr_dev(span1, "class", "puce");
        add_location(span1, file$b, 104, 8, 4038);
        attr_dev(span2, "class", "conteneur-puce");
        add_location(span2, file$b, 103, 6, 3999);
        attr_dev(button, "type", "button");
        attr_dev(button, "id",
        /*idBoutonToggle*/
        ctx[9]);
        attr_dev(button, "aria-label",
        /*srBoutonOuvrir*/
        ctx[4]);
        attr_dev(button, "class", "tooltip-toggle");
        add_location(button, file$b, 102, 42, 3872);
        attr_dev(span3, "class", "conteneur-tooltip");
        add_location(span3, file$b, 102, 2, 3832);
        attr_dev(span4, "class", "utd-component utd-infobulle");
        add_location(span4, file$b, 98, 0, 3659);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", Utils.cssFullPath);
        add_location(link, file$b, 168, 0, 5815);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, span4, anchor);
        if (if_block0) if_block0.m(span4, null);
        append_dev(span4, t0);
        append_dev(span4, span3);
        append_dev(span3, t1);
        append_dev(span3, button);
        append_dev(button, span2);
        append_dev(span2, span1);
        append_dev(span1, span0);
        append_dev(span4, t2);
        if (if_block1) if_block1.m(span4, null);
        insert_dev(target, t3, anchor);
        insert_dev(target, link, anchor);
        current = true;

        if (!mounted) {
          dispose = listen_dev(button, "click",
          /*afficherModale*/
          ctx[13], false, false, false);
          mounted = true;
        }
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        if (
        /*$$slots*/
        ctx[18]["texte-lie"]) {
          if (if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0 = create_if_block_4$3(ctx);
            if_block0.c();
            if_block0.m(span4, t0);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }

        if (!current || dirty &
        /*srBoutonOuvrir*/
        16) {
          attr_dev(button, "aria-label",
          /*srBoutonOuvrir*/
          ctx[4]);
        }

        if (
        /*afficher*/
        ctx[0]) {
          if (if_block1) {
            if_block1.p(ctx, dirty);

            if (dirty &
            /*afficher*/
            1) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block$9(ctx);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(span4, null);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, function () {
            if_block1 = null;
          });
          check_outros();
        }
      },
      i: function intro(local) {
        if (current) return;
        transition_in(if_block1);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block1);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(span4);
        if (if_block0) if_block0.d();
        if (if_block1) if_block1.d();
        if (detaching) detach_dev(t3);
        if (detaching) detach_dev(link);
        mounted = false;
        dispose();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$b.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function instance$b($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots$1 = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-infobulle', slots$1, []);
    var $$slots = compute_slots(slots$1);
    var _$$props$afficher = $$props.afficher,
        afficher = _$$props$afficher === void 0 ? false : _$$props$afficher;
    var _$$props$titre = $$props.titre,
        titre = _$$props$titre === void 0 ? "" : _$$props$titre;
    var _$$props$srTitre = $$props.srTitre,
        srTitre = _$$props$srTitre === void 0 ? Utils.obtenirLanguePage() === "fr" ? "Aide concernant&nbsp;" : "Help concerning&nbsp;" : _$$props$srTitre;
    var _$$props$srPrefixeCon = $$props.srPrefixeContenu,
        srPrefixeContenu = _$$props$srPrefixeCon === void 0 ? Utils.obtenirLanguePage() === "fr" ? "Détails :" : "Details:" : _$$props$srPrefixeCon;
    var _$$props$srBoutonOuvr = $$props.srBoutonOuvrir,
        srBoutonOuvrir = _$$props$srBoutonOuvr === void 0 ? Utils.obtenirLanguePage() === "fr" ? "Afficher l'aide contextuelle" : "Show help about" : _$$props$srBoutonOuvr;
    var _$$props$srBoutonFerm = $$props.srBoutonFermer,
        srBoutonFermer = _$$props$srBoutonFerm === void 0 ? Utils.obtenirLanguePage() === "fr" ? "Fermer" : "Close" : _$$props$srBoutonFerm;
    var _$$props$contenu = $$props.contenu,
        contenu = _$$props$contenu === void 0 ? "" : _$$props$contenu;
    var idBoutonToggle = Utils.genererId();
    var idModale = Utils.genererId();
    var idEntete = Utils.genererId();
    var idPrefixeContenu = Utils.genererId();
    var thisComponent = get_current_component();
    var html;
    var body;
    var slots = [];
    var htmlSlotContenu;
    onMount(function () {
      html = thisComponent.getRootNode().getElementsByTagName("html")[0];
      body = thisComponent.getRootNode().getElementsByTagName("body")[0];
      $$invalidate(7, slots = Array.from(thisComponent.querySelectorAll('[slot]')));
      assignerHtmlSlotContenu();

      if (Utils.estMobile()) {
        html.classList.add("est-mobile");
      }

      Utils.reafficherApresChargement(thisComponent);
    });
    /**
    * Permet de pallier à un problème de perte de focus à l'intérieur de la modale. En effet, si on clique dans le contenu de la slot "contenu" et qu'on fait TAB, le focus
    * tombe dans la page en dessous car le keydown est sur le body de la page (probablement car nous sommes dans une slot).
    * Nous cachons donc le contenu de la slot, récupérons son html et l'assignons nous-même au contrôle. De cette façon nous allons nous réglons le problème et en bonus
    * nous nous assurons d'une conformité visuelle, puisque c'est le css de notre composant qui va s'appliquer et non celui de l'application.
    * NOTE. Le problème ne semble pas se produire avec le composant utd-dialog. On dirait que le fait que d'autres contrôles focusables sont présents empêche le problème. Je ne comprends pas vraiment.
    */

    function assignerHtmlSlotContenu() {
      if (slots.length) {
        var slotContenu = thisComponent.querySelector("[slot=contenu]");

        if (slotContenu) {
          var contenuHtml = thisComponent.querySelector("[slot=contenu]").innerHTML;

          if (contenuHtml) {
            $$invalidate(8, htmlSlotContenu = contenuHtml);
          }
        }
      }
    }

    function afficherModale(e) {
      Utils.ajusterInterfaceAvantAffichageModale(html, body);
      $$invalidate(0, afficher = true);
    }

    function masquerModale(e) {
      $$invalidate(0, afficher = false);
      redonnerFocusBoutonToggle();
    }

    function redonnerFocusBoutonToggle() {
      var controleFocus = thisComponent.shadowRoot.getElementById(idBoutonToggle);

      if (controleFocus) {
        //On redonne le focus au contrôle spécifié (normalement le bouton toggle de l'infobulle)
        controleFocus.focus();
      }
    }

    function keydown(e) {
      if (e.key === "Escape") {
        masquerModale();
      }
    }

    function finAnimationFermeture(e) {
      Utils.ajusterInterfaceApresFermetureModale(html, body);
    }

    function conserverFocusInfobulle(e) {
      thisComponent.shadowRoot.getElementById(idPrefixeContenu).focus();
      Utils.conserverFocusElement(thisComponent.shadowRoot.getElementById(idModale), thisComponent);
    }

    var writable_props = ['afficher', 'titre', 'srTitre', 'srPrefixeContenu', 'srBoutonOuvrir', 'srBoutonFermer', 'contenu'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-infobulle> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('afficher' in $$props) $$invalidate(0, afficher = $$props.afficher);
      if ('titre' in $$props) $$invalidate(1, titre = $$props.titre);
      if ('srTitre' in $$props) $$invalidate(2, srTitre = $$props.srTitre);
      if ('srPrefixeContenu' in $$props) $$invalidate(3, srPrefixeContenu = $$props.srPrefixeContenu);
      if ('srBoutonOuvrir' in $$props) $$invalidate(4, srBoutonOuvrir = $$props.srBoutonOuvrir);
      if ('srBoutonFermer' in $$props) $$invalidate(5, srBoutonFermer = $$props.srBoutonFermer);
      if ('contenu' in $$props) $$invalidate(6, contenu = $$props.contenu);
    };

    $$self.$capture_state = function () {
      return {
        onMount: onMount,
        fly: fly,
        get_current_component: get_current_component,
        Utils: Utils,
        afficher: afficher,
        titre: titre,
        srTitre: srTitre,
        srPrefixeContenu: srPrefixeContenu,
        srBoutonOuvrir: srBoutonOuvrir,
        srBoutonFermer: srBoutonFermer,
        contenu: contenu,
        idBoutonToggle: idBoutonToggle,
        idModale: idModale,
        idEntete: idEntete,
        idPrefixeContenu: idPrefixeContenu,
        thisComponent: thisComponent,
        html: html,
        body: body,
        slots: slots,
        htmlSlotContenu: htmlSlotContenu,
        assignerHtmlSlotContenu: assignerHtmlSlotContenu,
        afficherModale: afficherModale,
        masquerModale: masquerModale,
        redonnerFocusBoutonToggle: redonnerFocusBoutonToggle,
        keydown: keydown,
        finAnimationFermeture: finAnimationFermeture,
        conserverFocusInfobulle: conserverFocusInfobulle
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('afficher' in $$props) $$invalidate(0, afficher = $$props.afficher);
      if ('titre' in $$props) $$invalidate(1, titre = $$props.titre);
      if ('srTitre' in $$props) $$invalidate(2, srTitre = $$props.srTitre);
      if ('srPrefixeContenu' in $$props) $$invalidate(3, srPrefixeContenu = $$props.srPrefixeContenu);
      if ('srBoutonOuvrir' in $$props) $$invalidate(4, srBoutonOuvrir = $$props.srBoutonOuvrir);
      if ('srBoutonFermer' in $$props) $$invalidate(5, srBoutonFermer = $$props.srBoutonFermer);
      if ('contenu' in $$props) $$invalidate(6, contenu = $$props.contenu);
      if ('html' in $$props) html = $$props.html;
      if ('body' in $$props) body = $$props.body;
      if ('slots' in $$props) $$invalidate(7, slots = $$props.slots);
      if ('htmlSlotContenu' in $$props) $$invalidate(8, htmlSlotContenu = $$props.htmlSlotContenu);
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    return [afficher, titre, srTitre, srPrefixeContenu, srBoutonOuvrir, srBoutonFermer, contenu, slots, htmlSlotContenu, idBoutonToggle, idModale, idEntete, idPrefixeContenu, afficherModale, masquerModale, keydown, finAnimationFermeture, conserverFocusInfobulle, $$slots];
  }

  var Infobulle = /*#__PURE__*/function (_SvelteElement) {
    _inherits(Infobulle, _SvelteElement);

    var _super = _createSuper$b(Infobulle);

    function Infobulle(options) {
      var _this;

      _classCallCheck(this, Infobulle);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: _objectSpread$1(_objectSpread$1({}, attribute_to_object(_this.attributes)), {}, {
          $$slots: get_custom_elements_slots(_assertThisInitialized(_this))
        }),
        customElement: true
      }, instance$b, create_fragment$b, safe_not_equal, {
        afficher: 0,
        titre: 1,
        srTitre: 2,
        srPrefixeContenu: 3,
        srBoutonOuvrir: 4,
        srBoutonFermer: 5,
        contenu: 6
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(Infobulle, [{
      key: "afficher",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(afficher) {
        this.$$set({
          afficher: afficher
        });
        flush();
      }
    }, {
      key: "titre",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(titre) {
        this.$$set({
          titre: titre
        });
        flush();
      }
    }, {
      key: "srTitre",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(srTitre) {
        this.$$set({
          srTitre: srTitre
        });
        flush();
      }
    }, {
      key: "srPrefixeContenu",
      get: function get() {
        return this.$$.ctx[3];
      },
      set: function set(srPrefixeContenu) {
        this.$$set({
          srPrefixeContenu: srPrefixeContenu
        });
        flush();
      }
    }, {
      key: "srBoutonOuvrir",
      get: function get() {
        return this.$$.ctx[4];
      },
      set: function set(srBoutonOuvrir) {
        this.$$set({
          srBoutonOuvrir: srBoutonOuvrir
        });
        flush();
      }
    }, {
      key: "srBoutonFermer",
      get: function get() {
        return this.$$.ctx[5];
      },
      set: function set(srBoutonFermer) {
        this.$$set({
          srBoutonFermer: srBoutonFermer
        });
        flush();
      }
    }, {
      key: "contenu",
      get: function get() {
        return this.$$.ctx[6];
      },
      set: function set(contenu) {
        this.$$set({
          contenu: contenu
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["afficher", "titre", "srTitre", "srPrefixeContenu", "srBoutonOuvrir", "srBoutonFermer", "contenu"];
      }
    }]);

    return Infobulle;
  }(SvelteElement);

  customElements.define("utd-infobulle", Infobulle);

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  var _assign = function __assign() {
    _assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return _assign.apply(this, arguments);
  };

  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }

  function __generator(thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (g && (g = 0, op[0] && (_ = 0)), _) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  }

  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function next() {
        if (o && i >= o.length) o = void 0;
        return {
          value: o && o[i++],
          done: !o
        };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }

  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;

    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
        ar.push(r.value);
      }
    } catch (error) {
      e = {
        error: error
      };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }

    return ar;
  }
  /** @ignore */


  var ENTRIES = 'ENTRIES';
  /** @ignore */

  var KEYS = 'KEYS';
  /** @ignore */

  var VALUES = 'VALUES';
  /** @ignore */

  var LEAF = '';
  /**
   * @private
   */

  var TreeIterator =
  /** @class */
  function () {
    function TreeIterator(set, type) {
      var node = set._tree;
      var keys = Array.from(node.keys());
      this.set = set;
      this._type = type;
      this._path = keys.length > 0 ? [{
        node: node,
        keys: keys
      }] : [];
    }

    TreeIterator.prototype.next = function () {
      var value = this.dive();
      this.backtrack();
      return value;
    };

    TreeIterator.prototype.dive = function () {
      if (this._path.length === 0) {
        return {
          done: true,
          value: undefined
        };
      }

      var _a = last$1(this._path),
          node = _a.node,
          keys = _a.keys;

      if (last$1(keys) === LEAF) {
        return {
          done: false,
          value: this.result()
        };
      }

      var child = node.get(last$1(keys));

      this._path.push({
        node: child,
        keys: Array.from(child.keys())
      });

      return this.dive();
    };

    TreeIterator.prototype.backtrack = function () {
      if (this._path.length === 0) {
        return;
      }

      var keys = last$1(this._path).keys;
      keys.pop();

      if (keys.length > 0) {
        return;
      }

      this._path.pop();

      this.backtrack();
    };

    TreeIterator.prototype.key = function () {
      return this.set._prefix + this._path.map(function (_a) {
        var keys = _a.keys;
        return last$1(keys);
      }).filter(function (key) {
        return key !== LEAF;
      }).join('');
    };

    TreeIterator.prototype.value = function () {
      return last$1(this._path).node.get(LEAF);
    };

    TreeIterator.prototype.result = function () {
      switch (this._type) {
        case VALUES:
          return this.value();

        case KEYS:
          return this.key();

        default:
          return [this.key(), this.value()];
      }
    };

    TreeIterator.prototype[Symbol.iterator] = function () {
      return this;
    };

    return TreeIterator;
  }();

  var last$1 = function last$1(array) {
    return array[array.length - 1];
  };
  /**
   * @ignore
   */


  var fuzzySearch = function fuzzySearch(node, query, maxDistance) {
    var results = new Map();
    if (query === undefined) return results; // Number of columns in the Levenshtein matrix.

    var n = query.length + 1; // Matching terms can never be longer than N + maxDistance.

    var m = n + maxDistance; // Fill first matrix row and column with numbers: 0 1 2 3 ...

    var matrix = new Uint8Array(m * n).fill(maxDistance + 1);

    for (var j = 0; j < n; ++j) {
      matrix[j] = j;
    }

    for (var i = 1; i < m; ++i) {
      matrix[i * n] = i;
    }

    recurse(node, query, maxDistance, results, matrix, 1, n, '');
    return results;
  }; // Modified version of http://stevehanov.ca/blog/?id=114
  // This builds a Levenshtein matrix for a given query and continuously updates
  // it for nodes in the radix tree that fall within the given maximum edit
  // distance. Keeping the same matrix around is beneficial especially for larger
  // edit distances.
  //
  //           k   a   t   e   <-- query
  //       0   1   2   3   4
  //   c   1   1   2   3   4
  //   a   2   2   1   2   3
  //   t   3   3   2   1  [2]  <-- edit distance
  //   ^
  //   ^ term in radix tree, rows are added and removed as needed


  var recurse = function recurse(node, query, maxDistance, results, matrix, m, n, prefix) {
    var e_1, _a;

    var offset = m * n;

    try {
      key: for (var _b = __values(node.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var key = _c.value;

        if (key === LEAF) {
          // We've reached a leaf node. Check if the edit distance acceptable and
          // store the result if it is.
          var distance = matrix[offset - 1];

          if (distance <= maxDistance) {
            results.set(prefix, [node.get(key), distance]);
          }
        } else {
          // Iterate over all characters in the key. Update the Levenshtein matrix
          // and check if the minimum distance in the last row is still within the
          // maximum edit distance. If it is, we can recurse over all child nodes.
          var i = m;

          for (var pos = 0; pos < key.length; ++pos, ++i) {
            var char = key[pos];
            var thisRowOffset = n * i;
            var prevRowOffset = thisRowOffset - n; // Set the first column based on the previous row, and initialize the
            // minimum distance in the current row.

            var minDistance = matrix[thisRowOffset];
            var jmin = Math.max(0, i - maxDistance - 1);
            var jmax = Math.min(n - 1, i + maxDistance); // Iterate over remaining columns (characters in the query).

            for (var j = jmin; j < jmax; ++j) {
              var different = char !== query[j]; // It might make sense to only read the matrix positions used for
              // deletion/insertion if the characters are different. But we want to
              // avoid conditional reads for performance reasons.

              var rpl = matrix[prevRowOffset + j] + +different;
              var del = matrix[prevRowOffset + j + 1] + 1;
              var ins = matrix[thisRowOffset + j] + 1;
              var dist = matrix[thisRowOffset + j + 1] = Math.min(rpl, del, ins);
              if (dist < minDistance) minDistance = dist;
            } // Because distance will never decrease, we can stop. There will be no
            // matching child nodes.


            if (minDistance > maxDistance) {
              continue key;
            }
          }

          recurse(node.get(key), query, maxDistance, results, matrix, i, n, prefix + key);
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  };
  /**
   * A class implementing the same interface as a standard JavaScript
   * [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)
   * with string keys, but adding support for efficiently searching entries with
   * prefix or fuzzy search. This class is used internally by [[MiniSearch]] as
   * the inverted index data structure. The implementation is a radix tree
   * (compressed prefix tree).
   *
   * Since this class can be of general utility beyond _MiniSearch_, it is
   * exported by the `minisearch` package and can be imported (or required) as
   * `minisearch/SearchableMap`.
   *
   * @typeParam T  The type of the values stored in the map.
   */


  var SearchableMap =
  /** @class */
  function () {
    /**
     * The constructor is normally called without arguments, creating an empty
     * map. In order to create a [[SearchableMap]] from an iterable or from an
     * object, check [[SearchableMap.from]] and [[SearchableMap.fromObject]].
     *
     * The constructor arguments are for internal use, when creating derived
     * mutable views of a map at a prefix.
     */
    function SearchableMap(tree, prefix) {
      if (tree === void 0) {
        tree = new Map();
      }

      if (prefix === void 0) {
        prefix = '';
      }

      this._size = undefined;
      this._tree = tree;
      this._prefix = prefix;
    }
    /**
     * Creates and returns a mutable view of this [[SearchableMap]], containing only
     * entries that share the given prefix.
     *
     * ### Usage:
     *
     * ```javascript
     * let map = new SearchableMap()
     * map.set("unicorn", 1)
     * map.set("universe", 2)
     * map.set("university", 3)
     * map.set("unique", 4)
     * map.set("hello", 5)
     *
     * let uni = map.atPrefix("uni")
     * uni.get("unique") // => 4
     * uni.get("unicorn") // => 1
     * uni.get("hello") // => undefined
     *
     * let univer = map.atPrefix("univer")
     * univer.get("unique") // => undefined
     * univer.get("universe") // => 2
     * univer.get("university") // => 3
     * ```
     *
     * @param prefix  The prefix
     * @return A [[SearchableMap]] representing a mutable view of the original Map at the given prefix
     */


    SearchableMap.prototype.atPrefix = function (prefix) {
      var e_1, _a;

      if (!prefix.startsWith(this._prefix)) {
        throw new Error('Mismatched prefix');
      }

      var _b = __read(trackDown(this._tree, prefix.slice(this._prefix.length)), 2),
          node = _b[0],
          path = _b[1];

      if (node === undefined) {
        var _c = __read(last(path), 2),
            parentNode = _c[0],
            key = _c[1];

        try {
          for (var _d = __values(parentNode.keys()), _e = _d.next(); !_e.done; _e = _d.next()) {
            var k = _e.value;

            if (k !== LEAF && k.startsWith(key)) {
              var node_1 = new Map();
              node_1.set(k.slice(key.length), parentNode.get(k));
              return new SearchableMap(node_1, prefix);
            }
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }

      return new SearchableMap(node, prefix);
    };
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear
     */


    SearchableMap.prototype.clear = function () {
      this._size = undefined;

      this._tree.clear();
    };
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete
     * @param key  Key to delete
     */


    SearchableMap.prototype.delete = function (key) {
      this._size = undefined;
      return remove(this._tree, key);
    };
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries
     * @return An iterator iterating through `[key, value]` entries.
     */


    SearchableMap.prototype.entries = function () {
      return new TreeIterator(this, ENTRIES);
    };
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach
     * @param fn  Iteration function
     */


    SearchableMap.prototype.forEach = function (fn) {
      var e_2, _a;

      try {
        for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read(_c.value, 2),
              key = _d[0],
              value = _d[1];

          fn(key, value, this);
        }
      } catch (e_2_1) {
        e_2 = {
          error: e_2_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_2) throw e_2.error;
        }
      }
    };
    /**
     * Returns a Map of all the entries that have a key within the given edit
     * distance from the search key. The keys of the returned Map are the matching
     * keys, while the values are two-element arrays where the first element is
     * the value associated to the key, and the second is the edit distance of the
     * key to the search key.
     *
     * ### Usage:
     *
     * ```javascript
     * let map = new SearchableMap()
     * map.set('hello', 'world')
     * map.set('hell', 'yeah')
     * map.set('ciao', 'mondo')
     *
     * // Get all entries that match the key 'hallo' with a maximum edit distance of 2
     * map.fuzzyGet('hallo', 2)
     * // => Map(2) { 'hello' => ['world', 1], 'hell' => ['yeah', 2] }
     *
     * // In the example, the "hello" key has value "world" and edit distance of 1
     * // (change "e" to "a"), the key "hell" has value "yeah" and edit distance of 2
     * // (change "e" to "a", delete "o")
     * ```
     *
     * @param key  The search key
     * @param maxEditDistance  The maximum edit distance (Levenshtein)
     * @return A Map of the matching keys to their value and edit distance
     */


    SearchableMap.prototype.fuzzyGet = function (key, maxEditDistance) {
      return fuzzySearch(this._tree, key, maxEditDistance);
    };
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get
     * @param key  Key to get
     * @return Value associated to the key, or `undefined` if the key is not
     * found.
     */


    SearchableMap.prototype.get = function (key) {
      var node = lookup(this._tree, key);
      return node !== undefined ? node.get(LEAF) : undefined;
    };
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has
     * @param key  Key
     * @return True if the key is in the map, false otherwise
     */


    SearchableMap.prototype.has = function (key) {
      var node = lookup(this._tree, key);
      return node !== undefined && node.has(LEAF);
    };
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys
     * @return An `Iterable` iterating through keys
     */


    SearchableMap.prototype.keys = function () {
      return new TreeIterator(this, KEYS);
    };
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set
     * @param key  Key to set
     * @param value  Value to associate to the key
     * @return The [[SearchableMap]] itself, to allow chaining
     */


    SearchableMap.prototype.set = function (key, value) {
      if (typeof key !== 'string') {
        throw new Error('key must be a string');
      }

      this._size = undefined;
      var node = createPath(this._tree, key);
      node.set(LEAF, value);
      return this;
    };

    Object.defineProperty(SearchableMap.prototype, "size", {
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size
       */
      get: function get() {
        if (this._size) {
          return this._size;
        }
        /** @ignore */


        this._size = 0;
        var iter = this.entries();

        while (!iter.next().done) {
          this._size += 1;
        }

        return this._size;
      },
      enumerable: false,
      configurable: true
    });
    /**
     * Updates the value at the given key using the provided function. The function
     * is called with the current value at the key, and its return value is used as
     * the new value to be set.
     *
     * ### Example:
     *
     * ```javascript
     * // Increment the current value by one
     * searchableMap.update('somekey', (currentValue) => currentValue == null ? 0 : currentValue + 1)
     * ```
     *
     * If the value at the given key is or will be an object, it might not require
     * re-assignment. In that case it is better to use `fetch()`, because it is
     * faster.
     *
     * @param key  The key to update
     * @param fn  The function used to compute the new value from the current one
     * @return The [[SearchableMap]] itself, to allow chaining
     */

    SearchableMap.prototype.update = function (key, fn) {
      if (typeof key !== 'string') {
        throw new Error('key must be a string');
      }

      this._size = undefined;
      var node = createPath(this._tree, key);
      node.set(LEAF, fn(node.get(LEAF)));
      return this;
    };
    /**
     * Fetches the value of the given key. If the value does not exist, calls the
     * given function to create a new value, which is inserted at the given key
     * and subsequently returned.
     *
     * ### Example:
     *
     * ```javascript
     * const map = searchableMap.fetch('somekey', () => new Map())
     * map.set('foo', 'bar')
     * ```
     *
     * @param key  The key to update
     * @param defaultValue  A function that creates a new value if the key does not exist
     * @return The existing or new value at the given key
     */


    SearchableMap.prototype.fetch = function (key, initial) {
      if (typeof key !== 'string') {
        throw new Error('key must be a string');
      }

      this._size = undefined;
      var node = createPath(this._tree, key);
      var value = node.get(LEAF);

      if (value === undefined) {
        node.set(LEAF, value = initial());
      }

      return value;
    };
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values
     * @return An `Iterable` iterating through values.
     */


    SearchableMap.prototype.values = function () {
      return new TreeIterator(this, VALUES);
    };
    /**
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator
     */


    SearchableMap.prototype[Symbol.iterator] = function () {
      return this.entries();
    };
    /**
     * Creates a [[SearchableMap]] from an `Iterable` of entries
     *
     * @param entries  Entries to be inserted in the [[SearchableMap]]
     * @return A new [[SearchableMap]] with the given entries
     */


    SearchableMap.from = function (entries) {
      var e_3, _a;

      var tree = new SearchableMap();

      try {
        for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
          var _b = __read(entries_1_1.value, 2),
              key = _b[0],
              value = _b[1];

          tree.set(key, value);
        }
      } catch (e_3_1) {
        e_3 = {
          error: e_3_1
        };
      } finally {
        try {
          if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return)) _a.call(entries_1);
        } finally {
          if (e_3) throw e_3.error;
        }
      }

      return tree;
    };
    /**
     * Creates a [[SearchableMap]] from the iterable properties of a JavaScript object
     *
     * @param object  Object of entries for the [[SearchableMap]]
     * @return A new [[SearchableMap]] with the given entries
     */


    SearchableMap.fromObject = function (object) {
      return SearchableMap.from(Object.entries(object));
    };

    return SearchableMap;
  }();

  var trackDown = function trackDown(tree, key, path) {
    var e_4, _a;

    if (path === void 0) {
      path = [];
    }

    if (key.length === 0 || tree == null) {
      return [tree, path];
    }

    try {
      for (var _b = __values(tree.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var k = _c.value;

        if (k !== LEAF && key.startsWith(k)) {
          path.push([tree, k]); // performance: update in place

          return trackDown(tree.get(k), key.slice(k.length), path);
        }
      }
    } catch (e_4_1) {
      e_4 = {
        error: e_4_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_4) throw e_4.error;
      }
    }

    path.push([tree, key]); // performance: update in place

    return trackDown(undefined, '', path);
  };

  var lookup = function lookup(tree, key) {
    var e_5, _a;

    if (key.length === 0 || tree == null) {
      return tree;
    }

    try {
      for (var _b = __values(tree.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var k = _c.value;

        if (k !== LEAF && key.startsWith(k)) {
          return lookup(tree.get(k), key.slice(k.length));
        }
      }
    } catch (e_5_1) {
      e_5 = {
        error: e_5_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_5) throw e_5.error;
      }
    }
  }; // Create a path in the radix tree for the given key, and returns the deepest
  // node. This function is in the hot path for indexing. It avoids unnecessary
  // string operations and recursion for performance.


  var createPath = function createPath(node, key) {
    var e_6, _a;

    var keyLength = key.length;

    outer: for (var pos = 0; node && pos < keyLength;) {
      try {
        for (var _b = (e_6 = void 0, __values(node.keys())), _c = _b.next(); !_c.done; _c = _b.next()) {
          var k = _c.value; // Check whether this key is a candidate: the first characters must match.

          if (k !== LEAF && key[pos] === k[0]) {
            var len = Math.min(keyLength - pos, k.length); // Advance offset to the point where key and k no longer match.

            var offset = 1;

            while (offset < len && key[pos + offset] === k[offset]) {
              ++offset;
            }

            var child_1 = node.get(k);

            if (offset === k.length) {
              // The existing key is shorter than the key we need to create.
              node = child_1;
            } else {
              // Partial match: we need to insert an intermediate node to contain
              // both the existing subtree and the new node.
              var intermediate = new Map();
              intermediate.set(k.slice(offset), child_1);
              node.set(key.slice(pos, pos + offset), intermediate);
              node.delete(k);
              node = intermediate;
            }

            pos += offset;
            continue outer;
          }
        }
      } catch (e_6_1) {
        e_6 = {
          error: e_6_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_6) throw e_6.error;
        }
      } // Create a final child node to contain the final suffix of the key.


      var child = new Map();
      node.set(key.slice(pos), child);
      return child;
    }

    return node;
  };

  var remove = function remove(tree, key) {
    var _a = __read(trackDown(tree, key), 2),
        node = _a[0],
        path = _a[1];

    if (node === undefined) {
      return;
    }

    node.delete(LEAF);

    if (node.size === 0) {
      cleanup(path);
    } else if (node.size === 1) {
      var _b = __read(node.entries().next().value, 2),
          key_1 = _b[0],
          value = _b[1];

      merge(path, key_1, value);
    }
  };

  var cleanup = function cleanup(path) {
    if (path.length === 0) {
      return;
    }

    var _a = __read(last(path), 2),
        node = _a[0],
        key = _a[1];

    node.delete(key);

    if (node.size === 0) {
      cleanup(path.slice(0, -1));
    } else if (node.size === 1) {
      var _b = __read(node.entries().next().value, 2),
          key_2 = _b[0],
          value = _b[1];

      if (key_2 !== LEAF) {
        merge(path.slice(0, -1), key_2, value);
      }
    }
  };

  var merge = function merge(path, key, value) {
    if (path.length === 0) {
      return;
    }

    var _a = __read(last(path), 2),
        node = _a[0],
        nodeKey = _a[1];

    node.set(nodeKey + key, value);
    node.delete(nodeKey);
  };

  var last = function last(array) {
    return array[array.length - 1];
  };

  var _a;

  var OR = 'or';
  var AND = 'and';
  var AND_NOT = 'and_not';
  /**
   * [[MiniSearch]] is the main entrypoint class, implementing a full-text search
   * engine in memory.
   *
   * @typeParam T  The type of the documents being indexed.
   *
   * ### Basic example:
   *
   * ```javascript
   * const documents = [
   *   {
   *     id: 1,
   *     title: 'Moby Dick',
   *     text: 'Call me Ishmael. Some years ago...',
   *     category: 'fiction'
   *   },
   *   {
   *     id: 2,
   *     title: 'Zen and the Art of Motorcycle Maintenance',
   *     text: 'I can see by my watch...',
   *     category: 'fiction'
   *   },
   *   {
   *     id: 3,
   *     title: 'Neuromancer',
   *     text: 'The sky above the port was...',
   *     category: 'fiction'
   *   },
   *   {
   *     id: 4,
   *     title: 'Zen and the Art of Archery',
   *     text: 'At first sight it must seem...',
   *     category: 'non-fiction'
   *   },
   *   // ...and more
   * ]
   *
   * // Create a search engine that indexes the 'title' and 'text' fields for
   * // full-text search. Search results will include 'title' and 'category' (plus the
   * // id field, that is always stored and returned)
   * const miniSearch = new MiniSearch({
   *   fields: ['title', 'text'],
   *   storeFields: ['title', 'category']
   * })
   *
   * // Add documents to the index
   * miniSearch.addAll(documents)
   *
   * // Search for documents:
   * let results = miniSearch.search('zen art motorcycle')
   * // => [
   * //   { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258 },
   * //   { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629 }
   * // ]
   * ```
   */

  var MiniSearch =
  /** @class */
  function () {
    /**
     * @param options  Configuration options
     *
     * ### Examples:
     *
     * ```javascript
     * // Create a search engine that indexes the 'title' and 'text' fields of your
     * // documents:
     * const miniSearch = new MiniSearch({ fields: ['title', 'text'] })
     * ```
     *
     * ### ID Field:
     *
     * ```javascript
     * // Your documents are assumed to include a unique 'id' field, but if you want
     * // to use a different field for document identification, you can set the
     * // 'idField' option:
     * const miniSearch = new MiniSearch({ idField: 'key', fields: ['title', 'text'] })
     * ```
     *
     * ### Options and defaults:
     *
     * ```javascript
     * // The full set of options (here with their default value) is:
     * const miniSearch = new MiniSearch({
     *   // idField: field that uniquely identifies a document
     *   idField: 'id',
     *
     *   // extractField: function used to get the value of a field in a document.
     *   // By default, it assumes the document is a flat object with field names as
     *   // property keys and field values as string property values, but custom logic
     *   // can be implemented by setting this option to a custom extractor function.
     *   extractField: (document, fieldName) => document[fieldName],
     *
     *   // tokenize: function used to split fields into individual terms. By
     *   // default, it is also used to tokenize search queries, unless a specific
     *   // `tokenize` search option is supplied. When tokenizing an indexed field,
     *   // the field name is passed as the second argument.
     *   tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),
     *
     *   // processTerm: function used to process each tokenized term before
     *   // indexing. It can be used for stemming and normalization. Return a falsy
     *   // value in order to discard a term. By default, it is also used to process
     *   // search queries, unless a specific `processTerm` option is supplied as a
     *   // search option. When processing a term from a indexed field, the field
     *   // name is passed as the second argument.
     *   processTerm: (term, _fieldName) => term.toLowerCase(),
     *
     *   // searchOptions: default search options, see the `search` method for
     *   // details
     *   searchOptions: undefined,
     *
     *   // fields: document fields to be indexed. Mandatory, but not set by default
     *   fields: undefined
     *
     *   // storeFields: document fields to be stored and returned as part of the
     *   // search results.
     *   storeFields: []
     * })
     * ```
     */
    function MiniSearch(options) {
      if ((options === null || options === void 0 ? void 0 : options.fields) == null) {
        throw new Error('MiniSearch: option "fields" must be provided');
      }

      var autoVacuum = options.autoVacuum == null || options.autoVacuum === true ? defaultAutoVacuumOptions : options.autoVacuum;
      this._options = _assign(_assign(_assign({}, defaultOptions), options), {
        autoVacuum: autoVacuum,
        searchOptions: _assign(_assign({}, defaultSearchOptions), options.searchOptions || {}),
        autoSuggestOptions: _assign(_assign({}, defaultAutoSuggestOptions), options.autoSuggestOptions || {})
      });
      this._index = new SearchableMap();
      this._documentCount = 0;
      this._documentIds = new Map();
      this._idToShortId = new Map(); // Fields are defined during initialization, don't change, are few in
      // number, rarely need iterating over, and have string keys. Therefore in
      // this case an object is a better candidate than a Map to store the mapping
      // from field key to ID.

      this._fieldIds = {};
      this._fieldLength = new Map();
      this._avgFieldLength = [];
      this._nextId = 0;
      this._storedFields = new Map();
      this._dirtCount = 0;
      this._currentVacuum = null;
      this._enqueuedVacuum = null;
      this._enqueuedVacuumConditions = defaultVacuumConditions;
      this.addFields(this._options.fields);
    }
    /**
     * Adds a document to the index
     *
     * @param document  The document to be indexed
     */


    MiniSearch.prototype.add = function (document) {
      var e_1, _a, e_2, _b, e_3, _c;

      var _d = this._options,
          extractField = _d.extractField,
          tokenize = _d.tokenize,
          processTerm = _d.processTerm,
          fields = _d.fields,
          idField = _d.idField;
      var id = extractField(document, idField);

      if (id == null) {
        throw new Error("MiniSearch: document does not have ID field \"".concat(idField, "\""));
      }

      if (this._idToShortId.has(id)) {
        throw new Error("MiniSearch: duplicate ID ".concat(id));
      }

      var shortDocumentId = this.addDocumentId(id);
      this.saveStoredFields(shortDocumentId, document);

      try {
        for (var fields_1 = __values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {
          var field = fields_1_1.value;
          var fieldValue = extractField(document, field);
          if (fieldValue == null) continue;
          var tokens = tokenize(fieldValue.toString(), field);
          var fieldId = this._fieldIds[field];
          var uniqueTerms = new Set(tokens).size;
          this.addFieldLength(shortDocumentId, fieldId, this._documentCount - 1, uniqueTerms);

          try {
            for (var tokens_1 = (e_2 = void 0, __values(tokens)), tokens_1_1 = tokens_1.next(); !tokens_1_1.done; tokens_1_1 = tokens_1.next()) {
              var term = tokens_1_1.value;
              var processedTerm = processTerm(term, field);

              if (Array.isArray(processedTerm)) {
                try {
                  for (var processedTerm_1 = (e_3 = void 0, __values(processedTerm)), processedTerm_1_1 = processedTerm_1.next(); !processedTerm_1_1.done; processedTerm_1_1 = processedTerm_1.next()) {
                    var t = processedTerm_1_1.value;
                    this.addTerm(fieldId, shortDocumentId, t);
                  }
                } catch (e_3_1) {
                  e_3 = {
                    error: e_3_1
                  };
                } finally {
                  try {
                    if (processedTerm_1_1 && !processedTerm_1_1.done && (_c = processedTerm_1.return)) _c.call(processedTerm_1);
                  } finally {
                    if (e_3) throw e_3.error;
                  }
                }
              } else if (processedTerm) {
                this.addTerm(fieldId, shortDocumentId, processedTerm);
              }
            }
          } catch (e_2_1) {
            e_2 = {
              error: e_2_1
            };
          } finally {
            try {
              if (tokens_1_1 && !tokens_1_1.done && (_b = tokens_1.return)) _b.call(tokens_1);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (fields_1_1 && !fields_1_1.done && (_a = fields_1.return)) _a.call(fields_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    };
    /**
     * Adds all the given documents to the index
     *
     * @param documents  An array of documents to be indexed
     */


    MiniSearch.prototype.addAll = function (documents) {
      var e_4, _a;

      try {
        for (var documents_1 = __values(documents), documents_1_1 = documents_1.next(); !documents_1_1.done; documents_1_1 = documents_1.next()) {
          var document_1 = documents_1_1.value;
          this.add(document_1);
        }
      } catch (e_4_1) {
        e_4 = {
          error: e_4_1
        };
      } finally {
        try {
          if (documents_1_1 && !documents_1_1.done && (_a = documents_1.return)) _a.call(documents_1);
        } finally {
          if (e_4) throw e_4.error;
        }
      }
    };
    /**
     * Adds all the given documents to the index asynchronously.
     *
     * Returns a promise that resolves (to `undefined`) when the indexing is done.
     * This method is useful when index many documents, to avoid blocking the main
     * thread. The indexing is performed asynchronously and in chunks.
     *
     * @param documents  An array of documents to be indexed
     * @param options  Configuration options
     * @return A promise resolving to `undefined` when the indexing is done
     */


    MiniSearch.prototype.addAllAsync = function (documents, options) {
      var _this = this;

      if (options === void 0) {
        options = {};
      }

      var _a = options.chunkSize,
          chunkSize = _a === void 0 ? 10 : _a;
      var acc = {
        chunk: [],
        promise: Promise.resolve()
      };

      var _b = documents.reduce(function (_a, document, i) {
        var chunk = _a.chunk,
            promise = _a.promise;
        chunk.push(document);

        if ((i + 1) % chunkSize === 0) {
          return {
            chunk: [],
            promise: promise.then(function () {
              return new Promise(function (resolve) {
                return setTimeout(resolve, 0);
              });
            }).then(function () {
              return _this.addAll(chunk);
            })
          };
        } else {
          return {
            chunk: chunk,
            promise: promise
          };
        }
      }, acc),
          chunk = _b.chunk,
          promise = _b.promise;

      return promise.then(function () {
        return _this.addAll(chunk);
      });
    };
    /**
     * Removes the given document from the index.
     *
     * The document to remove must NOT have changed between indexing and removal,
     * otherwise the index will be corrupted.
     *
     * This method requires passing the full document to be removed (not just the
     * ID), and immediately removes the document from the inverted index, allowing
     * memory to be released. A convenient alternative is [[MiniSearch.discard]],
     * which needs only the document ID, and has the same visible effect, but
     * delays cleaning up the index until the next vacuuming.
     *
     * @param document  The document to be removed
     */


    MiniSearch.prototype.remove = function (document) {
      var e_5, _a, e_6, _b, e_7, _c;

      var _d = this._options,
          tokenize = _d.tokenize,
          processTerm = _d.processTerm,
          extractField = _d.extractField,
          fields = _d.fields,
          idField = _d.idField;
      var id = extractField(document, idField);

      if (id == null) {
        throw new Error("MiniSearch: document does not have ID field \"".concat(idField, "\""));
      }

      var shortId = this._idToShortId.get(id);

      if (shortId == null) {
        throw new Error("MiniSearch: cannot remove document with ID ".concat(id, ": it is not in the index"));
      }

      try {
        for (var fields_2 = __values(fields), fields_2_1 = fields_2.next(); !fields_2_1.done; fields_2_1 = fields_2.next()) {
          var field = fields_2_1.value;
          var fieldValue = extractField(document, field);
          if (fieldValue == null) continue;
          var tokens = tokenize(fieldValue.toString(), field);
          var fieldId = this._fieldIds[field];
          var uniqueTerms = new Set(tokens).size;
          this.removeFieldLength(shortId, fieldId, this._documentCount, uniqueTerms);

          try {
            for (var tokens_2 = (e_6 = void 0, __values(tokens)), tokens_2_1 = tokens_2.next(); !tokens_2_1.done; tokens_2_1 = tokens_2.next()) {
              var term = tokens_2_1.value;
              var processedTerm = processTerm(term, field);

              if (Array.isArray(processedTerm)) {
                try {
                  for (var processedTerm_2 = (e_7 = void 0, __values(processedTerm)), processedTerm_2_1 = processedTerm_2.next(); !processedTerm_2_1.done; processedTerm_2_1 = processedTerm_2.next()) {
                    var t = processedTerm_2_1.value;
                    this.removeTerm(fieldId, shortId, t);
                  }
                } catch (e_7_1) {
                  e_7 = {
                    error: e_7_1
                  };
                } finally {
                  try {
                    if (processedTerm_2_1 && !processedTerm_2_1.done && (_c = processedTerm_2.return)) _c.call(processedTerm_2);
                  } finally {
                    if (e_7) throw e_7.error;
                  }
                }
              } else if (processedTerm) {
                this.removeTerm(fieldId, shortId, processedTerm);
              }
            }
          } catch (e_6_1) {
            e_6 = {
              error: e_6_1
            };
          } finally {
            try {
              if (tokens_2_1 && !tokens_2_1.done && (_b = tokens_2.return)) _b.call(tokens_2);
            } finally {
              if (e_6) throw e_6.error;
            }
          }
        }
      } catch (e_5_1) {
        e_5 = {
          error: e_5_1
        };
      } finally {
        try {
          if (fields_2_1 && !fields_2_1.done && (_a = fields_2.return)) _a.call(fields_2);
        } finally {
          if (e_5) throw e_5.error;
        }
      }

      this._storedFields.delete(shortId);

      this._documentIds.delete(shortId);

      this._idToShortId.delete(id);

      this._fieldLength.delete(shortId);

      this._documentCount -= 1;
    };
    /**
     * Removes all the given documents from the index. If called with no arguments,
     * it removes _all_ documents from the index.
     *
     * @param documents  The documents to be removed. If this argument is omitted,
     * all documents are removed. Note that, for removing all documents, it is
     * more efficient to call this method with no arguments than to pass all
     * documents.
     */


    MiniSearch.prototype.removeAll = function (documents) {
      var e_8, _a;

      if (documents) {
        try {
          for (var documents_2 = __values(documents), documents_2_1 = documents_2.next(); !documents_2_1.done; documents_2_1 = documents_2.next()) {
            var document_2 = documents_2_1.value;
            this.remove(document_2);
          }
        } catch (e_8_1) {
          e_8 = {
            error: e_8_1
          };
        } finally {
          try {
            if (documents_2_1 && !documents_2_1.done && (_a = documents_2.return)) _a.call(documents_2);
          } finally {
            if (e_8) throw e_8.error;
          }
        }
      } else if (arguments.length > 0) {
        throw new Error('Expected documents to be present. Omit the argument to remove all documents.');
      } else {
        this._index = new SearchableMap();
        this._documentCount = 0;
        this._documentIds = new Map();
        this._idToShortId = new Map();
        this._fieldLength = new Map();
        this._avgFieldLength = [];
        this._storedFields = new Map();
        this._nextId = 0;
      }
    };
    /**
     * Discards the document with the given ID, so it won't appear in search results
     *
     * It has the same visible effect of [[MiniSearch.remove]] (both cause the
     * document to stop appearing in searches), but a different effect on the
     * internal data structures:
     *
     *   - [[MiniSearch.remove]] requires passing the full document to be removed
     *   as argument, and removes it from the inverted index immediately.
     *
     *   - [[MiniSearch.discard]] instead only needs the document ID, and works by
     *   marking the current version of the document as discarded, so it is
     *   immediately ignored by searches. This is faster and more convenient than
     *   `remove`, but the index is not immediately modified. To take care of
     *   that, vacuuming is performed after a certain number of documents are
     *   discarded, cleaning up the index and allowing memory to be released.
     *
     * After discarding a document, it is possible to re-add a new version, and
     * only the new version will appear in searches. In other words, discarding
     * and re-adding a document works exactly like removing and re-adding it. The
     * [[MiniSearch.replace]] method can also be used to replace a document with a
     * new version.
     *
     * #### Details about vacuuming
     *
     * Repetite calls to this method would leave obsolete document references in
     * the index, invisible to searches. Two mechanisms take care of cleaning up:
     * clean up during search, and vacuuming.
     *
     *   - Upon search, whenever a discarded ID is found (and ignored for the
     *   results), references to the discarded document are removed from the
     *   inverted index entries for the search terms. This ensures that subsequent
     *   searches for the same terms do not need to skip these obsolete references
     *   again.
     *
     *   - In addition, vacuuming is performed automatically by default (see the
     *   `autoVacuum` field in [[Options]]) after a certain number of documents
     *   are discarded. Vacuuming traverses all terms in the index, cleaning up
     *   all references to discarded documents. Vacuuming can also be triggered
     *   manually by calling [[MiniSearch.vacuum]].
     *
     * @param id  The ID of the document to be discarded
     */


    MiniSearch.prototype.discard = function (id) {
      var _this = this;

      var shortId = this._idToShortId.get(id);

      if (shortId == null) {
        throw new Error("MiniSearch: cannot discard document with ID ".concat(id, ": it is not in the index"));
      }

      this._idToShortId.delete(id);

      this._documentIds.delete(shortId);

      this._storedFields.delete(shortId);

      (this._fieldLength.get(shortId) || []).forEach(function (fieldLength, fieldId) {
        _this.removeFieldLength(shortId, fieldId, _this._documentCount, fieldLength);
      });

      this._fieldLength.delete(shortId);

      this._documentCount -= 1;
      this._dirtCount += 1;
      this.maybeAutoVacuum();
    };

    MiniSearch.prototype.maybeAutoVacuum = function () {
      if (this._options.autoVacuum === false) {
        return;
      }

      var _a = this._options.autoVacuum,
          minDirtFactor = _a.minDirtFactor,
          minDirtCount = _a.minDirtCount,
          batchSize = _a.batchSize,
          batchWait = _a.batchWait;
      this.conditionalVacuum({
        batchSize: batchSize,
        batchWait: batchWait
      }, {
        minDirtCount: minDirtCount,
        minDirtFactor: minDirtFactor
      });
    };
    /**
     * Discards the documents with the given IDs, so they won't appear in search
     * results
     *
     * It is equivalent to calling [[MiniSearch.discard]] for all the given IDs,
     * but with the optimization of triggering at most one automatic vacuuming at
     * the end.
     *
     * Note: to remove all documents from the index, it is faster and more
     * convenient to call [[MiniSearch.removeAll]] with no argument, instead of
     * passing all IDs to this method.
     */


    MiniSearch.prototype.discardAll = function (ids) {
      var e_9, _a;

      var autoVacuum = this._options.autoVacuum;

      try {
        this._options.autoVacuum = false;

        try {
          for (var ids_1 = __values(ids), ids_1_1 = ids_1.next(); !ids_1_1.done; ids_1_1 = ids_1.next()) {
            var id = ids_1_1.value;
            this.discard(id);
          }
        } catch (e_9_1) {
          e_9 = {
            error: e_9_1
          };
        } finally {
          try {
            if (ids_1_1 && !ids_1_1.done && (_a = ids_1.return)) _a.call(ids_1);
          } finally {
            if (e_9) throw e_9.error;
          }
        }
      } finally {
        this._options.autoVacuum = autoVacuum;
      }

      this.maybeAutoVacuum();
    };
    /**
     * It replaces an existing document with the given updated version
     *
     * It works by discarding the current version and adding the updated one, so
     * it is functionally equivalent to calling [[MiniSearch.discard]] followed by
     * [[MiniSearch.add]]. The ID of the updated document should be the same as
     * the original one.
     *
     * Since it uses [[MiniSearch.discard]] internally, this method relies on
     * vacuuming to clean up obsolete document references from the index, allowing
     * memory to be released (see [[MiniSearch.discard]]).
     *
     * @param updatedDocument  The updated document to replace the old version
     * with
     */


    MiniSearch.prototype.replace = function (updatedDocument) {
      var _a = this._options,
          idField = _a.idField,
          extractField = _a.extractField;
      var id = extractField(updatedDocument, idField);
      this.discard(id);
      this.add(updatedDocument);
    };
    /**
     * Triggers a manual vacuuming, cleaning up references to discarded documents
     * from the inverted index
     *
     * Vacuiuming is only useful for applications that use the
     * [[MiniSearch.discard]] or [[MiniSearch.replace]] methods.
     *
     * By default, vacuuming is performed automatically when needed (controlled by
     * the `autoVacuum` field in [[Options]]), so there is usually no need to call
     * this method, unless one wants to make sure to perform vacuuming at a
     * specific moment.
     *
     * Vacuuming traverses all terms in the inverted index in batches, and cleans
     * up references to discarded documents from the posting list, allowing memory
     * to be released.
     *
     * The method takes an optional object as argument with the following keys:
     *
     *   - `batchSize`: the size of each batch (1000 by default)
     *
     *   - `batchWait`: the number of milliseconds to wait between batches (10 by
     *   default)
     *
     * On large indexes, vacuuming could have a non-negligible cost: batching
     * avoids blocking the thread for long, diluting this cost so that it is not
     * negatively affecting the application. Nonetheless, this method should only
     * be called when necessary, and relying on automatic vacuuming is usually
     * better.
     *
     * It returns a promise that resolves (to undefined) when the clean up is
     * completed. If vacuuming is already ongoing at the time this method is
     * called, a new one is enqueued immediately after the ongoing one, and a
     * corresponding promise is returned. However, no more than one vacuuming is
     * enqueued on top of the ongoing one, even if this method is called more
     * times (enqueuing multiple ones would be useless).
     *
     * @param options  Configuration options for the batch size and delay. See
     * [[VacuumOptions]].
     */


    MiniSearch.prototype.vacuum = function (options) {
      if (options === void 0) {
        options = {};
      }

      return this.conditionalVacuum(options);
    };

    MiniSearch.prototype.conditionalVacuum = function (options, conditions) {
      var _this = this; // If a vacuum is already ongoing, schedule another as soon as it finishes,
      // unless there's already one enqueued. If one was already enqueued, do not
      // enqueue another on top, but make sure that the conditions are the
      // broadest.


      if (this._currentVacuum) {
        this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && conditions;

        if (this._enqueuedVacuum != null) {
          return this._enqueuedVacuum;
        }

        this._enqueuedVacuum = this._currentVacuum.then(function () {
          var conditions = _this._enqueuedVacuumConditions;
          _this._enqueuedVacuumConditions = defaultVacuumConditions;
          return _this.performVacuuming(options, conditions);
        });
        return this._enqueuedVacuum;
      }

      if (this.vacuumConditionsMet(conditions) === false) {
        return Promise.resolve();
      }

      this._currentVacuum = this.performVacuuming(options);
      return this._currentVacuum;
    };

    MiniSearch.prototype.performVacuuming = function (options, conditions) {
      return __awaiter(this, void 0, void 0, function () {
        var initialDirtCount, batchSize, batchWait_1, i, _a, _b, _c, term, fieldsData, fieldsData_1, fieldsData_1_1, _d, fieldId, fieldIndex, fieldIndex_1, fieldIndex_1_1, _e, shortId, e_10_1;

        var e_10, _f, e_11, _g, e_12, _h;

        return __generator(this, function (_j) {
          switch (_j.label) {
            case 0:
              initialDirtCount = this._dirtCount;
              if (!this.vacuumConditionsMet(conditions)) return [3
              /*break*/
              , 10];
              batchSize = options.batchSize || defaultVacuumOptions.batchSize;
              batchWait_1 = options.batchWait || defaultVacuumOptions.batchWait;
              i = 1;
              _j.label = 1;

            case 1:
              _j.trys.push([1, 7, 8, 9]);

              _a = __values(this._index), _b = _a.next();
              _j.label = 2;

            case 2:
              if (!!_b.done) return [3
              /*break*/
              , 6];
              _c = __read(_b.value, 2), term = _c[0], fieldsData = _c[1];

              try {
                for (fieldsData_1 = (e_11 = void 0, __values(fieldsData)), fieldsData_1_1 = fieldsData_1.next(); !fieldsData_1_1.done; fieldsData_1_1 = fieldsData_1.next()) {
                  _d = __read(fieldsData_1_1.value, 2), fieldId = _d[0], fieldIndex = _d[1];

                  try {
                    for (fieldIndex_1 = (e_12 = void 0, __values(fieldIndex)), fieldIndex_1_1 = fieldIndex_1.next(); !fieldIndex_1_1.done; fieldIndex_1_1 = fieldIndex_1.next()) {
                      _e = __read(fieldIndex_1_1.value, 1), shortId = _e[0];

                      if (this._documentIds.has(shortId)) {
                        continue;
                      }

                      if (fieldIndex.size <= 1) {
                        fieldsData.delete(fieldId);
                      } else {
                        fieldIndex.delete(shortId);
                      }
                    }
                  } catch (e_12_1) {
                    e_12 = {
                      error: e_12_1
                    };
                  } finally {
                    try {
                      if (fieldIndex_1_1 && !fieldIndex_1_1.done && (_h = fieldIndex_1.return)) _h.call(fieldIndex_1);
                    } finally {
                      if (e_12) throw e_12.error;
                    }
                  }
                }
              } catch (e_11_1) {
                e_11 = {
                  error: e_11_1
                };
              } finally {
                try {
                  if (fieldsData_1_1 && !fieldsData_1_1.done && (_g = fieldsData_1.return)) _g.call(fieldsData_1);
                } finally {
                  if (e_11) throw e_11.error;
                }
              }

              if (this._index.get(term).size === 0) {
                this._index.delete(term);
              }

              if (!(i % batchSize === 0)) return [3
              /*break*/
              , 4];
              return [4
              /*yield*/
              , new Promise(function (resolve) {
                return setTimeout(resolve, batchWait_1);
              })];

            case 3:
              _j.sent();

              _j.label = 4;

            case 4:
              i += 1;
              _j.label = 5;

            case 5:
              _b = _a.next();
              return [3
              /*break*/
              , 2];

            case 6:
              return [3
              /*break*/
              , 9];

            case 7:
              e_10_1 = _j.sent();
              e_10 = {
                error: e_10_1
              };
              return [3
              /*break*/
              , 9];

            case 8:
              try {
                if (_b && !_b.done && (_f = _a.return)) _f.call(_a);
              } finally {
                if (e_10) throw e_10.error;
              }

              return [7
              /*endfinally*/
              ];

            case 9:
              this._dirtCount -= initialDirtCount;
              _j.label = 10;

            case 10:
              // Make the next lines always async, so they execute after this function returns
              return [4
              /*yield*/
              , null];

            case 11:
              // Make the next lines always async, so they execute after this function returns
              _j.sent();

              this._currentVacuum = this._enqueuedVacuum;
              this._enqueuedVacuum = null;
              return [2
              /*return*/
              ];
          }
        });
      });
    };

    MiniSearch.prototype.vacuumConditionsMet = function (conditions) {
      if (conditions == null) {
        return true;
      }

      var minDirtCount = conditions.minDirtCount,
          minDirtFactor = conditions.minDirtFactor;
      minDirtCount = minDirtCount || defaultAutoVacuumOptions.minDirtCount;
      minDirtFactor = minDirtFactor || defaultAutoVacuumOptions.minDirtFactor;
      return this.dirtCount >= minDirtCount && this.dirtFactor >= minDirtFactor;
    };

    Object.defineProperty(MiniSearch.prototype, "isVacuuming", {
      /**
       * Is `true` if a vacuuming operation is ongoing, `false` otherwise
       */
      get: function get() {
        return this._currentVacuum != null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MiniSearch.prototype, "dirtCount", {
      /**
       * The number of documents discarded since the most recent vacuuming
       */
      get: function get() {
        return this._dirtCount;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MiniSearch.prototype, "dirtFactor", {
      /**
       * A number between 0 and 1 giving an indication about the proportion of
       * documents that are discarded, and can therefore be cleaned up by vacuuming.
       * A value close to 0 means that the index is relatively clean, while a higher
       * value means that the index is relatively dirty, and vacuuming could release
       * memory.
       */
      get: function get() {
        return this._dirtCount / (1 + this._documentCount + this._dirtCount);
      },
      enumerable: false,
      configurable: true
    });
    /**
     * Returns `true` if a document with the given ID is present in the index and
     * available for search, `false` otherwise
     *
     * @param id  The document ID
     */

    MiniSearch.prototype.has = function (id) {
      return this._idToShortId.has(id);
    };
    /**
     * Search for documents matching the given search query.
     *
     * The result is a list of scored document IDs matching the query, sorted by
     * descending score, and each including data about which terms were matched and
     * in which fields.
     *
     * ### Basic usage:
     *
     * ```javascript
     * // Search for "zen art motorcycle" with default options: terms have to match
     * // exactly, and individual terms are joined with OR
     * miniSearch.search('zen art motorcycle')
     * // => [ { id: 2, score: 2.77258, match: { ... } }, { id: 4, score: 1.38629, match: { ... } } ]
     * ```
     *
     * ### Restrict search to specific fields:
     *
     * ```javascript
     * // Search only in the 'title' field
     * miniSearch.search('zen', { fields: ['title'] })
     * ```
     *
     * ### Field boosting:
     *
     * ```javascript
     * // Boost a field
     * miniSearch.search('zen', { boost: { title: 2 } })
     * ```
     *
     * ### Prefix search:
     *
     * ```javascript
     * // Search for "moto" with prefix search (it will match documents
     * // containing terms that start with "moto" or "neuro")
     * miniSearch.search('moto neuro', { prefix: true })
     * ```
     *
     * ### Fuzzy search:
     *
     * ```javascript
     * // Search for "ismael" with fuzzy search (it will match documents containing
     * // terms similar to "ismael", with a maximum edit distance of 0.2 term.length
     * // (rounded to nearest integer)
     * miniSearch.search('ismael', { fuzzy: 0.2 })
     * ```
     *
     * ### Combining strategies:
     *
     * ```javascript
     * // Mix of exact match, prefix search, and fuzzy search
     * miniSearch.search('ismael mob', {
     *  prefix: true,
     *  fuzzy: 0.2
     * })
     * ```
     *
     * ### Advanced prefix and fuzzy search:
     *
     * ```javascript
     * // Perform fuzzy and prefix search depending on the search term. Here
     * // performing prefix and fuzzy search only on terms longer than 3 characters
     * miniSearch.search('ismael mob', {
     *  prefix: term => term.length > 3
     *  fuzzy: term => term.length > 3 ? 0.2 : null
     * })
     * ```
     *
     * ### Combine with AND:
     *
     * ```javascript
     * // Combine search terms with AND (to match only documents that contain both
     * // "motorcycle" and "art")
     * miniSearch.search('motorcycle art', { combineWith: 'AND' })
     * ```
     *
     * ### Combine with AND_NOT:
     *
     * There is also an AND_NOT combinator, that finds documents that match the
     * first term, but do not match any of the other terms. This combinator is
     * rarely useful with simple queries, and is meant to be used with advanced
     * query combinations (see later for more details).
     *
     * ### Filtering results:
     *
     * ```javascript
     * // Filter only results in the 'fiction' category (assuming that 'category'
     * // is a stored field)
     * miniSearch.search('motorcycle art', {
     *   filter: (result) => result.category === 'fiction'
     * })
     * ```
     *
     * ### Advanced combination of queries:
     *
     * It is possible to combine different subqueries with OR, AND, and AND_NOT,
     * and even with different search options, by passing a query expression
     * tree object as the first argument, instead of a string.
     *
     * ```javascript
     * // Search for documents that contain "zen" and ("motorcycle" or "archery")
     * miniSearch.search({
     *   combineWith: 'AND',
     *   queries: [
     *     'zen',
     *     {
     *       combineWith: 'OR',
     *       queries: ['motorcycle', 'archery']
     *     }
     *   ]
     * })
     *
     * // Search for documents that contain ("apple" or "pear") but not "juice" and
     * // not "tree"
     * miniSearch.search({
     *   combineWith: 'AND_NOT',
     *   queries: [
     *     {
     *       combineWith: 'OR',
     *       queries: ['apple', 'pear']
     *     },
     *     'juice',
     *     'tree'
     *   ]
     * })
     * ```
     *
     * Each node in the expression tree can be either a string, or an object that
     * supports all `SearchOptions` fields, plus a `queries` array field for
     * subqueries.
     *
     * Note that, while this can become complicated to do by hand for complex or
     * deeply nested queries, it provides a formalized expression tree API for
     * external libraries that implement a parser for custom query languages.
     *
     * @param query  Search query
     * @param options  Search options. Each option, if not given, defaults to the corresponding value of `searchOptions` given to the constructor, or to the library default.
     */


    MiniSearch.prototype.search = function (query, searchOptions) {
      var e_13, _a;

      if (searchOptions === void 0) {
        searchOptions = {};
      }

      var combinedResults = this.executeQuery(query, searchOptions);
      var results = [];

      try {
        for (var combinedResults_1 = __values(combinedResults), combinedResults_1_1 = combinedResults_1.next(); !combinedResults_1_1.done; combinedResults_1_1 = combinedResults_1.next()) {
          var _b = __read(combinedResults_1_1.value, 2),
              docId = _b[0],
              _c = _b[1],
              score = _c.score,
              terms = _c.terms,
              match = _c.match; // Final score takes into account the number of matching QUERY terms.
          // The end user will only receive the MATCHED terms.


          var quality = terms.length;
          var result = {
            id: this._documentIds.get(docId),
            score: score * quality,
            terms: Object.keys(match),
            match: match
          };
          Object.assign(result, this._storedFields.get(docId));

          if (searchOptions.filter == null || searchOptions.filter(result)) {
            results.push(result);
          }
        }
      } catch (e_13_1) {
        e_13 = {
          error: e_13_1
        };
      } finally {
        try {
          if (combinedResults_1_1 && !combinedResults_1_1.done && (_a = combinedResults_1.return)) _a.call(combinedResults_1);
        } finally {
          if (e_13) throw e_13.error;
        }
      }

      results.sort(byScore);
      return results;
    };
    /**
     * Provide suggestions for the given search query
     *
     * The result is a list of suggested modified search queries, derived from the
     * given search query, each with a relevance score, sorted by descending score.
     *
     * By default, it uses the same options used for search, except that by
     * default it performs prefix search on the last term of the query, and
     * combine terms with `'AND'` (requiring all query terms to match). Custom
     * options can be passed as a second argument. Defaults can be changed upon
     * calling the `MiniSearch` constructor, by passing a `autoSuggestOptions`
     * option.
     *
     * ### Basic usage:
     *
     * ```javascript
     * // Get suggestions for 'neuro':
     * miniSearch.autoSuggest('neuro')
     * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 0.46240 } ]
     * ```
     *
     * ### Multiple words:
     *
     * ```javascript
     * // Get suggestions for 'zen ar':
     * miniSearch.autoSuggest('zen ar')
     * // => [
     * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },
     * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }
     * // ]
     * ```
     *
     * ### Fuzzy suggestions:
     *
     * ```javascript
     * // Correct spelling mistakes using fuzzy search:
     * miniSearch.autoSuggest('neromancer', { fuzzy: 0.2 })
     * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]
     * ```
     *
     * ### Filtering:
     *
     * ```javascript
     * // Get suggestions for 'zen ar', but only within the 'fiction' category
     * // (assuming that 'category' is a stored field):
     * miniSearch.autoSuggest('zen ar', {
     *   filter: (result) => result.category === 'fiction'
     * })
     * // => [
     * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },
     * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }
     * // ]
     * ```
     *
     * @param queryString  Query string to be expanded into suggestions
     * @param options  Search options. The supported options and default values
     * are the same as for the `search` method, except that by default prefix
     * search is performed on the last term in the query, and terms are combined
     * with `'AND'`.
     * @return  A sorted array of suggestions sorted by relevance score.
     */


    MiniSearch.prototype.autoSuggest = function (queryString, options) {
      var e_14, _a, e_15, _b;

      if (options === void 0) {
        options = {};
      }

      options = _assign(_assign({}, this._options.autoSuggestOptions), options);
      var suggestions = new Map();

      try {
        for (var _c = __values(this.search(queryString, options)), _d = _c.next(); !_d.done; _d = _c.next()) {
          var _e = _d.value,
              score = _e.score,
              terms = _e.terms;
          var phrase = terms.join(' ');
          var suggestion = suggestions.get(phrase);

          if (suggestion != null) {
            suggestion.score += score;
            suggestion.count += 1;
          } else {
            suggestions.set(phrase, {
              score: score,
              terms: terms,
              count: 1
            });
          }
        }
      } catch (e_14_1) {
        e_14 = {
          error: e_14_1
        };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        } finally {
          if (e_14) throw e_14.error;
        }
      }

      var results = [];

      try {
        for (var suggestions_1 = __values(suggestions), suggestions_1_1 = suggestions_1.next(); !suggestions_1_1.done; suggestions_1_1 = suggestions_1.next()) {
          var _f = __read(suggestions_1_1.value, 2),
              suggestion = _f[0],
              _g = _f[1],
              score = _g.score,
              terms = _g.terms,
              count = _g.count;

          results.push({
            suggestion: suggestion,
            terms: terms,
            score: score / count
          });
        }
      } catch (e_15_1) {
        e_15 = {
          error: e_15_1
        };
      } finally {
        try {
          if (suggestions_1_1 && !suggestions_1_1.done && (_b = suggestions_1.return)) _b.call(suggestions_1);
        } finally {
          if (e_15) throw e_15.error;
        }
      }

      results.sort(byScore);
      return results;
    };

    Object.defineProperty(MiniSearch.prototype, "documentCount", {
      /**
       * Total number of documents available to search
       */
      get: function get() {
        return this._documentCount;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MiniSearch.prototype, "termCount", {
      /**
       * Number of terms in the index
       */
      get: function get() {
        return this._index.size;
      },
      enumerable: false,
      configurable: true
    });
    /**
     * Deserializes a JSON index (serialized with `JSON.stringify(miniSearch)`)
     * and instantiates a MiniSearch instance. It should be given the same options
     * originally used when serializing the index.
     *
     * ### Usage:
     *
     * ```javascript
     * // If the index was serialized with:
     * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })
     * miniSearch.addAll(documents)
     *
     * const json = JSON.stringify(miniSearch)
     * // It can later be deserialized like this:
     * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })
     * ```
     *
     * @param json  JSON-serialized index
     * @param options  configuration options, same as the constructor
     * @return An instance of MiniSearch deserialized from the given JSON.
     */

    MiniSearch.loadJSON = function (json, options) {
      if (options == null) {
        throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index');
      }

      return this.loadJS(JSON.parse(json), options);
    };
    /**
     * Returns the default value of an option. It will throw an error if no option
     * with the given name exists.
     *
     * @param optionName  Name of the option
     * @return The default value of the given option
     *
     * ### Usage:
     *
     * ```javascript
     * // Get default tokenizer
     * MiniSearch.getDefault('tokenize')
     *
     * // Get default term processor
     * MiniSearch.getDefault('processTerm')
     *
     * // Unknown options will throw an error
     * MiniSearch.getDefault('notExisting')
     * // => throws 'MiniSearch: unknown option "notExisting"'
     * ```
     */


    MiniSearch.getDefault = function (optionName) {
      if (defaultOptions.hasOwnProperty(optionName)) {
        return getOwnProperty(defaultOptions, optionName);
      } else {
        throw new Error("MiniSearch: unknown option \"".concat(optionName, "\""));
      }
    };
    /**
     * @ignore
     */


    MiniSearch.loadJS = function (js, options) {
      var e_16, _a, e_17, _b, e_18, _c;

      var index = js.index,
          documentCount = js.documentCount,
          nextId = js.nextId,
          documentIds = js.documentIds,
          fieldIds = js.fieldIds,
          fieldLength = js.fieldLength,
          averageFieldLength = js.averageFieldLength,
          storedFields = js.storedFields,
          dirtCount = js.dirtCount,
          serializationVersion = js.serializationVersion;

      if (serializationVersion !== 1 && serializationVersion !== 2) {
        throw new Error('MiniSearch: cannot deserialize an index created with an incompatible version');
      }

      var miniSearch = new MiniSearch(options);
      miniSearch._documentCount = documentCount;
      miniSearch._nextId = nextId;
      miniSearch._documentIds = objectToNumericMap(documentIds);
      miniSearch._idToShortId = new Map();
      miniSearch._fieldIds = fieldIds;
      miniSearch._fieldLength = objectToNumericMap(fieldLength);
      miniSearch._avgFieldLength = averageFieldLength;
      miniSearch._storedFields = objectToNumericMap(storedFields);
      miniSearch._dirtCount = dirtCount || 0;
      miniSearch._index = new SearchableMap();

      try {
        for (var _d = __values(miniSearch._documentIds), _e = _d.next(); !_e.done; _e = _d.next()) {
          var _f = __read(_e.value, 2),
              shortId = _f[0],
              id = _f[1];

          miniSearch._idToShortId.set(id, shortId);
        }
      } catch (e_16_1) {
        e_16 = {
          error: e_16_1
        };
      } finally {
        try {
          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        } finally {
          if (e_16) throw e_16.error;
        }
      }

      try {
        for (var index_1 = __values(index), index_1_1 = index_1.next(); !index_1_1.done; index_1_1 = index_1.next()) {
          var _g = __read(index_1_1.value, 2),
              term = _g[0],
              data = _g[1];

          var dataMap = new Map();

          try {
            for (var _h = (e_18 = void 0, __values(Object.keys(data))), _j = _h.next(); !_j.done; _j = _h.next()) {
              var fieldId = _j.value;
              var indexEntry = data[fieldId]; // Version 1 used to nest the index entry inside a field called ds

              if (serializationVersion === 1) {
                indexEntry = indexEntry.ds;
              }

              dataMap.set(parseInt(fieldId, 10), objectToNumericMap(indexEntry));
            }
          } catch (e_18_1) {
            e_18 = {
              error: e_18_1
            };
          } finally {
            try {
              if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
            } finally {
              if (e_18) throw e_18.error;
            }
          }

          miniSearch._index.set(term, dataMap);
        }
      } catch (e_17_1) {
        e_17 = {
          error: e_17_1
        };
      } finally {
        try {
          if (index_1_1 && !index_1_1.done && (_b = index_1.return)) _b.call(index_1);
        } finally {
          if (e_17) throw e_17.error;
        }
      }

      return miniSearch;
    };
    /**
     * @ignore
     */


    MiniSearch.prototype.executeQuery = function (query, searchOptions) {
      var _this = this;

      if (searchOptions === void 0) {
        searchOptions = {};
      }

      if (typeof query !== 'string') {
        var options_1 = _assign(_assign(_assign({}, searchOptions), query), {
          queries: undefined
        });

        var results_1 = query.queries.map(function (subquery) {
          return _this.executeQuery(subquery, options_1);
        });
        return this.combineResults(results_1, options_1.combineWith);
      }

      var _a = this._options,
          tokenize = _a.tokenize,
          processTerm = _a.processTerm,
          globalSearchOptions = _a.searchOptions;

      var options = _assign(_assign({
        tokenize: tokenize,
        processTerm: processTerm
      }, globalSearchOptions), searchOptions);

      var searchTokenize = options.tokenize,
          searchProcessTerm = options.processTerm;
      var terms = searchTokenize(query).flatMap(function (term) {
        return searchProcessTerm(term);
      }).filter(function (term) {
        return !!term;
      });
      var queries = terms.map(termToQuerySpec(options));
      var results = queries.map(function (query) {
        return _this.executeQuerySpec(query, options);
      });
      return this.combineResults(results, options.combineWith);
    };
    /**
     * @ignore
     */


    MiniSearch.prototype.executeQuerySpec = function (query, searchOptions) {
      var e_19, _a, e_20, _b;

      var options = _assign(_assign({}, this._options.searchOptions), searchOptions);

      var boosts = (options.fields || this._options.fields).reduce(function (boosts, field) {
        var _a;

        return _assign(_assign({}, boosts), (_a = {}, _a[field] = getOwnProperty(options.boost, field) || 1, _a));
      }, {});

      var boostDocument = options.boostDocument,
          weights = options.weights,
          maxFuzzy = options.maxFuzzy,
          bm25params = options.bm25;

      var _c = _assign(_assign({}, defaultSearchOptions.weights), weights),
          fuzzyWeight = _c.fuzzy,
          prefixWeight = _c.prefix;

      var data = this._index.get(query.term);

      var results = this.termResults(query.term, query.term, 1, data, boosts, boostDocument, bm25params);
      var prefixMatches;
      var fuzzyMatches;

      if (query.prefix) {
        prefixMatches = this._index.atPrefix(query.term);
      }

      if (query.fuzzy) {
        var fuzzy = query.fuzzy === true ? 0.2 : query.fuzzy;
        var maxDistance = fuzzy < 1 ? Math.min(maxFuzzy, Math.round(query.term.length * fuzzy)) : fuzzy;
        if (maxDistance) fuzzyMatches = this._index.fuzzyGet(query.term, maxDistance);
      }

      if (prefixMatches) {
        try {
          for (var prefixMatches_1 = __values(prefixMatches), prefixMatches_1_1 = prefixMatches_1.next(); !prefixMatches_1_1.done; prefixMatches_1_1 = prefixMatches_1.next()) {
            var _d = __read(prefixMatches_1_1.value, 2),
                term = _d[0],
                data_1 = _d[1];

            var distance = term.length - query.term.length;

            if (!distance) {
              continue;
            } // Skip exact match.
            // Delete the term from fuzzy results (if present) if it is also a
            // prefix result. This entry will always be scored as a prefix result.


            fuzzyMatches === null || fuzzyMatches === void 0 ? void 0 : fuzzyMatches.delete(term); // Weight gradually approaches 0 as distance goes to infinity, with the
            // weight for the hypothetical distance 0 being equal to prefixWeight.
            // The rate of change is much lower than that of fuzzy matches to
            // account for the fact that prefix matches stay more relevant than
            // fuzzy matches for longer distances.

            var weight = prefixWeight * term.length / (term.length + 0.3 * distance);
            this.termResults(query.term, term, weight, data_1, boosts, boostDocument, bm25params, results);
          }
        } catch (e_19_1) {
          e_19 = {
            error: e_19_1
          };
        } finally {
          try {
            if (prefixMatches_1_1 && !prefixMatches_1_1.done && (_a = prefixMatches_1.return)) _a.call(prefixMatches_1);
          } finally {
            if (e_19) throw e_19.error;
          }
        }
      }

      if (fuzzyMatches) {
        try {
          for (var _e = __values(fuzzyMatches.keys()), _f = _e.next(); !_f.done; _f = _e.next()) {
            var term = _f.value;

            var _g = __read(fuzzyMatches.get(term), 2),
                data_2 = _g[0],
                distance = _g[1];

            if (!distance) {
              continue;
            } // Skip exact match.
            // Weight gradually approaches 0 as distance goes to infinity, with the
            // weight for the hypothetical distance 0 being equal to fuzzyWeight.


            var weight = fuzzyWeight * term.length / (term.length + distance);
            this.termResults(query.term, term, weight, data_2, boosts, boostDocument, bm25params, results);
          }
        } catch (e_20_1) {
          e_20 = {
            error: e_20_1
          };
        } finally {
          try {
            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
          } finally {
            if (e_20) throw e_20.error;
          }
        }
      }

      return results;
    };
    /**
     * @ignore
     */


    MiniSearch.prototype.combineResults = function (results, combineWith) {
      if (combineWith === void 0) {
        combineWith = OR;
      }

      if (results.length === 0) {
        return new Map();
      }

      var operator = combineWith.toLowerCase();
      return results.reduce(combinators[operator]) || new Map();
    };
    /**
     * Allows serialization of the index to JSON, to possibly store it and later
     * deserialize it with `MiniSearch.loadJSON`.
     *
     * Normally one does not directly call this method, but rather call the
     * standard JavaScript `JSON.stringify()` passing the `MiniSearch` instance,
     * and JavaScript will internally call this method. Upon deserialization, one
     * must pass to `loadJSON` the same options used to create the original
     * instance that was serialized.
     *
     * ### Usage:
     *
     * ```javascript
     * // Serialize the index:
     * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })
     * miniSearch.addAll(documents)
     * const json = JSON.stringify(miniSearch)
     *
     * // Later, to deserialize it:
     * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })
     * ```
     *
     * @return A plain-object serializeable representation of the search index.
     */


    MiniSearch.prototype.toJSON = function () {
      var e_21, _a, e_22, _b;

      var index = [];

      try {
        for (var _c = __values(this._index), _d = _c.next(); !_d.done; _d = _c.next()) {
          var _e = __read(_d.value, 2),
              term = _e[0],
              fieldIndex = _e[1];

          var data = {};

          try {
            for (var fieldIndex_2 = (e_22 = void 0, __values(fieldIndex)), fieldIndex_2_1 = fieldIndex_2.next(); !fieldIndex_2_1.done; fieldIndex_2_1 = fieldIndex_2.next()) {
              var _f = __read(fieldIndex_2_1.value, 2),
                  fieldId = _f[0],
                  freqs = _f[1];

              data[fieldId] = Object.fromEntries(freqs);
            }
          } catch (e_22_1) {
            e_22 = {
              error: e_22_1
            };
          } finally {
            try {
              if (fieldIndex_2_1 && !fieldIndex_2_1.done && (_b = fieldIndex_2.return)) _b.call(fieldIndex_2);
            } finally {
              if (e_22) throw e_22.error;
            }
          }

          index.push([term, data]);
        }
      } catch (e_21_1) {
        e_21 = {
          error: e_21_1
        };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        } finally {
          if (e_21) throw e_21.error;
        }
      }

      return {
        documentCount: this._documentCount,
        nextId: this._nextId,
        documentIds: Object.fromEntries(this._documentIds),
        fieldIds: this._fieldIds,
        fieldLength: Object.fromEntries(this._fieldLength),
        averageFieldLength: this._avgFieldLength,
        storedFields: Object.fromEntries(this._storedFields),
        dirtCount: this._dirtCount,
        index: index,
        serializationVersion: 2
      };
    };
    /**
     * @ignore
     */


    MiniSearch.prototype.termResults = function (sourceTerm, derivedTerm, termWeight, fieldTermData, fieldBoosts, boostDocumentFn, bm25params, results) {
      var e_23, _a, e_24, _b, _c;

      if (results === void 0) {
        results = new Map();
      }

      if (fieldTermData == null) return results;

      try {
        for (var _d = __values(Object.keys(fieldBoosts)), _e = _d.next(); !_e.done; _e = _d.next()) {
          var field = _e.value;
          var fieldBoost = fieldBoosts[field];
          var fieldId = this._fieldIds[field];
          var fieldTermFreqs = fieldTermData.get(fieldId);
          if (fieldTermFreqs == null) continue;
          var matchingFields = fieldTermFreqs.size;
          var avgFieldLength = this._avgFieldLength[fieldId];

          try {
            for (var _f = (e_24 = void 0, __values(fieldTermFreqs.keys())), _g = _f.next(); !_g.done; _g = _f.next()) {
              var docId = _g.value;

              if (!this._documentIds.has(docId)) {
                this.removeTerm(fieldId, docId, derivedTerm);
                matchingFields -= 1;
                continue;
              }

              var docBoost = boostDocumentFn ? boostDocumentFn(this._documentIds.get(docId), derivedTerm) : 1;
              if (!docBoost) continue;
              var termFreq = fieldTermFreqs.get(docId);

              var fieldLength = this._fieldLength.get(docId)[fieldId]; // NOTE: The total number of fields is set to the number of documents
              // `this._documentCount`. It could also make sense to use the number of
              // documents where the current field is non-blank as a normalisation
              // factor. This will make a difference in scoring if the field is rarely
              // present. This is currently not supported, and may require further
              // analysis to see if it is a valid use case.


              var rawScore = calcBM25Score(termFreq, matchingFields, this._documentCount, fieldLength, avgFieldLength, bm25params);
              var weightedScore = termWeight * fieldBoost * docBoost * rawScore;
              var result = results.get(docId);

              if (result) {
                result.score += weightedScore;
                assignUniqueTerm(result.terms, sourceTerm);
                var match = getOwnProperty(result.match, derivedTerm);

                if (match) {
                  match.push(field);
                } else {
                  result.match[derivedTerm] = [field];
                }
              } else {
                results.set(docId, {
                  score: weightedScore,
                  terms: [sourceTerm],
                  match: (_c = {}, _c[derivedTerm] = [field], _c)
                });
              }
            }
          } catch (e_24_1) {
            e_24 = {
              error: e_24_1
            };
          } finally {
            try {
              if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
            } finally {
              if (e_24) throw e_24.error;
            }
          }
        }
      } catch (e_23_1) {
        e_23 = {
          error: e_23_1
        };
      } finally {
        try {
          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
        } finally {
          if (e_23) throw e_23.error;
        }
      }

      return results;
    };
    /**
     * @ignore
     */


    MiniSearch.prototype.addTerm = function (fieldId, documentId, term) {
      var indexData = this._index.fetch(term, createMap);

      var fieldIndex = indexData.get(fieldId);

      if (fieldIndex == null) {
        fieldIndex = new Map();
        fieldIndex.set(documentId, 1);
        indexData.set(fieldId, fieldIndex);
      } else {
        var docs = fieldIndex.get(documentId);
        fieldIndex.set(documentId, (docs || 0) + 1);
      }
    };
    /**
     * @ignore
     */


    MiniSearch.prototype.removeTerm = function (fieldId, documentId, term) {
      if (!this._index.has(term)) {
        this.warnDocumentChanged(documentId, fieldId, term);
        return;
      }

      var indexData = this._index.fetch(term, createMap);

      var fieldIndex = indexData.get(fieldId);

      if (fieldIndex == null || fieldIndex.get(documentId) == null) {
        this.warnDocumentChanged(documentId, fieldId, term);
      } else if (fieldIndex.get(documentId) <= 1) {
        if (fieldIndex.size <= 1) {
          indexData.delete(fieldId);
        } else {
          fieldIndex.delete(documentId);
        }
      } else {
        fieldIndex.set(documentId, fieldIndex.get(documentId) - 1);
      }

      if (this._index.get(term).size === 0) {
        this._index.delete(term);
      }
    };
    /**
     * @ignore
     */


    MiniSearch.prototype.warnDocumentChanged = function (shortDocumentId, fieldId, term) {
      var e_25, _a;

      try {
        for (var _b = __values(Object.keys(this._fieldIds)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var fieldName = _c.value;

          if (this._fieldIds[fieldName] === fieldId) {
            this._options.logger('warn', "MiniSearch: document with ID ".concat(this._documentIds.get(shortDocumentId), " has changed before removal: term \"").concat(term, "\" was not present in field \"").concat(fieldName, "\". Removing a document after it has changed can corrupt the index!"), 'version_conflict');

            return;
          }
        }
      } catch (e_25_1) {
        e_25 = {
          error: e_25_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_25) throw e_25.error;
        }
      }
    };
    /**
     * @ignore
     */


    MiniSearch.prototype.addDocumentId = function (documentId) {
      var shortDocumentId = this._nextId;

      this._idToShortId.set(documentId, shortDocumentId);

      this._documentIds.set(shortDocumentId, documentId);

      this._documentCount += 1;
      this._nextId += 1;
      return shortDocumentId;
    };
    /**
     * @ignore
     */


    MiniSearch.prototype.addFields = function (fields) {
      for (var i = 0; i < fields.length; i++) {
        this._fieldIds[fields[i]] = i;
      }
    };
    /**
     * @ignore
     */


    MiniSearch.prototype.addFieldLength = function (documentId, fieldId, count, length) {
      var fieldLengths = this._fieldLength.get(documentId);

      if (fieldLengths == null) this._fieldLength.set(documentId, fieldLengths = []);
      fieldLengths[fieldId] = length;
      var averageFieldLength = this._avgFieldLength[fieldId] || 0;
      var totalFieldLength = averageFieldLength * count + length;
      this._avgFieldLength[fieldId] = totalFieldLength / (count + 1);
    };
    /**
     * @ignore
     */


    MiniSearch.prototype.removeFieldLength = function (documentId, fieldId, count, length) {
      if (count === 1) {
        this._avgFieldLength[fieldId] = 0;
        return;
      }

      var totalFieldLength = this._avgFieldLength[fieldId] * count - length;
      this._avgFieldLength[fieldId] = totalFieldLength / (count - 1);
    };
    /**
     * @ignore
     */


    MiniSearch.prototype.saveStoredFields = function (documentId, doc) {
      var e_26, _a;

      var _b = this._options,
          storeFields = _b.storeFields,
          extractField = _b.extractField;

      if (storeFields == null || storeFields.length === 0) {
        return;
      }

      var documentFields = this._storedFields.get(documentId);

      if (documentFields == null) this._storedFields.set(documentId, documentFields = {});

      try {
        for (var storeFields_1 = __values(storeFields), storeFields_1_1 = storeFields_1.next(); !storeFields_1_1.done; storeFields_1_1 = storeFields_1.next()) {
          var fieldName = storeFields_1_1.value;
          var fieldValue = extractField(doc, fieldName);
          if (fieldValue !== undefined) documentFields[fieldName] = fieldValue;
        }
      } catch (e_26_1) {
        e_26 = {
          error: e_26_1
        };
      } finally {
        try {
          if (storeFields_1_1 && !storeFields_1_1.done && (_a = storeFields_1.return)) _a.call(storeFields_1);
        } finally {
          if (e_26) throw e_26.error;
        }
      }
    };

    return MiniSearch;
  }();

  var getOwnProperty = function getOwnProperty(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined;
  };

  var combinators = (_a = {}, _a[OR] = function (a, b) {
    var e_27, _a;

    try {
      for (var _b = __values(b.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var docId = _c.value;
        var existing = a.get(docId);

        if (existing == null) {
          a.set(docId, b.get(docId));
        } else {
          var _d = b.get(docId),
              score = _d.score,
              terms = _d.terms,
              match = _d.match;

          existing.score = existing.score + score;
          existing.match = Object.assign(existing.match, match);
          assignUniqueTerms(existing.terms, terms);
        }
      }
    } catch (e_27_1) {
      e_27 = {
        error: e_27_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_27) throw e_27.error;
      }
    }

    return a;
  }, _a[AND] = function (a, b) {
    var e_28, _a;

    var combined = new Map();

    try {
      for (var _b = __values(b.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var docId = _c.value;
        var existing = a.get(docId);
        if (existing == null) continue;

        var _d = b.get(docId),
            score = _d.score,
            terms = _d.terms,
            match = _d.match;

        assignUniqueTerms(existing.terms, terms);
        combined.set(docId, {
          score: existing.score + score,
          terms: existing.terms,
          match: Object.assign(existing.match, match)
        });
      }
    } catch (e_28_1) {
      e_28 = {
        error: e_28_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_28) throw e_28.error;
      }
    }

    return combined;
  }, _a[AND_NOT] = function (a, b) {
    var e_29, _a;

    try {
      for (var _b = __values(b.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var docId = _c.value;
        a.delete(docId);
      }
    } catch (e_29_1) {
      e_29 = {
        error: e_29_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_29) throw e_29.error;
      }
    }

    return a;
  }, _a);
  var defaultBM25params = {
    k: 1.2,
    b: 0.7,
    d: 0.5
  };

  var calcBM25Score = function calcBM25Score(termFreq, matchingCount, totalCount, fieldLength, avgFieldLength, bm25params) {
    var k = bm25params.k,
        b = bm25params.b,
        d = bm25params.d;
    var invDocFreq = Math.log(1 + (totalCount - matchingCount + 0.5) / (matchingCount + 0.5));
    return invDocFreq * (d + termFreq * (k + 1) / (termFreq + k * (1 - b + b * fieldLength / avgFieldLength)));
  };

  var termToQuerySpec = function termToQuerySpec(options) {
    return function (term, i, terms) {
      var fuzzy = typeof options.fuzzy === 'function' ? options.fuzzy(term, i, terms) : options.fuzzy || false;
      var prefix = typeof options.prefix === 'function' ? options.prefix(term, i, terms) : options.prefix === true;
      return {
        term: term,
        fuzzy: fuzzy,
        prefix: prefix
      };
    };
  };

  var defaultOptions = {
    idField: 'id',
    extractField: function extractField(document, fieldName) {
      return document[fieldName];
    },
    tokenize: function tokenize(text, fieldName) {
      return text.split(SPACE_OR_PUNCTUATION);
    },
    processTerm: function processTerm(term, fieldName) {
      return term.toLowerCase();
    },
    fields: undefined,
    searchOptions: undefined,
    storeFields: [],
    logger: function logger(level, message, code) {
      return console != null && console.warn != null && console[level](message);
    },
    autoVacuum: true
  };
  var defaultSearchOptions = {
    combineWith: OR,
    prefix: false,
    fuzzy: false,
    maxFuzzy: 6,
    boost: {},
    weights: {
      fuzzy: 0.45,
      prefix: 0.375
    },
    bm25: defaultBM25params
  };
  var defaultAutoSuggestOptions = {
    combineWith: AND,
    prefix: function prefix(term, i, terms) {
      return i === terms.length - 1;
    }
  };
  var defaultVacuumOptions = {
    batchSize: 1000,
    batchWait: 10
  };
  var defaultVacuumConditions = {
    minDirtFactor: 0.1,
    minDirtCount: 20
  };

  var defaultAutoVacuumOptions = _assign(_assign({}, defaultVacuumOptions), defaultVacuumConditions);

  var assignUniqueTerm = function assignUniqueTerm(target, term) {
    // Avoid adding duplicate terms.
    if (!target.includes(term)) target.push(term);
  };

  var assignUniqueTerms = function assignUniqueTerms(target, source) {
    var e_30, _a;

    try {
      for (var source_1 = __values(source), source_1_1 = source_1.next(); !source_1_1.done; source_1_1 = source_1.next()) {
        var term = source_1_1.value; // Avoid adding duplicate terms.

        if (!target.includes(term)) target.push(term);
      }
    } catch (e_30_1) {
      e_30 = {
        error: e_30_1
      };
    } finally {
      try {
        if (source_1_1 && !source_1_1.done && (_a = source_1.return)) _a.call(source_1);
      } finally {
        if (e_30) throw e_30.error;
      }
    }
  };

  var byScore = function byScore(_a, _b) {
    var a = _a.score;
    var b = _b.score;
    return b - a;
  };

  var createMap = function createMap() {
    return new Map();
  };

  var objectToNumericMap = function objectToNumericMap(object) {
    var e_31, _a;

    var map = new Map();

    try {
      for (var _b = __values(Object.keys(object)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var key = _c.value;
        map.set(parseInt(key, 10), object[key]);
      }
    } catch (e_31_1) {
      e_31 = {
        error: e_31_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_31) throw e_31.error;
      }
    }

    return map;
  }; // This regular expression matches any Unicode space or punctuation character
  // Adapted from https://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7BZ%7D%5Cp%7BP%7D&abb=on&c=on&esc=on


  var SPACE_OR_PUNCTUATION = /[\n\r -#%-\*,-\/:;\?@\[-\]_\{\}\xA0\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/;

  function _createSuper$a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$a(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$a() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var console_1$1 = globals.console;
  var file$a = "src\\components\\listederoulante.svelte";

  function get_each_context$1(ctx, list, i) {
    var child_ctx = ctx.slice();
    child_ctx[89] = list[i];
    child_ctx[91] = i;
    return child_ctx;
  }

  function get_each_context_1(ctx, list, i) {
    var child_ctx = ctx.slice();
    child_ctx[92] = list[i];
    child_ctx[91] = i;
    return child_ctx;
  } // (1088:10) {:else}


  function create_else_block$4(ctx) {
    var ul;
    var each_value_1 =
    /*optionsSelectionnees*/
    ctx[10];
    validate_each_argument(each_value_1);
    var each_blocks = [];

    for (var i = 0; i < each_value_1.length; i += 1) {
      each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    }

    var block = {
      c: function create() {
        ul = element("ul");

        for (var _i = 0; _i < each_blocks.length; _i += 1) {
          each_blocks[_i].c();
        }

        attr_dev(ul, "aria-label",
        /*labelListeValeursSelectionnees*/
        ctx[19]);
        add_location(ul, file$a, 1088, 14, 37207);
      },
      m: function mount(target, anchor) {
        insert_dev(target, ul, anchor);

        for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
          each_blocks[_i2].m(ul, null);
        }
      },
      p: function update(ctx, dirty) {
        if (dirty[0] &
        /*titleEtiquette, afficherOptions, descriptionEtiquette, optionsSelectionnees, deselectionnerOptionViaEtiquette, blurOptionSelectionnee*/
        545653768) {
          each_value_1 =
          /*optionsSelectionnees*/
          ctx[10];
          validate_each_argument(each_value_1);

          var _i3;

          for (_i3 = 0; _i3 < each_value_1.length; _i3 += 1) {
            var child_ctx = get_each_context_1(ctx, each_value_1, _i3);

            if (each_blocks[_i3]) {
              each_blocks[_i3].p(child_ctx, dirty);
            } else {
              each_blocks[_i3] = create_each_block_1(child_ctx);

              each_blocks[_i3].c();

              each_blocks[_i3].m(ul, null);
            }
          }

          for (; _i3 < each_blocks.length; _i3 += 1) {
            each_blocks[_i3].d(1);
          }

          each_blocks.length = each_value_1.length;
        }
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(ul);
        destroy_each(each_blocks, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_else_block$4.name,
      type: "else",
      source: "(1088:10) {:else}",
      ctx: ctx
    });
    return block;
  } // (1086:10) {#if !multiple}


  function create_if_block_5$1(ctx) {
    var span;
    var t_value =
    /*optionsSelectionnees*/
    ctx[10][0].texte + "";
    var t;
    var block = {
      c: function create() {
        span = element("span");
        t = text(t_value);
        add_location(span, file$a, 1086, 14, 37096);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
        append_dev(span, t);
      },
      p: function update(ctx, dirty) {
        if (dirty[0] &
        /*optionsSelectionnees*/
        1024 && t_value !== (t_value =
        /*optionsSelectionnees*/
        ctx[10][0].texte + "")) set_data_dev(t, t_value);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(span);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_5$1.name,
      type: "if",
      source: "(1086:10) {#if !multiple}",
      ctx: ctx
    });
    return block;
  } // (1083:8) {#if optionsSelectionnees.length === 0}


  function create_if_block_4$2(ctx) {
    var span;
    var t;
    var block = {
      c: function create() {
        span = element("span");
        t = text(
        /*placeholder*/
        ctx[2]);
        attr_dev(span, "class", "utd-placeholder");
        add_location(span, file$a, 1083, 10, 36986);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
        append_dev(span, t);
      },
      p: function update(ctx, dirty) {
        if (dirty[0] &
        /*placeholder*/
        4) set_data_dev(t,
        /*placeholder*/
        ctx[2]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(span);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_4$2.name,
      type: "if",
      source: "(1083:8) {#if optionsSelectionnees.length === 0}",
      ctx: ctx
    });
    return block;
  } // (1090:16) {#each optionsSelectionnees as optionSelectionnee, i}


  function create_each_block_1(ctx) {
    var li;
    var button;
    var span0;
    var t0_value =
    /*optionSelectionnee*/
    ctx[92].texte + "";
    var t0;
    var t1;
    var span1;
    var button_tabindex_value;
    var button_indexeoption_value;
    var t2;
    var mounted;
    var dispose;
    var block = {
      c: function create() {
        li = element("li");
        button = element("button");
        span0 = element("span");
        t0 = text(t0_value);
        t1 = space();
        span1 = element("span");
        t2 = space();
        attr_dev(span0, "class", "texte");
        add_location(span0, file$a, 1092, 22, 37667);
        attr_dev(span1, "aria-hidden", "true");
        attr_dev(span1, "class", "utd-icone-svg md x-fermer-bleu");
        add_location(span1, file$a, 1093, 22, 37744);
        attr_dev(button, "type", "button");
        attr_dev(button, "class", "etiquette");
        attr_dev(button, "title",
        /*titleEtiquette*/
        ctx[17]);
        attr_dev(button, "tabindex", button_tabindex_value =
        /*afficherOptions*/
        ctx[3] ? '0' : '-1');
        attr_dev(button, "aria-description",
        /*descriptionEtiquette*/
        ctx[18]);
        attr_dev(button, "indexeoption", button_indexeoption_value =
        /*optionSelectionnee*/
        ctx[92].indexe);
        add_location(button, file$a, 1091, 20, 37374);
        add_location(li, file$a, 1090, 18, 37348);
      },
      m: function mount(target, anchor) {
        insert_dev(target, li, anchor);
        append_dev(li, button);
        append_dev(button, span0);
        append_dev(span0, t0);
        append_dev(button, t1);
        append_dev(button, span1);
        append_dev(li, t2);

        if (!mounted) {
          dispose = [listen_dev(button, "click",
          /*deselectionnerOptionViaEtiquette*/
          ctx[23], false, false, false), listen_dev(button, "blur",
          /*blurOptionSelectionnee*/
          ctx[29], false, false, false)];
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (dirty[0] &
        /*optionsSelectionnees*/
        1024 && t0_value !== (t0_value =
        /*optionSelectionnee*/
        ctx[92].texte + "")) set_data_dev(t0, t0_value);

        if (dirty[0] &
        /*afficherOptions*/
        8 && button_tabindex_value !== (button_tabindex_value =
        /*afficherOptions*/
        ctx[3] ? '0' : '-1')) {
          attr_dev(button, "tabindex", button_tabindex_value);
        }

        if (dirty[0] &
        /*optionsSelectionnees*/
        1024 && button_indexeoption_value !== (button_indexeoption_value =
        /*optionSelectionnee*/
        ctx[92].indexe)) {
          attr_dev(button, "indexeoption", button_indexeoption_value);
        }
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(li);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_each_block_1.name,
      type: "each",
      source: "(1090:16) {#each optionsSelectionnees as optionSelectionnee, i}",
      ctx: ctx
    });
    return block;
  } // (1104:6) {#if recherchable === 'true'}


  function create_if_block_3$2(ctx) {
    var span;
    var label;
    var t0;
    var t1;
    var input;
    var input_aria_activedescendant_value;
    var span_class_value;
    var mounted;
    var dispose;
    var block = {
      c: function create() {
        span = element("span");
        label = element("label");
        t0 = text(
        /*textePlaceholderRecherche*/
        ctx[21]);
        t1 = space();
        input = element("input");
        attr_dev(label, "for",
        /*idControleRecherche*/
        ctx[14]);
        attr_dev(label, "class", "utd-sr-only");
        add_location(label, file$a, 1105, 10, 38183);
        attr_dev(input, "type", "text");
        attr_dev(input, "id",
        /*idControleRecherche*/
        ctx[14]);
        attr_dev(input, "class", "utd-form-control recherche");
        attr_dev(input, "role", "combobox");
        attr_dev(input, "aria-expanded", "true");
        attr_dev(input, "aria-autocomplete", "none");
        attr_dev(input, "autocomplete", "off");
        attr_dev(input, "spellcheck", "false");
        attr_dev(input, "placeholder",
        /*textePlaceholderRecherche*/
        ctx[21]);
        attr_dev(input, "aria-description",
        /*ariaDescriptionRecherche*/
        ctx[7]);
        attr_dev(input, "aria-controls",
        /*idControleResultats*/
        ctx[15]);
        attr_dev(input, "aria-activedescendant", input_aria_activedescendant_value =
        /*afficherOptions*/
        ctx[3] ?
        /*idActiveDescendant*/
        ctx[8] : null);
        add_location(input, file$a, 1106, 10, 38285);
        attr_dev(span, "class", span_class_value = "conteneur-recherche " + (!
        /*afficherOptions*/
        ctx[3] ? 'utd-d-none' : ''));
        add_location(span, file$a, 1104, 8, 38098);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
        append_dev(span, label);
        append_dev(label, t0);
        append_dev(span, t1);
        append_dev(span, input);

        if (!mounted) {
          dispose = [listen_dev(input, "input",
          /*traiterSaisieRecherche*/
          ctx[26], false, false, false), listen_dev(input, "blur",
          /*blurRecherche*/
          ctx[28], false, false, false)];
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (dirty[0] &
        /*ariaDescriptionRecherche*/
        128) {
          attr_dev(input, "aria-description",
          /*ariaDescriptionRecherche*/
          ctx[7]);
        }

        if (dirty[0] &
        /*afficherOptions, idActiveDescendant*/
        264 && input_aria_activedescendant_value !== (input_aria_activedescendant_value =
        /*afficherOptions*/
        ctx[3] ?
        /*idActiveDescendant*/
        ctx[8] : null)) {
          attr_dev(input, "aria-activedescendant", input_aria_activedescendant_value);
        }

        if (dirty[0] &
        /*afficherOptions*/
        8 && span_class_value !== (span_class_value = "conteneur-recherche " + (!
        /*afficherOptions*/
        ctx[3] ? 'utd-d-none' : ''))) {
          attr_dev(span, "class", span_class_value);
        }
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(span);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_3$2.name,
      type: "if",
      source: "(1104:6) {#if recherchable === 'true'}",
      ctx: ctx
    });
    return block;
  } // (1111:6) {#if !multiple && recherchable === 'false' && afficherOptions}


  function create_if_block_2$4(ctx) {
    var span;
    var block = {
      c: function create() {
        span = element("span");
        attr_dev(span, "class", "separateur-resultats");
        attr_dev(span, "aria-hidden", "true");
        add_location(span, file$a, 1111, 8, 38844);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(span);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_2$4.name,
      type: "if",
      source: "(1111:6) {#if !multiple && recherchable === 'false' && afficherOptions}",
      ctx: ctx
    });
    return block;
  } // (1116:8) {#if suggestions.length === 0}


  function create_if_block_1$5(ctx) {
    var span;
    var block = {
      c: function create() {
        span = element("span");
        span.textContent = "".concat(
        /*texteAucunResultat*/
        ctx[20]);
        attr_dev(span, "class", "texte-aucun-resultat");
        attr_dev(span, "aria-hidden", "true");
        add_location(span, file$a, 1116, 10, 39220);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
      },
      p: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(span);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_1$5.name,
      type: "if",
      source: "(1116:8) {#if suggestions.length === 0}",
      ctx: ctx
    });
    return block;
  } // (1123:14) {#if multiple}


  function create_if_block$8(ctx) {
    var span;
    var block = {
      c: function create() {
        span = element("span");
        attr_dev(span, "class", "utd-checkbox");
        attr_dev(span, "aria-hidden", "true");
        add_location(span, file$a, 1123, 16, 39889);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(span);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block$8.name,
      type: "if",
      source: "(1123:14) {#if multiple}",
      ctx: ctx
    });
    return block;
  } // (1121:10) {#each suggestions as suggestion, i}


  function create_each_block$1(ctx) {
    var li;
    var t0;
    var span;
    var t1_value =
    /*suggestion*/
    ctx[89].texte + "";
    var t1;
    var t2;
    var li_class_value;
    var li_aria_label_value;
    var li_id_value;
    var li_value_value;
    var li_indexeoption_value;
    var li_aria_selected_value;
    var mounted;
    var dispose;
    var if_block =
    /*multiple*/
    ctx[13] && create_if_block$8(ctx);
    var block = {
      c: function create() {
        li = element("li");
        if (if_block) if_block.c();
        t0 = space();
        span = element("span");
        t1 = text(t1_value);
        t2 = space();
        attr_dev(span, "class", "texte-option");
        add_location(span, file$a, 1125, 14, 40007);
        attr_dev(li, "class", li_class_value =
        /*i*/
        ctx[91] ===
        /*indexeFocusSuggestion*/
        ctx[4] ? 'focus' : '');
        attr_dev(li, "aria-label", li_aria_label_value =
        /*suggestion*/
        ctx[89].texte);
        attr_dev(li, "role", "option");
        attr_dev(li, "id", li_id_value =
        /*suggestion*/
        ctx[89].id);
        li.value = li_value_value =
        /*suggestion*/
        ctx[89].value;
        attr_dev(li, "indexesuggestion", /*i*/
        ctx[91]);
        attr_dev(li, "indexeoption", li_indexeoption_value =
        /*suggestion*/
        ctx[89].indexe);
        attr_dev(li, "aria-selected", li_aria_selected_value =
        /*suggestion*/
        ctx[89].selected ? 'true' : 'false');
        add_location(li, file$a, 1121, 12, 39552);
      },
      m: function mount(target, anchor) {
        insert_dev(target, li, anchor);
        if (if_block) if_block.m(li, null);
        append_dev(li, t0);
        append_dev(li, span);
        append_dev(span, t1);
        append_dev(li, t2);

        if (!mounted) {
          dispose = listen_dev(li, "click",
          /*clickOption*/
          ctx[30], false, false, false);
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (
        /*multiple*/
        ctx[13]) {
          if (if_block) ; else {
            if_block = create_if_block$8(ctx);
            if_block.c();
            if_block.m(li, t0);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }

        if (dirty[0] &
        /*suggestions*/
        512 && t1_value !== (t1_value =
        /*suggestion*/
        ctx[89].texte + "")) set_data_dev(t1, t1_value);

        if (dirty[0] &
        /*indexeFocusSuggestion*/
        16 && li_class_value !== (li_class_value =
        /*i*/
        ctx[91] ===
        /*indexeFocusSuggestion*/
        ctx[4] ? 'focus' : '')) {
          attr_dev(li, "class", li_class_value);
        }

        if (dirty[0] &
        /*suggestions*/
        512 && li_aria_label_value !== (li_aria_label_value =
        /*suggestion*/
        ctx[89].texte)) {
          attr_dev(li, "aria-label", li_aria_label_value);
        }

        if (dirty[0] &
        /*suggestions*/
        512 && li_id_value !== (li_id_value =
        /*suggestion*/
        ctx[89].id)) {
          attr_dev(li, "id", li_id_value);
        }

        if (dirty[0] &
        /*suggestions*/
        512 && li_value_value !== (li_value_value =
        /*suggestion*/
        ctx[89].value)) {
          prop_dev(li, "value", li_value_value);
        }

        if (dirty[0] &
        /*suggestions*/
        512 && li_indexeoption_value !== (li_indexeoption_value =
        /*suggestion*/
        ctx[89].indexe)) {
          attr_dev(li, "indexeoption", li_indexeoption_value);
        }

        if (dirty[0] &
        /*suggestions*/
        512 && li_aria_selected_value !== (li_aria_selected_value =
        /*suggestion*/
        ctx[89].selected ? 'true' : 'false')) {
          attr_dev(li, "aria-selected", li_aria_selected_value);
        }
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(li);
        if (if_block) if_block.d();
        mounted = false;
        dispose();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_each_block$1.name,
      type: "each",
      source: "(1121:10) {#each suggestions as suggestion, i}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment$a(ctx) {
    var div1;
    var slot;
    var t0;
    var span0;
    var t1;
    var t2;
    var span4;
    var span2;
    var t3;
    var span1;
    var span2_class_value;
    var t4;
    var t5;
    var t6;
    var span3;
    var t7;
    var ul;
    var ul_aria_multiselectable_value;
    var span3_class_value;
    var span4_class_value;
    var span4_role_value;
    var span4_aria_expanded_value;
    var span4_tabindex_value;
    var span4_aria_owns_value;
    var span4_aria_multiselectable_value;
    var span4_aria_activedescendant_value;
    var t8;
    var div0;
    var div0_class_value;
    var div1_class_value;
    var t9;
    var link;
    var mounted;
    var dispose;

    function select_block_type(ctx, dirty) {
      if (
      /*optionsSelectionnees*/
      ctx[10].length === 0) return create_if_block_4$2;
      if (!
      /*multiple*/
      ctx[13]) return create_if_block_5$1;
      return create_else_block$4;
    }

    var current_block_type = select_block_type(ctx);
    var if_block0 = current_block_type(ctx);
    var if_block1 =
    /*recherchable*/
    ctx[0] === 'true' && create_if_block_3$2(ctx);
    var if_block2 = !
    /*multiple*/
    ctx[13] &&
    /*recherchable*/
    ctx[0] === 'false' &&
    /*afficherOptions*/
    ctx[3] && create_if_block_2$4(ctx);
    var if_block3 =
    /*suggestions*/
    ctx[9].length === 0 && create_if_block_1$5(ctx);
    var each_value =
    /*suggestions*/
    ctx[9];
    validate_each_argument(each_value);
    var each_blocks = [];

    for (var i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    }

    var block = {
      c: function create() {
        div1 = element("div");
        slot = element("slot");
        t0 = space();
        span0 = element("span");
        t1 = text(
        /*texteNotificationLecteurEcran*/
        ctx[11]);
        t2 = space();
        span4 = element("span");
        span2 = element("span");
        if_block0.c();
        t3 = space();
        span1 = element("span");
        t4 = space();
        if (if_block1) if_block1.c();
        t5 = space();
        if (if_block2) if_block2.c();
        t6 = space();
        span3 = element("span");
        if (if_block3) if_block3.c();
        t7 = space();
        ul = element("ul");

        for (var _i4 = 0; _i4 < each_blocks.length; _i4 += 1) {
          each_blocks[_i4].c();
        }

        t8 = space();
        div0 = element("div");
        t9 = space();
        link = element("link");
        this.c = noop;
        add_location(slot, file$a, 1075, 2, 35975);
        attr_dev(span0, "aria-live", "polite");
        attr_dev(span0, "id",
        /*idControleZoneNotificationLecteurEcran*/
        ctx[16]);
        attr_dev(span0, "class", "utd-sr-only");
        attr_dev(span0, "tabindex", "-1");
        add_location(span0, file$a, 1077, 4, 35996);
        attr_dev(span1, "class", "utd-icone-svg chevron-bleu-piv developper");
        add_location(span1, file$a, 1100, 8, 37969);
        attr_dev(span2, "class", span2_class_value = "selection " + (
        /*multiple*/
        ctx[13] &&
        /*optionsSelectionnees*/
        ctx[10].length > 0 ? 'contient-etiquettes' : ''));
        add_location(span2, file$a, 1080, 6, 36764);
        attr_dev(ul, "class", "suggestions");
        attr_dev(ul, "role", "listbox");
        attr_dev(ul, "aria-label",
        /*srLibelleListeValeursPossibles*/
        ctx[22]);
        attr_dev(ul, "aria-multiselectable", ul_aria_multiselectable_value =
        /*multiple*/
        ctx[13] ? 'true' : null);
        attr_dev(ul, "id",
        /*idControleResultats*/
        ctx[15]);
        add_location(ul, file$a, 1119, 8, 39328);
        attr_dev(span3, "class", span3_class_value = "resultats utd-scrollbar-verticale" + (!
        /*afficherOptions*/
        ctx[3] ? ' utd-d-none' : '') + (
        /*recherchable*/
        ctx[0] === 'true' ? ' recherchable' : '') + (
        /*estScrollbarSuggestionsVisible*/
        ctx[12] ? " scrollbar-visible" : ''));
        attr_dev(span3, "dir", "ltr");
        add_location(span3, file$a, 1114, 6, 38928);
        attr_dev(span4, "class", span4_class_value = "conteneur utd-form-control" + (
        /*afficherOptions*/
        ctx[3] ? ' ouvert' : ''));
        attr_dev(span4, "dir", "ltr");
        attr_dev(span4, "role", span4_role_value =
        /*afficherOptions*/
        ctx[3] ? null : 'listbox');
        attr_dev(span4, "aria-expanded", span4_aria_expanded_value =
        /*afficherOptions*/
        ctx[3] ? 'true' : 'false');
        attr_dev(span4, "tabindex", span4_tabindex_value =
        /*afficherOptions*/
        ctx[3] ? '-1' : '0');
        attr_dev(span4, "aria-disabled", "false");
        attr_dev(span4, "aria-label",
        /*ariaLabel*/
        ctx[5]);
        attr_dev(span4, "aria-description",
        /*ariaDescriptionConteneur*/
        ctx[6]);
        attr_dev(span4, "aria-owns", span4_aria_owns_value =
        /*recherchable*/
        ctx[0] === 'false' ?
        /*idControleResultats*/
        ctx[15] : null);
        attr_dev(span4, "aria-multiselectable", span4_aria_multiselectable_value =
        /*multiple*/
        ctx[13] &&
        /*recherchable*/
        ctx[0] === 'false' ? 'true' : null);
        attr_dev(span4, "aria-activedescendant", span4_aria_activedescendant_value =
        /*recherchable*/
        ctx[0] === 'false' &&
        /*afficherOptions*/
        ctx[3] ?
        /*idActiveDescendant*/
        ctx[8] : null);
        add_location(span4, file$a, 1079, 4, 36147);
        attr_dev(div0, "class", div0_class_value = "espaceur" + (!
        /*afficherOptions*/
        ctx[3] ? ' utd-d-none' : ''));
        add_location(div0, file$a, 1132, 4, 40170);
        attr_dev(div1, "class", div1_class_value = "utd-component utd-liste-deroulante " +
        /*largeur*/
        ctx[1] + (
        /*multiple*/
        ctx[13] ? ' multiple' : '') + (
        /*recherchable*/
        ctx[0] === 'true' ? ' recherchable' : ''));
        add_location(div1, file$a, 1074, 0, 35836);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", Utils.cssFullPath);
        add_location(link, file$a, 1135, 0, 40249);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div1, anchor);
        append_dev(div1, slot);
        append_dev(div1, t0);
        append_dev(div1, span0);
        append_dev(span0, t1);
        append_dev(div1, t2);
        append_dev(div1, span4);
        append_dev(span4, span2);
        if_block0.m(span2, null);
        append_dev(span2, t3);
        append_dev(span2, span1);
        append_dev(span4, t4);
        if (if_block1) if_block1.m(span4, null);
        append_dev(span4, t5);
        if (if_block2) if_block2.m(span4, null);
        append_dev(span4, t6);
        append_dev(span4, span3);
        if (if_block3) if_block3.m(span3, null);
        append_dev(span3, t7);
        append_dev(span3, ul);

        for (var _i5 = 0; _i5 < each_blocks.length; _i5 += 1) {
          each_blocks[_i5].m(ul, null);
        }

        append_dev(div1, t8);
        append_dev(div1, div0);
        insert_dev(target, t9, anchor);
        insert_dev(target, link, anchor);

        if (!mounted) {
          dispose = [listen_dev(span2, "click",
          /*clickSelection*/
          ctx[25], false, false, false), listen_dev(span2, "mousedown", selectionMouseDown, false, false, false), listen_dev(span3, "mousedown", resultatsMouseDown, false, false, false), listen_dev(span4, "blur",
          /*blurConteneur*/
          ctx[27], false, false, false), listen_dev(span4, "keydown",
          /*onKeyDown*/
          ctx[24], false, false, false)];
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (dirty[0] &
        /*texteNotificationLecteurEcran*/
        2048) set_data_dev(t1,
        /*texteNotificationLecteurEcran*/
        ctx[11]);

        if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0.d(1);
          if_block0 = current_block_type(ctx);

          if (if_block0) {
            if_block0.c();
            if_block0.m(span2, t3);
          }
        }

        if (dirty[0] &
        /*multiple, optionsSelectionnees*/
        9216 && span2_class_value !== (span2_class_value = "selection " + (
        /*multiple*/
        ctx[13] &&
        /*optionsSelectionnees*/
        ctx[10].length > 0 ? 'contient-etiquettes' : ''))) {
          attr_dev(span2, "class", span2_class_value);
        }

        if (
        /*recherchable*/
        ctx[0] === 'true') {
          if (if_block1) {
            if_block1.p(ctx, dirty);
          } else {
            if_block1 = create_if_block_3$2(ctx);
            if_block1.c();
            if_block1.m(span4, t5);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }

        if (!
        /*multiple*/
        ctx[13] &&
        /*recherchable*/
        ctx[0] === 'false' &&
        /*afficherOptions*/
        ctx[3]) {
          if (if_block2) ; else {
            if_block2 = create_if_block_2$4(ctx);
            if_block2.c();
            if_block2.m(span4, t6);
          }
        } else if (if_block2) {
          if_block2.d(1);
          if_block2 = null;
        }

        if (
        /*suggestions*/
        ctx[9].length === 0) {
          if (if_block3) {
            if_block3.p(ctx, dirty);
          } else {
            if_block3 = create_if_block_1$5(ctx);
            if_block3.c();
            if_block3.m(span3, t7);
          }
        } else if (if_block3) {
          if_block3.d(1);
          if_block3 = null;
        }

        if (dirty[0] &
        /*indexeFocusSuggestion, suggestions, clickOption, multiple*/
        1073750544) {
          each_value =
          /*suggestions*/
          ctx[9];
          validate_each_argument(each_value);

          var _i6;

          for (_i6 = 0; _i6 < each_value.length; _i6 += 1) {
            var child_ctx = get_each_context$1(ctx, each_value, _i6);

            if (each_blocks[_i6]) {
              each_blocks[_i6].p(child_ctx, dirty);
            } else {
              each_blocks[_i6] = create_each_block$1(child_ctx);

              each_blocks[_i6].c();

              each_blocks[_i6].m(ul, null);
            }
          }

          for (; _i6 < each_blocks.length; _i6 += 1) {
            each_blocks[_i6].d(1);
          }

          each_blocks.length = each_value.length;
        }

        if (dirty[0] &
        /*multiple*/
        8192 && ul_aria_multiselectable_value !== (ul_aria_multiselectable_value =
        /*multiple*/
        ctx[13] ? 'true' : null)) {
          attr_dev(ul, "aria-multiselectable", ul_aria_multiselectable_value);
        }

        if (dirty[0] &
        /*afficherOptions, recherchable, estScrollbarSuggestionsVisible*/
        4105 && span3_class_value !== (span3_class_value = "resultats utd-scrollbar-verticale" + (!
        /*afficherOptions*/
        ctx[3] ? ' utd-d-none' : '') + (
        /*recherchable*/
        ctx[0] === 'true' ? ' recherchable' : '') + (
        /*estScrollbarSuggestionsVisible*/
        ctx[12] ? " scrollbar-visible" : ''))) {
          attr_dev(span3, "class", span3_class_value);
        }

        if (dirty[0] &
        /*afficherOptions*/
        8 && span4_class_value !== (span4_class_value = "conteneur utd-form-control" + (
        /*afficherOptions*/
        ctx[3] ? ' ouvert' : ''))) {
          attr_dev(span4, "class", span4_class_value);
        }

        if (dirty[0] &
        /*afficherOptions*/
        8 && span4_role_value !== (span4_role_value =
        /*afficherOptions*/
        ctx[3] ? null : 'listbox')) {
          attr_dev(span4, "role", span4_role_value);
        }

        if (dirty[0] &
        /*afficherOptions*/
        8 && span4_aria_expanded_value !== (span4_aria_expanded_value =
        /*afficherOptions*/
        ctx[3] ? 'true' : 'false')) {
          attr_dev(span4, "aria-expanded", span4_aria_expanded_value);
        }

        if (dirty[0] &
        /*afficherOptions*/
        8 && span4_tabindex_value !== (span4_tabindex_value =
        /*afficherOptions*/
        ctx[3] ? '-1' : '0')) {
          attr_dev(span4, "tabindex", span4_tabindex_value);
        }

        if (dirty[0] &
        /*ariaLabel*/
        32) {
          attr_dev(span4, "aria-label",
          /*ariaLabel*/
          ctx[5]);
        }

        if (dirty[0] &
        /*ariaDescriptionConteneur*/
        64) {
          attr_dev(span4, "aria-description",
          /*ariaDescriptionConteneur*/
          ctx[6]);
        }

        if (dirty[0] &
        /*recherchable*/
        1 && span4_aria_owns_value !== (span4_aria_owns_value =
        /*recherchable*/
        ctx[0] === 'false' ?
        /*idControleResultats*/
        ctx[15] : null)) {
          attr_dev(span4, "aria-owns", span4_aria_owns_value);
        }

        if (dirty[0] &
        /*multiple, recherchable*/
        8193 && span4_aria_multiselectable_value !== (span4_aria_multiselectable_value =
        /*multiple*/
        ctx[13] &&
        /*recherchable*/
        ctx[0] === 'false' ? 'true' : null)) {
          attr_dev(span4, "aria-multiselectable", span4_aria_multiselectable_value);
        }

        if (dirty[0] &
        /*recherchable, afficherOptions, idActiveDescendant*/
        265 && span4_aria_activedescendant_value !== (span4_aria_activedescendant_value =
        /*recherchable*/
        ctx[0] === 'false' &&
        /*afficherOptions*/
        ctx[3] ?
        /*idActiveDescendant*/
        ctx[8] : null)) {
          attr_dev(span4, "aria-activedescendant", span4_aria_activedescendant_value);
        }

        if (dirty[0] &
        /*afficherOptions*/
        8 && div0_class_value !== (div0_class_value = "espaceur" + (!
        /*afficherOptions*/
        ctx[3] ? ' utd-d-none' : ''))) {
          attr_dev(div0, "class", div0_class_value);
        }

        if (dirty[0] &
        /*largeur, multiple, recherchable*/
        8195 && div1_class_value !== (div1_class_value = "utd-component utd-liste-deroulante " +
        /*largeur*/
        ctx[1] + (
        /*multiple*/
        ctx[13] ? ' multiple' : '') + (
        /*recherchable*/
        ctx[0] === 'true' ? ' recherchable' : ''))) {
          attr_dev(div1, "class", div1_class_value);
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(div1);
        if_block0.d();
        if (if_block1) if_block1.d();
        if (if_block2) if_block2.d();
        if (if_block3) if_block3.d();
        destroy_each(each_blocks, detaching);
        if (detaching) detach_dev(t9);
        if (detaching) detach_dev(link);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$a.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  var nbCaracteresMinimalRecherche = 2; //TODO déplacer dans utils?
  //On obtient le texte à partir du contenu textuel du contrôle label en excluant les éléments qui ne doivent pas être lus au lecteur écran.

  function obtenirTexteLecteurEcranControle(controle, selecteurExclusion) {
    var selecteurs = selecteurExclusion || ["[aria-hidden='true']"];
    var controleEpure = controle.cloneNode(true);
    var elementsExlus = controleEpure.querySelectorAll(selecteurs.join(','));

    for (var i = 0; i < elementsExlus.length; i++) {
      elementsExlus[i].remove();
    }

    return controleEpure.textContent;
  } //TODO déplacer dans utils?


  function obtenirTexteSelonAttributAria(controle, nomAttribut) {
    if (controle && controle.getAttribute(nomAttribut)) {
      var ids = controle.getAttribute(nomAttribut).split(' ');

      if (ids.length) {
        var textes = [];

        for (var i = 0; i < ids.length; i++) {
          var _controle = document.getElementById(ids[i]);

          if (_controle) {
            textes.push(_controle.textContent);
          }
        }

        return textes.join(' ');
      }
    } else {
      return '';
    }
  } //TODO déplacer dans utils?


  function majAttributControle(controle, nomAttribut, valeur) {
    if (valeur) {
      controle.setAttribute(nomAttribut, valeur);
    } else {
      controle.removeAttribute(nomAttribut);
    }
  }

  function selectionMouseDown(e) {
    //Petite twist afin de ne pas provoquer de blur si on click sur le contrôle de sélection à partir d'un autre contrôle. (Évite la loop de fermeture/ouverture du dropdown)
    e.preventDefault();
    e.stopPropagation();
  }

  function resultatsMouseDown(e) {
    //Petite twist afin de ne pas provoquer de blur si on click sur un contrôle d'option à partir d'un autre contrôle. (Évite la fermeture du dropdown via l'événement blur du contrôle de recherche)
    e.preventDefault();
  }

  function instance$a($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-liste-deroulante', slots, []);
    var languePage = Utils.obtenirLanguePage();
    var _$$props$recherchable = $$props.recherchable,
        recherchable = _$$props$recherchable === void 0 ? "false" : _$$props$recherchable;
    var _$$props$rechercheFlo = $$props.rechercheFloue,
        rechercheFloue = _$$props$rechercheFlo === void 0 ? "true" : _$$props$rechercheFlo;
    var _$$props$precisionRec = $$props.precisionRecherche,
        precisionRecherche = _$$props$precisionRec === void 0 ? "0.2" : _$$props$precisionRec;
    var _$$props$largeur = $$props.largeur,
        largeur = _$$props$largeur === void 0 ? "md" : _$$props$largeur; //Valeurs possible sm, md, lg

    var _$$props$placeholder = $$props.placeholder,
        placeholder = _$$props$placeholder === void 0 ? languePage === 'fr' ? "Effectuer un choix" : "Make a selection" : _$$props$placeholder; //Contrôles

    var thisComponent = get_current_component();
    var idControleRecherche = Utils.genererId();
    var idControleResultats = Utils.genererId();
    var idControleZoneNotificationLecteurEcran = Utils.genererId();
    var titleEtiquette = languePage === 'fr' ? "Supprimer" : "Delete";
    var descriptionEtiquette = languePage === 'fr' ? "Déselectionner" : "Unselect";
    var texteNotificationEtiquetteSupprimee = languePage === 'fr' ? "Élément désélectionné" : "Item unselected";
    var srPrefixeDescriptionValeurSelectionnee = languePage === 'fr' ? "Valeur sélectionnée" : "Selected value";
    var srPrefixeDescriptionValeursSelectionnees = languePage === 'fr' ? "Valeurs sélectionnées" : "Selected values";
    var labelListeValeursSelectionnees = languePage === 'fr' ? "Valeurs sélectionnées" : "Selected values";
    var srResultatsTrouves = languePage === 'fr' ? "{x} résultats trouvés" : "{x} results found.";
    var texteAucunResultat = languePage === 'fr' ? "Aucun résultat trouvé." : "No results found.";
    var srAucunResultat = texteAucunResultat;
    var textePlaceholderRecherche = languePage === 'fr' ? "Rechercher dans la liste" : "Search in the list";
    var texteCommunAriaDescriptionRecherche = languePage === 'fr' ? "Utilisez les touches flèches haut et bas pour naviguer dans la liste des choix possibles, Entrée ou Espace pour effectuer une sélection" : "Use the up and down arrow keys to navigate through the list of possible choices, Enter or Space to make a selection";
    var texteAccesSelectionAriaDescriptionRecherche = languePage === 'fr' ? ", et Shift + Tab afin d'accéder à la liste des éléments sélectionnés" : ", and Shift + Tab to to access the list of selected items";
    var srLibelleListeValeursPossibles = "Choix disponibles:" ;
    var mounted = false;
    var html;
    var composant;
    var controleConteneur;
    var controleSelection;
    var controleLabel;
    var ariaLabel = null;
    var ariaDescriptionConteneur = null;
    var ariaDescriptionRecherche = null;
    var controleRecherche;
    var controleSelect;
    var controleEspaceur;
    var controleZoneNotificationLecteurEcran;
    var controleConteneurResultats;
    var afficherOptions = false;
    var indexeFocusSuggestion = null;
    var idActiveDescendant = null;
    var options = [];
    var suggestions = [];
    var optionsSelectionnees = [];
    var texteRecherche = "";
    var texteNotificationLecteurEcran = "";
    var estDeselectionEnCours = false;
    var miniSearch;
    var optionsMiniSearch;
    var estScrollbarSuggestionsVisible = false;
    var multiple = false;
    onMount(function () {
      optionsMiniSearch = {
        fuzzy: rechercheFloue === 'true' ? parseFloat(precisionRecherche) : null,
        prefix: true,
        fields: ['texte', 'motsCles'],
        storeFields: ['id', 'indexe'],
        stopWords: new Set([]),
        combineWith: 'OR',
        filter: null,
        processTerm: function processTerm(term, _fieldName) {
          return indexerTerme(term);
        }
      };
      mounted = true;
      html = thisComponent.getRootNode().getElementsByTagName("html")[0];
      composant = thisComponent.shadowRoot.querySelector('.utd-liste-deroulante');
      controleConteneur = thisComponent.shadowRoot.querySelector('.conteneur');
      controleEspaceur = thisComponent.shadowRoot.querySelector('.espaceur');
      controleSelection = thisComponent.shadowRoot.querySelector('.selection');
      controleZoneNotificationLecteurEcran = thisComponent.shadowRoot.getElementById(idControleZoneNotificationLecteurEcran);
      controleRecherche = thisComponent.shadowRoot.getElementById(idControleRecherche);
      controleConteneurResultats = thisComponent.shadowRoot.querySelector('.resultats');
      ajusterControleSelectOriginal();

      if (!controleSelect) {
        return;
      }

      ajusterControleLabelOriginal();
      initialiserOptionsSuggestionsEtRecherche();
      definirAttributsInitiauxControles();
      observerChildListSelectOriginal();
      observerAttributsSelectOriginal();
      observerAttributsLabelOrignal();
      Utils.reafficherApresChargement(thisComponent);
    });

    function initialiserOptionsSuggestionsEtRecherche() {
      options = obtenirOptions(); //Settimeout important afin de s'assurer que le paint et autres traitements sont complétés (ex. avec VueFormulate)

      setTimeout(function () {
        definirOptionsSelectionnees();
        definirSuggestions();
      });

      if (recherchable === 'true') {
        miniSearch = new MiniSearch(optionsMiniSearch);
        miniSearch.addAll(options);
      }
    }
    /**
    * Obtient le terme à indexer (normalisé et tout).
    * @param terme
    */


    function indexerTerme(terme) {
      if (terme.length <= 1 || optionsMiniSearch.stopWords.has(terme)) {
        return null;
      }

      return Utils.normaliserChaineCaracteres(terme);
    }

    function definirAriaDescriptionRecherche(initial) {
      var ariaDescription = null;

      if (initial || !afficherOptions) {
        ariaDescription = multiple ? "".concat(texteCommunAriaDescriptionRecherche).concat(texteAccesSelectionAriaDescriptionRecherche, ".") : "".concat(texteCommunAriaDescriptionRecherche, ".");
      }

      $$invalidate(7, ariaDescriptionRecherche = ariaDescription);
    }

    function definirAttributsInitiauxControles() {
      //Settimeout important afin de s'assurer que le paint et autres traitements sont complétés (ex. avec VueFormulate)
      setTimeout(function () {
        majAttributControle(controleConteneur, 'aria-invalid', controleSelect.getAttribute('aria-invalid'));
        majAttributControle(controleConteneur, 'aria-required', controleSelect.getAttribute('aria-required'));
        definirAriaLabelConteneur();
        definirAriaDescriptionConteneur();
        definirAriaDescriptionRecherche();
      });
    }

    function definirAriaLabelConteneur() {
      //1 - aria-label sur le select
      if (controleSelect && controleSelect.getAttribute('aria-label')) {
        $$invalidate(5, ariaLabel = controleSelect.getAttribute('aria-label'));
        return;
      } //2 - aria-label sur le label


      if (controleLabel && controleLabel.getAttribute('aria-label')) {
        $$invalidate(5, ariaLabel = controleLabel.getAttribute('aria-label'));
        return;
      } //3 - aria-labelledby sur le select


      var ariaLabelledBySelect = obtenirTexteSelonAttributAria(controleSelect, 'aria-labelledby');

      if (ariaLabelledBySelect) {
        $$invalidate(5, ariaLabel = ariaLabelledBySelect);
        return;
      } //4 - contenu textuel du label


      if (controleLabel) {
        $$invalidate(5, ariaLabel = obtenirTexteLecteurEcranControle(controleLabel));
      }

      return null;
    }

    function definirAriaDescriptionConteneur() {
      var description = obtenirTexteSelonAttributAria(controleSelect, 'aria-describedby');
      description = description ? description + '. ' : '';
      var prefixe = multiple ? srPrefixeDescriptionValeursSelectionnees : srPrefixeDescriptionValeurSelectionnee;

      if (optionsSelectionnees.length) {
        var texteNbOptions = multiple ? " (".concat(optionsSelectionnees.length, ")") : '';
        description += "".concat(prefixe).concat(texteNbOptions, " : ").concat(obtenirTexteOptionsSelectionnees());
      } else {
        description += "".concat(placeholder, ".");
      }

      $$invalidate(6, ariaDescriptionConteneur = description.replace("..", "."));
    }

    function obtenirTexteOptionsSelectionnees() {
      var texte = "";
      optionsSelectionnees.forEach(function (option, i) {
        texte += option.texte + (i === optionsSelectionnees.length - 1 ? '' : ', ');
      });
      return texte;
    }

    function observerAttributsSelectOriginal() {
      var observer = new MutationObserver(function (mutations) {
        mutations.forEach(function (mutation) {
          var nomAttribut = mutation.attributeName;
          var nouvelleValeur = mutation.target.getAttribute(nomAttribut);
          var nomAttributMaj = nomAttribut === 'aria-describedby' ? 'aria-description' : nomAttribut;

          if (nomAttribut === 'aria-describedby') {
            definirAriaDescriptionConteneur();
          } else {
            majAttributControle(controleConteneur, nomAttributMaj, nouvelleValeur);
          }
        });
      });
      observer.observe(controleSelect, {
        attributeFilter: ['aria-describedby', 'aria-required', 'aria-invalid', 'aria-label']
      });
    }

    function observerChildListSelectOriginal() {
      var observer = new MutationObserver(function (mutations) {
        initialiserOptionsSuggestionsEtRecherche();
      });
      observer.observe(controleSelect, {
        subtree: true,
        childList: true
      });
    }

    function observerAttributsLabelOrignal() {
      if (!controleLabel) {
        return;
      }

      var observerCharacterData = new MutationObserver(function (mutations) {
        mutations.forEach(function (mutation) {
          definirAriaLabelConteneur();
        });
      });
      var observerAriaLabel = new MutationObserver(function (mutations) {
        mutations.forEach(function (mutation) {
          definirAriaLabelConteneur();
        });
      });
      observerAriaLabel.observe(controleLabel, {
        attributeFilter: ['aria-label']
      });
      observerCharacterData.observe(controleLabel, {
        subtree: true,
        childList: true,
        characterData: true
      });
    }

    function obtenirOptions() {
      var options = [];

      for (var i = 0; i < controleSelect.options.length; i++) {
        var option = controleSelect.options[i];
        var texte = option.label || option.value;

        if (option.value) {
          var opt = {
            id: Utils.genererId(),
            texte: texte,
            valeur: option.value,
            motsCles: option.getAttribute('mots-cles'),
            indexe: i,
            selected: option.selected,
            disabled: option.disabled,
            hidden: option.hidden
          };
          options.push(opt);
        }
      }

      return options;
    }

    function retirerOptionPlaceholderControleSelectOriginal() {
      //Pour le moment on ne retire que la 1ere option d'un select multiple si elle est vide, hidden et disabled... Dans ce cas il s'agit d'un placeholder, mais ça ne sert à rien pour un select multiple.
      if (controleSelect.options.length) {
        var option = controleSelect.options[0];

        if (!option.value && option.getAttribute('hidden') !== null && option.getAttribute('disabled') !== null) {
          controleSelect.options[0] = null;
        }
      }
    }

    function definirSuggestions(doitNotifierLecteurEcran) {
      var nouvellesSuggestions = [];
      var resultatRecherche = [];

      var optionsRecherche = _objectSpread(_objectSpread({}, optionsMiniSearch), {
        fuzzy: function fuzzy(term) {
          return term.length > 3 ? optionsMiniSearch.fuzzy : null;
        }
      });

      var texteRechercheSansEspace = texteRecherche.trim();

      if (texteRechercheSansEspace !== "" && texteRechercheSansEspace.length >= nbCaracteresMinimalRecherche) {
        resultatRecherche = miniSearch.search(texteRechercheSansEspace, optionsRecherche).map(function (item) {
          return options.find(function (option) {
            return item.indexe === option.indexe;
          });
        });
      } else {
        resultatRecherche = options;
      }

      var _loop = function _loop(i) {
        var suggestion = resultatRecherche[i];
        suggestion.selected = optionsSelectionnees.findIndex(function (option) {
          return suggestion.indexe === option.indexe;
        }) >= 0;
        nouvellesSuggestions.push(suggestion);
      };

      for (var i = 0; i < resultatRecherche.length; i++) {
        _loop(i);
      }

      if (doitNotifierLecteurEcran) {
        if (nouvellesSuggestions.length === 0) {
          notifierLecteurEcran(srAucunResultat);
        } else {
          notifierLecteurEcran(srResultatsTrouves.replace("{x}", nouvellesSuggestions.length));
          $$invalidate(4, indexeFocusSuggestion = null);
        }
      }

      $$invalidate(9, suggestions = nouvellesSuggestions); //Vérifier si scrollbar visible ou non (servira a ajouter une marge de droite afin que la scrollbar ne soit pas collée sur la bordure du contrôle)

      definirPresenceScrollbarResultats();
    }

    var definirSuggestionsDebounced = Utils.debounce(function () {
      return definirSuggestions(true);
    });

    function definirPresenceScrollbarResultats() {
      setTimeout(function () {
        $$invalidate(12, estScrollbarSuggestionsVisible = controleConteneurResultats.scrollHeight > controleConteneurResultats.clientHeight);
      });
    }

    function ajusterControleSelectOriginal() {
      controleSelect = thisComponent.querySelector("select");

      if (!controleSelect) {
        return;
      }

      if (controleSelect.getAttribute('multiple') !== null) {
        $$invalidate(13, multiple = true);
      }

      ajouterPlaceholderSelectOriginal(); //Si le select original reçoit le focus, on le redonne tout de suite à notre composant

      controleSelect.addEventListener('focus', function (e) {
        e.preventDefault();
        e.stopPropagation();
        controleConteneur.focus();
      });
      controleSelect.classList.add('utd-sr-only');
      controleSelect.setAttribute("tabindex", "-1");
      controleSelect.setAttribute("aria-hidden", "true");

      if (multiple) {
        controleSelect.setAttribute("multiple", "");
        retirerOptionPlaceholderControleSelectOriginal();
      }
    }

    function ajouterPlaceholderSelectOriginal() {
      if (controleSelect.options[0].value !== '') {
        var optionPlaceholder = new Option(placeholder, '');
        optionPlaceholder.disabled = true;
        optionPlaceholder.hidden = true;
        optionPlaceholder.selected = true;
        controleSelect.options.add(optionPlaceholder, 0);
      }
    }

    function ajusterControleLabelOriginal() {
      controleLabel = thisComponent.querySelector("label");

      if (!controleLabel) {
        controleLabel = thisComponent.getRootNode().querySelector("label[for=\"".concat(controleSelect.id, "\"]"));
      }

      if (!controleLabel) {
        controleLabel = thisComponent.parentElement.querySelector('label');
      } //On annule le comportement par défaut du click afin d'éviter qu'il donne le focus au contrôle select original qui est hors écran. Cela faisait afficher le contrôle natif en mobile une fraction de seconde avant que le focus retourne sur notre conteneur.


      if (controleLabel) {
        controleLabel.addEventListener('click', function (e) {
          e.preventDefault();
          e.stopPropagation();
          controleConteneur.focus();
        });
      }
    }

    function selectionnerOption(indexeSuggestion) {
      var doitNotifierLecteurEcran = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (indexeSuggestion !== null) {
        var indexeSelectionPrecedente = controleSelect.selectedIndex;
        var indexeOption = suggestions[indexeSuggestion].indexe;
        majValeurListeOriginale(indexeOption);
        definirOptionsSelectionnees();

        if (!multiple) {
          if (indexeSelectionPrecedente >= 0) {
            var indexePrecedent = suggestions.findIndex(function (element) {
              return element.indexe === indexeSelectionPrecedente;
            });

            if (indexePrecedent >= 0) {
              $$invalidate(9, suggestions[indexePrecedent].selected = false, suggestions);
            }
          }

          $$invalidate(9, suggestions[indexeSuggestion].selected = true, suggestions);

          if (doitNotifierLecteurEcran) {
            notifierLecteurEcran(suggestions[indexeSuggestion].texte);
          }
        } else {
          $$invalidate(9, suggestions[indexeSuggestion].selected = optionsSelectionnees.findIndex(function (element) {
            return element.indexe === indexeOption;
          }) >= 0, suggestions);
        }

        if (!multiple) {
          definirAfficherOptions(false);
          controleConteneur.focus();
        } else {
          $$invalidate(4, indexeFocusSuggestion = indexeSuggestion);
        }
      }
    }

    function deselectionnerOptionViaEtiquette(e) {
      e.preventDefault();
      e.stopPropagation();
      var indexeOption = e.currentTarget.getAttribute('indexeOption');

      if (indexeOption !== null) {
        estDeselectionEnCours = true;
        setTimeout(function () {
          estDeselectionEnCours = false;
        });
        indexeOption = parseInt(indexeOption); //TODO la détection clavier ne fonctionne pas (e.detail ne semble pas toujours fonctionner c'est bizarre)... ce n'est pas si grave... pe avec un span role="button" et 2 events? click pour souris et enter/spacebar pour keydown?
        //On donne le focus à la prochaine étiquette (ou la précédente si aucune prochaine) suite à la suppression.

        var prochaineEtiquette;
        prochaineEtiquette = e.currentTarget.parentNode.nextSibling;

        if (!prochaineEtiquette) {
          prochaineEtiquette = e.currentTarget.parentNode.previousSibling;
        }

        var indexeOptionProchaineEtiquette;

        if (prochaineEtiquette) {
          indexeOptionProchaineEtiquette = prochaineEtiquette.querySelector('button').getAttribute('indexeOption');
        }

        majValeurListeOriginale(indexeOption);

        if (indexeOptionProchaineEtiquette >= 0) {
          notifierLecteurEcran(texteNotificationEtiquetteSupprimee); //Ici on utilise les setTimeout pour la lecture au lecteur écran. Sans cela la lecture n'est pas faite au lecteur écran car pour lui il demeure sur la meme node (c'est effectivement la même occurance dans la liste). On masque l'élément avant son retrait des éléments sélectionnés afin que la lecture du changement d'étiquette se fasse bien au lecteur écran.

          e.currentTarget.parentNode.classList.add('utd-d-none');
          majOptionsSelectionees(indexeOption);
          definirAriaDescriptionConteneur();
          setTimeout(function () {
            controleSelection.querySelector("[indexeOption=\"".concat(indexeOptionProchaineEtiquette, "\"]")).parentNode.classList.remove('utd-d-none');
          });
          setTimeout(function () {
            var controle = controleSelection.querySelector("[indexeOption=\"".concat(indexeOptionProchaineEtiquette, "\"]"));

            if (controle) {
              controle.focus();
            }
          }, 250);
        } else {
          majOptionsSelectionees(indexeOption);
          definirAriaDescriptionConteneur();
          notifierLecteurEcran(texteNotificationEtiquetteSupprimee);

          if (recherchable === 'true') {
            controleRecherche.focus();
          } else {
            controleConteneur.focus();
          }
        } //Désélectionner l'élément dans la liste des suggestions


        var indexeSuggestion = suggestions.findIndex(function (element) {
          return element.indexe === indexeOption;
        });

        if (indexeSuggestion >= 0) {
          $$invalidate(9, suggestions[indexeSuggestion].selected = false, suggestions);
        }
      }
    }

    function notifierLecteurEcran(texte) {
      $$invalidate(11, texteNotificationLecteurEcran = texte); //On s'assure que le texte va être lu (car parfois c'est le même texte, s'il ne change pas, il n'est pas lu)

      setTimeout(function () {
        $$invalidate(11, texteNotificationLecteurEcran = "");
      }, 400);
    }

    function majValeurListeOriginale(indexe) {
      if (multiple) {
        controleSelect.options[indexe].selected = !controleSelect.options[indexe].selected;
      } else {
        controleSelect.selectedIndex = indexe;
      } //Important! Nécessaire afin que notamment VueFormulate (FRW) considère la nouvelle valeur saisie... Sinon c'est comme si rien n'avait été sélectionné.


      controleSelect.dispatchEvent(new Event('change'));
    }

    function majOptionsSelectionees(indexe) {
      var indexeSelection = optionsSelectionnees.findIndex(function (element) {
        return element.indexe === indexe;
      });

      if (indexeSelection >= 0) {
        optionsSelectionnees.splice(indexeSelection, 1);
        $$invalidate(10, optionsSelectionnees);
      }
    }

    function definirOptionsSelectionnees() {
      $$invalidate(10, optionsSelectionnees = []);

      var _loop2 = function _loop2(i) {
        var option = controleSelect.selectedOptions[i];

        if (option.value) {
          optionsSelectionnees.push(options.find(function (element) {
            return element.indexe === option.index;
          }));
        }
      };

      for (var i = 0; i < controleSelect.selectedOptions.length; i++) {
        _loop2(i);
      }
    }

    function onKeyDown(e) {
      switch (e.key) {
        case "Enter":
        case " ":
          //On conserve comportement natif si barre espace et contrôle courant est textbox de recherche
          if (e.key === " " && e.target == controleRecherche && indexeFocusSuggestion === null) {
            return;
          } //Si contrôle courant est une etiquette, on procède à la désélection


          if (e.target.classList.contains('etiquette')) {
            return;
          }

          e.preventDefault();

          if (indexeFocusSuggestion !== null) {
            selectionnerOption(indexeFocusSuggestion);
            definirAriaDescriptionConteneur();
          } else {
            definirAfficherOptions(!afficherOptions);

            if (suggestions.length && recherchable === 'false') {
              $$invalidate(4, indexeFocusSuggestion = 0);
            }
          }

          break;

        case "Tab":
          //Pour une liste déroulante multiple sans recherche avec des selections actives, on veut que le SHIFT + TAB donne le focus à la dernière étiquette et TAB passe au contrôle suivant.
          if (recherchable === 'false' && multiple && afficherOptions && e.target === controleConteneur && optionsSelectionnees.length > 0) {
            if (e.shiftKey) {
              e.preventDefault();
              e.stopPropagation();
              var etiquettes = controleSelection.querySelectorAll('.etiquette');

              if (etiquettes.length) {
                etiquettes[etiquettes.length - 1].focus();
              }
            } else {
              //Si tab seulement on ferme la liste (le focus ira au prochain contrôle)
              definirAfficherOptions(false);
            }
          }

          break;

        case "Escape":
          definirAfficherOptions(false);
          controleConteneur.focus();
          break;

        case "ArrowDown":
        case "ArrowRight":
          //On conserve comportement natif si flèche droite et contrôle courant est textbox de recherche
          if (e.key === 'ArrowRight' && e.target == controleRecherche) {
            return;
          }

          e.preventDefault(); //Si liste simple sans recherche, la flèche provoque un changement de l'option sélectionnée comme un select natif

          if (recherchable === 'false' && !multiple && !afficherOptions) {
            selectionnerOption(obtenirIndexeProchaineSuggestion(controleSelect.selectedIndex, 1), true);
            return;
          } //Affiche les options si ne sont pas visibles actuellement


          if (!afficherOptions) {
            definirAfficherOptions(true);

            if (suggestions.length && recherchable === 'false') {
              $$invalidate(4, indexeFocusSuggestion = 0);
            }
          } else if (suggestions.length) {
            if (indexeFocusSuggestion !== null) {
              modifierIndexeOptionCourante(1);
            } else {
              $$invalidate(4, indexeFocusSuggestion = indexeFocusSuggestion || 0);
            }
          }

          assurerOptionCouranteVisible();
          break;

        case "ArrowUp":
        case "ArrowLeft":
          //On conserve comportement natif si flèche gauche et contrôle courant est textbox de recherche
          if (e.key === 'ArrowLeft' && e.target == controleRecherche) {
            return;
          }

          e.preventDefault(); //Si liste simple sans recherche, la flèche provoque un changement de l'option sélectionnée comme un select natif

          if (recherchable === 'false' && !multiple && !afficherOptions) {
            selectionnerOption(obtenirIndexeProchaineSuggestion(controleSelect.selectedIndex, -1), true);
            return;
          }

          if (!afficherOptions) {
            definirAfficherOptions(true);

            if (suggestions.length && recherchable === 'false') {
              $$invalidate(4, indexeFocusSuggestion = suggestions.length - 1);
            }
          } else if (suggestions.length) {
            if (indexeFocusSuggestion !== null) {
              modifierIndexeOptionCourante(-1);
            } else {
              $$invalidate(4, indexeFocusSuggestion = indexeFocusSuggestion || suggestions.length - 1);
            }
          }

          assurerOptionCouranteVisible();
          break;

        case "Home":
        case "PageUp":
          //On conserve comportement natif si End et contrôle courant est textbox de recherche
          if (e.target == controleRecherche) {
            return;
          }

          e.preventDefault(); //Si liste simple sans recherche, la flèche provoque un changement de l'option sélectionnée comme un select natif

          if (recherchable === 'false' && !multiple && !afficherOptions) {
            if (e.key === "PageUp") {
              var step = Math.floor((suggestions.length - 1) / 4);
              step = step > 8 ? 8 : step;
              var indexe = controleSelect.selectedIndex - step < 0 ? 0 : controleSelect.selectedIndex - step;
              selectionnerOption(indexe, true);
            } else {
              selectionnerOption(0, true);
            }

            return;
          }

          if (!afficherOptions) {
            definirAfficherOptions(true);

            if (suggestions.length && recherchable === 'false') {
              $$invalidate(4, indexeFocusSuggestion = 0);
            }
          } else if (suggestions.length) {
            $$invalidate(4, indexeFocusSuggestion = 0);
          }

          assurerOptionCouranteVisible();
          break;

        case "End":
        case "PageDown":
          //On conserve comportement natif si End et contrôle courant est textbox de recherche
          if (e.target == controleRecherche) {
            return;
          }

          e.preventDefault(); //Si liste simple sans recherche, la flèche provoque un changement de l'option sélectionnée comme un select natif

          if (recherchable === 'false' && !multiple && !afficherOptions) {
            if (e.key === "PageDown") {
              var _step = Math.floor((suggestions.length - 1) / 4);

              _step = _step > 8 ? 8 : _step;

              var _indexe = controleSelect.selectedIndex + _step > suggestions.length - 1 ? suggestions.length - 1 : controleSelect.selectedIndex + _step;

              selectionnerOption(_indexe, true);
            } else {
              selectionnerOption(suggestions.length - 1, true);
            }

            return;
          }

          if (!afficherOptions) {
            definirAfficherOptions(true);

            if (suggestions.length && recherchable === 'false') {
              $$invalidate(4, indexeFocusSuggestion = suggestions.length - 1);
            }
          } else if (suggestions.length) {
            $$invalidate(4, indexeFocusSuggestion = suggestions.length - 1);
          }

          assurerOptionCouranteVisible();
          break;
      }
    }

    function obtenirIndexeProchaineSuggestion(indexeCourantControleSelect, step) {
      var indexeTrouve = false;
      var indexeCourantSuggestion = suggestions.findIndex(function (s) {
        return s.indexe === indexeCourantControleSelect;
      }); //Si suggestion associée à indexe courant du select (ex. le placeholder index 0 hidden disabled qui n'est pas intégré dans nos suggestions) on retourne 0 (1ere suggestion)

      if (indexeCourantSuggestion < 0) {
        return 0;
      }

      var prochainIndexe = indexeCourantSuggestion + step;

      while (!indexeTrouve) {
        if (step > 0 && prochainIndexe > suggestions.length - 1 || step < 0 && prochainIndexe < 0) {
          return indexeCourantSuggestion;
        } else {
          var prochaineSuggestion = suggestions[prochainIndexe];

          if (!prochaineSuggestion.disabled && !prochaineSuggestion.hidden) {
            return prochainIndexe;
          }
        }

        prochainIndexe = prochainIndexe + step;
      }
    }

    function clickSelection(e) {
      definirAfficherOptions(!afficherOptions);

      if (recherchable === 'true' && afficherOptions) {
        controleRecherche.parentElement.classList.remove('utd-d-none');
        controleRecherche.focus();
      } else {
        controleConteneur.focus();
      }
    }

    function majActiveDescendant() {
      if (indexeFocusSuggestion !== null) {
        $$invalidate(8, idActiveDescendant = suggestions[indexeFocusSuggestion].id);
      } else {
        $$invalidate(8, idActiveDescendant = null);
      }
    }

    function definirAfficherOptions(doitAfficherOptions) {
      if (doitAfficherOptions) {
        console.log(controleConteneur.offsetHeight);
        controleEspaceur.style.height = controleConteneur.offsetHeight + "px";
        $$invalidate(3, afficherOptions = true);
      } else {
        $$invalidate(3, afficherOptions = false);
      }
    }

    function toggleAfficherOptions() {
      if (!mounted) {
        return;
      }

      if (afficherOptions) {
        if (recherchable === 'true') {
          controleRecherche.value = '';
          texteRecherche = '';
          definirSuggestions();
          setTimeout(function () {
            controleRecherche.focus();
          }); //Ici on attend volontairement avant de modifier le aria-description du champ recherche. Si on modifie immédiatement le lecteur écran considère la nouvelle valeur. Dans le cas présent, on veut que le aria-description disparaisse après l'affichage de la recherche. 

          setTimeout(function () {
            definirAriaDescriptionRecherche();
          }, 200);
        } else {
          controleConteneur.focus();
        }

        assurerControleVisible();
        definirPresenceScrollbarResultats();
      } else {
        definirAriaDescriptionRecherche();
        $$invalidate(4, indexeFocusSuggestion = null);
      }
    }

    function modifierIndexeOptionCourante(step) {
      if (!step) {
        $$invalidate(4, indexeFocusSuggestion = null);
        return;
      }

      var prochainIndexe = indexeFocusSuggestion + step;
      var indexeDerniereOption = suggestions.length - 1;

      if (prochainIndexe > indexeDerniereOption) {
        $$invalidate(4, indexeFocusSuggestion = 0);
      } else if (prochainIndexe < 0) {
        $$invalidate(4, indexeFocusSuggestion = indexeDerniereOption);
      } else {
        $$invalidate(4, indexeFocusSuggestion = prochainIndexe);
      }
    }

    function traiterSaisieRecherche() {
      // Empêche le traitement si simplement un focus ou un blur (l'événement input est lancé sur focus et blur)
      if (texteRecherche === controleRecherche.value) {
        return;
      }

      texteRecherche = controleRecherche.value;
      definirSuggestionsDebounced();
    }

    function blurConteneur(e) {
      if (!estFocusInterieurComposant(e)) {
        definirAfficherOptions(false);
        controleSelect.dispatchEvent(new Event('blur'));
        definirAriaDescriptionConteneur();
      }
    }

    function blurRecherche(e) {
      if (!estFocusInterieurComposant(e)) {
        definirAfficherOptions(false);
        controleSelect.dispatchEvent(new Event('blur'));
      } else {
        $$invalidate(4, indexeFocusSuggestion = null);
      }
    }

    function blurOptionSelectionnee(e) {
      if (estDeselectionEnCours) {
        estDeselectionEnCours = false;
        return;
      }

      if (!estFocusInterieurComposant(e)) {
        definirAfficherOptions(false);
      }
    }

    function estFocusInterieurComposant(e) {
      return composant !== e.relatedTarget && composant.contains(e.relatedTarget);
    }

    function clickOption(e) {
      e.stopPropagation();
      var indexeSuggestion = e.currentTarget.getAttribute('indexeSuggestion');

      if (indexeSuggestion) {
        selectionnerOption(parseInt(indexeSuggestion));
        definirAriaDescriptionConteneur();
      }
    }

    function assurerOptionCouranteVisible() {
      //SetTimeout nécessaire afin que le paint de la page soit fait et qu'on puisse travailler avec l'option qui vient de recevoir le focus.
      setTimeout(function () {
        var option = thisComponent.shadowRoot.querySelector('.suggestions .focus');

        if (!option) {
          return;
        }

        var hauteurConteneur = controleConteneurResultats.getBoundingClientRect().height;
        var hauteurOption = option.getBoundingClientRect().height;
        var offsetConteneur = controleConteneurResultats.scrollTop + hauteurConteneur; //Si nous sommes sur la 1ere ou la dernière suggestion on gère manuellement le scroll

        if (indexeFocusSuggestion === 0) {
          controleConteneurResultats.scroll({
            top: 0
          });
          return;
        } else if (indexeFocusSuggestion === suggestions.length - 1) {
          controleConteneurResultats.scroll({
            top: option.offsetTop
          });
          return;
        }

        if (option.offsetTop + hauteurOption > offsetConteneur) {
          if (option.offsetTop + hauteurOption > offsetConteneur + hauteurOption) {
            //Ici on traite le cas ou le user aurait modifié la position du scroll (ex. avec la souris), dans ce cas on remet l'option courant en au de liste
            controleConteneurResultats.scroll({
              top: option.offsetTop
            });
          } else {
            controleConteneurResultats.scroll({
              top: controleConteneurResultats.scrollTop + hauteurOption
            });
          }
        } else if (option.offsetTop < offsetConteneur - hauteurConteneur) {
          if (option.offsetTop < offsetConteneur - hauteurOption) {
            //Ici on traite le cas ou le user aurait modifié la position du scroll (ex. avec la souris), dans ce cas on remet l'option courant en au de liste
            controleConteneurResultats.scroll({
              top: option.offsetTop
            });
          } else {
            controleConteneurResultats.scroll({
              top: controleConteneurResultats.scrollTop - hauteurOption
            });
          }
        }
      });
    }
    /**
    * On s'assure que notre contrôle est visible en entier ou du moins au maximum de la hauteur disponible.
    */


    function assurerControleVisible() {
      //SetTimeout nécessaire afin que le paint de la page soit fait 
      setTimeout(function () {
        var rectConteneur = controleConteneur.getBoundingClientRect();
        var rectLabel = controleLabel.getBoundingClientRect();
        var hauteurFenetre = window.innerHeight;
        var hauteurConteneur = rectConteneur.height;
        var topLabel = rectLabel.top;
        var topConteneur = rectConteneur.top;
        var offsetTopLabel = html.scrollTop + topLabel;
        var hauteurLabel = topConteneur - topLabel;
        var hauteurControle = hauteurLabel + hauteurConteneur;
        var posYBasFenetre = html.scrollTop + hauteurFenetre;
        var posYBasControle = offsetTopLabel + hauteurControle;

        if (hauteurControle > hauteurFenetre) {
          //La hauteur de notre contrôle est supérieure à la hauteur du viewport, on scroll afin que le label soit au haut de l'écran.
          window.scroll({
            top: html.scrollTop + rectLabel.top
          });
        } else if (posYBasControle > posYBasFenetre) {
          //Notre contrôle n'est pas entièrement visible, on scroll juste ce qu'il faut pour que le bas de notre contrôle soit visible
          var hauteurPortionMasquee = posYBasControle - posYBasFenetre;
          window.scroll({
            top: html.scrollTop + hauteurPortionMasquee
          });
        }
      });
    }

    var writable_props = ['recherchable', 'rechercheFloue', 'precisionRecherche', 'largeur', 'placeholder'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn("<utd-liste-deroulante> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('recherchable' in $$props) $$invalidate(0, recherchable = $$props.recherchable);
      if ('rechercheFloue' in $$props) $$invalidate(31, rechercheFloue = $$props.rechercheFloue);
      if ('precisionRecherche' in $$props) $$invalidate(32, precisionRecherche = $$props.precisionRecherche);
      if ('largeur' in $$props) $$invalidate(1, largeur = $$props.largeur);
      if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
    };

    $$self.$capture_state = function () {
      return {
        onMount: onMount,
        Utils: Utils,
        get_current_component: get_current_component,
        MiniSearch: MiniSearch,
        languePage: languePage,
        recherchable: recherchable,
        rechercheFloue: rechercheFloue,
        precisionRecherche: precisionRecherche,
        largeur: largeur,
        placeholder: placeholder,
        thisComponent: thisComponent,
        idControleRecherche: idControleRecherche,
        idControleResultats: idControleResultats,
        idControleZoneNotificationLecteurEcran: idControleZoneNotificationLecteurEcran,
        titleEtiquette: titleEtiquette,
        descriptionEtiquette: descriptionEtiquette,
        texteNotificationEtiquetteSupprimee: texteNotificationEtiquetteSupprimee,
        srPrefixeDescriptionValeurSelectionnee: srPrefixeDescriptionValeurSelectionnee,
        srPrefixeDescriptionValeursSelectionnees: srPrefixeDescriptionValeursSelectionnees,
        labelListeValeursSelectionnees: labelListeValeursSelectionnees,
        srResultatsTrouves: srResultatsTrouves,
        texteAucunResultat: texteAucunResultat,
        srAucunResultat: srAucunResultat,
        textePlaceholderRecherche: textePlaceholderRecherche,
        texteCommunAriaDescriptionRecherche: texteCommunAriaDescriptionRecherche,
        texteAccesSelectionAriaDescriptionRecherche: texteAccesSelectionAriaDescriptionRecherche,
        srLibelleListeValeursPossibles: srLibelleListeValeursPossibles,
        nbCaracteresMinimalRecherche: nbCaracteresMinimalRecherche,
        mounted: mounted,
        html: html,
        composant: composant,
        controleConteneur: controleConteneur,
        controleSelection: controleSelection,
        controleLabel: controleLabel,
        ariaLabel: ariaLabel,
        ariaDescriptionConteneur: ariaDescriptionConteneur,
        ariaDescriptionRecherche: ariaDescriptionRecherche,
        controleRecherche: controleRecherche,
        controleSelect: controleSelect,
        controleEspaceur: controleEspaceur,
        controleZoneNotificationLecteurEcran: controleZoneNotificationLecteurEcran,
        controleConteneurResultats: controleConteneurResultats,
        afficherOptions: afficherOptions,
        indexeFocusSuggestion: indexeFocusSuggestion,
        idActiveDescendant: idActiveDescendant,
        options: options,
        suggestions: suggestions,
        optionsSelectionnees: optionsSelectionnees,
        texteRecherche: texteRecherche,
        texteNotificationLecteurEcran: texteNotificationLecteurEcran,
        estDeselectionEnCours: estDeselectionEnCours,
        miniSearch: miniSearch,
        optionsMiniSearch: optionsMiniSearch,
        estScrollbarSuggestionsVisible: estScrollbarSuggestionsVisible,
        multiple: multiple,
        initialiserOptionsSuggestionsEtRecherche: initialiserOptionsSuggestionsEtRecherche,
        indexerTerme: indexerTerme,
        definirAriaDescriptionRecherche: definirAriaDescriptionRecherche,
        definirAttributsInitiauxControles: definirAttributsInitiauxControles,
        definirAriaLabelConteneur: definirAriaLabelConteneur,
        definirAriaDescriptionConteneur: definirAriaDescriptionConteneur,
        obtenirTexteOptionsSelectionnees: obtenirTexteOptionsSelectionnees,
        observerAttributsSelectOriginal: observerAttributsSelectOriginal,
        observerChildListSelectOriginal: observerChildListSelectOriginal,
        observerAttributsLabelOrignal: observerAttributsLabelOrignal,
        obtenirTexteLecteurEcranControle: obtenirTexteLecteurEcranControle,
        obtenirTexteSelonAttributAria: obtenirTexteSelonAttributAria,
        majAttributControle: majAttributControle,
        obtenirOptions: obtenirOptions,
        retirerOptionPlaceholderControleSelectOriginal: retirerOptionPlaceholderControleSelectOriginal,
        definirSuggestions: definirSuggestions,
        definirSuggestionsDebounced: definirSuggestionsDebounced,
        definirPresenceScrollbarResultats: definirPresenceScrollbarResultats,
        ajusterControleSelectOriginal: ajusterControleSelectOriginal,
        ajouterPlaceholderSelectOriginal: ajouterPlaceholderSelectOriginal,
        ajusterControleLabelOriginal: ajusterControleLabelOriginal,
        selectionnerOption: selectionnerOption,
        deselectionnerOptionViaEtiquette: deselectionnerOptionViaEtiquette,
        notifierLecteurEcran: notifierLecteurEcran,
        majValeurListeOriginale: majValeurListeOriginale,
        majOptionsSelectionees: majOptionsSelectionees,
        definirOptionsSelectionnees: definirOptionsSelectionnees,
        onKeyDown: onKeyDown,
        obtenirIndexeProchaineSuggestion: obtenirIndexeProchaineSuggestion,
        clickSelection: clickSelection,
        selectionMouseDown: selectionMouseDown,
        majActiveDescendant: majActiveDescendant,
        definirAfficherOptions: definirAfficherOptions,
        toggleAfficherOptions: toggleAfficherOptions,
        modifierIndexeOptionCourante: modifierIndexeOptionCourante,
        traiterSaisieRecherche: traiterSaisieRecherche,
        blurConteneur: blurConteneur,
        blurRecherche: blurRecherche,
        blurOptionSelectionnee: blurOptionSelectionnee,
        estFocusInterieurComposant: estFocusInterieurComposant,
        resultatsMouseDown: resultatsMouseDown,
        clickOption: clickOption,
        assurerOptionCouranteVisible: assurerOptionCouranteVisible,
        assurerControleVisible: assurerControleVisible
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('recherchable' in $$props) $$invalidate(0, recherchable = $$props.recherchable);
      if ('rechercheFloue' in $$props) $$invalidate(31, rechercheFloue = $$props.rechercheFloue);
      if ('precisionRecherche' in $$props) $$invalidate(32, precisionRecherche = $$props.precisionRecherche);
      if ('largeur' in $$props) $$invalidate(1, largeur = $$props.largeur);
      if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
      if ('mounted' in $$props) mounted = $$props.mounted;
      if ('html' in $$props) html = $$props.html;
      if ('composant' in $$props) composant = $$props.composant;
      if ('controleConteneur' in $$props) controleConteneur = $$props.controleConteneur;
      if ('controleSelection' in $$props) controleSelection = $$props.controleSelection;
      if ('controleLabel' in $$props) controleLabel = $$props.controleLabel;
      if ('ariaLabel' in $$props) $$invalidate(5, ariaLabel = $$props.ariaLabel);
      if ('ariaDescriptionConteneur' in $$props) $$invalidate(6, ariaDescriptionConteneur = $$props.ariaDescriptionConteneur);
      if ('ariaDescriptionRecherche' in $$props) $$invalidate(7, ariaDescriptionRecherche = $$props.ariaDescriptionRecherche);
      if ('controleRecherche' in $$props) controleRecherche = $$props.controleRecherche;
      if ('controleSelect' in $$props) controleSelect = $$props.controleSelect;
      if ('controleEspaceur' in $$props) controleEspaceur = $$props.controleEspaceur;
      if ('controleZoneNotificationLecteurEcran' in $$props) controleZoneNotificationLecteurEcran = $$props.controleZoneNotificationLecteurEcran;
      if ('controleConteneurResultats' in $$props) controleConteneurResultats = $$props.controleConteneurResultats;
      if ('afficherOptions' in $$props) $$invalidate(3, afficherOptions = $$props.afficherOptions);
      if ('indexeFocusSuggestion' in $$props) $$invalidate(4, indexeFocusSuggestion = $$props.indexeFocusSuggestion);
      if ('idActiveDescendant' in $$props) $$invalidate(8, idActiveDescendant = $$props.idActiveDescendant);
      if ('options' in $$props) options = $$props.options;
      if ('suggestions' in $$props) $$invalidate(9, suggestions = $$props.suggestions);
      if ('optionsSelectionnees' in $$props) $$invalidate(10, optionsSelectionnees = $$props.optionsSelectionnees);
      if ('texteRecherche' in $$props) texteRecherche = $$props.texteRecherche;
      if ('texteNotificationLecteurEcran' in $$props) $$invalidate(11, texteNotificationLecteurEcran = $$props.texteNotificationLecteurEcran);
      if ('estDeselectionEnCours' in $$props) estDeselectionEnCours = $$props.estDeselectionEnCours;
      if ('miniSearch' in $$props) miniSearch = $$props.miniSearch;
      if ('optionsMiniSearch' in $$props) optionsMiniSearch = $$props.optionsMiniSearch;
      if ('estScrollbarSuggestionsVisible' in $$props) $$invalidate(12, estScrollbarSuggestionsVisible = $$props.estScrollbarSuggestionsVisible);
      if ('multiple' in $$props) $$invalidate(13, multiple = $$props.multiple);
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    $$self.$$.update = function () {
      if ($$self.$$.dirty[0] &
      /*afficherOptions*/
      8) {
        // Watches
        toggleAfficherOptions();
      }

      if ($$self.$$.dirty[0] &
      /*indexeFocusSuggestion*/
      16) {
        majActiveDescendant();
      }
    };

    return [recherchable, largeur, placeholder, afficherOptions, indexeFocusSuggestion, ariaLabel, ariaDescriptionConteneur, ariaDescriptionRecherche, idActiveDescendant, suggestions, optionsSelectionnees, texteNotificationLecteurEcran, estScrollbarSuggestionsVisible, multiple, idControleRecherche, idControleResultats, idControleZoneNotificationLecteurEcran, titleEtiquette, descriptionEtiquette, labelListeValeursSelectionnees, texteAucunResultat, textePlaceholderRecherche, srLibelleListeValeursPossibles, deselectionnerOptionViaEtiquette, onKeyDown, clickSelection, traiterSaisieRecherche, blurConteneur, blurRecherche, blurOptionSelectionnee, clickOption, rechercheFloue, precisionRecherche];
  }

  var Listederoulante = /*#__PURE__*/function (_SvelteElement) {
    _inherits(Listederoulante, _SvelteElement);

    var _super = _createSuper$a(Listederoulante);

    function Listederoulante(options) {
      var _this;

      _classCallCheck(this, Listederoulante);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$a, create_fragment$a, safe_not_equal, {
        recherchable: 0,
        rechercheFloue: 31,
        precisionRecherche: 32,
        largeur: 1,
        placeholder: 2
      }, null, [-1, -1, -1, -1]);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(Listederoulante, [{
      key: "recherchable",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(recherchable) {
        this.$$set({
          recherchable: recherchable
        });
        flush();
      }
    }, {
      key: "rechercheFloue",
      get: function get() {
        return this.$$.ctx[31];
      },
      set: function set(rechercheFloue) {
        this.$$set({
          rechercheFloue: rechercheFloue
        });
        flush();
      }
    }, {
      key: "precisionRecherche",
      get: function get() {
        return this.$$.ctx[32];
      },
      set: function set(precisionRecherche) {
        this.$$set({
          precisionRecherche: precisionRecherche
        });
        flush();
      }
    }, {
      key: "largeur",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(largeur) {
        this.$$set({
          largeur: largeur
        });
        flush();
      }
    }, {
      key: "placeholder",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(placeholder) {
        this.$$set({
          placeholder: placeholder
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["recherchable", "rechercheFloue", "precisionRecherche", "largeur", "placeholder"];
      }
    }]);

    return Listederoulante;
  }(SvelteElement);

  customElements.define("utd-liste-deroulante", Listederoulante);

  function _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$9() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var console_1 = globals.console;
  var file$9 = "src\\components\\menuHorizontal.svelte";

  function create_fragment$9(ctx) {
    var h2;
    var t0;
    var t1;
    var nav;
    var a;
    var span0;
    var t2;
    var span1;
    var t4;
    var div;
    var slot;
    var t5;
    var link;
    var mounted;
    var dispose;
    var block = {
      c: function create() {
        h2 = element("h2");
        t0 = text(
        /*titre*/
        ctx[0]);
        t1 = space();
        nav = element("nav");
        a = element("a");
        span0 = element("span");
        t2 = space();
        span1 = element("span");
        span1.textContent = "".concat(
        /*srTexteSortirMenu*/
        ctx[4]);
        t4 = space();
        div = element("div");
        slot = element("slot");
        t5 = space();
        link = element("link");
        this.c = noop;
        attr_dev(h2, "id",
        /*idTitreMenu*/
        ctx[3]);
        attr_dev(h2, "class", "utd-sr-only");
        add_location(h2, file$9, 175, 0, 6022);
        attr_dev(span0, "aria-hidden", "true");
        attr_dev(span0, "class", "utd-icone-svg chevron-blanc");
        add_location(span0, file$9, 179, 4, 6307);
        attr_dev(span1, "class", "utd-sr-only");
        add_location(span1, file$9, 180, 4, 6375);
        attr_dev(a, "role", "button");
        attr_dev(a, "href", "#" +
        /*idMenu*/
        ctx[2]);
        attr_dev(a, "class", "toggle utd-d-none");
        attr_dev(a, "aria-controls",
        /*idMenu*/
        ctx[2]);
        add_location(a, file$9, 178, 2, 6175);
        add_location(slot, file$9, 186, 4, 6530);
        attr_dev(div, "id",
        /*idMenu*/
        ctx[2]);
        attr_dev(div, "role", "list");
        attr_dev(div, "class", "menu");
        toggle_class(div, "visible",
        /*afficher*/
        ctx[1]);
        add_location(div, file$9, 185, 2, 6457);
        attr_dev(nav, "class", "utd-menu-horizontal");
        attr_dev(nav, "aria-labelledby",
        /*idTitreMenu*/
        ctx[3]);
        toggle_class(nav, "visible",
        /*afficher*/
        ctx[1]);
        add_location(nav, file$9, 177, 0, 6081);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", Utils.cssFullPath);
        add_location(link, file$9, 189, 0, 6565);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, h2, anchor);
        append_dev(h2, t0);
        insert_dev(target, t1, anchor);
        insert_dev(target, nav, anchor);
        append_dev(nav, a);
        append_dev(a, span0);
        append_dev(a, t2);
        append_dev(a, span1);
        append_dev(nav, t4);
        append_dev(nav, div);
        append_dev(div, slot);
        insert_dev(target, t5, anchor);
        insert_dev(target, link, anchor);

        if (!mounted) {
          dispose = listen_dev(a, "click", prevent_default(
          /*toggleAfficher*/
          ctx[5]), false, true, false);
          mounted = true;
        }
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        if (dirty &
        /*titre*/
        1) set_data_dev(t0,
        /*titre*/
        ctx[0]);

        if (dirty &
        /*afficher*/
        2) {
          toggle_class(div, "visible",
          /*afficher*/
          ctx[1]);
        }

        if (dirty &
        /*afficher*/
        2) {
          toggle_class(nav, "visible",
          /*afficher*/
          ctx[1]);
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(h2);
        if (detaching) detach_dev(t1);
        if (detaching) detach_dev(nav);
        if (detaching) detach_dev(t5);
        if (detaching) detach_dev(link);
        mounted = false;
        dispose();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$9.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function ajouterElementsMenuAuMenuOriginal(elementMenuItem, parent) {
    Array.from(parent.children).forEach(function (child) {
      var elementMenu = {
        libelle: child.getAttribute('libelle'),
        href: child.getAttribute('href'),
        children: []
      };
      elementMenuItem.push(elementMenu); //

      if (child.childNodes.length) {
        ajouterElementsMenuAuMenuOriginal(elementMenu.children, child);
      }
    });
  }

  function instance$9($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-menu-horizontal', slots, []);
    var _$$props$titre = $$props.titre,
        titre = _$$props$titre === void 0 ? Utils.obtenirLanguePage() === 'en' ? 'Main navigation menu' : 'Menu principal de navigation' : _$$props$titre;
    var afficher = false;
    var idMenu = Utils.genererId();
    var idTitreMenu = Utils.genererId();
    var srTexteSortirMenu = Utils.obtenirLanguePage() === "en" ? "Press ESC key to exit menu." : "Appuyez sur la touche Échappe pour sortir du menu.";
    var thisComponent = get_current_component();
    var controleMenu;
    var controleMenuItemPlus;
    var largeurConteneur = 0;
    var largeurMenu = 0;
    var menuOriginal = [];
    var dernierIndexeVisible = 0;
    var estAjustementAffichageEnCours = true; // Références pour accessibilité
    // https://www.w3.org/WAI/ARIA/apg/patterns/disclosure/examples/disclosure-navigation/

    ajouterElementsMenuAuMenuOriginal(menuOriginal, thisComponent);
    onMount(function () {
      controleMenu = thisComponent.shadowRoot.getElementById(idMenu);
      ajusterAffichageControle();
      window.addEventListener("resize", ecranRedimensionneDebounced);
      window.addEventListener("resize", function () {
        thisComponent.classList.add('ajustement-en-cours');
      });
    });
    var ecranRedimensionneDebounced = Utils.debounce(function () {
      return ajusterAffichageControle();
    }, 100);

    function ajusterAffichageControle() {
      thisComponent.classList.add('ajustement-en-cours');
      console.log('ajusterAffichageControle');
      supprimerMenuPlus();
      afficherTousMenusNiveau1(); //TODO fermer tous les menus
      //TODO css du plus (hover, active, etc.)
      //TODO navigation au clavier comme w3c

      setTimeout(function () {
        if (contientMenusNonVisibles()) {
          ajouterMenuPlusTemporaire();
          setTimeout(function () {
            //On enlève 1, car notre menuPlus temporaire ne doit pas compter
            dernierIndexeVisible = obtenirDernierIndexeVisible() - 1;
            thisComponent.children[0].remove();
            masquerMenusExcedentaires(); //            console.log('dernier indexe visible -> ' + dernierIndexeVisible)          

            setTimeout(function () {
              thisComponent.classList.remove('ajustement-en-cours');
              Utils.reafficherApresChargement(thisComponent);
            }, 100);
          });
        } else {
          //        console.log('Le menu fit, rien à faire!')
          thisComponent.classList.remove('ajustement-en-cours');
          Utils.reafficherApresChargement(thisComponent);
        }
      }); //      console.log(menuOriginal)
    }

    function supprimerMenuPlus() {
      var menuPlus = thisComponent.querySelector('utd-menu-horizontal-item[est-menu-plus]');

      if (menuPlus) {
        menuPlus.remove();
      }
    }

    function afficherTousMenusNiveau1() {
      var menus = thisComponent.querySelectorAll('utd-menu-horizontal-item.utd-d-none');
      menus.forEach(function (menu) {
        menu.classList.remove('utd-d-none');
      });
    }

    function masquerMenusExcedentaires() {
      var menuPlus = document.createElement('utd-menu-horizontal-item');
      menuPlus.setAttribute('libelle', 'Plus');
      menuPlus.setAttribute('est-menu-plus', 'true');

      for (var i = dernierIndexeVisible + 1; i < thisComponent.children.length; i++) {
        var cln = thisComponent.children[i].cloneNode(true);
        menuPlus.appendChild(cln);
        thisComponent.children[i].classList.add('utd-d-none');
      }

      thisComponent.appendChild(menuPlus);
    }

    function toggleAfficher() {
      $$invalidate(1, afficher = !afficher);
    }

    function contientMenusNonVisibles() {
      largeurConteneur = thisComponent.getBoundingClientRect().right;
      largeurMenu = thisComponent.children[thisComponent.children.length - 1].getBoundingClientRect().right;
      return largeurMenu > largeurConteneur;
    }

    function obtenirDernierIndexeVisible() {
      var menuVisible = true;
      var i = 0;
      var indexeDernierElementVisible = 0;
      var menuPlus = thisComponent.children[thisComponent.children.length - 1];
      var largeurMenuPlus = menuPlus.getBoundingClientRect().right - menuPlus.getBoundingClientRect().left; //    console.log('Largeur menu plus -> ' + largeurMenuPlus)

      while (menuVisible && i <= thisComponent.children.length - 1) {
        var item = thisComponent.children[i];

        if (item.getBoundingClientRect().right + largeurMenuPlus <= largeurConteneur) {
          indexeDernierElementVisible = i;
          i++;
        } else {
          menuVisible = false;
        }
      }

      return indexeDernierElementVisible;
    }

    function ajouterMenuPlusTemporaire() {
      var menuPlusTemp = document.createElement('utd-menu-horizontal-item');
      menuPlusTemp.setAttribute('libelle', 'Plus');
      var elementTemp = document.createElement('utd-menu-horizontal-item');
      elementTemp.setAttribute('libelle', 'Temporaire');
      menuPlusTemp.appendChild(elementTemp);
      thisComponent.prepend(menuPlusTemp);
      controleMenuItemPlus = menuPlusTemp;
    }

    function ajouterMenuPlus() {
      var menuPlus = document.createElement('utd-menu-horizontal-item');
      menuPlus.setAttribute('libelle', 'Plus');
      thisComponent.childNodes.forEach(function (item) {
        var cln = item.cloneNode(true);
        menuPlus.appendChild(cln);
      });
      thisComponent.appendChild(menuPlus);
      controleMenuItemPlus = menuPlus;
    }

    var writable_props = ['titre'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn("<utd-menu-horizontal> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
    };

    $$self.$capture_state = function () {
      return {
        onMount: onMount,
        Utils: Utils,
        get_current_component: get_current_component,
        titre: titre,
        afficher: afficher,
        idMenu: idMenu,
        idTitreMenu: idTitreMenu,
        srTexteSortirMenu: srTexteSortirMenu,
        thisComponent: thisComponent,
        controleMenu: controleMenu,
        controleMenuItemPlus: controleMenuItemPlus,
        largeurConteneur: largeurConteneur,
        largeurMenu: largeurMenu,
        menuOriginal: menuOriginal,
        dernierIndexeVisible: dernierIndexeVisible,
        estAjustementAffichageEnCours: estAjustementAffichageEnCours,
        ecranRedimensionneDebounced: ecranRedimensionneDebounced,
        ajusterAffichageControle: ajusterAffichageControle,
        supprimerMenuPlus: supprimerMenuPlus,
        afficherTousMenusNiveau1: afficherTousMenusNiveau1,
        masquerMenusExcedentaires: masquerMenusExcedentaires,
        ajouterElementsMenuAuMenuOriginal: ajouterElementsMenuAuMenuOriginal,
        toggleAfficher: toggleAfficher,
        contientMenusNonVisibles: contientMenusNonVisibles,
        obtenirDernierIndexeVisible: obtenirDernierIndexeVisible,
        ajouterMenuPlusTemporaire: ajouterMenuPlusTemporaire,
        ajouterMenuPlus: ajouterMenuPlus
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
      if ('afficher' in $$props) $$invalidate(1, afficher = $$props.afficher);
      if ('controleMenu' in $$props) controleMenu = $$props.controleMenu;
      if ('controleMenuItemPlus' in $$props) controleMenuItemPlus = $$props.controleMenuItemPlus;
      if ('largeurConteneur' in $$props) largeurConteneur = $$props.largeurConteneur;
      if ('largeurMenu' in $$props) largeurMenu = $$props.largeurMenu;
      if ('menuOriginal' in $$props) menuOriginal = $$props.menuOriginal;
      if ('dernierIndexeVisible' in $$props) dernierIndexeVisible = $$props.dernierIndexeVisible;
      if ('estAjustementAffichageEnCours' in $$props) estAjustementAffichageEnCours = $$props.estAjustementAffichageEnCours;
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    return [titre, afficher, idMenu, idTitreMenu, srTexteSortirMenu, toggleAfficher];
  }

  var MenuHorizontal = /*#__PURE__*/function (_SvelteElement) {
    _inherits(MenuHorizontal, _SvelteElement);

    var _super = _createSuper$9(MenuHorizontal);

    function MenuHorizontal(options) {
      var _this;

      _classCallCheck(this, MenuHorizontal);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$9, create_fragment$9, safe_not_equal, {
        titre: 0
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(MenuHorizontal, [{
      key: "titre",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(titre) {
        this.$$set({
          titre: titre
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["titre"];
      }
    }]);

    return MenuHorizontal;
  }(SvelteElement);

  customElements.define("utd-menu-horizontal", MenuHorizontal);

  function _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$8() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$8 = "src\\components\\menuHorizontalItem.svelte"; // (223:2) {:else}

  function create_else_block$3(ctx) {
    var a;
    var span;
    var t;
    var a_aria_current_value;
    var mounted;
    var dispose;
    var block = {
      c: function create() {
        a = element("a");
        span = element("span");
        t = text(
        /*libelle*/
        ctx[2]);
        add_location(span, file$8, 224, 6, 6539);
        attr_dev(a, "href",
        /*href*/
        ctx[3]);
        attr_dev(a, "aria-current", a_aria_current_value =
        /*actif*/
        ctx[1] === 'true' ? 'page' : null);
        add_location(a, file$8, 223, 4, 6424);
      },
      m: function mount(target, anchor) {
        insert_dev(target, a, anchor);
        append_dev(a, span);
        append_dev(span, t);

        if (!mounted) {
          dispose = [listen_dev(a, "keydown",
          /*onKeyDown*/
          ctx[10], false, false, false), listen_dev(a, "blur",
          /*onBlur*/
          ctx[11], false, false, false)];
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*libelle*/
        4) set_data_dev(t,
        /*libelle*/
        ctx[2]);

        if (dirty &
        /*href*/
        8) {
          attr_dev(a, "href",
          /*href*/
          ctx[3]);
        }

        if (dirty &
        /*actif*/
        2 && a_aria_current_value !== (a_aria_current_value =
        /*actif*/
        ctx[1] === 'true' ? 'page' : null)) {
          attr_dev(a, "aria-current", a_aria_current_value);
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(a);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_else_block$3.name,
      type: "else",
      source: "(223:2) {:else}",
      ctx: ctx
    });
    return block;
  } // (213:2) {#if possedeEnfants}


  function create_if_block_1$4(ctx) {
    var a;
    var span0;
    var t0;
    var t1;
    var span1;
    var span1_class_value;
    var t2;
    var if_block_anchor;
    var current;
    var mounted;
    var dispose;
    var if_block =
    /*afficher*/
    ctx[0] === 'true' && create_if_block_2$3(ctx);
    var block = {
      c: function create() {
        a = element("a");
        span0 = element("span");
        t0 = text(
        /*libelle*/
        ctx[2]);
        t1 = space();
        span1 = element("span");
        t2 = space();
        if (if_block) if_block.c();
        if_block_anchor = empty();
        add_location(span0, file$8, 214, 6, 6066);
        attr_dev(span1, "aria-hidden", "true");
        attr_dev(span1, "class", span1_class_value = "utd-icone-svg " + (
        /*niveau*/
        ctx[7] === 1 ? 'chevron-blanc' : 'chevron-bleu-piv'));
        add_location(span1, file$8, 215, 6, 6096);
        attr_dev(a, "role", "button");
        attr_dev(a, "href",
        /*href*/
        ctx[3]);
        attr_dev(a, "aria-expanded",
        /*afficher*/
        ctx[0]);
        attr_dev(a, "aria-controls",
        /*idSousMenu*/
        ctx[8]);
        add_location(a, file$8, 213, 4, 5889);
      },
      m: function mount(target, anchor) {
        insert_dev(target, a, anchor);
        append_dev(a, span0);
        append_dev(span0, t0);
        append_dev(a, t1);
        append_dev(a, span1);
        insert_dev(target, t2, anchor);
        if (if_block) if_block.m(target, anchor);
        insert_dev(target, if_block_anchor, anchor);
        current = true;

        if (!mounted) {
          dispose = [listen_dev(a, "click", prevent_default(
          /*toggleAfficher*/
          ctx[9]), false, true, false), listen_dev(a, "keydown",
          /*onKeyDown*/
          ctx[10], false, false, false), listen_dev(a, "blur",
          /*onBlur*/
          ctx[11], false, false, false)];
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (!current || dirty &
        /*libelle*/
        4) set_data_dev(t0,
        /*libelle*/
        ctx[2]);

        if (!current || dirty &
        /*niveau*/
        128 && span1_class_value !== (span1_class_value = "utd-icone-svg " + (
        /*niveau*/
        ctx[7] === 1 ? 'chevron-blanc' : 'chevron-bleu-piv'))) {
          attr_dev(span1, "class", span1_class_value);
        }

        if (!current || dirty &
        /*href*/
        8) {
          attr_dev(a, "href",
          /*href*/
          ctx[3]);
        }

        if (!current || dirty &
        /*afficher*/
        1) {
          attr_dev(a, "aria-expanded",
          /*afficher*/
          ctx[0]);
        }

        if (
        /*afficher*/
        ctx[0] === 'true') {
          if (if_block) {
            if_block.p(ctx, dirty);

            if (dirty &
            /*afficher*/
            1) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block_2$3(ctx);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, function () {
            if_block = null;
          });
          check_outros();
        }
      },
      i: function intro(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(a);
        if (detaching) detach_dev(t2);
        if (if_block) if_block.d(detaching);
        if (detaching) detach_dev(if_block_anchor);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_1$4.name,
      type: "if",
      source: "(213:2) {#if possedeEnfants}",
      ctx: ctx
    });
    return block;
  } // (218:4) {#if afficher === 'true'}


  function create_if_block_2$3(ctx) {
    var div;
    var slot;
    var div_transition;
    var current;
    var block = {
      c: function create() {
        div = element("div");
        slot = element("slot");
        add_location(slot, file$8, 219, 8, 6369);
        attr_dev(div, "id",
        /*idSousMenu*/
        ctx[8]);
        attr_dev(div, "role", "list");
        attr_dev(div, "class", "sous-menu");
        add_location(div, file$8, 218, 6, 6247);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        append_dev(div, slot);
        current = true;
      },
      p: function update(new_ctx, dirty) {
        ctx = new_ctx;
      },
      i: function intro(local) {
        if (current) return;
        add_render_callback(function () {
          if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {
            duration:
            /*animer*/
            ctx[4] === 'true' ? 250 : 0
          }, true);
          div_transition.run(1);
        });
        current = true;
      },
      o: function outro(local) {
        if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {
          duration:
          /*animer*/
          ctx[4] === 'true' ? 250 : 0
        }, false);
        div_transition.run(0);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
        if (detaching && div_transition) div_transition.end();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_2$3.name,
      type: "if",
      source: "(218:4) {#if afficher === 'true'}",
      ctx: ctx
    });
    return block;
  } // (228:2) {#if niveau === 1}


  function create_if_block$7(ctx) {
    var span;
    var block = {
      c: function create() {
        span = element("span");
        attr_dev(span, "class", "bordure-bas");
        add_location(span, file$8, 228, 4, 6612);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(span);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block$7.name,
      type: "if",
      source: "(228:2) {#if niveau === 1}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment$8(ctx) {
    var div;
    var current_block_type_index;
    var if_block0;
    var t0;
    var div_class_value;
    var t1;
    var link;
    var current;
    var if_block_creators = [create_if_block_1$4, create_else_block$3];
    var if_blocks = [];

    function select_block_type(ctx, dirty) {
      if (
      /*possedeEnfants*/
      ctx[6]) return 0;
      return 1;
    }

    current_block_type_index = select_block_type(ctx);
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    var if_block1 =
    /*niveau*/
    ctx[7] === 1 && create_if_block$7(ctx);
    var block = {
      c: function create() {
        div = element("div");
        if_block0.c();
        t0 = space();
        if (if_block1) if_block1.c();
        t1 = space();
        link = element("link");
        this.c = noop;
        attr_dev(div, "class", div_class_value = "utd-menu-horizontal-item niv" +
        /*niveau*/
        ctx[7] + (
        /*afficher*/
        ctx[0] === 'true' ? ' visible' : '') + (
        /*actif*/
        ctx[1] === 'true' ? ' active' : '') + (
        /*estMenuPlus*/
        ctx[5] === 'true' ? ' menu-plus' : ''));
        attr_dev(div, "role", "listitem");
        add_location(div, file$8, 211, 0, 5671);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", Utils.cssFullPath);
        add_location(link, file$8, 232, 0, 6684);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        if_blocks[current_block_type_index].m(div, null);
        append_dev(div, t0);
        if (if_block1) if_block1.m(div, null);
        insert_dev(target, t1, anchor);
        insert_dev(target, link, anchor);
        current = true;
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        var previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx);

        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, function () {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block0 = if_blocks[current_block_type_index];

          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block0.c();
          } else {
            if_block0.p(ctx, dirty);
          }

          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }

        if (
        /*niveau*/
        ctx[7] === 1) {
          if (if_block1) ; else {
            if_block1 = create_if_block$7(ctx);
            if_block1.c();
            if_block1.m(div, null);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }

        if (!current || dirty &
        /*niveau, afficher, actif, estMenuPlus*/
        163 && div_class_value !== (div_class_value = "utd-menu-horizontal-item niv" +
        /*niveau*/
        ctx[7] + (
        /*afficher*/
        ctx[0] === 'true' ? ' visible' : '') + (
        /*actif*/
        ctx[1] === 'true' ? ' active' : '') + (
        /*estMenuPlus*/
        ctx[5] === 'true' ? ' menu-plus' : ''))) {
          attr_dev(div, "class", div_class_value);
        }
      },
      i: function intro(local) {
        if (current) return;
        transition_in(if_block0);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block0);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
        if_blocks[current_block_type_index].d();
        if (if_block1) if_block1.d();
        if (detaching) detach_dev(t1);
        if (detaching) detach_dev(link);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$8.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function donnerFocusElementSuivant(elements) {
    if (!elements.length) {
      return;
    }

    var indexeCourant = elements.indexOf(document.activeElement);

    if (indexeCourant >= 0) {
      var prochainIndexe = Math.min(elements.length - 1, indexeCourant + 1);
      elements[prochainIndexe].setAttribute('focus', 'true');
    } else {
      elements[0].setAttribute('focus', 'true');
    }
  }

  function donnerFocusElementPrecedent(elements) {
    if (!elements.length) {
      return;
    }

    var indexeCourant = elements.indexOf(document.activeElement);

    if (indexeCourant >= 0) {
      var prochainIndexe = Math.max(0, indexeCourant - 1);
      elements[prochainIndexe].setAttribute('focus', 'true');
    } else {
      elements[0].setAttribute('focus', 'true');
    }
  }

  function estMenuItem$1(element) {
    return element && element.tagName.toLowerCase() === 'utd-menu-horizontal-item';
  }

  function instance$8($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-menu-horizontal-item', slots, []);
    var _$$props$libelle = $$props.libelle,
        libelle = _$$props$libelle === void 0 ? '' : _$$props$libelle;
    var _$$props$href = $$props.href,
        href = _$$props$href === void 0 ? '' : _$$props$href;
    var _$$props$afficher = $$props.afficher,
        afficher = _$$props$afficher === void 0 ? 'false' : _$$props$afficher;
    var _$$props$animer = $$props.animer,
        animer = _$$props$animer === void 0 ? 'true' : _$$props$animer;
    var _$$props$focus = $$props.focus,
        focus = _$$props$focus === void 0 ? 'false' : _$$props$focus;
    var _$$props$actif = $$props.actif,
        actif = _$$props$actif === void 0 ? 'false' : _$$props$actif;
    var _$$props$estMenuPlus = $$props.estMenuPlus,
        estMenuPlus = _$$props$estMenuPlus === void 0 ? 'false' : _$$props$estMenuPlus;
    var possedeEnfants = false;
    var niveau = 1;
    var thisComponent = get_current_component();
    var idSousMenu = Utils.genererId();
    onMount(function () {
      $$invalidate(1, actif = estElementActif());
      $$invalidate(7, niveau = obtenirNiveau());
      $$invalidate(6, possedeEnfants = !!thisComponent.querySelector('utd-menu-horizontal-item'));
      Utils.reafficherApresChargement(thisComponent);
    });

    function toggleFocus() {
      if (focus === 'true') {
        var premierLien = thisComponent.shadowRoot.querySelector('a');

        if (premierLien) {
          premierLien.focus();
        }

        $$invalidate(12, focus = 'false');
      }
    }

    function toggleAfficher() {
      // Lorsqu'on doit afficher un sous menu, on doit tous les fermer d'abord.
      if (afficher === 'false') {
        fermerMenusNiveauCourant();
      }

      $$invalidate(0, afficher = afficher === 'true' ? 'false' : 'true');
    }

    function fermerMenusNiveauCourant() {
      var menus = obtenirElementsNiveauCourant();
      menus.forEach(function (menu) {
        menu.setAttribute('afficher', 'false');
      });
    }

    function fermerMenuParent() {
      thisComponent.parentElement.setAttribute('afficher', 'false');
    }

    function obtenirElementsNiveauCourant() {
      if (thisComponent) {
        return Array.from(thisComponent.parentElement.children).filter(function (enfant) {
          return enfant.matches('utd-menu-horizontal-item');
        });
      }

      return null;
    }

    function obtenirElementsNiveauSuivant() {
      if (thisComponent) {
        return Array.from(thisComponent.children).filter(function (enfant) {
          return enfant.matches('utd-menu-horizontal-item');
        });
      }

      return null;
    }

    function estElementActif() {
      if (href) {
        return window.location.pathname.startsWith(href).toString();
      } // return (window.location.pathname === href).toString()

    }

    function obtenirNiveau() {
      var niveau = 1;
      var elementParent = thisComponent.parentElement;

      while (elementParent.tagName.toLowerCase() === 'utd-menu-horizontal-item') {
        ++niveau;
        elementParent = elementParent.parentElement;
      }

      return niveau;
    }

    function obtenirMenuHorizontal() {
      var elementParent = thisComponent.parentElement;

      while (elementParent.tagName.toLowerCase() !== 'utd-menu-horizontal') {
        elementParent = elementParent.parentElement;
      }

      return elementParent;
    }

    function fermerMenus() {
      if (possedeEnfants && afficher === 'true') {
        fermerMenusNiveauCourant();
      } else {
        fermerMenuParent();
        thisComponent.parentElement.setAttribute('focus', 'true');
      }
    }

    function onKeyDown(e) {
      thisComponent.parentElement;

      switch (e.key) {
        case "Escape":
          fermerMenus();
          e.preventDefault();
          break;

        case "Enter":
        case " ":
          if (possedeEnfants) {
            toggleAfficher();
            e.preventDefault();
          }

          break;

        case "ArrowUp":
        case "ArrowLeft":
          donnerFocusElementPrecedent(obtenirElementsNiveauCourant());
          e.preventDefault();
          break;

        case "ArrowDown":
        case "ArrowRight":
          if (possedeEnfants) {
            if (e.key === "ArrowDown" && afficher === 'true') {
              donnerFocusElementSuivant(obtenirElementsNiveauSuivant());
            } else {
              donnerFocusElementSuivant(obtenirElementsNiveauCourant());
            }
          } else {
            donnerFocusElementSuivant(obtenirElementsNiveauCourant());
          }

          e.preventDefault();
          break;
      }
    }

    function onBlur(e) {
      var utdMenuHorizontalParent = thisComponent.closest('utd-menu-horizontal');

      if (!utdMenuHorizontalParent.contains(e.relatedTarget)) {
        var itemsMenu = utdMenuHorizontalParent.querySelectorAll('utd-menu-horizontal-item');
        itemsMenu.forEach(function (item) {}); // item.setAttribute('afficher', 'false')
      }
    }

    var writable_props = ['libelle', 'href', 'afficher', 'animer', 'focus', 'actif', 'estMenuPlus'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-menu-horizontal-item> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('libelle' in $$props) $$invalidate(2, libelle = $$props.libelle);
      if ('href' in $$props) $$invalidate(3, href = $$props.href);
      if ('afficher' in $$props) $$invalidate(0, afficher = $$props.afficher);
      if ('animer' in $$props) $$invalidate(4, animer = $$props.animer);
      if ('focus' in $$props) $$invalidate(12, focus = $$props.focus);
      if ('actif' in $$props) $$invalidate(1, actif = $$props.actif);
      if ('estMenuPlus' in $$props) $$invalidate(5, estMenuPlus = $$props.estMenuPlus);
    };

    $$self.$capture_state = function () {
      return {
        onMount: onMount,
        Utils: Utils,
        slide: slide,
        current_component: current_component,
        get_current_component: get_current_component,
        libelle: libelle,
        href: href,
        afficher: afficher,
        animer: animer,
        focus: focus,
        actif: actif,
        estMenuPlus: estMenuPlus,
        possedeEnfants: possedeEnfants,
        niveau: niveau,
        thisComponent: thisComponent,
        idSousMenu: idSousMenu,
        toggleFocus: toggleFocus,
        toggleAfficher: toggleAfficher,
        fermerMenusNiveauCourant: fermerMenusNiveauCourant,
        fermerMenuParent: fermerMenuParent,
        obtenirElementsNiveauCourant: obtenirElementsNiveauCourant,
        obtenirElementsNiveauSuivant: obtenirElementsNiveauSuivant,
        estElementActif: estElementActif,
        obtenirNiveau: obtenirNiveau,
        obtenirMenuHorizontal: obtenirMenuHorizontal,
        fermerMenus: fermerMenus,
        onKeyDown: onKeyDown,
        donnerFocusElementSuivant: donnerFocusElementSuivant,
        donnerFocusElementPrecedent: donnerFocusElementPrecedent,
        estMenuItem: estMenuItem$1,
        onBlur: onBlur
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('libelle' in $$props) $$invalidate(2, libelle = $$props.libelle);
      if ('href' in $$props) $$invalidate(3, href = $$props.href);
      if ('afficher' in $$props) $$invalidate(0, afficher = $$props.afficher);
      if ('animer' in $$props) $$invalidate(4, animer = $$props.animer);
      if ('focus' in $$props) $$invalidate(12, focus = $$props.focus);
      if ('actif' in $$props) $$invalidate(1, actif = $$props.actif);
      if ('estMenuPlus' in $$props) $$invalidate(5, estMenuPlus = $$props.estMenuPlus);
      if ('possedeEnfants' in $$props) $$invalidate(6, possedeEnfants = $$props.possedeEnfants);
      if ('niveau' in $$props) $$invalidate(7, niveau = $$props.niveau);
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    $$self.$$.update = function () {
      if ($$self.$$.dirty &
      /*focus*/
      4096) {
        // Watch sur la prop focus
        toggleFocus();
      }
    };

    return [afficher, actif, libelle, href, animer, estMenuPlus, possedeEnfants, niveau, idSousMenu, toggleAfficher, onKeyDown, onBlur, focus];
  }

  var MenuHorizontalItem = /*#__PURE__*/function (_SvelteElement) {
    _inherits(MenuHorizontalItem, _SvelteElement);

    var _super = _createSuper$8(MenuHorizontalItem);

    function MenuHorizontalItem(options) {
      var _this;

      _classCallCheck(this, MenuHorizontalItem);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$8, create_fragment$8, safe_not_equal, {
        libelle: 2,
        href: 3,
        afficher: 0,
        animer: 4,
        focus: 12,
        actif: 1,
        estMenuPlus: 5
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(MenuHorizontalItem, [{
      key: "libelle",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(libelle) {
        this.$$set({
          libelle: libelle
        });
        flush();
      }
    }, {
      key: "href",
      get: function get() {
        return this.$$.ctx[3];
      },
      set: function set(href) {
        this.$$set({
          href: href
        });
        flush();
      }
    }, {
      key: "afficher",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(afficher) {
        this.$$set({
          afficher: afficher
        });
        flush();
      }
    }, {
      key: "animer",
      get: function get() {
        return this.$$.ctx[4];
      },
      set: function set(animer) {
        this.$$set({
          animer: animer
        });
        flush();
      }
    }, {
      key: "focus",
      get: function get() {
        return this.$$.ctx[12];
      },
      set: function set(focus) {
        this.$$set({
          focus: focus
        });
        flush();
      }
    }, {
      key: "actif",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(actif) {
        this.$$set({
          actif: actif
        });
        flush();
      }
    }, {
      key: "estMenuPlus",
      get: function get() {
        return this.$$.ctx[5];
      },
      set: function set(estMenuPlus) {
        this.$$set({
          estMenuPlus: estMenuPlus
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["libelle", "href", "afficher", "animer", "focus", "actif", "estMenuPlus"];
      }
    }]);

    return MenuHorizontalItem;
  }(SvelteElement);

  customElements.define("utd-menu-horizontal-item", MenuHorizontalItem);

  function _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$7 = "src\\components\\menuVertical.svelte";

  function create_fragment$7(ctx) {
    var nav;
    var a;
    var span0;
    var t0;
    var t1;
    var span1;
    var t2;
    var span2;
    var t4;
    var span3;
    var t5;
    var span3_class_value;
    var t6;
    var div;
    var slot;
    var t7;
    var link;
    var mounted;
    var dispose;
    var block = {
      c: function create() {
        nav = element("nav");
        a = element("a");
        span0 = element("span");
        t0 = text(
        /*titre*/
        ctx[0]);
        t1 = space();
        span1 = element("span");
        t2 = space();
        span2 = element("span");
        span2.textContent = "".concat(
        /*srTexteSortirMenu*/
        ctx[5]);
        t4 = space();
        span3 = element("span");
        t5 = text(
        /*titre*/
        ctx[0]);
        t6 = space();
        div = element("div");
        slot = element("slot");
        t7 = space();
        link = element("link");
        this.c = noop;
        add_location(span0, file$7, 32, 4, 1293);
        attr_dev(span1, "aria-hidden", "true");
        attr_dev(span1, "class", "utd-icone-svg chevron-bleu-piv");
        add_location(span1, file$7, 33, 4, 1319);
        attr_dev(span2, "class", "utd-sr-only");
        add_location(span2, file$7, 34, 4, 1390);
        attr_dev(a, "role", "button");
        attr_dev(a, "href", "#" +
        /*idMenu*/
        ctx[3]);
        attr_dev(a, "class", "toggle");
        attr_dev(a, "aria-controls",
        /*idMenu*/
        ctx[3]);
        add_location(a, file$7, 31, 2, 1172);
        attr_dev(span3, "class", span3_class_value = "titre " + (
        /*titreVisible*/
        ctx[1] === 'true' ? '' : 'utd-sr-only'));
        attr_dev(span3, "id",
        /*idTitreMenu*/
        ctx[4]);
        add_location(span3, file$7, 39, 2, 1472);
        add_location(slot, file$7, 41, 4, 1649);
        attr_dev(div, "id",
        /*idMenu*/
        ctx[3]);
        attr_dev(div, "role", "menu");
        attr_dev(div, "class", "menu");
        toggle_class(div, "visible",
        /*afficher*/
        ctx[2]);
        add_location(div, file$7, 40, 2, 1576);
        attr_dev(nav, "class", "utd-menu-vertical");
        attr_dev(nav, "aria-labelledby",
        /*idTitreMenu*/
        ctx[4]);
        toggle_class(nav, "visible",
        /*afficher*/
        ctx[2]);
        add_location(nav, file$7, 30, 0, 1080);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", Utils.cssFullPath);
        add_location(link, file$7, 44, 0, 1684);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, nav, anchor);
        append_dev(nav, a);
        append_dev(a, span0);
        append_dev(span0, t0);
        append_dev(a, t1);
        append_dev(a, span1);
        append_dev(a, t2);
        append_dev(a, span2);
        append_dev(nav, t4);
        append_dev(nav, span3);
        append_dev(span3, t5);
        append_dev(nav, t6);
        append_dev(nav, div);
        append_dev(div, slot);
        insert_dev(target, t7, anchor);
        insert_dev(target, link, anchor);

        if (!mounted) {
          dispose = listen_dev(a, "click", prevent_default(
          /*toggleAfficher*/
          ctx[6]), false, true, false);
          mounted = true;
        }
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        if (dirty &
        /*titre*/
        1) set_data_dev(t0,
        /*titre*/
        ctx[0]);
        if (dirty &
        /*titre*/
        1) set_data_dev(t5,
        /*titre*/
        ctx[0]);

        if (dirty &
        /*titreVisible*/
        2 && span3_class_value !== (span3_class_value = "titre " + (
        /*titreVisible*/
        ctx[1] === 'true' ? '' : 'utd-sr-only'))) {
          attr_dev(span3, "class", span3_class_value);
        }

        if (dirty &
        /*afficher*/
        4) {
          toggle_class(div, "visible",
          /*afficher*/
          ctx[2]);
        }

        if (dirty &
        /*afficher*/
        4) {
          toggle_class(nav, "visible",
          /*afficher*/
          ctx[2]);
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(nav);
        if (detaching) detach_dev(t7);
        if (detaching) detach_dev(link);
        mounted = false;
        dispose();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$7.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function instance$7($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-menu-vertical', slots, []);
    var _$$props$titre = $$props.titre,
        titre = _$$props$titre === void 0 ? Utils.obtenirLanguePage() === 'en' ? 'Secondary menu' : 'Menu secondaire' : _$$props$titre;
    var _$$props$titreVisible = $$props.titreVisible,
        titreVisible = _$$props$titreVisible === void 0 ? "true" : _$$props$titreVisible;
    var afficher = false;
    var idMenu = Utils.genererId();
    var idTitreMenu = Utils.genererId();
    var srTexteSortirMenu = Utils.obtenirLanguePage() === "en" ? "Press ESC key to exit menu." : "Appuyez sur la touche Échappe pour sortir du menu.";
    var thisComponent = get_current_component(); // Références pour accessibilité
    // https://www.w3.org/WAI/ARIA/apg/example-index/menubar/menubar-navigation, https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/menu_role et https://usability.yale.edu/web-accessibility/articles/focus-keyboard-operability

    onMount(function () {
      Utils.reafficherApresChargement(thisComponent);
    });

    function toggleAfficher() {
      $$invalidate(2, afficher = !afficher);
    }

    var writable_props = ['titre', 'titreVisible'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-menu-vertical> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
      if ('titreVisible' in $$props) $$invalidate(1, titreVisible = $$props.titreVisible);
    };

    $$self.$capture_state = function () {
      return {
        onMount: onMount,
        Utils: Utils,
        get_current_component: get_current_component,
        titre: titre,
        titreVisible: titreVisible,
        afficher: afficher,
        idMenu: idMenu,
        idTitreMenu: idTitreMenu,
        srTexteSortirMenu: srTexteSortirMenu,
        thisComponent: thisComponent,
        toggleAfficher: toggleAfficher
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
      if ('titreVisible' in $$props) $$invalidate(1, titreVisible = $$props.titreVisible);
      if ('afficher' in $$props) $$invalidate(2, afficher = $$props.afficher);
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    return [titre, titreVisible, afficher, idMenu, idTitreMenu, srTexteSortirMenu, toggleAfficher];
  }

  var MenuVertical = /*#__PURE__*/function (_SvelteElement) {
    _inherits(MenuVertical, _SvelteElement);

    var _super = _createSuper$7(MenuVertical);

    function MenuVertical(options) {
      var _this;

      _classCallCheck(this, MenuVertical);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$7, create_fragment$7, safe_not_equal, {
        titre: 0,
        titreVisible: 1
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(MenuVertical, [{
      key: "titre",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(titre) {
        this.$$set({
          titre: titre
        });
        flush();
      }
    }, {
      key: "titreVisible",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(titreVisible) {
        this.$$set({
          titreVisible: titreVisible
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["titre", "titreVisible"];
      }
    }]);

    return MenuVertical;
  }(SvelteElement);

  customElements.define("utd-menu-vertical", MenuVertical);

  function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$6 = "src\\components\\menuVerticalItem.svelte"; // (210:2) {:else}

  function create_else_block$2(ctx) {
    var a;
    var span;
    var t;
    var a_aria_current_value;
    var mounted;
    var dispose;
    var block = {
      c: function create() {
        a = element("a");
        span = element("span");
        t = text(
        /*libelle*/
        ctx[2]);
        add_location(span, file$6, 211, 6, 6494);
        attr_dev(a, "href",
        /*href*/
        ctx[3]);
        attr_dev(a, "role", "menuitem");
        attr_dev(a, "aria-current", a_aria_current_value =
        /*actif*/
        ctx[1] === 'true' ? 'page' : null);
        attr_dev(a, "tabindex",
        /*indextab*/
        ctx[4]);
        add_location(a, file$6, 210, 4, 6339);
      },
      m: function mount(target, anchor) {
        insert_dev(target, a, anchor);
        append_dev(a, span);
        append_dev(span, t);

        if (!mounted) {
          dispose = [listen_dev(a, "keydown",
          /*onKeyDown*/
          ctx[10], false, false, false), listen_dev(a, "focus",
          /*onFocus*/
          ctx[11], false, false, false)];
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*libelle*/
        4) set_data_dev(t,
        /*libelle*/
        ctx[2]);

        if (dirty &
        /*href*/
        8) {
          attr_dev(a, "href",
          /*href*/
          ctx[3]);
        }

        if (dirty &
        /*actif*/
        2 && a_aria_current_value !== (a_aria_current_value =
        /*actif*/
        ctx[1] === 'true' ? 'page' : null)) {
          attr_dev(a, "aria-current", a_aria_current_value);
        }

        if (dirty &
        /*indextab*/
        16) {
          attr_dev(a, "tabindex",
          /*indextab*/
          ctx[4]);
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(a);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_else_block$2.name,
      type: "else",
      source: "(210:2) {:else}",
      ctx: ctx
    });
    return block;
  } // (200:2) {#if possedeEnfants}


  function create_if_block$6(ctx) {
    var a;
    var span0;
    var t0;
    var t1;
    var span1;
    var t2;
    var if_block_anchor;
    var current;
    var mounted;
    var dispose;
    var if_block =
    /*afficher*/
    ctx[0] === 'true' && create_if_block_1$3(ctx);
    var block = {
      c: function create() {
        a = element("a");
        span0 = element("span");
        t0 = text(
        /*libelle*/
        ctx[2]);
        t1 = space();
        span1 = element("span");
        t2 = space();
        if (if_block) if_block.c();
        if_block_anchor = empty();
        add_location(span0, file$6, 201, 6, 6018);
        attr_dev(span1, "aria-hidden", "true");
        attr_dev(span1, "class", "utd-icone-svg chevron-bleu-piv");
        add_location(span1, file$6, 202, 6, 6048);
        attr_dev(a, "role", "menuitem");
        attr_dev(a, "href",
        /*href*/
        ctx[3]);
        attr_dev(a, "aria-expanded",
        /*afficher*/
        ctx[0]);
        attr_dev(a, "aria-haspopup", "menu");
        attr_dev(a, "aria-controls",
        /*idSousMenu*/
        ctx[8]);
        attr_dev(a, "tabindex",
        /*indextab*/
        ctx[4]);
        add_location(a, file$6, 200, 4, 5795);
      },
      m: function mount(target, anchor) {
        insert_dev(target, a, anchor);
        append_dev(a, span0);
        append_dev(span0, t0);
        append_dev(a, t1);
        append_dev(a, span1);
        insert_dev(target, t2, anchor);
        if (if_block) if_block.m(target, anchor);
        insert_dev(target, if_block_anchor, anchor);
        current = true;

        if (!mounted) {
          dispose = [listen_dev(a, "click", prevent_default(
          /*toggleAfficher*/
          ctx[9]), false, true, false), listen_dev(a, "keydown",
          /*onKeyDown*/
          ctx[10], false, false, false), listen_dev(a, "focus",
          /*onFocus*/
          ctx[11], false, false, false)];
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (!current || dirty &
        /*libelle*/
        4) set_data_dev(t0,
        /*libelle*/
        ctx[2]);

        if (!current || dirty &
        /*href*/
        8) {
          attr_dev(a, "href",
          /*href*/
          ctx[3]);
        }

        if (!current || dirty &
        /*afficher*/
        1) {
          attr_dev(a, "aria-expanded",
          /*afficher*/
          ctx[0]);
        }

        if (!current || dirty &
        /*indextab*/
        16) {
          attr_dev(a, "tabindex",
          /*indextab*/
          ctx[4]);
        }

        if (
        /*afficher*/
        ctx[0] === 'true') {
          if (if_block) {
            if_block.p(ctx, dirty);

            if (dirty &
            /*afficher*/
            1) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block_1$3(ctx);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, function () {
            if_block = null;
          });
          check_outros();
        }
      },
      i: function intro(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(a);
        if (detaching) detach_dev(t2);
        if (if_block) if_block.d(detaching);
        if (detaching) detach_dev(if_block_anchor);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block$6.name,
      type: "if",
      source: "(200:2) {#if possedeEnfants}",
      ctx: ctx
    });
    return block;
  } // (205:4) {#if afficher === 'true'}


  function create_if_block_1$3(ctx) {
    var div;
    var slot;
    var div_transition;
    var current;
    var block = {
      c: function create() {
        div = element("div");
        slot = element("slot");
        add_location(slot, file$6, 206, 8, 6284);
        attr_dev(div, "id",
        /*idSousMenu*/
        ctx[8]);
        attr_dev(div, "role", "menu");
        attr_dev(div, "class", "sous-menu");
        add_location(div, file$6, 205, 6, 6162);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        append_dev(div, slot);
        current = true;
      },
      p: function update(new_ctx, dirty) {
        ctx = new_ctx;
      },
      i: function intro(local) {
        if (current) return;
        add_render_callback(function () {
          if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {
            duration:
            /*animer*/
            ctx[5] === 'true' ? 250 : 0
          }, true);
          div_transition.run(1);
        });
        current = true;
      },
      o: function outro(local) {
        if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {
          duration:
          /*animer*/
          ctx[5] === 'true' ? 250 : 0
        }, false);
        div_transition.run(0);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
        if (detaching && div_transition) div_transition.end();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_1$3.name,
      type: "if",
      source: "(205:4) {#if afficher === 'true'}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment$6(ctx) {
    var div;
    var current_block_type_index;
    var if_block;
    var div_class_value;
    var t;
    var link;
    var current;
    var if_block_creators = [create_if_block$6, create_else_block$2];
    var if_blocks = [];

    function select_block_type(ctx, dirty) {
      if (
      /*possedeEnfants*/
      ctx[6]) return 0;
      return 1;
    }

    current_block_type_index = select_block_type(ctx);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    var block = {
      c: function create() {
        div = element("div");
        if_block.c();
        t = space();
        link = element("link");
        this.c = noop;
        attr_dev(div, "class", div_class_value = "utd-menu-vertical-item niv" +
        /*niveau*/
        ctx[7] + " " + (
        /*afficher*/
        ctx[0] === 'true' ? 'visible' : '') + " " + (
        /*actif*/
        ctx[1] === 'true' ? 'active' : ''));
        add_location(div, file$6, 198, 0, 5639);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", Utils.cssFullPath);
        add_location(link, file$6, 215, 0, 6561);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        if_blocks[current_block_type_index].m(div, null);
        insert_dev(target, t, anchor);
        insert_dev(target, link, anchor);
        current = true;
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        var previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx);

        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, function () {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];

          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block.c();
          } else {
            if_block.p(ctx, dirty);
          }

          transition_in(if_block, 1);
          if_block.m(div, null);
        }

        if (!current || dirty &
        /*niveau, afficher, actif*/
        131 && div_class_value !== (div_class_value = "utd-menu-vertical-item niv" +
        /*niveau*/
        ctx[7] + " " + (
        /*afficher*/
        ctx[0] === 'true' ? 'visible' : '') + " " + (
        /*actif*/
        ctx[1] === 'true' ? 'active' : ''))) {
          attr_dev(div, "class", div_class_value);
        }
      },
      i: function intro(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
        if_blocks[current_block_type_index].d();
        if (detaching) detach_dev(t);
        if (detaching) detach_dev(link);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$6.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function estMenuItem(element) {
    return element && element.tagName.toLowerCase() === 'utd-menu-vertical-item';
  }

  function instance$6($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-menu-vertical-item', slots, []);
    var _$$props$libelle = $$props.libelle,
        libelle = _$$props$libelle === void 0 ? '' : _$$props$libelle;
    var _$$props$href = $$props.href,
        href = _$$props$href === void 0 ? '' : _$$props$href;
    var _$$props$afficher = $$props.afficher,
        afficher = _$$props$afficher === void 0 ? 'false' : _$$props$afficher;
    var _$$props$indextab = $$props.indextab,
        indextab = _$$props$indextab === void 0 ? '0' : _$$props$indextab;
    var _$$props$animer = $$props.animer,
        animer = _$$props$animer === void 0 ? 'true' : _$$props$animer;
    var _$$props$focus = $$props.focus,
        focus = _$$props$focus === void 0 ? 'false' : _$$props$focus;
    var _$$props$actif = $$props.actif,
        actif = _$$props$actif === void 0 ? 'false' : _$$props$actif;
    var possedeEnfants = false;
    var niveau = 1;
    var thisComponent = get_current_component();
    var idSousMenu = Utils.genererId();
    onMount(function () {
      $$invalidate(1, actif = estElementActif());
      $$invalidate(7, niveau = obtenirNiveau());
      $$invalidate(6, possedeEnfants = !!thisComponent.querySelector('utd-menu-vertical-item'));
      Utils.reafficherApresChargement(thisComponent);
    });

    function toggleFocus() {
      if (focus === 'true') {
        thisComponent.shadowRoot.querySelector('a').focus();
        $$invalidate(12, focus = 'false');
      }
    }

    function toggleAfficher() {
      $$invalidate(0, afficher = afficher === 'true' ? 'false' : 'true');
    }

    function estElementActif() {
      if (href) {
        return (window.location.pathname === href).toString();
      }
    }

    function obtenirNiveau() {
      var niveau = 1;
      var elementParent = thisComponent.parentElement;

      while (elementParent.tagName.toLowerCase() === 'utd-menu-vertical-item') {
        ++niveau;

        if (actif === 'true') {
          elementParent.setAttribute('actif', 'true');
          elementParent.setAttribute('animer', 'false');
          elementParent.setAttribute('afficher', 'true');
          elementParent.setAttribute('animer', 'true');
        }

        elementParent = elementParent.parentElement;
      }

      return niveau;
    }

    function obtenirMenuVertical() {
      var elementParent = thisComponent.parentElement;

      while (elementParent.tagName.toLowerCase() !== 'utd-menu-vertical') {
        elementParent = elementParent.parentElement;
      }

      return elementParent;
    }

    function onKeyDown(e) {
      var parent = thisComponent.parentElement;

      switch (e.key) {
        case "Escape":
          if (estMenuItem(parent)) {
            parent.setAttribute('afficher', 'false');
            parent.setAttribute('focus', 'true');
          }

          e.preventDefault();
          break;

        case "Enter":
        case " ":
          if (possedeEnfants) {
            if (afficher === 'false') {
              $$invalidate(0, afficher = 'true');
              thisComponent.querySelector('utd-menu-vertical-item').setAttribute('focus', 'true');
            }

            e.preventDefault();
          }

          break;

        case "ArrowLeft":
          accederMenuPrecedent();
          e.preventDefault();
          break;

        case "ArrowUp":
          accederMenuPrecedent(true);
          e.preventDefault();
          break;

        case "ArrowRight":
          if (possedeEnfants) {
            if (afficher === 'false') {
              $$invalidate(0, afficher = 'true');
              thisComponent.querySelector('utd-menu-vertical-item').setAttribute('focus', 'true');
            } else {
              accederMenuSuivant();
            }
          } else {
            accederMenuSuivant();
          }

          e.preventDefault();
          break;

        case "ArrowDown":
          accederMenuSuivant(true);
          e.preventDefault();
          break;
      }
    }

    function accederMenuSuivant(doitBoucler) {
      var parent = thisComponent.parentElement;
      var prochainMenu;
      $$invalidate(0, afficher = 'false');

      if (!doitBoucler && estMenuItem(parent)) {
        parent.setAttribute('afficher', 'false');
        prochainMenu = parent.nextElementSibling;
      } else {
        prochainMenu = thisComponent.nextElementSibling;
      }

      if (estMenuItem(prochainMenu)) {
        prochainMenu.setAttribute('focus', 'true');
      } else {
        if (doitBoucler) {
          parent.querySelector('utd-menu-vertical-item').setAttribute('focus', 'true');
        } else {
          parent.parentElement.querySelector('utd-menu-vertical-item').setAttribute('focus', 'true');
        }
      }
    }

    function accederMenuPrecedent(doitBoucler) {
      var parent = thisComponent.parentElement;
      var menuPrecedent;
      $$invalidate(0, afficher = 'false');

      if (!doitBoucler && estMenuItem(parent)) {
        parent.setAttribute('afficher', 'false');
        parent.setAttribute('focus', 'true');
      } else {
        menuPrecedent = thisComponent.previousElementSibling;
      }

      if (estMenuItem(menuPrecedent)) {
        menuPrecedent.setAttribute('focus', 'true');
      } else {
        var elements = parent.children;
        elements[elements.length - 1].setAttribute('focus', 'true');
      }
    }

    function onFocus() {
      // Tab roving!!! On gère le tabindex des éléments du menu afin que seul l'élément actif puisse être focusable (via tab) de sorte qu'on gère le focus via les flèches du clavier et 
      // un TAB provoque la sortie du menu.
      retirerPossibiliteFocusElementsMenu();
      thisComponent.setAttribute('indextab', '0');
    }

    function retirerPossibiliteFocusElementsMenu() {
      var menuVertical = obtenirMenuVertical();
      var elements = menuVertical.querySelectorAll('utd-menu-vertical-item');
      elements.forEach(function (element) {
        element.setAttribute('indextab', '-1');
      });
    }

    var writable_props = ['libelle', 'href', 'afficher', 'indextab', 'animer', 'focus', 'actif'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-menu-vertical-item> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('libelle' in $$props) $$invalidate(2, libelle = $$props.libelle);
      if ('href' in $$props) $$invalidate(3, href = $$props.href);
      if ('afficher' in $$props) $$invalidate(0, afficher = $$props.afficher);
      if ('indextab' in $$props) $$invalidate(4, indextab = $$props.indextab);
      if ('animer' in $$props) $$invalidate(5, animer = $$props.animer);
      if ('focus' in $$props) $$invalidate(12, focus = $$props.focus);
      if ('actif' in $$props) $$invalidate(1, actif = $$props.actif);
    };

    $$self.$capture_state = function () {
      return {
        onMount: onMount,
        Utils: Utils,
        slide: slide,
        get_current_component: get_current_component,
        libelle: libelle,
        href: href,
        afficher: afficher,
        indextab: indextab,
        animer: animer,
        focus: focus,
        actif: actif,
        possedeEnfants: possedeEnfants,
        niveau: niveau,
        thisComponent: thisComponent,
        idSousMenu: idSousMenu,
        toggleFocus: toggleFocus,
        toggleAfficher: toggleAfficher,
        estElementActif: estElementActif,
        obtenirNiveau: obtenirNiveau,
        obtenirMenuVertical: obtenirMenuVertical,
        onKeyDown: onKeyDown,
        accederMenuSuivant: accederMenuSuivant,
        accederMenuPrecedent: accederMenuPrecedent,
        estMenuItem: estMenuItem,
        onFocus: onFocus,
        retirerPossibiliteFocusElementsMenu: retirerPossibiliteFocusElementsMenu
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('libelle' in $$props) $$invalidate(2, libelle = $$props.libelle);
      if ('href' in $$props) $$invalidate(3, href = $$props.href);
      if ('afficher' in $$props) $$invalidate(0, afficher = $$props.afficher);
      if ('indextab' in $$props) $$invalidate(4, indextab = $$props.indextab);
      if ('animer' in $$props) $$invalidate(5, animer = $$props.animer);
      if ('focus' in $$props) $$invalidate(12, focus = $$props.focus);
      if ('actif' in $$props) $$invalidate(1, actif = $$props.actif);
      if ('possedeEnfants' in $$props) $$invalidate(6, possedeEnfants = $$props.possedeEnfants);
      if ('niveau' in $$props) $$invalidate(7, niveau = $$props.niveau);
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    $$self.$$.update = function () {
      if ($$self.$$.dirty &
      /*focus*/
      4096) {
        // Watch sur la prop focus
        toggleFocus();
      }
    };

    return [afficher, actif, libelle, href, indextab, animer, possedeEnfants, niveau, idSousMenu, toggleAfficher, onKeyDown, onFocus, focus];
  }

  var MenuVerticalItem = /*#__PURE__*/function (_SvelteElement) {
    _inherits(MenuVerticalItem, _SvelteElement);

    var _super = _createSuper$6(MenuVerticalItem);

    function MenuVerticalItem(options) {
      var _this;

      _classCallCheck(this, MenuVerticalItem);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$6, create_fragment$6, safe_not_equal, {
        libelle: 2,
        href: 3,
        afficher: 0,
        indextab: 4,
        animer: 5,
        focus: 12,
        actif: 1
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(MenuVerticalItem, [{
      key: "libelle",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(libelle) {
        this.$$set({
          libelle: libelle
        });
        flush();
      }
    }, {
      key: "href",
      get: function get() {
        return this.$$.ctx[3];
      },
      set: function set(href) {
        this.$$set({
          href: href
        });
        flush();
      }
    }, {
      key: "afficher",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(afficher) {
        this.$$set({
          afficher: afficher
        });
        flush();
      }
    }, {
      key: "indextab",
      get: function get() {
        return this.$$.ctx[4];
      },
      set: function set(indextab) {
        this.$$set({
          indextab: indextab
        });
        flush();
      }
    }, {
      key: "animer",
      get: function get() {
        return this.$$.ctx[5];
      },
      set: function set(animer) {
        this.$$set({
          animer: animer
        });
        flush();
      }
    }, {
      key: "focus",
      get: function get() {
        return this.$$.ctx[12];
      },
      set: function set(focus) {
        this.$$set({
          focus: focus
        });
        flush();
      }
    }, {
      key: "actif",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(actif) {
        this.$$set({
          actif: actif
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["libelle", "href", "afficher", "indextab", "animer", "focus", "actif"];
      }
    }]);

    return MenuVerticalItem;
  }(SvelteElement);

  customElements.define("utd-menu-vertical-item", MenuVerticalItem);

  function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$5 = "src\\components\\pointsSuspension.svelte"; // (237:2) {#if estAffichageTexteTronque && !estTexteCompletAffiche}

  function create_if_block_1$2(ctx) {
    var a;
    var span;
    var t;
    var a_class_value;
    var a_title_value;
    var mounted;
    var dispose;

    function select_block_type(ctx, dirty) {
      if (
      /*afficherTexteLien*/
      ctx[0] === 'true') return create_if_block_3$1;
      return create_else_block$1;
    }

    var current_block_type = select_block_type(ctx);
    var if_block0 = current_block_type(ctx);
    var if_block1 =
    /*afficherTexteLien*/
    ctx[0] === 'true' && create_if_block_2$2(ctx);
    var block = {
      c: function create() {
        a = element("a");
        span = element("span");
        if_block0.c();
        t = space();
        if (if_block1) if_block1.c();
        attr_dev(span, "aria-hidden", "true");
        add_location(span, file$5, 238, 6, 7420);
        attr_dev(a, "href", "#");
        attr_dev(a, "role", "button");
        attr_dev(a, "class", a_class_value = "ellipsis " + (
        /*estAjustementAffichageEnCours*/
        ctx[5] ? ' utd-d-none' : ''));
        attr_dev(a, "title", a_title_value =
        /*afficherTexteLien*/
        ctx[0] === 'true' ? null :
        /*texteLien*/
        ctx[1]);
        add_location(a, file$5, 237, 4, 7202);
      },
      m: function mount(target, anchor) {
        insert_dev(target, a, anchor);
        append_dev(a, span);
        if_block0.m(span, null);
        append_dev(a, t);
        if (if_block1) if_block1.m(a, null);

        if (!mounted) {
          dispose = listen_dev(a, "click", prevent_default(
          /*afficherContenuSupplementaire*/
          ctx[9]), false, true, false);
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0.d(1);
          if_block0 = current_block_type(ctx);

          if (if_block0) {
            if_block0.c();
            if_block0.m(span, null);
          }
        }

        if (
        /*afficherTexteLien*/
        ctx[0] === 'true') {
          if (if_block1) {
            if_block1.p(ctx, dirty);
          } else {
            if_block1 = create_if_block_2$2(ctx);
            if_block1.c();
            if_block1.m(a, null);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }

        if (dirty &
        /*estAjustementAffichageEnCours*/
        32 && a_class_value !== (a_class_value = "ellipsis " + (
        /*estAjustementAffichageEnCours*/
        ctx[5] ? ' utd-d-none' : ''))) {
          attr_dev(a, "class", a_class_value);
        }

        if (dirty &
        /*afficherTexteLien, texteLien*/
        3 && a_title_value !== (a_title_value =
        /*afficherTexteLien*/
        ctx[0] === 'true' ? null :
        /*texteLien*/
        ctx[1])) {
          attr_dev(a, "title", a_title_value);
        }
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(a);
        if_block0.d();
        if (if_block1) if_block1.d();
        mounted = false;
        dispose();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_1$2.name,
      type: "if",
      source: "(237:2) {#if estAffichageTexteTronque && !estTexteCompletAffiche}",
      ctx: ctx
    });
    return block;
  } // (242:8) {:else}


  function create_else_block$1(ctx) {
    var t0;
    var span;
    var t2;
    var block = {
      c: function create() {
        t0 = text("[");
        span = element("span");
        span.textContent = "...";
        t2 = text("]");
        attr_dev(span, "class", "dots");
        add_location(span, file$5, 242, 11, 7588);
      },
      m: function mount(target, anchor) {
        insert_dev(target, t0, anchor);
        insert_dev(target, span, anchor);
        insert_dev(target, t2, anchor);
      },
      p: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(t0);
        if (detaching) detach_dev(span);
        if (detaching) detach_dev(t2);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_else_block$1.name,
      type: "else",
      source: "(242:8) {:else}",
      ctx: ctx
    });
    return block;
  } // (240:8) {#if afficherTexteLien === 'true'}


  function create_if_block_3$1(ctx) {
    var span;
    var t1;
    var t2;
    var t3;
    var block = {
      c: function create() {
        span = element("span");
        span.textContent = "...";
        t1 = text(" [");
        t2 = text(
        /*texteLien*/
        ctx[1]);
        t3 = text("]");
        attr_dev(span, "class", "dots");
        add_location(span, file$5, 240, 10, 7502);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
        insert_dev(target, t1, anchor);
        insert_dev(target, t2, anchor);
        insert_dev(target, t3, anchor);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*texteLien*/
        2) set_data_dev(t2,
        /*texteLien*/
        ctx[1]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(span);
        if (detaching) detach_dev(t1);
        if (detaching) detach_dev(t2);
        if (detaching) detach_dev(t3);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_3$1.name,
      type: "if",
      source: "(240:8) {#if afficherTexteLien === 'true'}",
      ctx: ctx
    });
    return block;
  } // (247:6) {#if afficherTexteLien === 'true'}


  function create_if_block_2$2(ctx) {
    var span;
    var t;
    var block = {
      c: function create() {
        span = element("span");
        t = text(
        /*texteLien*/
        ctx[1]);
        attr_dev(span, "class", "utd-sr-only");
        add_location(span, file$5, 247, 8, 7721);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
        append_dev(span, t);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*texteLien*/
        2) set_data_dev(t,
        /*texteLien*/
        ctx[1]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(span);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_2$2.name,
      type: "if",
      source: "(247:6) {#if afficherTexteLien === 'true'}",
      ctx: ctx
    });
    return block;
  } // (254:2) {#if estTexteCompletAffiche}


  function create_if_block$5(ctx) {
    var span;
    var t;
    var span_class_value;
    var span_transition;
    var current;
    var block = {
      c: function create() {
        span = element("span");
        t = text(
        /*texteSupplementaire*/
        ctx[4]);
        attr_dev(span, "class", span_class_value = "texte-supplementaire" + (
        /*estAffichageTexteTronque*/
        ctx[3] ? ' estAffichageTexteTronque' : '') + (
        /*estTexteCompletAffiche*/
        ctx[2] ? ' estTexteCompletAffiche' : ''));
        attr_dev(span, "id",
        /*idTexteSupplementaire*/
        ctx[7]);
        attr_dev(span, "tabindex", "-1");
        add_location(span, file$5, 254, 4, 7853);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
        append_dev(span, t);
        current = true;
      },
      p: function update(ctx, dirty) {
        if (!current || dirty &
        /*texteSupplementaire*/
        16) set_data_dev(t,
        /*texteSupplementaire*/
        ctx[4]);

        if (!current || dirty &
        /*estAffichageTexteTronque, estTexteCompletAffiche*/
        12 && span_class_value !== (span_class_value = "texte-supplementaire" + (
        /*estAffichageTexteTronque*/
        ctx[3] ? ' estAffichageTexteTronque' : '') + (
        /*estTexteCompletAffiche*/
        ctx[2] ? ' estTexteCompletAffiche' : ''))) {
          attr_dev(span, "class", span_class_value);
        }
      },
      i: function intro(local) {
        if (current) return;
        add_render_callback(function () {
          if (!span_transition) span_transition = create_bidirectional_transition(span, fade, {
            duration: 250
          }, true);
          span_transition.run(1);
        });
        current = true;
      },
      o: function outro(local) {
        if (!span_transition) span_transition = create_bidirectional_transition(span, fade, {
          duration: 250
        }, false);
        span_transition.run(0);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(span);
        if (detaching && span_transition) span_transition.end();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block$5.name,
      type: "if",
      source: "(254:2) {#if estTexteCompletAffiche}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment$5(ctx) {
    var div;
    var span;
    var slot;
    var t0;
    var t1;
    var div_class_value;
    var t2;
    var link;
    var current;
    var if_block0 =
    /*estAffichageTexteTronque*/
    ctx[3] && !
    /*estTexteCompletAffiche*/
    ctx[2] && create_if_block_1$2(ctx);
    var if_block1 =
    /*estTexteCompletAffiche*/
    ctx[2] && create_if_block$5(ctx);
    var block = {
      c: function create() {
        div = element("div");
        span = element("span");
        slot = element("slot");
        t0 = space();
        if (if_block0) if_block0.c();
        t1 = space();
        if (if_block1) if_block1.c();
        t2 = space();
        link = element("link");
        this.c = noop;
        add_location(slot, file$5, 233, 4, 7100);
        attr_dev(span, "class", "texte");
        attr_dev(span, "id",
        /*idTexte*/
        ctx[8]);
        add_location(span, file$5, 232, 2, 7059);
        attr_dev(div, "class", div_class_value = "utd-component utd-points-suspension" + (
        /*estAjustementAffichageEnCours*/
        ctx[5] ? ' ajustement-en-cours' : ''));
        attr_dev(div, "id",
        /*idConteneur*/
        ctx[6]);
        add_location(div, file$5, 231, 0, 6925);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", Utils.cssFullPath);
        add_location(link, file$5, 259, 0, 8139);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        append_dev(div, span);
        append_dev(span, slot);
        append_dev(div, t0);
        if (if_block0) if_block0.m(div, null);
        append_dev(div, t1);
        if (if_block1) if_block1.m(div, null);
        insert_dev(target, t2, anchor);
        insert_dev(target, link, anchor);
        current = true;
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        if (
        /*estAffichageTexteTronque*/
        ctx[3] && !
        /*estTexteCompletAffiche*/
        ctx[2]) {
          if (if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0 = create_if_block_1$2(ctx);
            if_block0.c();
            if_block0.m(div, t1);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }

        if (
        /*estTexteCompletAffiche*/
        ctx[2]) {
          if (if_block1) {
            if_block1.p(ctx, dirty);

            if (dirty &
            /*estTexteCompletAffiche*/
            4) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block$5(ctx);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(div, null);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, function () {
            if_block1 = null;
          });
          check_outros();
        }

        if (!current || dirty &
        /*estAjustementAffichageEnCours*/
        32 && div_class_value !== (div_class_value = "utd-component utd-points-suspension" + (
        /*estAjustementAffichageEnCours*/
        ctx[5] ? ' ajustement-en-cours' : ''))) {
          attr_dev(div, "class", div_class_value);
        }
      },
      i: function intro(local) {
        if (current) return;
        transition_in(if_block1);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block1);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
        if (if_block0) if_block0.d();
        if (if_block1) if_block1.d();
        if (detaching) detach_dev(t2);
        if (detaching) detach_dev(link);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$5.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function instance$5($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-points-suspension', slots, []);
    var _$$props$nbLignes = $$props.nbLignes,
        nbLignes = _$$props$nbLignes === void 0 ? '1' : _$$props$nbLignes;
    var _$$props$affichageIni = $$props.affichageInitial,
        affichageInitial = _$$props$affichageIni === void 0 ? 'true' : _$$props$affichageIni;
    var _$$props$afficherText = $$props.afficherTexteLien,
        afficherTexteLien = _$$props$afficherText === void 0 ? 'false' : _$$props$afficherText;
    var _$$props$texteLien = $$props.texteLien,
        texteLien = _$$props$texteLien === void 0 ? Utils.obtenirLanguePage() === "fr" ? "Voir plus" : "Show more" : _$$props$texteLien; // Références pour accessibilité
    // https://www.accede-web.com/en/guidelines/rich-interface-components/show-more-buttons/

    var idConteneur = Utils.genererId();
    var idTexteSupplementaire = Utils.genererId();
    var idTexte = Utils.genererId();
    var thisComponent = get_current_component();
    var estTexteCompletAffiche = false;
    var estAffichageTexteTronque = false;
    var conteneur;
    var controleTexte;
    var controleTexteSupplementaire;
    var hauteurMax = 24;
    var texteComplet = '';
    var texteSupplementaire = '';
    var estAjustementAffichageEnCours = true;
    var estEvenementObserverEnCours = false;
    var mounted = false;
    onMount(function () {
      //
      if (!window.ResizeObserver) {
        $$invalidate(5, estAjustementAffichageEnCours = false);
        $$invalidate(2, estTexteCompletAffiche = true);
        Utils.reafficherApresChargement(thisComponent);
        mounted = true;
      } else {
        conteneur = thisComponent.shadowRoot.getElementById(idConteneur);
        controleTexte = thisComponent.shadowRoot.getElementById(idTexte);
        texteComplet = thisComponent.textContent;
        ajusterAffichageControle();
        Utils.reafficherApresChargement(thisComponent); // Détecter les resize sur le composant et redessiner

        observerRezise();
        mounted = true;
      }
    });

    function initialiserAffichage() {
      if (mounted && affichageInitial === 'true') {
        $$invalidate(2, estTexteCompletAffiche = false);
        ajusterAffichageControle();
      }
    }

    function ajusterAffichageControle() {
      $$invalidate(5, estAjustementAffichageEnCours = true);
      estEvenementObserverEnCours = true;
      controleTexte.textContent = "";
      conteneur.removeAttribute('style'); // On doit repaint ici afin que l'interface soit à jour avant d'effectuer les ajustements à l'affichage du contrôle (ex. le bouton ... doit être retiré si présent, car bousille le calcul pour la hauteur)

      setTimeout(function () {
        ajusterAffichageControle2();
      });
    }

    function ajusterAffichageControle2() {
      hauteurMax = obtenirHauteurMaximale();
      conteneur.style.maxHeight = hauteurMax + 'px';
      controleTexte.textContent = texteComplet;
      controleTexteSupplementaire = thisComponent.shadowRoot.getElementById(idTexteSupplementaire);

      if (controleTexteSupplementaire) {
        controleTexteSupplementaire.textContent = '';
      }

      if (doitTronquerTexte()) {
        thisComponent.textContent = "";
        tronquerTexte();
      } else {
        $$invalidate(3, estAffichageTexteTronque = false);
      }

      $$invalidate(5, estAjustementAffichageEnCours = false);
      setTimeout(function () {
        estEvenementObserverEnCours = false;
      }, 500);
    }

    var resizeObserverDebounced = Utils.debounce(function (entries) {
      return resizeObserver(entries);
    });

    function observerRezise() {
      var observer = new ResizeObserver(resizeObserverDebounced);
      observer.observe(thisComponent);
    }

    function resizeObserver(entries) {
      entries.forEach(function (entry) {
        if (affichageInitial === 'true') {
          $$invalidate(10, affichageInitial = 'false');
          return;
        }

        if (estEvenementObserverEnCours) {
          return;
        }

        if (!estTexteCompletAffiche) {
          ajusterAffichageControle();
        }
      });
    }

    function afficherContenuSupplementaire() {
      conteneur.removeAttribute('style');
      $$invalidate(2, estTexteCompletAffiche = true);
      setTimeout(function () {
        var controleTexteSupplementaire = thisComponent.shadowRoot.getElementById(idTexteSupplementaire);
        controleTexteSupplementaire.focus();
      }, 250);
    }

    function obtenirHauteurMaximale() {
      var nombreLignes = parseInt(nbLignes);
      var htmlBidon = 'TjpyYZ';

      for (var i = 1; i < nombreLignes; i++) {
        htmlBidon += '<br/>TjpyYZ';
      }

      controleTexte.innerHTML = htmlBidon;
      var height = controleTexte.getBoundingClientRect().height;
      controleTexte.textContent = ''; // On se donne un petit jeu sur la hauteur... Il y a toujours une petite différence et ça cause problème (à cause du lien ... qui est plus gros entre autres)

      return height + 2;
    }

    function doitTronquerTexte() {
      //console.log('hauteur contrôle texte -> ' + controleTexte.getBoundingClientRect().height + '     hauteur max -> ' + hauteurMax)
      return controleTexte.getBoundingClientRect().height > hauteurMax;
    }

    function tronquerTexte() {
      var texteCourant = "";
      var posGauche = 0;
      var posDroite = texteComplet.length - 1;
      var posMilieu = 0;
      var estHauteurZero = false;

      while (posGauche < posDroite) {
        posMilieu = Math.floor((posGauche + posDroite) / 2);

        if (posGauche === posMilieu) {
          break;
        }

        var texteTemp = texteComplet.slice(posGauche, posMilieu);
        controleTexte.textContent = texteCourant + texteTemp;
        var height = controleTexte.getBoundingClientRect().height; //console.log('G ' + posGauche + '    M ' + posMilieu + '   height -> ' + height + '   hauteurMax -> ' + hauteurMax)
        // Petite patch pour certains fureteurs/appareils sur lesquels la hauteur du texteTemp au chargement initial était de 0??? Rien à comprendre (ex. Big Sur Safari 14.1)

        if (height === 0) {
          estHauteurZero = true;
          controleTexte.textContent = '';
          setTimeout(function () {
            tronquerTexte();
          }, 100);
          break;
        }

        if (height > hauteurMax) {
          posDroite = posMilieu;
        } else {
          texteCourant += texteTemp;
          posGauche = posMilieu;
        }
      }

      if (estHauteurZero) {
        return;
      } // Ici petit ajustement de x caractères pour compenser l'ajustement requis avec notre "..."


      texteCourant = texteComplet.slice(0, posMilieu - obtenirNbCaracteresTexteLien()); // Trouver le dernier espace avant notre tronquage et utiliser cette position pour le tronquage.

      var posDernierEspace = texteCourant.lastIndexOf(' ');
      $$invalidate(4, texteSupplementaire = texteComplet.slice(posDernierEspace));
      controleTexte.textContent = texteComplet.slice(0, posDernierEspace);
      $$invalidate(3, estAffichageTexteTronque = true);
    }

    function obtenirNbCaracteresTexteLien() {
      if (afficherTexteLien === 'true') {
        return "... [".concat(texteLien, "]").length;
      } else {
        return 5;
      }
    }

    var writable_props = ['nbLignes', 'affichageInitial', 'afficherTexteLien', 'texteLien'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-points-suspension> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('nbLignes' in $$props) $$invalidate(11, nbLignes = $$props.nbLignes);
      if ('affichageInitial' in $$props) $$invalidate(10, affichageInitial = $$props.affichageInitial);
      if ('afficherTexteLien' in $$props) $$invalidate(0, afficherTexteLien = $$props.afficherTexteLien);
      if ('texteLien' in $$props) $$invalidate(1, texteLien = $$props.texteLien);
    };

    $$self.$capture_state = function () {
      return {
        onMount: onMount,
        fade: fade,
        Utils: Utils,
        get_current_component: get_current_component,
        nbLignes: nbLignes,
        affichageInitial: affichageInitial,
        afficherTexteLien: afficherTexteLien,
        texteLien: texteLien,
        idConteneur: idConteneur,
        idTexteSupplementaire: idTexteSupplementaire,
        idTexte: idTexte,
        thisComponent: thisComponent,
        estTexteCompletAffiche: estTexteCompletAffiche,
        estAffichageTexteTronque: estAffichageTexteTronque,
        conteneur: conteneur,
        controleTexte: controleTexte,
        controleTexteSupplementaire: controleTexteSupplementaire,
        hauteurMax: hauteurMax,
        texteComplet: texteComplet,
        texteSupplementaire: texteSupplementaire,
        estAjustementAffichageEnCours: estAjustementAffichageEnCours,
        estEvenementObserverEnCours: estEvenementObserverEnCours,
        mounted: mounted,
        initialiserAffichage: initialiserAffichage,
        ajusterAffichageControle: ajusterAffichageControle,
        ajusterAffichageControle2: ajusterAffichageControle2,
        resizeObserverDebounced: resizeObserverDebounced,
        observerRezise: observerRezise,
        resizeObserver: resizeObserver,
        afficherContenuSupplementaire: afficherContenuSupplementaire,
        obtenirHauteurMaximale: obtenirHauteurMaximale,
        doitTronquerTexte: doitTronquerTexte,
        tronquerTexte: tronquerTexte,
        obtenirNbCaracteresTexteLien: obtenirNbCaracteresTexteLien
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('nbLignes' in $$props) $$invalidate(11, nbLignes = $$props.nbLignes);
      if ('affichageInitial' in $$props) $$invalidate(10, affichageInitial = $$props.affichageInitial);
      if ('afficherTexteLien' in $$props) $$invalidate(0, afficherTexteLien = $$props.afficherTexteLien);
      if ('texteLien' in $$props) $$invalidate(1, texteLien = $$props.texteLien);
      if ('estTexteCompletAffiche' in $$props) $$invalidate(2, estTexteCompletAffiche = $$props.estTexteCompletAffiche);
      if ('estAffichageTexteTronque' in $$props) $$invalidate(3, estAffichageTexteTronque = $$props.estAffichageTexteTronque);
      if ('conteneur' in $$props) conteneur = $$props.conteneur;
      if ('controleTexte' in $$props) controleTexte = $$props.controleTexte;
      if ('controleTexteSupplementaire' in $$props) controleTexteSupplementaire = $$props.controleTexteSupplementaire;
      if ('hauteurMax' in $$props) hauteurMax = $$props.hauteurMax;
      if ('texteComplet' in $$props) texteComplet = $$props.texteComplet;
      if ('texteSupplementaire' in $$props) $$invalidate(4, texteSupplementaire = $$props.texteSupplementaire);
      if ('estAjustementAffichageEnCours' in $$props) $$invalidate(5, estAjustementAffichageEnCours = $$props.estAjustementAffichageEnCours);
      if ('estEvenementObserverEnCours' in $$props) estEvenementObserverEnCours = $$props.estEvenementObserverEnCours;
      if ('mounted' in $$props) mounted = $$props.mounted;
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    $$self.$$.update = function () {
      if ($$self.$$.dirty &
      /*affichageInitial*/
      1024) {
        // Watch sur la prop affichageInitial
        initialiserAffichage();
      }
    };

    return [afficherTexteLien, texteLien, estTexteCompletAffiche, estAffichageTexteTronque, texteSupplementaire, estAjustementAffichageEnCours, idConteneur, idTexteSupplementaire, idTexte, afficherContenuSupplementaire, affichageInitial, nbLignes];
  }

  var PointsSuspension = /*#__PURE__*/function (_SvelteElement) {
    _inherits(PointsSuspension, _SvelteElement);

    var _super = _createSuper$5(PointsSuspension);

    function PointsSuspension(options) {
      var _this;

      _classCallCheck(this, PointsSuspension);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$5, create_fragment$5, safe_not_equal, {
        nbLignes: 11,
        affichageInitial: 10,
        afficherTexteLien: 0,
        texteLien: 1
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(PointsSuspension, [{
      key: "nbLignes",
      get: function get() {
        return this.$$.ctx[11];
      },
      set: function set(nbLignes) {
        this.$$set({
          nbLignes: nbLignes
        });
        flush();
      }
    }, {
      key: "affichageInitial",
      get: function get() {
        return this.$$.ctx[10];
      },
      set: function set(affichageInitial) {
        this.$$set({
          affichageInitial: affichageInitial
        });
        flush();
      }
    }, {
      key: "afficherTexteLien",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(afficherTexteLien) {
        this.$$set({
          afficherTexteLien: afficherTexteLien
        });
        flush();
      }
    }, {
      key: "texteLien",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(texteLien) {
        this.$$set({
          texteLien: texteLien
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["nbLignes", "affichageInitial", "afficherTexteLien", "texteLien"];
      }
    }]);

    return PointsSuspension;
  }(SvelteElement);

  customElements.define("utd-points-suspension", PointsSuspension);

  function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$4 = "src\\components\\section.svelte"; // (91:4) {:else}

  function create_else_block(ctx) {
    var previous_tag =
    /*tagTitre*/
    ctx[3];
    var svelte_element_anchor;
    validate_dynamic_element(
    /*tagTitre*/
    ctx[3]);
    validate_void_dynamic_element(
    /*tagTitre*/
    ctx[3]);
    var svelte_element =
    /*tagTitre*/
    ctx[3] && create_dynamic_element_1(ctx);
    var block = {
      c: function create() {
        if (svelte_element) svelte_element.c();
        svelte_element_anchor = empty();
      },
      m: function mount(target, anchor) {
        if (svelte_element) svelte_element.m(target, anchor);
        insert_dev(target, svelte_element_anchor, anchor);
      },
      p: function update(ctx, dirty) {
        if (
        /*tagTitre*/
        ctx[3]) {
          if (!previous_tag) {
            svelte_element = create_dynamic_element_1(ctx);
            svelte_element.c();
            svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
          } else if (safe_not_equal(previous_tag,
          /*tagTitre*/
          ctx[3])) {
            svelte_element.d(1);
            validate_dynamic_element(
            /*tagTitre*/
            ctx[3]);
            validate_void_dynamic_element(
            /*tagTitre*/
            ctx[3]);
            svelte_element = create_dynamic_element_1(ctx);
            svelte_element.c();
            svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
          } else {
            svelte_element.p(ctx, dirty);
          }
        } else if (previous_tag) {
          svelte_element.d(1);
          svelte_element = null;
        }

        previous_tag =
        /*tagTitre*/
        ctx[3];
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(svelte_element_anchor);
        if (svelte_element) svelte_element.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_else_block.name,
      type: "else",
      source: "(91:4) {:else}",
      ctx: ctx
    });
    return block;
  } // (81:4) {#if extensible === 'true'}


  function create_if_block_1$1(ctx) {
    var previous_tag =
    /*tagTitre*/
    ctx[3];
    var svelte_element_anchor;
    validate_dynamic_element(
    /*tagTitre*/
    ctx[3]);
    validate_void_dynamic_element(
    /*tagTitre*/
    ctx[3]);
    var svelte_element =
    /*tagTitre*/
    ctx[3] && create_dynamic_element(ctx);
    var block = {
      c: function create() {
        if (svelte_element) svelte_element.c();
        svelte_element_anchor = empty();
      },
      m: function mount(target, anchor) {
        if (svelte_element) svelte_element.m(target, anchor);
        insert_dev(target, svelte_element_anchor, anchor);
      },
      p: function update(ctx, dirty) {
        if (
        /*tagTitre*/
        ctx[3]) {
          if (!previous_tag) {
            svelte_element = create_dynamic_element(ctx);
            svelte_element.c();
            svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
          } else if (safe_not_equal(previous_tag,
          /*tagTitre*/
          ctx[3])) {
            svelte_element.d(1);
            validate_dynamic_element(
            /*tagTitre*/
            ctx[3]);
            validate_void_dynamic_element(
            /*tagTitre*/
            ctx[3]);
            svelte_element = create_dynamic_element(ctx);
            svelte_element.c();
            svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
          } else {
            svelte_element.p(ctx, dirty);
          }
        } else if (previous_tag) {
          svelte_element.d(1);
          svelte_element = null;
        }

        previous_tag =
        /*tagTitre*/
        ctx[3];
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(svelte_element_anchor);
        if (svelte_element) svelte_element.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_1$1.name,
      type: "if",
      source: "(81:4) {#if extensible === 'true'}",
      ctx: ctx
    });
    return block;
  } // (93:8) {#if titre}


  function create_if_block_4$1(ctx) {
    var t;
    var block = {
      c: function create() {
        t = text(
        /*titre*/
        ctx[1]);
      },
      m: function mount(target, anchor) {
        insert_dev(target, t, anchor);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*titre*/
        2) set_data_dev(t,
        /*titre*/
        ctx[1]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(t);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_4$1.name,
      type: "if",
      source: "(93:8) {#if titre}",
      ctx: ctx
    });
    return block;
  } // (92:6) <svelte:element this={tagTitre} class="titre">


  function create_dynamic_element_1(ctx) {
    var svelte_element;
    var t;
    var slot;
    var if_block =
    /*titre*/
    ctx[1] && create_if_block_4$1(ctx);
    var svelte_element_levels = [{
      class: "titre"
    }];
    var svelte_element_data = {};

    for (var i = 0; i < svelte_element_levels.length; i += 1) {
      svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
    }

    var block = {
      c: function create() {
        svelte_element = element(
        /*tagTitre*/
        ctx[3]);
        if (if_block) if_block.c();
        t = space();
        slot = element("slot");
        attr_dev(slot, "name", "titre");
        add_location(slot, file$4, 95, 8, 3038);
        set_attributes(svelte_element, svelte_element_data);
        add_location(svelte_element, file$4, 91, 6, 2926);
      },
      m: function mount(target, anchor) {
        insert_dev(target, svelte_element, anchor);
        if (if_block) if_block.m(svelte_element, null);
        append_dev(svelte_element, t);
        append_dev(svelte_element, slot);
      },
      p: function update(ctx, dirty) {
        if (
        /*titre*/
        ctx[1]) {
          if (if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block = create_if_block_4$1(ctx);
            if_block.c();
            if_block.m(svelte_element, t);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }

        set_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [{
          class: "titre"
        }]));
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(svelte_element);
        if (if_block) if_block.d();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_dynamic_element_1.name,
      type: "child_dynamic_element",
      source: "(92:6) <svelte:element this={tagTitre} class=\\\"titre\\\">",
      ctx: ctx
    });
    return block;
  } // (84:10) {#if titre}


  function create_if_block_2$1(ctx) {
    var t;
    var block = {
      c: function create() {
        t = text(
        /*titre*/
        ctx[1]);
      },
      m: function mount(target, anchor) {
        insert_dev(target, t, anchor);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*titre*/
        2) set_data_dev(t,
        /*titre*/
        ctx[1]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(t);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_2$1.name,
      type: "if",
      source: "(84:10) {#if titre}",
      ctx: ctx
    });
    return block;
  } // (82:4) <svelte:element this={tagTitre} class="titre">


  function create_dynamic_element(ctx) {
    var svelte_element;
    var button;
    var t0;
    var slot;
    var t1;
    var span;
    var button_aria_expanded_value;
    var mounted;
    var dispose;
    var if_block =
    /*titre*/
    ctx[1] && create_if_block_2$1(ctx);
    var svelte_element_levels = [{
      class: "titre"
    }];
    var svelte_element_data = {};

    for (var i = 0; i < svelte_element_levels.length; i += 1) {
      svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
    }

    var block = {
      c: function create() {
        svelte_element = element(
        /*tagTitre*/
        ctx[3]);
        button = element("button");
        if (if_block) if_block.c();
        t0 = space();
        slot = element("slot");
        t1 = space();
        span = element("span");
        attr_dev(slot, "name", "titre");
        add_location(slot, file$4, 86, 10, 2764);
        attr_dev(span, "class", "utd-icone-svg chevron-blanc");
        add_location(span, file$4, 87, 8, 2807);
        attr_dev(button, "type", "button");
        attr_dev(button, "class", "");
        attr_dev(button, "aria-controls",
        /*idContenu*/
        ctx[5]);
        attr_dev(button, "aria-expanded", button_aria_expanded_value = !
        /*estReduit*/
        ctx[4]);
        add_location(button, file$4, 82, 6, 2569);
        set_attributes(svelte_element, svelte_element_data);
        add_location(svelte_element, file$4, 81, 4, 2514);
      },
      m: function mount(target, anchor) {
        insert_dev(target, svelte_element, anchor);
        append_dev(svelte_element, button);
        if (if_block) if_block.m(button, null);
        append_dev(button, t0);
        append_dev(button, slot);
        append_dev(button, t1);
        append_dev(button, span);

        if (!mounted) {
          dispose = listen_dev(button, "click",
          /*toggleAffichageContenu*/
          ctx[6], false, false, false);
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (
        /*titre*/
        ctx[1]) {
          if (if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block = create_if_block_2$1(ctx);
            if_block.c();
            if_block.m(button, t0);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }

        if (dirty &
        /*estReduit*/
        16 && button_aria_expanded_value !== (button_aria_expanded_value = !
        /*estReduit*/
        ctx[4])) {
          attr_dev(button, "aria-expanded", button_aria_expanded_value);
        }

        set_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [{
          class: "titre"
        }]));
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(svelte_element);
        if (if_block) if_block.d();
        mounted = false;
        dispose();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_dynamic_element.name,
      type: "child_dynamic_element",
      source: "(82:4) <svelte:element this={tagTitre} class=\\\"titre\\\">",
      ctx: ctx
    });
    return block;
  } // (103:4) {#if extensible === 'false' || !estReduit}


  function create_if_block$4(ctx) {
    var div;
    var slot;
    var div_transition;
    var current;
    var block = {
      c: function create() {
        div = element("div");
        slot = element("slot");
        add_location(slot, file$4, 104, 6, 3262);
        add_location(div, file$4, 103, 4, 3213);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        append_dev(div, slot);
        current = true;
      },
      i: function intro(local) {
        if (current) return;
        add_render_callback(function () {
          if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {
            duration: 250
          }, true);
          div_transition.run(1);
        });
        current = true;
      },
      o: function outro(local) {
        if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {
          duration: 250
        }, false);
        div_transition.run(0);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
        if (detaching && div_transition) div_transition.end();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block$4.name,
      type: "if",
      source: "(103:4) {#if extensible === 'false' || !estReduit}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment$4(ctx) {
    var div2;
    var div0;
    var t0;
    var div1;
    var div2_class_value;
    var t1;
    var link;
    var current;

    function select_block_type(ctx, dirty) {
      if (
      /*extensible*/
      ctx[0] === 'true') return create_if_block_1$1;
      return create_else_block;
    }

    var current_block_type = select_block_type(ctx);
    var if_block0 = current_block_type(ctx);
    var if_block1 = (
    /*extensible*/
    ctx[0] === 'false' || !
    /*estReduit*/
    ctx[4]) && create_if_block$4(ctx);
    var block = {
      c: function create() {
        div2 = element("div");
        div0 = element("div");
        if_block0.c();
        t0 = space();
        div1 = element("div");
        if (if_block1) if_block1.c();
        t1 = space();
        link = element("link");
        this.c = noop;
        attr_dev(div0, "class", "entete");
        add_location(div0, file$4, 79, 2, 2455);
        attr_dev(div1, "id",
        /*idContenu*/
        ctx[5]);
        attr_dev(div1, "class", "contenu");
        add_location(div1, file$4, 101, 2, 3120);
        attr_dev(div2, "class", div2_class_value = "utd-component utd-section" + (
        /*extensible*/
        ctx[0] === 'true' ? ' extensible' : '') + (!
        /*estReduit*/
        ctx[4] ? ' ouvert' : '') + (
        /*bordure*/
        ctx[2] === 'true' ? ' bordure' : ''));
        add_location(div2, file$4, 78, 0, 2300);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", Utils.cssFullPath);
        add_location(link, file$4, 111, 0, 3316);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div2, anchor);
        append_dev(div2, div0);
        if_block0.m(div0, null);
        append_dev(div2, t0);
        append_dev(div2, div1);
        if (if_block1) if_block1.m(div1, null);
        insert_dev(target, t1, anchor);
        insert_dev(target, link, anchor);
        current = true;
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0.d(1);
          if_block0 = current_block_type(ctx);

          if (if_block0) {
            if_block0.c();
            if_block0.m(div0, null);
          }
        }

        if (
        /*extensible*/
        ctx[0] === 'false' || !
        /*estReduit*/
        ctx[4]) {
          if (if_block1) {
            if (dirty &
            /*extensible, estReduit*/
            17) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block$4(ctx);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(div1, null);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, function () {
            if_block1 = null;
          });
          check_outros();
        }

        if (!current || dirty &
        /*extensible, estReduit, bordure*/
        21 && div2_class_value !== (div2_class_value = "utd-component utd-section" + (
        /*extensible*/
        ctx[0] === 'true' ? ' extensible' : '') + (!
        /*estReduit*/
        ctx[4] ? ' ouvert' : '') + (
        /*bordure*/
        ctx[2] === 'true' ? ' bordure' : ''))) {
          attr_dev(div2, "class", div2_class_value);
        }
      },
      i: function intro(local) {
        if (current) return;
        transition_in(if_block1);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block1);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div2);
        if_block0.d();
        if (if_block1) if_block1.d();
        if (detaching) detach_dev(t1);
        if (detaching) detach_dev(link);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$4.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function instance$4($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-section', slots, []);
    var _$$props$extensible = $$props.extensible,
        extensible = _$$props$extensible === void 0 ? "true" : _$$props$extensible;
    var _$$props$reduit = $$props.reduit,
        reduit = _$$props$reduit === void 0 ? "true" : _$$props$reduit;
    var _$$props$titre = $$props.titre,
        titre = _$$props$titre === void 0 ? "" : _$$props$titre;
    var _$$props$bordure = $$props.bordure,
        bordure = _$$props$bordure === void 0 ? "true" : _$$props$bordure;
    var _$$props$tagTitre = $$props.tagTitre,
        tagTitre = _$$props$tagTitre === void 0 ? "h2" : _$$props$tagTitre;
    var _$$props$conserverEta = $$props.conserverEtatAffichage,
        conserverEtatAffichage = _$$props$conserverEta === void 0 ? "false" : _$$props$conserverEta;
    var idEntete = Utils.genererId();
    var idContenu = 'corps' + idEntete;
    var thisComponent = get_current_component();
    var estReduit = reduit === 'true' ? true : false;
    var mounted = false; //TODO éventuellement déterminer automatiquement le niveau de header via un script? 

    onMount(function () {
      definirEtatAffichageInitial();
      Utils.reafficherApresChargement(thisComponent);
      mounted = true;
    });

    function gererEtatAffichage() {
      if (!mounted) {
        return;
      }

      $$invalidate(4, estReduit = reduit === 'true' ? true : false);
      conserverEtatAffichageSession();
      Utils.dispatchWcEvent(thisComponent, "changementEtat", {
        reduit: estReduit
      });
    }

    function definirEtatAffichageInitial() {
      if (conserverEtatAffichage === 'true') {
        if (thisComponent.id) {
          var valeur = sessionStorage.getItem(thisComponent.id); //Si null (clé non trouvée dans le session storage, on va utiliser la valeur par défaut reçue en paramètre, sinon on l'écrase avec celle du session storage)

          if (valeur !== null) {
            if (valeur === '1') {
              thisComponent.setAttribute('reduit', 'false');
            } else {
              thisComponent.setAttribute('reduit', 'true');
            }
          }
        }
      }

      $$invalidate(4, estReduit = reduit === 'true' ? true : false);
      conserverEtatAffichageSession();
    }

    function conserverEtatAffichageSession() {
      if (conserverEtatAffichage === 'true' && thisComponent.id) {
        sessionStorage.setItem(thisComponent.id, estReduit ? '0' : '1');
      }
    }

    function toggleAffichageContenu() {
      thisComponent.setAttribute('reduit', estReduit ? 'false' : 'true');
    }

    var writable_props = ['extensible', 'reduit', 'titre', 'bordure', 'tagTitre', 'conserverEtatAffichage'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-section> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('extensible' in $$props) $$invalidate(0, extensible = $$props.extensible);
      if ('reduit' in $$props) $$invalidate(7, reduit = $$props.reduit);
      if ('titre' in $$props) $$invalidate(1, titre = $$props.titre);
      if ('bordure' in $$props) $$invalidate(2, bordure = $$props.bordure);
      if ('tagTitre' in $$props) $$invalidate(3, tagTitre = $$props.tagTitre);
      if ('conserverEtatAffichage' in $$props) $$invalidate(8, conserverEtatAffichage = $$props.conserverEtatAffichage);
    };

    $$self.$capture_state = function () {
      return {
        slide: slide,
        Utils: Utils,
        onMount: onMount,
        get_current_component: get_current_component,
        extensible: extensible,
        reduit: reduit,
        titre: titre,
        bordure: bordure,
        tagTitre: tagTitre,
        conserverEtatAffichage: conserverEtatAffichage,
        idEntete: idEntete,
        idContenu: idContenu,
        thisComponent: thisComponent,
        estReduit: estReduit,
        mounted: mounted,
        gererEtatAffichage: gererEtatAffichage,
        definirEtatAffichageInitial: definirEtatAffichageInitial,
        conserverEtatAffichageSession: conserverEtatAffichageSession,
        toggleAffichageContenu: toggleAffichageContenu
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('extensible' in $$props) $$invalidate(0, extensible = $$props.extensible);
      if ('reduit' in $$props) $$invalidate(7, reduit = $$props.reduit);
      if ('titre' in $$props) $$invalidate(1, titre = $$props.titre);
      if ('bordure' in $$props) $$invalidate(2, bordure = $$props.bordure);
      if ('tagTitre' in $$props) $$invalidate(3, tagTitre = $$props.tagTitre);
      if ('conserverEtatAffichage' in $$props) $$invalidate(8, conserverEtatAffichage = $$props.conserverEtatAffichage);
      if ('estReduit' in $$props) $$invalidate(4, estReduit = $$props.estReduit);
      if ('mounted' in $$props) mounted = $$props.mounted;
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    $$self.$$.update = function () {
      if ($$self.$$.dirty &
      /*reduit*/
      128) {
        gererEtatAffichage();
      }
    };

    return [extensible, titre, bordure, tagTitre, estReduit, idContenu, toggleAffichageContenu, reduit, conserverEtatAffichage];
  }

  var Section = /*#__PURE__*/function (_SvelteElement) {
    _inherits(Section, _SvelteElement);

    var _super = _createSuper$4(Section);

    function Section(options) {
      var _this;

      _classCallCheck(this, Section);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$4, create_fragment$4, safe_not_equal, {
        extensible: 0,
        reduit: 7,
        titre: 1,
        bordure: 2,
        tagTitre: 3,
        conserverEtatAffichage: 8
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(Section, [{
      key: "extensible",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(extensible) {
        this.$$set({
          extensible: extensible
        });
        flush();
      }
    }, {
      key: "reduit",
      get: function get() {
        return this.$$.ctx[7];
      },
      set: function set(reduit) {
        this.$$set({
          reduit: reduit
        });
        flush();
      }
    }, {
      key: "titre",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(titre) {
        this.$$set({
          titre: titre
        });
        flush();
      }
    }, {
      key: "bordure",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(bordure) {
        this.$$set({
          bordure: bordure
        });
        flush();
      }
    }, {
      key: "tagTitre",
      get: function get() {
        return this.$$.ctx[3];
      },
      set: function set(tagTitre) {
        this.$$set({
          tagTitre: tagTitre
        });
        flush();
      }
    }, {
      key: "conserverEtatAffichage",
      get: function get() {
        return this.$$.ctx[8];
      },
      set: function set(conserverEtatAffichage) {
        this.$$set({
          conserverEtatAffichage: conserverEtatAffichage
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["extensible", "reduit", "titre", "bordure", "tagTitre", "conserverEtatAffichage"];
      }
    }]);

    return Section;
  }(SvelteElement);

  customElements.define("utd-section", Section);

  function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$3 = "src\\components\\menuAncres.svelte";

  function get_each_context(ctx, list, i) {
    var child_ctx = ctx.slice();
    child_ctx[5] = list[i];
    return child_ctx;
  } // (38:0) {#if ancres && ancres.length}


  function create_if_block$3(ctx) {
    var div;
    var h2;
    var t0;
    var t1;
    var nav;
    var ul;
    var each_value =
    /*ancres*/
    ctx[1];
    validate_each_argument(each_value);
    var each_blocks = [];

    for (var i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    }

    var block = {
      c: function create() {
        div = element("div");
        h2 = element("h2");
        t0 = text(
        /*titre*/
        ctx[0]);
        t1 = space();
        nav = element("nav");
        ul = element("ul");

        for (var _i = 0; _i < each_blocks.length; _i += 1) {
          each_blocks[_i].c();
        }

        attr_dev(h2, "id", "titreTableMatieres");
        add_location(h2, file$3, 39, 4, 952);
        add_location(ul, file$3, 41, 6, 1049);
        attr_dev(nav, "aria-describedby", "titreTableMatieres");
        add_location(nav, file$3, 40, 4, 998);
        attr_dev(div, "class", "utd-component utd-menu-ancres");
        add_location(div, file$3, 38, 2, 903);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        append_dev(div, h2);
        append_dev(h2, t0);
        append_dev(div, t1);
        append_dev(div, nav);
        append_dev(nav, ul);

        for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
          each_blocks[_i2].m(ul, null);
        }
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*titre*/
        1) set_data_dev(t0,
        /*titre*/
        ctx[0]);

        if (dirty &
        /*ancres*/
        2) {
          each_value =
          /*ancres*/
          ctx[1];
          validate_each_argument(each_value);

          var _i3;

          for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
            var child_ctx = get_each_context(ctx, each_value, _i3);

            if (each_blocks[_i3]) {
              each_blocks[_i3].p(child_ctx, dirty);
            } else {
              each_blocks[_i3] = create_each_block(child_ctx);

              each_blocks[_i3].c();

              each_blocks[_i3].m(ul, null);
            }
          }

          for (; _i3 < each_blocks.length; _i3 += 1) {
            each_blocks[_i3].d(1);
          }

          each_blocks.length = each_value.length;
        }
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
        destroy_each(each_blocks, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block$3.name,
      type: "if",
      source: "(38:0) {#if ancres && ancres.length}",
      ctx: ctx
    });
    return block;
  } // (43:8) {#each ancres as ancre}


  function create_each_block(ctx) {
    var li;
    var a;
    var t0_value =
    /*ancre*/
    ctx[5].textContent + "";
    var t0;
    var a_href_value;
    var t1;
    var block = {
      c: function create() {
        li = element("li");
        a = element("a");
        t0 = text(t0_value);
        t1 = space();
        attr_dev(a, "href", a_href_value = "#" +
        /*ancre*/
        ctx[5].id);
        add_location(a, file$3, 44, 12, 1116);
        add_location(li, file$3, 43, 10, 1098);
      },
      m: function mount(target, anchor) {
        insert_dev(target, li, anchor);
        append_dev(li, a);
        append_dev(a, t0);
        append_dev(li, t1);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*ancres*/
        2 && t0_value !== (t0_value =
        /*ancre*/
        ctx[5].textContent + "")) set_data_dev(t0, t0_value);

        if (dirty &
        /*ancres*/
        2 && a_href_value !== (a_href_value = "#" +
        /*ancre*/
        ctx[5].id)) {
          attr_dev(a, "href", a_href_value);
        }
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(li);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_each_block.name,
      type: "each",
      source: "(43:8) {#each ancres as ancre}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment$3(ctx) {
    var t;
    var link;
    var if_block =
    /*ancres*/
    ctx[1] &&
    /*ancres*/
    ctx[1].length && create_if_block$3(ctx);
    var block = {
      c: function create() {
        if (if_block) if_block.c();
        t = space();
        link = element("link");
        this.c = noop;
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", Utils.cssFullPath);
        add_location(link, file$3, 52, 0, 1265);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (if_block) if_block.m(target, anchor);
        insert_dev(target, t, anchor);
        insert_dev(target, link, anchor);
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        if (
        /*ancres*/
        ctx[1] &&
        /*ancres*/
        ctx[1].length) {
          if (if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block = create_if_block$3(ctx);
            if_block.c();
            if_block.m(t.parentNode, t);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (if_block) if_block.d(detaching);
        if (detaching) detach_dev(t);
        if (detaching) detach_dev(link);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$3.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function instance$3($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-menu-ancres', slots, []);
    var _$$props$titre = $$props.titre,
        titre = _$$props$titre === void 0 ? Utils.obtenirLanguePage() === 'fr' ? "Dans cette page :" : "On this page:" : _$$props$titre;
    var _$$props$selecteur = $$props.selecteur,
        selecteur = _$$props$selecteur === void 0 ? '.ancre' : _$$props$selecteur;
    var ancres;
    var thisComponent = get_current_component();
    onMount(function () {
      $$invalidate(1, ancres = obtenirAncres());
      Utils.reafficherApresChargement(thisComponent);
    });

    function obtenirAncres() {
      var ancres = document.querySelectorAll(selecteur); //Ajouter un id aux ancres qui n'en n'auraient pas

      ancres.forEach(function (ancre) {
        if (!ancre.id) {
          ancre.id = Utils.genererId();
        }
      });
      return ancres;
    }

    var writable_props = ['titre', 'selecteur'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-menu-ancres> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
      if ('selecteur' in $$props) $$invalidate(2, selecteur = $$props.selecteur);
    };

    $$self.$capture_state = function () {
      return {
        onMount: onMount,
        Utils: Utils,
        get_current_component: get_current_component,
        titre: titre,
        selecteur: selecteur,
        ancres: ancres,
        thisComponent: thisComponent,
        obtenirAncres: obtenirAncres
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
      if ('selecteur' in $$props) $$invalidate(2, selecteur = $$props.selecteur);
      if ('ancres' in $$props) $$invalidate(1, ancres = $$props.ancres);
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    return [titre, ancres, selecteur];
  }

  var MenuAncres = /*#__PURE__*/function (_SvelteElement) {
    _inherits(MenuAncres, _SvelteElement);

    var _super = _createSuper$3(MenuAncres);

    function MenuAncres(options) {
      var _this;

      _classCallCheck(this, MenuAncres);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$3, create_fragment$3, safe_not_equal, {
        titre: 0,
        selecteur: 2
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(MenuAncres, [{
      key: "titre",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(titre) {
        this.$$set({
          titre: titre
        });
        flush();
      }
    }, {
      key: "selecteur",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(selecteur) {
        this.$$set({
          selecteur: selecteur
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["titre", "selecteur"];
      }
    }]);

    return MenuAncres;
  }(SvelteElement);

  customElements.define("utd-menu-ancres", MenuAncres);

  function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$2 = "src\\components\\pivEntete.svelte"; // (41:0) {#if passerContenu === 'true'}

  function create_if_block_9(ctx) {
    var div1;
    var div0;
    var a;
    var t;
    var mounted;
    var dispose;
    var block = {
      c: function create() {
        div1 = element("div");
        div0 = element("div");
        a = element("a");
        t = text(
        /*textePasserContenu*/
        ctx[12]);
        attr_dev(a, "href",
        /*urlPasserContenu*/
        ctx[11]);
        attr_dev(a, "class", "utd-passer-contenu");
        add_location(a, file$2, 43, 8, 1544);
        attr_dev(div0, "class", "utd-passer-contenu");
        add_location(div0, file$2, 42, 4, 1502);
        attr_dev(div1, "class", "utd-conteneur-passer-contenu");
        add_location(div1, file$2, 41, 2, 1454);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div1, anchor);
        append_dev(div1, div0);
        append_dev(div0, a);
        append_dev(a, t);

        if (!mounted) {
          dispose = listen_dev(a, "click",
          /*clickLien*/
          ctx[15], false, false, false);
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*textePasserContenu*/
        4096) set_data_dev(t,
        /*textePasserContenu*/
        ctx[12]);

        if (dirty &
        /*urlPasserContenu*/
        2048) {
          attr_dev(a, "href",
          /*urlPasserContenu*/
          ctx[11]);
        }
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div1);
        mounted = false;
        dispose();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_9.name,
      type: "if",
      source: "(41:0) {#if passerContenu === 'true'}",
      ctx: ctx
    });
    return block;
  } // (60:10) {#if titreSite2}


  function create_if_block_8(ctx) {
    var span;
    var t;
    var block = {
      c: function create() {
        span = element("span");
        t = text(
        /*titreSite2*/
        ctx[4]);
        attr_dev(span, "class", "description");
        add_location(span, file$2, 60, 12, 2141);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
        append_dev(span, t);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*titreSite2*/
        16) set_data_dev(t,
        /*titreSite2*/
        ctx[4]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(span);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_8.name,
      type: "if",
      source: "(60:10) {#if titreSite2}",
      ctx: ctx
    });
    return block;
  } // (67:8) {#if Utils.slotExiste(slots, 'boutonRecherche')}


  function create_if_block_7(ctx) {
    var div;
    var slot;
    var block = {
      c: function create() {
        div = element("div");
        slot = element("slot");
        attr_dev(slot, "name", "boutonRecherche");
        add_location(slot, file$2, 68, 12, 2394);
        attr_dev(div, "class", "bouton-recherche");
        add_location(div, file$2, 67, 10, 2350);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        append_dev(div, slot);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_7.name,
      type: "if",
      source: "(67:8) {#if Utils.slotExiste(slots, 'boutonRecherche')}",
      ctx: ctx
    });
    return block;
  } // (77:10) {#if urlNousJoindre || urlLangueAlternative}


  function create_if_block_4(ctx) {
    var ul;
    var t;
    var if_block0 =
    /*urlLangueAlternative*/
    ctx[7] && create_if_block_6(ctx);
    var if_block1 =
    /*urlNousJoindre*/
    ctx[9] && create_if_block_5(ctx);
    var block = {
      c: function create() {
        ul = element("ul");
        if (if_block0) if_block0.c();
        t = space();
        if (if_block1) if_block1.c();
        add_location(ul, file$2, 77, 12, 2642);
      },
      m: function mount(target, anchor) {
        insert_dev(target, ul, anchor);
        if (if_block0) if_block0.m(ul, null);
        append_dev(ul, t);
        if (if_block1) if_block1.m(ul, null);
      },
      p: function update(ctx, dirty) {
        if (
        /*urlLangueAlternative*/
        ctx[7]) {
          if (if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0 = create_if_block_6(ctx);
            if_block0.c();
            if_block0.m(ul, t);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }

        if (
        /*urlNousJoindre*/
        ctx[9]) {
          if (if_block1) {
            if_block1.p(ctx, dirty);
          } else {
            if_block1 = create_if_block_5(ctx);
            if_block1.c();
            if_block1.m(ul, null);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(ul);
        if (if_block0) if_block0.d();
        if (if_block1) if_block1.d();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_4.name,
      type: "if",
      source: "(77:10) {#if urlNousJoindre || urlLangueAlternative}",
      ctx: ctx
    });
    return block;
  } // (74:8) {#if Utils.slotExiste(slots, 'liens')}


  function create_if_block_3(ctx) {
    var slot;
    var block = {
      c: function create() {
        slot = element("slot");
        attr_dev(slot, "name", "liens");
        add_location(slot, file$2, 74, 10, 2530);
      },
      m: function mount(target, anchor) {
        insert_dev(target, slot, anchor);
      },
      p: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(slot);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_3.name,
      type: "if",
      source: "(74:8) {#if Utils.slotExiste(slots, 'liens')}",
      ctx: ctx
    });
    return block;
  } // (79:14) {#if urlLangueAlternative}


  function create_if_block_6(ctx) {
    var li;
    var a;
    var t;
    var block = {
      c: function create() {
        li = element("li");
        a = element("a");
        t = text(
        /*texteLangueAlternative*/
        ctx[6]);
        attr_dev(a, "href",
        /*urlLangueAlternative*/
        ctx[7]);
        add_location(a, file$2, 79, 20, 2710);
        add_location(li, file$2, 79, 16, 2706);
      },
      m: function mount(target, anchor) {
        insert_dev(target, li, anchor);
        append_dev(li, a);
        append_dev(a, t);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*texteLangueAlternative*/
        64) set_data_dev(t,
        /*texteLangueAlternative*/
        ctx[6]);

        if (dirty &
        /*urlLangueAlternative*/
        128) {
          attr_dev(a, "href",
          /*urlLangueAlternative*/
          ctx[7]);
        }
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(li);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_6.name,
      type: "if",
      source: "(79:14) {#if urlLangueAlternative}",
      ctx: ctx
    });
    return block;
  } // (82:14) {#if urlNousJoindre}


  function create_if_block_5(ctx) {
    var li;
    var a;
    var t;
    var block = {
      c: function create() {
        li = element("li");
        a = element("a");
        t = text(
        /*texteNousJoindre*/
        ctx[8]);
        attr_dev(a, "href",
        /*urlNousJoindre*/
        ctx[9]);
        add_location(a, file$2, 82, 20, 2871);
        add_location(li, file$2, 82, 16, 2867);
      },
      m: function mount(target, anchor) {
        insert_dev(target, li, anchor);
        append_dev(li, a);
        append_dev(a, t);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*texteNousJoindre*/
        256) set_data_dev(t,
        /*texteNousJoindre*/
        ctx[8]);

        if (dirty &
        /*urlNousJoindre*/
        512) {
          attr_dev(a, "href",
          /*urlNousJoindre*/
          ctx[9]);
        }
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(li);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_5.name,
      type: "if",
      source: "(82:14) {#if urlNousJoindre}",
      ctx: ctx
    });
    return block;
  } // (93:8) {#if titreSite2}


  function create_if_block_2(ctx) {
    var span;
    var t;
    var block = {
      c: function create() {
        span = element("span");
        t = text(
        /*titreSite2*/
        ctx[4]);
        attr_dev(span, "class", "description");
        add_location(span, file$2, 93, 10, 3180);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
        append_dev(span, t);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*titreSite2*/
        16) set_data_dev(t,
        /*titreSite2*/
        ctx[4]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(span);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_2.name,
      type: "if",
      source: "(93:8) {#if titreSite2}",
      ctx: ctx
    });
    return block;
  } // (98:6) {#if Utils.slotExiste(slots, 'boutonRechercheMobile')}


  function create_if_block_1(ctx) {
    var div;
    var slot;
    var block = {
      c: function create() {
        div = element("div");
        slot = element("slot");
        attr_dev(slot, "name", "boutonRechercheMobile");
        add_location(slot, file$2, 99, 10, 3372);
        attr_dev(div, "class", "bouton-recherche");
        add_location(div, file$2, 98, 8, 3330);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        append_dev(div, slot);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_1.name,
      type: "if",
      source: "(98:6) {#if Utils.slotExiste(slots, 'boutonRechercheMobile')}",
      ctx: ctx
    });
    return block;
  } // (104:4) {#if Utils.slotExiste(slots, 'zoneRecherche')}


  function create_if_block$2(ctx) {
    var div;
    var slot;
    var block = {
      c: function create() {
        div = element("div");
        slot = element("slot");
        attr_dev(slot, "name", "zoneRecherche");
        add_location(slot, file$2, 105, 8, 3566);
        attr_dev(div, "class", "zone-recherche");
        add_location(div, file$2, 104, 6, 3528);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        append_dev(div, slot);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block$2.name,
      type: "if",
      source: "(104:4) {#if Utils.slotExiste(slots, 'zoneRecherche')}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment$2(ctx) {
    var t0;
    var div7;
    var div6;
    var div3;
    var div0;
    var a0;
    var img;
    var img_src_value;
    var t1;
    var div1;
    var a1;
    var span0;
    var t2;
    var t3;
    var t4;
    var div2;
    var show_if_3 = Utils.slotExiste(
    /*slots*/
    ctx[13], 'boutonRecherche');
    var t5;
    var show_if_2;
    var t6;
    var div5;
    var div4;
    var span1;
    var t7;
    var t8;
    var t9;
    var show_if_1 = Utils.slotExiste(
    /*slots*/
    ctx[13], 'boutonRechercheMobile');
    var t10;
    var show_if = Utils.slotExiste(
    /*slots*/
    ctx[13], 'zoneRecherche');
    var t11;
    var link;
    var if_block0 =
    /*passerContenu*/
    ctx[10] === 'true' && create_if_block_9(ctx);
    var if_block1 =
    /*titreSite2*/
    ctx[4] && create_if_block_8(ctx);
    var if_block2 = show_if_3 && create_if_block_7(ctx);

    function select_block_type(ctx, dirty) {
      if (dirty &
      /*slots*/
      8192) show_if_2 = null;
      if (show_if_2 == null) show_if_2 = !!Utils.slotExiste(
      /*slots*/
      ctx[13], 'liens');
      if (show_if_2) return create_if_block_3;
      if (
      /*urlNousJoindre*/
      ctx[9] ||
      /*urlLangueAlternative*/
      ctx[7]) return create_if_block_4;
    }

    var current_block_type = select_block_type(ctx, -1);
    var if_block3 = current_block_type && current_block_type(ctx);
    var if_block4 =
    /*titreSite2*/
    ctx[4] && create_if_block_2(ctx);
    var if_block5 = show_if_1 && create_if_block_1(ctx);
    var if_block6 = show_if && create_if_block$2(ctx);
    var block = {
      c: function create() {
        if (if_block0) if_block0.c();
        t0 = space();
        div7 = element("div");
        div6 = element("div");
        div3 = element("div");
        div0 = element("div");
        a0 = element("a");
        img = element("img");
        t1 = space();
        div1 = element("div");
        a1 = element("a");
        span0 = element("span");
        t2 = text(
        /*titreSite1*/
        ctx[3]);
        t3 = space();
        if (if_block1) if_block1.c();
        t4 = space();
        div2 = element("div");
        if (if_block2) if_block2.c();
        t5 = space();
        if (if_block3) if_block3.c();
        t6 = space();
        div5 = element("div");
        div4 = element("div");
        span1 = element("span");
        t7 = text(
        /*titreSite1*/
        ctx[3]);
        t8 = space();
        if (if_block4) if_block4.c();
        t9 = space();
        if (if_block5) if_block5.c();
        t10 = space();
        if (if_block6) if_block6.c();
        t11 = space();
        link = element("link");
        this.c = noop;
        attr_dev(img, "alt",
        /*altLogo*/
        ctx[2]);
        if (!src_url_equal(img.src, img_src_value =
        /*srcLogo*/
        ctx[1])) attr_dev(img, "src", img_src_value);
        add_location(img, file$2, 53, 10, 1907);
        attr_dev(a0, "href",
        /*urlLogo*/
        ctx[0]);
        add_location(a0, file$2, 52, 8, 1875);
        attr_dev(div0, "class", "section-gauche signature-gouvernement");
        add_location(div0, file$2, 51, 6, 1814);
        add_location(span0, file$2, 58, 10, 2074);
        attr_dev(a1, "href",
        /*urlTitreSite*/
        ctx[5]);
        attr_dev(a1, "class", "titre-site");
        add_location(a1, file$2, 57, 8, 2018);
        attr_dev(div1, "class", "section-centre");
        add_location(div1, file$2, 56, 6, 1980);
        attr_dev(div2, "class", "section-droite");
        add_location(div2, file$2, 65, 6, 2252);
        attr_dev(div3, "class", "conteneur-sections");
        add_location(div3, file$2, 50, 4, 1774);
        add_location(span1, file$2, 91, 8, 3117);
        attr_dev(div4, "class", "titre-site");
        add_location(div4, file$2, 90, 6, 3083);
        attr_dev(div5, "class", "zone-titre-recherche");
        add_location(div5, file$2, 89, 4, 3041);
        attr_dev(div6, "class", "utd-container");
        add_location(div6, file$2, 49, 2, 1741);
        attr_dev(div7, "class", "utd-piv-entete");
        toggle_class(div7, "utd-d-none", !
        /*mounted*/
        ctx[14]);
        add_location(div7, file$2, 48, 0, 1681);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", Utils.cssFullPath);
        add_location(link, file$2, 114, 0, 3656);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (if_block0) if_block0.m(target, anchor);
        insert_dev(target, t0, anchor);
        insert_dev(target, div7, anchor);
        append_dev(div7, div6);
        append_dev(div6, div3);
        append_dev(div3, div0);
        append_dev(div0, a0);
        append_dev(a0, img);
        append_dev(div3, t1);
        append_dev(div3, div1);
        append_dev(div1, a1);
        append_dev(a1, span0);
        append_dev(span0, t2);
        append_dev(a1, t3);
        if (if_block1) if_block1.m(a1, null);
        append_dev(div3, t4);
        append_dev(div3, div2);
        if (if_block2) if_block2.m(div2, null);
        append_dev(div2, t5);
        if (if_block3) if_block3.m(div2, null);
        append_dev(div6, t6);
        append_dev(div6, div5);
        append_dev(div5, div4);
        append_dev(div4, span1);
        append_dev(span1, t7);
        append_dev(div4, t8);
        if (if_block4) if_block4.m(div4, null);
        append_dev(div5, t9);
        if (if_block5) if_block5.m(div5, null);
        append_dev(div6, t10);
        if (if_block6) if_block6.m(div6, null);
        insert_dev(target, t11, anchor);
        insert_dev(target, link, anchor);
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        if (
        /*passerContenu*/
        ctx[10] === 'true') {
          if (if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0 = create_if_block_9(ctx);
            if_block0.c();
            if_block0.m(t0.parentNode, t0);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }

        if (dirty &
        /*altLogo*/
        4) {
          attr_dev(img, "alt",
          /*altLogo*/
          ctx[2]);
        }

        if (dirty &
        /*srcLogo*/
        2 && !src_url_equal(img.src, img_src_value =
        /*srcLogo*/
        ctx[1])) {
          attr_dev(img, "src", img_src_value);
        }

        if (dirty &
        /*urlLogo*/
        1) {
          attr_dev(a0, "href",
          /*urlLogo*/
          ctx[0]);
        }

        if (dirty &
        /*titreSite1*/
        8) set_data_dev(t2,
        /*titreSite1*/
        ctx[3]);

        if (
        /*titreSite2*/
        ctx[4]) {
          if (if_block1) {
            if_block1.p(ctx, dirty);
          } else {
            if_block1 = create_if_block_8(ctx);
            if_block1.c();
            if_block1.m(a1, null);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }

        if (dirty &
        /*urlTitreSite*/
        32) {
          attr_dev(a1, "href",
          /*urlTitreSite*/
          ctx[5]);
        }

        if (dirty &
        /*slots*/
        8192) show_if_3 = Utils.slotExiste(
        /*slots*/
        ctx[13], 'boutonRecherche');

        if (show_if_3) {
          if (if_block2) ; else {
            if_block2 = create_if_block_7(ctx);
            if_block2.c();
            if_block2.m(div2, t5);
          }
        } else if (if_block2) {
          if_block2.d(1);
          if_block2 = null;
        }

        if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block3) {
          if_block3.p(ctx, dirty);
        } else {
          if (if_block3) if_block3.d(1);
          if_block3 = current_block_type && current_block_type(ctx);

          if (if_block3) {
            if_block3.c();
            if_block3.m(div2, null);
          }
        }

        if (dirty &
        /*titreSite1*/
        8) set_data_dev(t7,
        /*titreSite1*/
        ctx[3]);

        if (
        /*titreSite2*/
        ctx[4]) {
          if (if_block4) {
            if_block4.p(ctx, dirty);
          } else {
            if_block4 = create_if_block_2(ctx);
            if_block4.c();
            if_block4.m(div4, null);
          }
        } else if (if_block4) {
          if_block4.d(1);
          if_block4 = null;
        }

        if (dirty &
        /*slots*/
        8192) show_if_1 = Utils.slotExiste(
        /*slots*/
        ctx[13], 'boutonRechercheMobile');

        if (show_if_1) {
          if (if_block5) ; else {
            if_block5 = create_if_block_1(ctx);
            if_block5.c();
            if_block5.m(div5, null);
          }
        } else if (if_block5) {
          if_block5.d(1);
          if_block5 = null;
        }

        if (dirty &
        /*slots*/
        8192) show_if = Utils.slotExiste(
        /*slots*/
        ctx[13], 'zoneRecherche');

        if (show_if) {
          if (if_block6) ; else {
            if_block6 = create_if_block$2(ctx);
            if_block6.c();
            if_block6.m(div6, null);
          }
        } else if (if_block6) {
          if_block6.d(1);
          if_block6 = null;
        }

        if (dirty &
        /*mounted*/
        16384) {
          toggle_class(div7, "utd-d-none", !
          /*mounted*/
          ctx[14]);
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (if_block0) if_block0.d(detaching);
        if (detaching) detach_dev(t0);
        if (detaching) detach_dev(div7);
        if (if_block1) if_block1.d();
        if (if_block2) if_block2.d();

        if (if_block3) {
          if_block3.d();
        }

        if (if_block4) if_block4.d();
        if (if_block5) if_block5.d();
        if (if_block6) if_block6.d();
        if (detaching) detach_dev(t11);
        if (detaching) detach_dev(link);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$2.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function instance$2($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots$1 = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-piv-entete', slots$1, []);
    var _$$props$urlLogo = $$props.urlLogo,
        urlLogo = _$$props$urlLogo === void 0 ? '/' : _$$props$urlLogo;
    var _$$props$srcLogo = $$props.srcLogo,
        srcLogo = _$$props$srcLogo === void 0 ? "".concat(Utils.imagesRelativePath, "utd-sprite.svg?v=1.11.0#QUEBEC_blanc") : _$$props$srcLogo;
    var _$$props$altLogo = $$props.altLogo,
        altLogo = _$$props$altLogo === void 0 ? Utils.obtenirLanguePage() === 'fr' ? 'Signature du gouvernement du Québec.' : 'Québec government signature.' : _$$props$altLogo;
    var _$$props$titreSite = $$props.titreSite1,
        titreSite1 = _$$props$titreSite === void 0 ? '' : _$$props$titreSite;
    var _$$props$titreSite2 = $$props.titreSite2,
        titreSite2 = _$$props$titreSite2 === void 0 ? '' : _$$props$titreSite2;
    var _$$props$urlTitreSite = $$props.urlTitreSite,
        urlTitreSite = _$$props$urlTitreSite === void 0 ? '/' : _$$props$urlTitreSite;
    var _$$props$texteLangueA = $$props.texteLangueAlternative,
        texteLangueAlternative = _$$props$texteLangueA === void 0 ? Utils.obtenirLanguePage() === 'fr' ? 'English' : 'Français' : _$$props$texteLangueA;
    var _$$props$urlLangueAlt = $$props.urlLangueAlternative,
        urlLangueAlternative = _$$props$urlLangueAlt === void 0 ? '' : _$$props$urlLangueAlt;
    var _$$props$texteNousJoi = $$props.texteNousJoindre,
        texteNousJoindre = _$$props$texteNousJoi === void 0 ? Utils.obtenirLanguePage() === 'fr' ? 'Nous joindre' : 'Contact us' : _$$props$texteNousJoi;
    var _$$props$urlNousJoind = $$props.urlNousJoindre,
        urlNousJoindre = _$$props$urlNousJoind === void 0 ? '' : _$$props$urlNousJoind;
    var _$$props$passerConten = $$props.passerContenu,
        passerContenu = _$$props$passerConten === void 0 ? 'true' : _$$props$passerConten;
    var _$$props$urlPasserCon = $$props.urlPasserContenu,
        urlPasserContenu = _$$props$urlPasserCon === void 0 ? '#main' : _$$props$urlPasserCon;
    var _$$props$textePasserC = $$props.textePasserContenu,
        textePasserContenu = _$$props$textePasserC === void 0 ? Utils.obtenirLanguePage() === 'fr' ? 'Passer au contenu' : 'Skip to content' : _$$props$textePasserC;
    var thisComponent = get_current_component();
    var slots = [];
    var mounted = false;
    onMount(function () {
      $$invalidate(13, slots = Array.from(thisComponent.querySelectorAll('[slot]')));
      $$invalidate(14, mounted = true);
      Utils.reafficherApresChargement(thisComponent);
    });

    function clickLien() {
      Utils.dispatchWcEvent(thisComponent, "clickLien");
    }

    var writable_props = ['urlLogo', 'srcLogo', 'altLogo', 'titreSite1', 'titreSite2', 'urlTitreSite', 'texteLangueAlternative', 'urlLangueAlternative', 'texteNousJoindre', 'urlNousJoindre', 'passerContenu', 'urlPasserContenu', 'textePasserContenu'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-piv-entete> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('urlLogo' in $$props) $$invalidate(0, urlLogo = $$props.urlLogo);
      if ('srcLogo' in $$props) $$invalidate(1, srcLogo = $$props.srcLogo);
      if ('altLogo' in $$props) $$invalidate(2, altLogo = $$props.altLogo);
      if ('titreSite1' in $$props) $$invalidate(3, titreSite1 = $$props.titreSite1);
      if ('titreSite2' in $$props) $$invalidate(4, titreSite2 = $$props.titreSite2);
      if ('urlTitreSite' in $$props) $$invalidate(5, urlTitreSite = $$props.urlTitreSite);
      if ('texteLangueAlternative' in $$props) $$invalidate(6, texteLangueAlternative = $$props.texteLangueAlternative);
      if ('urlLangueAlternative' in $$props) $$invalidate(7, urlLangueAlternative = $$props.urlLangueAlternative);
      if ('texteNousJoindre' in $$props) $$invalidate(8, texteNousJoindre = $$props.texteNousJoindre);
      if ('urlNousJoindre' in $$props) $$invalidate(9, urlNousJoindre = $$props.urlNousJoindre);
      if ('passerContenu' in $$props) $$invalidate(10, passerContenu = $$props.passerContenu);
      if ('urlPasserContenu' in $$props) $$invalidate(11, urlPasserContenu = $$props.urlPasserContenu);
      if ('textePasserContenu' in $$props) $$invalidate(12, textePasserContenu = $$props.textePasserContenu);
    };

    $$self.$capture_state = function () {
      return {
        onMount: onMount,
        Utils: Utils,
        get_current_component: get_current_component,
        urlLogo: urlLogo,
        srcLogo: srcLogo,
        altLogo: altLogo,
        titreSite1: titreSite1,
        titreSite2: titreSite2,
        urlTitreSite: urlTitreSite,
        texteLangueAlternative: texteLangueAlternative,
        urlLangueAlternative: urlLangueAlternative,
        texteNousJoindre: texteNousJoindre,
        urlNousJoindre: urlNousJoindre,
        passerContenu: passerContenu,
        urlPasserContenu: urlPasserContenu,
        textePasserContenu: textePasserContenu,
        thisComponent: thisComponent,
        slots: slots,
        mounted: mounted,
        clickLien: clickLien
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('urlLogo' in $$props) $$invalidate(0, urlLogo = $$props.urlLogo);
      if ('srcLogo' in $$props) $$invalidate(1, srcLogo = $$props.srcLogo);
      if ('altLogo' in $$props) $$invalidate(2, altLogo = $$props.altLogo);
      if ('titreSite1' in $$props) $$invalidate(3, titreSite1 = $$props.titreSite1);
      if ('titreSite2' in $$props) $$invalidate(4, titreSite2 = $$props.titreSite2);
      if ('urlTitreSite' in $$props) $$invalidate(5, urlTitreSite = $$props.urlTitreSite);
      if ('texteLangueAlternative' in $$props) $$invalidate(6, texteLangueAlternative = $$props.texteLangueAlternative);
      if ('urlLangueAlternative' in $$props) $$invalidate(7, urlLangueAlternative = $$props.urlLangueAlternative);
      if ('texteNousJoindre' in $$props) $$invalidate(8, texteNousJoindre = $$props.texteNousJoindre);
      if ('urlNousJoindre' in $$props) $$invalidate(9, urlNousJoindre = $$props.urlNousJoindre);
      if ('passerContenu' in $$props) $$invalidate(10, passerContenu = $$props.passerContenu);
      if ('urlPasserContenu' in $$props) $$invalidate(11, urlPasserContenu = $$props.urlPasserContenu);
      if ('textePasserContenu' in $$props) $$invalidate(12, textePasserContenu = $$props.textePasserContenu);
      if ('slots' in $$props) $$invalidate(13, slots = $$props.slots);
      if ('mounted' in $$props) $$invalidate(14, mounted = $$props.mounted);
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    return [urlLogo, srcLogo, altLogo, titreSite1, titreSite2, urlTitreSite, texteLangueAlternative, urlLangueAlternative, texteNousJoindre, urlNousJoindre, passerContenu, urlPasserContenu, textePasserContenu, slots, mounted, clickLien];
  }

  var PivEntete = /*#__PURE__*/function (_SvelteElement) {
    _inherits(PivEntete, _SvelteElement);

    var _super = _createSuper$2(PivEntete);

    function PivEntete(options) {
      var _this;

      _classCallCheck(this, PivEntete);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$2, create_fragment$2, safe_not_equal, {
        urlLogo: 0,
        srcLogo: 1,
        altLogo: 2,
        titreSite1: 3,
        titreSite2: 4,
        urlTitreSite: 5,
        texteLangueAlternative: 6,
        urlLangueAlternative: 7,
        texteNousJoindre: 8,
        urlNousJoindre: 9,
        passerContenu: 10,
        urlPasserContenu: 11,
        textePasserContenu: 12
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(PivEntete, [{
      key: "urlLogo",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(urlLogo) {
        this.$$set({
          urlLogo: urlLogo
        });
        flush();
      }
    }, {
      key: "srcLogo",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(srcLogo) {
        this.$$set({
          srcLogo: srcLogo
        });
        flush();
      }
    }, {
      key: "altLogo",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(altLogo) {
        this.$$set({
          altLogo: altLogo
        });
        flush();
      }
    }, {
      key: "titreSite1",
      get: function get() {
        return this.$$.ctx[3];
      },
      set: function set(titreSite1) {
        this.$$set({
          titreSite1: titreSite1
        });
        flush();
      }
    }, {
      key: "titreSite2",
      get: function get() {
        return this.$$.ctx[4];
      },
      set: function set(titreSite2) {
        this.$$set({
          titreSite2: titreSite2
        });
        flush();
      }
    }, {
      key: "urlTitreSite",
      get: function get() {
        return this.$$.ctx[5];
      },
      set: function set(urlTitreSite) {
        this.$$set({
          urlTitreSite: urlTitreSite
        });
        flush();
      }
    }, {
      key: "texteLangueAlternative",
      get: function get() {
        return this.$$.ctx[6];
      },
      set: function set(texteLangueAlternative) {
        this.$$set({
          texteLangueAlternative: texteLangueAlternative
        });
        flush();
      }
    }, {
      key: "urlLangueAlternative",
      get: function get() {
        return this.$$.ctx[7];
      },
      set: function set(urlLangueAlternative) {
        this.$$set({
          urlLangueAlternative: urlLangueAlternative
        });
        flush();
      }
    }, {
      key: "texteNousJoindre",
      get: function get() {
        return this.$$.ctx[8];
      },
      set: function set(texteNousJoindre) {
        this.$$set({
          texteNousJoindre: texteNousJoindre
        });
        flush();
      }
    }, {
      key: "urlNousJoindre",
      get: function get() {
        return this.$$.ctx[9];
      },
      set: function set(urlNousJoindre) {
        this.$$set({
          urlNousJoindre: urlNousJoindre
        });
        flush();
      }
    }, {
      key: "passerContenu",
      get: function get() {
        return this.$$.ctx[10];
      },
      set: function set(passerContenu) {
        this.$$set({
          passerContenu: passerContenu
        });
        flush();
      }
    }, {
      key: "urlPasserContenu",
      get: function get() {
        return this.$$.ctx[11];
      },
      set: function set(urlPasserContenu) {
        this.$$set({
          urlPasserContenu: urlPasserContenu
        });
        flush();
      }
    }, {
      key: "textePasserContenu",
      get: function get() {
        return this.$$.ctx[12];
      },
      set: function set(textePasserContenu) {
        this.$$set({
          textePasserContenu: textePasserContenu
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["urlLogo", "srcLogo", "altLogo", "titreSite1", "titreSite2", "urlTitreSite", "texteLangueAlternative", "urlLangueAlternative", "texteNousJoindre", "urlNousJoindre", "passerContenu", "urlPasserContenu", "textePasserContenu"];
      }
    }]);

    return PivEntete;
  }(SvelteElement);

  customElements.define("utd-piv-entete", PivEntete);

  function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$1 = "src\\components\\pivPiedPage.svelte"; // (40:2) {#if Utils.slotExiste(slots, 'liens')}

  function create_if_block$1(ctx) {
    var div;
    var h2;
    var t0;
    var t1;
    var nav;
    var slot;
    var block = {
      c: function create() {
        div = element("div");
        h2 = element("h2");
        t0 = text(
        /*texteTitreSrLiens*/
        ctx[0]);
        t1 = space();
        nav = element("nav");
        slot = element("slot");
        attr_dev(h2, "class", "utd-sr-only");
        attr_dev(h2, "id", "utdTitreLiensPivPiedPage");
        add_location(h2, file$1, 41, 4, 1649);
        attr_dev(slot, "name", "liens");
        add_location(slot, file$1, 43, 6, 1789);
        attr_dev(nav, "aria-labelledby", "utdTitreLiensPivPiedPage");
        add_location(nav, file$1, 42, 4, 1733);
        attr_dev(div, "class", "liens");
        add_location(div, file$1, 40, 2, 1624);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        append_dev(div, h2);
        append_dev(h2, t0);
        append_dev(div, t1);
        append_dev(div, nav);
        append_dev(nav, slot);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*texteTitreSrLiens*/
        1) set_data_dev(t0,
        /*texteTitreSrLiens*/
        ctx[0]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block$1.name,
      type: "if",
      source: "(40:2) {#if Utils.slotExiste(slots, 'liens')}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment$1(ctx) {
    var div;
    var show_if = Utils.slotExiste(
    /*slots*/
    ctx[10], 'liens');
    var t0;
    var a0;
    var img;
    var img_alt_value;
    var img_src_value;
    var t1;
    var span1;
    var a1;
    var t2;
    var t3;
    var t4;
    var span0;
    var t5;
    var link;
    var if_block = show_if && create_if_block$1(ctx);
    var block = {
      c: function create() {
        div = element("div");
        if (if_block) if_block.c();
        t0 = space();
        a0 = element("a");
        img = element("img");
        t1 = space();
        span1 = element("span");
        a1 = element("a");
        t2 = text(
        /*texteCopyright*/
        ctx[6]);
        t3 = text(
        /*anneeCopyright*/
        ctx[7]);
        t4 = space();
        span0 = element("span");
        t5 = space();
        link = element("link");
        this.c = noop;
        attr_dev(img, "class", "logo-mo");
        attr_dev(img, "alt", img_alt_value = "" + (
        /*altLogo*/
        ctx[2] +
        /*texteSrOuvertureNouvelOnglet*/
        ctx[9]));
        if (!src_url_equal(img.src, img_src_value =
        /*srcLogo*/
        ctx[3])) attr_dev(img, "src", img_src_value);
        attr_dev(img, "width",
        /*widthLogo*/
        ctx[4]);
        attr_dev(img, "height",
        /*heightLogo*/
        ctx[5]);
        add_location(img, file$1, 49, 6, 1914);
        attr_dev(a0, "href",
        /*urlLogo*/
        ctx[1]);
        attr_dev(a0, "target", "_blank");
        attr_dev(a0, "rel", "noopener");
        add_location(a0, file$1, 48, 2, 1855);
        attr_dev(span0, "class", "utd-sr-only");
        add_location(span0, file$1, 55, 10, 2197);
        attr_dev(a1, "href",
        /*urlCopyright*/
        ctx[8]);
        attr_dev(a1, "target", "_blank");
        attr_dev(a1, "rel", "noopener");
        add_location(a1, file$1, 53, 6, 2085);
        attr_dev(span1, "class", "copyright");
        add_location(span1, file$1, 52, 2, 2053);
        attr_dev(div, "class", "utd-container utd-piv-pied-page");
        add_location(div, file$1, 37, 0, 1529);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", Utils.cssFullPath);
        add_location(link, file$1, 61, 0, 2303);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        if (if_block) if_block.m(div, null);
        append_dev(div, t0);
        append_dev(div, a0);
        append_dev(a0, img);
        append_dev(div, t1);
        append_dev(div, span1);
        append_dev(span1, a1);
        append_dev(a1, t2);
        append_dev(a1, t3);
        append_dev(a1, t4);
        append_dev(a1, span0);
        span0.innerHTML =
        /*texteSrOuvertureNouvelOnglet*/
        ctx[9];
        insert_dev(target, t5, anchor);
        insert_dev(target, link, anchor);
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        if (dirty &
        /*slots*/
        1024) show_if = Utils.slotExiste(
        /*slots*/
        ctx[10], 'liens');

        if (show_if) {
          if (if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block = create_if_block$1(ctx);
            if_block.c();
            if_block.m(div, t0);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }

        if (dirty &
        /*altLogo, texteSrOuvertureNouvelOnglet*/
        516 && img_alt_value !== (img_alt_value = "" + (
        /*altLogo*/
        ctx[2] +
        /*texteSrOuvertureNouvelOnglet*/
        ctx[9]))) {
          attr_dev(img, "alt", img_alt_value);
        }

        if (dirty &
        /*srcLogo*/
        8 && !src_url_equal(img.src, img_src_value =
        /*srcLogo*/
        ctx[3])) {
          attr_dev(img, "src", img_src_value);
        }

        if (dirty &
        /*widthLogo*/
        16) {
          attr_dev(img, "width",
          /*widthLogo*/
          ctx[4]);
        }

        if (dirty &
        /*heightLogo*/
        32) {
          attr_dev(img, "height",
          /*heightLogo*/
          ctx[5]);
        }

        if (dirty &
        /*urlLogo*/
        2) {
          attr_dev(a0, "href",
          /*urlLogo*/
          ctx[1]);
        }

        if (dirty &
        /*texteCopyright*/
        64) set_data_dev(t2,
        /*texteCopyright*/
        ctx[6]);
        if (dirty &
        /*anneeCopyright*/
        128) set_data_dev(t3,
        /*anneeCopyright*/
        ctx[7]);
        if (dirty &
        /*texteSrOuvertureNouvelOnglet*/
        512) span0.innerHTML =
        /*texteSrOuvertureNouvelOnglet*/
        ctx[9];

        if (dirty &
        /*urlCopyright*/
        256) {
          attr_dev(a1, "href",
          /*urlCopyright*/
          ctx[8]);
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
        if (if_block) if_block.d();
        if (detaching) detach_dev(t5);
        if (detaching) detach_dev(link);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$1.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function instance$1($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots$1 = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-piv-pied-page', slots$1, []);
    var textesDefaut = Utils.obtenirTextesDefaut();
    var languePage = Utils.obtenirLanguePage();
    var _$$props$texteTitreSr = $$props.texteTitreSrLiens,
        texteTitreSrLiens = _$$props$texteTitreSr === void 0 ? languePage === 'fr' ? 'Liens vers informations complémentaires' : 'Links to additional information' : _$$props$texteTitreSr;
    var _$$props$urlLogo = $$props.urlLogo,
        urlLogo = _$$props$urlLogo === void 0 ? languePage === 'fr' ? 'https://www.mtess.gouv.qc.ca/' : 'https://www.mtess.gouv.qc.ca/index_en.asp' : _$$props$urlLogo;
    var _$$props$altLogo = $$props.altLogo,
        altLogo = _$$props$altLogo === void 0 ? languePage === 'fr' ? "Minist\xE8re de l'Emploi et de la Solidarit\xE9 sociale" : "Minist\xE8re de l'Emploi et de la Solidarit\xE9 sociale" : _$$props$altLogo;
    var _$$props$srcLogo = $$props.srcLogo,
        srcLogo = _$$props$srcLogo === void 0 ? "".concat(Utils.imagesRelativePath, "logo_piv_bas_page.png") : _$$props$srcLogo;
    var _$$props$widthLogo = $$props.widthLogo,
        widthLogo = _$$props$widthLogo === void 0 ? '210' : _$$props$widthLogo;
    var _$$props$heightLogo = $$props.heightLogo,
        heightLogo = _$$props$heightLogo === void 0 ? '81' : _$$props$heightLogo;
    var _$$props$texteCopyrig = $$props.texteCopyright,
        texteCopyright = _$$props$texteCopyrig === void 0 ? languePage === 'fr' ? '© Gouvernement du Québec, ' : '© Gouvernement du Québec, ' : _$$props$texteCopyrig;
    var _$$props$anneeCopyrig = $$props.anneeCopyright,
        anneeCopyright = _$$props$anneeCopyrig === void 0 ? '2022' : _$$props$anneeCopyrig;
    var _$$props$urlCopyright = $$props.urlCopyright,
        urlCopyright = _$$props$urlCopyright === void 0 ? languePage === 'fr' ? 'https://www.quebec.ca/droit-auteur' : 'https://www.quebec.ca/en/copyright' : _$$props$urlCopyright;
    var _$$props$texteSrOuver = $$props.texteSrOuvertureNouvelOnglet,
        texteSrOuvertureNouvelOnglet = _$$props$texteSrOuver === void 0 ? textesDefaut.texteSrOuvertureNouvelOnglet : _$$props$texteSrOuver;
    var thisComponent = get_current_component();
    var slots = [];
    onMount(function () {
      $$invalidate(10, slots = Array.from(thisComponent.querySelectorAll('[slot]')));
      Utils.reafficherApresChargement(thisComponent);
    });
    var writable_props = ['texteTitreSrLiens', 'urlLogo', 'altLogo', 'srcLogo', 'widthLogo', 'heightLogo', 'texteCopyright', 'anneeCopyright', 'urlCopyright', 'texteSrOuvertureNouvelOnglet'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-piv-pied-page> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('texteTitreSrLiens' in $$props) $$invalidate(0, texteTitreSrLiens = $$props.texteTitreSrLiens);
      if ('urlLogo' in $$props) $$invalidate(1, urlLogo = $$props.urlLogo);
      if ('altLogo' in $$props) $$invalidate(2, altLogo = $$props.altLogo);
      if ('srcLogo' in $$props) $$invalidate(3, srcLogo = $$props.srcLogo);
      if ('widthLogo' in $$props) $$invalidate(4, widthLogo = $$props.widthLogo);
      if ('heightLogo' in $$props) $$invalidate(5, heightLogo = $$props.heightLogo);
      if ('texteCopyright' in $$props) $$invalidate(6, texteCopyright = $$props.texteCopyright);
      if ('anneeCopyright' in $$props) $$invalidate(7, anneeCopyright = $$props.anneeCopyright);
      if ('urlCopyright' in $$props) $$invalidate(8, urlCopyright = $$props.urlCopyright);
      if ('texteSrOuvertureNouvelOnglet' in $$props) $$invalidate(9, texteSrOuvertureNouvelOnglet = $$props.texteSrOuvertureNouvelOnglet);
    };

    $$self.$capture_state = function () {
      return {
        onMount: onMount,
        Utils: Utils,
        get_current_component: get_current_component,
        textesDefaut: textesDefaut,
        languePage: languePage,
        texteTitreSrLiens: texteTitreSrLiens,
        urlLogo: urlLogo,
        altLogo: altLogo,
        srcLogo: srcLogo,
        widthLogo: widthLogo,
        heightLogo: heightLogo,
        texteCopyright: texteCopyright,
        anneeCopyright: anneeCopyright,
        urlCopyright: urlCopyright,
        texteSrOuvertureNouvelOnglet: texteSrOuvertureNouvelOnglet,
        thisComponent: thisComponent,
        slots: slots
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('texteTitreSrLiens' in $$props) $$invalidate(0, texteTitreSrLiens = $$props.texteTitreSrLiens);
      if ('urlLogo' in $$props) $$invalidate(1, urlLogo = $$props.urlLogo);
      if ('altLogo' in $$props) $$invalidate(2, altLogo = $$props.altLogo);
      if ('srcLogo' in $$props) $$invalidate(3, srcLogo = $$props.srcLogo);
      if ('widthLogo' in $$props) $$invalidate(4, widthLogo = $$props.widthLogo);
      if ('heightLogo' in $$props) $$invalidate(5, heightLogo = $$props.heightLogo);
      if ('texteCopyright' in $$props) $$invalidate(6, texteCopyright = $$props.texteCopyright);
      if ('anneeCopyright' in $$props) $$invalidate(7, anneeCopyright = $$props.anneeCopyright);
      if ('urlCopyright' in $$props) $$invalidate(8, urlCopyright = $$props.urlCopyright);
      if ('texteSrOuvertureNouvelOnglet' in $$props) $$invalidate(9, texteSrOuvertureNouvelOnglet = $$props.texteSrOuvertureNouvelOnglet);
      if ('slots' in $$props) $$invalidate(10, slots = $$props.slots);
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    return [texteTitreSrLiens, urlLogo, altLogo, srcLogo, widthLogo, heightLogo, texteCopyright, anneeCopyright, urlCopyright, texteSrOuvertureNouvelOnglet, slots];
  }

  var PivPiedPage = /*#__PURE__*/function (_SvelteElement) {
    _inherits(PivPiedPage, _SvelteElement);

    var _super = _createSuper$1(PivPiedPage);

    function PivPiedPage(options) {
      var _this;

      _classCallCheck(this, PivPiedPage);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$1, create_fragment$1, safe_not_equal, {
        texteTitreSrLiens: 0,
        urlLogo: 1,
        altLogo: 2,
        srcLogo: 3,
        widthLogo: 4,
        heightLogo: 5,
        texteCopyright: 6,
        anneeCopyright: 7,
        urlCopyright: 8,
        texteSrOuvertureNouvelOnglet: 9
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(PivPiedPage, [{
      key: "texteTitreSrLiens",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(texteTitreSrLiens) {
        this.$$set({
          texteTitreSrLiens: texteTitreSrLiens
        });
        flush();
      }
    }, {
      key: "urlLogo",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(urlLogo) {
        this.$$set({
          urlLogo: urlLogo
        });
        flush();
      }
    }, {
      key: "altLogo",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(altLogo) {
        this.$$set({
          altLogo: altLogo
        });
        flush();
      }
    }, {
      key: "srcLogo",
      get: function get() {
        return this.$$.ctx[3];
      },
      set: function set(srcLogo) {
        this.$$set({
          srcLogo: srcLogo
        });
        flush();
      }
    }, {
      key: "widthLogo",
      get: function get() {
        return this.$$.ctx[4];
      },
      set: function set(widthLogo) {
        this.$$set({
          widthLogo: widthLogo
        });
        flush();
      }
    }, {
      key: "heightLogo",
      get: function get() {
        return this.$$.ctx[5];
      },
      set: function set(heightLogo) {
        this.$$set({
          heightLogo: heightLogo
        });
        flush();
      }
    }, {
      key: "texteCopyright",
      get: function get() {
        return this.$$.ctx[6];
      },
      set: function set(texteCopyright) {
        this.$$set({
          texteCopyright: texteCopyright
        });
        flush();
      }
    }, {
      key: "anneeCopyright",
      get: function get() {
        return this.$$.ctx[7];
      },
      set: function set(anneeCopyright) {
        this.$$set({
          anneeCopyright: anneeCopyright
        });
        flush();
      }
    }, {
      key: "urlCopyright",
      get: function get() {
        return this.$$.ctx[8];
      },
      set: function set(urlCopyright) {
        this.$$set({
          urlCopyright: urlCopyright
        });
        flush();
      }
    }, {
      key: "texteSrOuvertureNouvelOnglet",
      get: function get() {
        return this.$$.ctx[9];
      },
      set: function set(texteSrOuvertureNouvelOnglet) {
        this.$$set({
          texteSrOuvertureNouvelOnglet: texteSrOuvertureNouvelOnglet
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["texteTitreSrLiens", "urlLogo", "altLogo", "srcLogo", "widthLogo", "heightLogo", "texteCopyright", "anneeCopyright", "urlCopyright", "texteSrOuvertureNouvelOnglet"];
      }
    }]);

    return PivPiedPage;
  }(SvelteElement);

  customElements.define("utd-piv-pied-page", PivPiedPage);

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file = "src\\components\\piedPageSite.svelte"; // (22:4) {#if Utils.slotExiste(slots, 'contenu')}

  function create_if_block(ctx) {
    var slot;
    var block = {
      c: function create() {
        slot = element("slot");
        attr_dev(slot, "name", "contenu");
        add_location(slot, file, 22, 6, 585);
      },
      m: function mount(target, anchor) {
        insert_dev(target, slot, anchor);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(slot);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block.name,
      type: "if",
      source: "(22:4) {#if Utils.slotExiste(slots, 'contenu')}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment(ctx) {
    var div1;
    var div0;
    var show_if = Utils.slotExiste(
    /*slots*/
    ctx[0], 'contenu');
    var t;
    var link;
    var if_block = show_if && create_if_block(ctx);
    var block = {
      c: function create() {
        div1 = element("div");
        div0 = element("div");
        if (if_block) if_block.c();
        t = space();
        link = element("link");
        this.c = noop;
        attr_dev(div0, "class", "utd-container");
        add_location(div0, file, 20, 2, 504);
        attr_dev(div1, "class", "utd-pied-page-site");
        add_location(div1, file, 19, 0, 468);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", Utils.cssFullPath);
        add_location(link, file, 27, 0, 645);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div1, anchor);
        append_dev(div1, div0);
        if (if_block) if_block.m(div0, null);
        insert_dev(target, t, anchor);
        insert_dev(target, link, anchor);
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        if (dirty &
        /*slots*/
        1) show_if = Utils.slotExiste(
        /*slots*/
        ctx[0], 'contenu');

        if (show_if) {
          if (if_block) ; else {
            if_block = create_if_block(ctx);
            if_block.c();
            if_block.m(div0, null);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(div1);
        if (if_block) if_block.d();
        if (detaching) detach_dev(t);
        if (detaching) detach_dev(link);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function instance($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots$1 = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-pied-page-site', slots$1, []);
    var thisComponent = get_current_component();
    var slots = [];
    onMount(function () {
      $$invalidate(0, slots = Array.from(thisComponent.querySelectorAll('[slot]')));
    });
    var writable_props = [];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-pied-page-site> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$capture_state = function () {
      return {
        onMount: onMount,
        Utils: Utils,
        get_current_component: get_current_component,
        thisComponent: thisComponent,
        slots: slots
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('slots' in $$props) $$invalidate(0, slots = $$props.slots);
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    return [slots];
  }

  var PiedPageSite = /*#__PURE__*/function (_SvelteElement) {
    _inherits(PiedPageSite, _SvelteElement);

    var _super = _createSuper(PiedPageSite);

    function PiedPageSite(options) {
      var _this;

      _classCallCheck(this, PiedPageSite);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance, create_fragment, safe_not_equal, {}, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }
      }

      return _this;
    }

    return PiedPageSite;
  }(SvelteElement);

  customElements.define("utd-pied-page-site", PiedPageSite);

  exports.ajusterAccessibiliteLiens = ajusterAccessibiliteLiens;
  exports.customElements = customElements;
  exports.dialogue = dialogue;
  exports.extend = extend;
  exports.genererId = genererId;
  exports.message = message;
  exports.normaliserApostrophes = normaliserApostrophes;
  exports.normaliserChaineCaracteres = normaliserChaineCaracteres;
  exports.notification = notification;
  exports.obtenirIdControleActif = obtenirIdControleActif;
  exports.obtenirIdSelonTexte = obtenirIdSelonTexte;
  exports.obtenirLanguePage = obtenirLanguePage;
  exports.remplacerAccents = remplacerAccents;
  exports.traitementEnCours = traitementEnCours;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
