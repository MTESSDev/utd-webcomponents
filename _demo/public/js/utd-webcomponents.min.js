var utd = (function (exports) {
  'use strict';

  /*! Wrapper pour les customElements afin de supporter les attributs kebab case avec les customElements de svelte. 
      Référence : https://github.com/sveltejs/svelte/issues/3852
  */
  const customElements = {
    define: (tagName, CustomElement) => {
      class CustomElementWrapper extends CustomElement {
        static get observedAttributes() {
          return (super.observedAttributes || []).map((attr) =>
            attr.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase(),
          );
        }

        attributeChangedCallback(attrName, oldValue, newValue) {
          super.attributeChangedCallback(
            attrName.replace(/-([a-z])/g, (_, up) => up.toUpperCase()),
            oldValue,
            newValue === '' ? true : newValue, // [Tweaked] Value of omitted value attribute will be true
          );
        }
      }

      window.customElements.define(tagName, CustomElementWrapper); // <--- Call the actual customElements.define with our wrapper
    }
  };

  /*! utd-webcomponents v1.7.6 */
  //TODO ajouter possibilité que utd reçoive les textes de langue requis. De quelle façon?
  //A- En paramètre des méthodes qui en ont besoin
  //B- Globalement via une initialisation de texte UTD qui serait faite une fois.

  //IMPORTANT! Laisser ce commentaire, une fois le build terminé, il sera remplacé par une condition permettant de ne pas réexécuter le script (afin d'éviter les erreurs de custom elements dejà définis qui se produisent parfois. On suppose rechargement d'un onglet ou autre.)
  /*!_VerifierSiDejaCharge_*/

  /*======================================================================================================================*/
  /* -10- FENÊTRES DE MESSAGE
  /*======================================================================================================================*/
  const message = (function () {

      const elementsPublics = {};

      /**
       * Affiche une fenêtre de message (dialog).
       * @param {Object} parametres Paramètres.
       * @param {Object} parametres.type Type de message ("erreur", "information", "avertissement", "succes"  pour l'instant, autres types à venir). Défaut "avertissement".
       * @param {Object} parametres.titre Titre du message. Texte brut ou HTML (ex. Annuler les modifications) Défaut "". 
       * @param {Object} parametres.corps Corps du message. Texte brut ou HTML (ex. Désirez-vous annuler les modifications ou poursuivre?.) Défaut "".
       * @param {Object} parametres.texteBoutonPrimaire Texte du bouton primaire. (Celui le plus à droite). Si vide n'est pas affiché.
       * @param {Object} parametres.texteBoutonSecondaire Texte du bouton secondaire. (Situé à la gauche du bouton primaire). Si vide n'est pas affiché.
       * @param {Object} parametres.texteBoutonFermer Texte du bouton de fermeture du message. Défaut "Fermer" ou "Close en anglais".
       * @param {Object} parametres.afficherBoutonFermer Afficher le bouton pour fermer la fenêtre de message. Défaut true.
       * @param {Object} parametres.idControleFocusFermeture Id du contrôle auquel on redonne le focus à la fermeture de la fenêtre de message. Si non spécifié, focus redonné à l'élément actif avant l'affichage du message.
       * @returns {Object} Une promesse jQuery qui contiendra éventuellement un objet contenant la raison de fermeture. (ex. objet.primaire ou objet.secondaire)
       * @example afficherMessage(parametres)
                  .done(function (resultat) {
                      if (resultat.primaire) {
                          alert("Très bon choix! Poursuivre aurait pu causer une rupture du continuum espace temps!");
                      } else if (resultat.secondaire) {
                          alert("Mauvais choix! Vous auriez-du poursuivre. À cause de vous le continuum espace temps risque de se briser!");
                      } else {
                          alert("Vous vous êtes contenté de fermer la fenêtre sans faire de choix... La prochaine fois assumez-vous! L'avenir du monde est entre vos mains!");
                      }
                  });
      * @references https://www.w3.org/TR/wai-aria-practices/examples/dialog-modal/alertdialog.html
      * @notes Le titre et les boutons sont lus 2 fois dans NVDA... ça semble faire partie du pattern (voir lien ci-dessus). 
      */

      elementsPublics.afficher = function(parametres) {
         
          const valeursDefaut = {
              type: "",
              titre: "",
              corps: "",
              texteBoutonPrimaire: "",
              texteBoutonSecondaire: "",
              texteBoutonFermer: obtenirLanguePage() === 'fr' ? "Fermer" : "Close", 
              afficherBoutonFermer: false,
              estBoutonsTexteLong: false,
              idControleFocusFermeture: null
          };
      
          parametres = extend(valeursDefaut, parametres);
      
          parametres.idControleFocusFermeture = parametres.idControleFocusFermeture || obtenirIdControleActif();
      
          const conteneurFenetreMessage = ajouterControle(parametres);
          const fenetreMessage = conteneurFenetreMessage.querySelector('utd-dialog');  
      
          const boutons = conteneurFenetreMessage.querySelectorAll('[slot="pied"] > button');    
          boutons.forEach(btn => {
              btn.addEventListener("click", function() {
                  const raison = this.getAttribute('raison-fermeture');
                  fenetreMessage.setAttribute('raison-fermeture', raison);
                  fenetreMessage.setAttribute('afficher', 'false');
              });    
          });
          
          //Définir une promesse qui sera résolue à la fermeture de la fenêtre.
          return new Promise((resolve) => {        
              definirEvenementFermeture(fenetreMessage, resolve);      
              fenetreMessage.setAttribute('afficher', 'true');    
          });    
      };
      /**
       * (Privée)
       * Ajoute le contrôle de fenêtre de message au DOM.
       * @param {Object} parametres Paramètres de la function afficherMessage.
       * @returns Object correspondant au conteneur de la fenêtre de message.
       */
      function ajouterControle(parametres) {
      //    var classeIcone = obtenirClasseIcone(parametres.type);
          const type = parametres.type ? ` type="${parametres.type}" ` : '';
          let html = `
        <utd-dialog titre="${parametres.titre}" id-focus-fermeture="${parametres.idControleFocusFermeture}" estfenetremessage="true" boutons-texte-long="${parametres.estBoutonsTexteLong}" ${type}>
            <div slot="contenu">
                ${parametres.corps}
            </div>
            <div slot="pied">`;   
          
          const htmlBoutonPrimaire = `<button type="button" class="utd-btn primaire compact" raison-fermeture="primaire" data-ga-action="${parametres.titre}">${parametres.texteBoutonPrimaire}</button>`;
          const htmlBoutonSecondaire = parametres.texteBoutonSecondaire ? `<button type="button" class="utd-btn secondaire compact" raison-fermeture="secondaire" data-ga-action="${parametres.titre}">${parametres.texteBoutonSecondaire}</button>` : '';
                  
          html += `
                ${htmlBoutonSecondaire}${htmlBoutonPrimaire}                        
            </div>
        </utd-dialog>`;

          const id = genererId();
          const conteneurFenetreMessage = document.createElement('div');
          conteneurFenetreMessage.id = id;
          conteneurFenetreMessage.innerHTML = html;

          document.body.appendChild(conteneurFenetreMessage);

          return conteneurFenetreMessage;
      }

      /**
       * (Privéee)
       * Compléter la promesse indiquant de quelle façon la fenêtre s'est fermée et supprimer l'élément du DOM une fois qu'il n'est plus affiché.
       * @param {Object} fenetreMessage Objet correspondant à la fenêtre de message.
       * @param {Promise} resolve Résolution de promesse.
       */
      function definirEvenementFermeture(fenetreMessage, resolve) {
          fenetreMessage.addEventListener("fermeture", e => {       
              resolve(e.detail.raisonFermeture);
              
              //setTimeout ici afin de s'assurer que svelte a terminé son traitement avant de retirer le compsant du DOM
              setTimeout(() => {
                  fenetreMessage.parentElement.remove();    
              });  
              
          });
      }

      return elementsPublics;
  })();


  /*======================================================================================================================*/
  /* -11- DIALOGUE
  /*======================================================================================================================*/
  const dialogue = (function () {

      const elementsPublics = {};

      /**
      * Affiche une fenêtre de dialogue modal.
      * @param {Object} parametres Paramètres.
      * @param {Object} parametres.idDialogue Id du contrôle utd-dialog à afficher.
      * @param {Object} parametres.idControleFocusFermeture Id du contrôle auquel on redonne le focus à la fermeture du dialogue. Si non spécifié, focus redonné à l'élément actif avant l'affichage du message.
      */

      elementsPublics.afficher = function(idDialogue, idControleFocusFermeture) {
           
          if(!idDialogue){
              console.error('utd.dialogue.afficher -> Aucun id de dialogue spécifié.');
              return;
          }

          idControleFocusFermeture = idControleFocusFermeture || obtenirIdControleActif();

          const dialogue = document.getElementById(idDialogue);

          if(dialogue){
              dialogue.setAttribute('afficher', 'true');    

              if(idControleFocusFermeture){
                  dialogue.setAttribute('id-focus-fermeture', idControleFocusFermeture);    
              }   
          } else {
              console.error(`utd.dialogue.afficher -> Contrôle utd-dialog "${dialogue}" non trouvé.`);
          }
      };

      elementsPublics.masquer = function(idDialogue) {
           
          if(!idDialogue){
              console.error('utd.dialogue.masquer -> Aucun id de dialogue spécifié.');
              return;
          }

          const dialogue = document.getElementById(idDialogue);

          if(dialogue){
              dialogue.setAttribute('afficher', 'false');    

              const idFocus = dialogue.getAttribute('id-focus-fermeture');

              if(idFocus){
                  const controleFocus = document.getElementById(idFocus);
                  if(controleFocus){
                      controleFocus.focus();
                  } else {
                      console.log(`utd.dialogue.masquer -> Contrôle "${idFocus}" à qui redonner le focus non trouvé.`);        
                  }
              }   
          } else {
              console.error(`utd.dialogue.masquer -> Contrôle utd-dialog "${dialogue}" non trouvé.`);
          }
      };

      return elementsPublics;
  })();


  /*======================================================================================================================*/
  /* -20- TRAITEMENT EN COURS
  /*======================================================================================================================*/
  const traitementEnCours = (function () {

      let elementsPublics = {};

      elementsPublics.debuter = function(element, avecOverlay) {

          avecOverlay = avecOverlay !== undefined ? avecOverlay : true;

          if (element) {

              //Ajouter un overlay global pendant le traitement en cours s'il y a lieu (défaut oui)  
              if (avecOverlay) {
                  const overlay = document.createElement("div");

                  //Si un overlay est déjà présent, on ajoute le nouveau mais on le masque (il sera peut-être éventuellement réaffiché dans le traitement terminer du traitement en cours)
                  if (document.getElementsByClassName('utd-overlay').length > 0) {
                      overlay.classList.add('utd-d-none');
                  }

                  overlay.classList.add('utd-overlay');
                  document.body.appendChild(overlay);
              } 

              element.setAttribute('overlay', avecOverlay ? 'true' : 'false');

              if (element.tagName.toLowerCase() === 'button' || (element.tagName.toLowerCase() === 'input' && element.type.toLowerCase() === 'submit')) {

                  element.classList.add("utd-traitement-en-cours");
                  const htmlTraitementEnCours = '<div class="utd-spinner"></div>';

                  if (element.getElementsByClassName('utd-spinner').length === 0) {
                      element.innerHTML += htmlTraitementEnCours;
                  }

                  element.disabled = true;
              }

              notifierTraitementEnCoursLecteurEcran(element);
          }


      };

      elementsPublics.terminer = function(element) {

          if(element) {
              const spinner = element.querySelector('.utd-spinner');
              if(spinner){
                  spinner.remove();
              }               

              element.classList.remove("utd-traitement-en-cours");
              element.disabled = false;
     
              supprimerOverlay(element);

              element.removeAttribute('overlay');
              notifierTraitementEnCoursLecteurEcran(element, true);
          }
      };

      function supprimerOverlay(element) {
          //Si le traitement en cours sur l'élément avait un overlay on le retire.
          const avecOverlay = element.getAttribute('overlay');
          if(avecOverlay === 'true'){
              
              //Retrait du overlay 
              const overlayTraitementEnCours = document.getElementsByClassName('utd-overlay');

              if (overlayTraitementEnCours.length > 1) {
                  
                  //On enlève 1 overlay, si un masqué existe c'est lui qu'on enlève. S'il y en a d'autres ils seront fermés éventuellement.
                  const overlayInvisibles = document.getElementsByClassName('utd-overlay utd-d-none');
                  if(overlayInvisibles.length > 0){
                      overlayInvisibles[0].remove();    
                  } else {
                      //Si aucun overlay invisible, on enlève le 1er trouvé.
                      overlayTraitementEnCours[0].remove();
                  }
              } else if(overlayTraitementEnCours.length === 1){
                  overlayTraitementEnCours[0].remove();
              }
          }
      }
      function notifierTraitementEnCoursLecteurEcran(element, estTraitementTermine){

          //Générer un id à l'élément qui va contenir le spinner de traitement en cours
          if(!element.id){
              element.id = genererId();            
          }

          const idZoneNotification = `zoneNotification_${element.id}`;

          //Ajouter la zone de notification hors écran si elle n'existe pas déjà.
          let zoneNotificationsLecteurEcran = document.getElementById(idZoneNotification);
          if(!zoneNotificationsLecteurEcran){
              zoneNotificationsLecteurEcran = document.createElement("div");
              zoneNotificationsLecteurEcran.id = idZoneNotification;
              zoneNotificationsLecteurEcran.classList.add('utd-sr-only');
              document.body.appendChild(zoneNotificationsLecteurEcran);
          }

          let texte = "";

          if(estTraitementTermine){
              texte = obtenirLanguePage() === 'fr' ? "Traitement terminé." : "Processing complete.";
          } else {
              texte = obtenirLanguePage() === 'fr' ? "Traitement en cours." : "Processing...";
          }

          zoneNotificationsLecteurEcran.innerHTML = texte;
      }

      return elementsPublics;
  })();


  /*======================================================================================================================*/
  /* -30- NOTIFICATIONS
  /*======================================================================================================================*/
  const notification = (function () {

      const elementsPublics = {};

      /**
       * Affiche une notification (toast).
       * @param {Object} parametres Paramètres.
       * @param {Object} parametres.type Type de notification (positif, negatif ou neutre). Défaut "positif".
       * @param {Object} parametres.titre Titre de la notification (ex. Succès) Défaut "Succès" ou "Échec".
       * @param {Object} parametres.message Message de la notification (ex. Enregistrement effectué avec succès.) Défaut "".
       * @param {Object} parametres.texteBoutonFermer Texte du bouton de fermeture de la notification. Défaut "Fermer".
       * @param {Object} parametres.delaiFermeture Délai (en ms) de fermeture automatique de la notification. Défaut 5000.
       */

      elementsPublics.emettre = function(parametres) {
         
          const valeursDefaut = {
              type: "positif",
              titre: "", //parametres.type == "echec" ? "Échec" : "Succès",
              message: "",
              texteBoutonFermer: obtenirLanguePage() === 'fr' ? "Fermer" : "Close", 
              delaiFermeture: 5000
          };

          parametres = extend(valeursDefaut, parametres);       
         
          const zoneNotifications = obtenirZoneNotifications();

          const notification = ajouterNotification(zoneNotifications, parametres);

          retirerNotificationApresDelai(notification, parametres);
      };
      /**
       * Obtient la node correspondant à la zone de notifications utd.
       * @returns {object} La zone de notifications utd.
       */
      function obtenirZoneNotifications() {
          let zoneNotifications = document.getElementById('utdZoneNotifications');
          
          if(!zoneNotifications){
              zoneNotifications = document.createElement('div');
              zoneNotifications.id = 'utdZoneNotifications';
              zoneNotifications.classList.add('utd-notifications');
              document.body.appendChild(zoneNotifications);    
          }

          return zoneNotifications;
      }
      /**
       * (Privée)
       * Ajoute une notification dans la zone des notifications.
       * @param {Object} zoneNotifications Node correspondant à la zone de notifications.
       * @param {Object} parametres Paramètres de la méthode emettre (qui permet d'émettre une notification).
       * @returns {Object} Node correspondant à la notification ajoutée.
       */
      function ajouterNotification(zoneNotifications, parametres) {

          const notification = document.createElement('div');
          notification.classList.add("notification", parametres.type);        

          const possedeTitre = !!parametres.titre;
          if(!possedeTitre){
              notification.classList.add("sans-titre");
          }

          notification.innerHTML = obtenirHtmlNotification(parametres, possedeTitre);

          definirEvenementClick(notification);

          zoneNotifications.appendChild(notification);

          afficherNotification(notification);

          return notification;
      }
      /**
       * 
       * @param {Object} parametres Paramètres de la méthode emettre (qui permet d'émettre une notification).
       * @param {Boolean} possedeTitre Indique si la notification possède un titre ou non.
       * @returns 
       */
      function obtenirHtmlNotification(parametres, possedeTitre) {
          let html = `
            <button type="button">
                <span class="utd-sr-only">${parametres.texteBoutonFermer}</span>
                <span class="utd-icone-svg x-fermer-blanc" aria-hidden="true"></span>
            </button>
            <div role="alert">`;
          
              
          if(possedeTitre){
              const classeIcone = obtenirClasseIcone(parametres.type);
              html += `
                <div class="titre">
                    <span class="utd-icone-svg ${classeIcone} md" aria-hidden="true"></span>
                    <span class="texte">${parametres.titre}&nbsp;</span>
                </div>            
            `;
          }

          html += `
            <div class="texte-message">
                ${parametres.message}
            </div></div>`;

          return html;
      }
      /**
       * Obtient la classe de l'icône de titre.
       * @param {string} type Type de notification
       * @returns {string} Classe de l'icône de titre pour le type spécifié.
       */
      function obtenirClasseIcone(type) {
          switch (type) {
              case "negatif":
                  return "erreur-blanc";
              case "neutre":
                  return "information-blanc";
              default:
                  return "succes-blanc";
          }
      }
      /**
       * Affiche la notification en effectuant un fade in.
       * @param {Object} notification Node notification à afficher.
       */
      function afficherNotification(notification) {
          setTimeout(() => {
              notification.classList.add('visible'); 
           }, 10); 
      }
      /**
       * Retire la notification après le délai prévu.
       * @param {Object} notification Node correspondant à la notification à retirer.
       * @param {Object} parametres Paramètres de la méthode emettre (qui permet d'émettre une notification).
       */
      function retirerNotificationApresDelai(notification, parametres) {
          setTimeout(() => {                        
              retirerNotification(notification);
          }, parametres.delaiFermeture);
      }

      /**
       * Retire la notification du dom et en effectuant un fade out.
       * @param {Object} notification Node correspondant à la notification à retirer.
       */
      function retirerNotification(notification) {
          const dureeAnimationMs = 500;
          
          notification.classList.remove('visible');
          setTimeout(() => {
              notification.remove();
          }, dureeAnimationMs);            
      }

      /**
       * (Privéee)
       * Définit le traitement à effectuer sur le click d'une notification.
       * @param {Object} notification Node de notification sur laquelle on doit appliquer l'événement.
       */
      function definirEvenementClick(notification) {
          notification.addEventListener("click", e => {        
              retirerNotification(notification);
          });
      }

      return elementsPublics;
  })();


  /* ============================================================= */
  /* ======================== UTILITAIRES ======================== */
  /* ============================================================= */
  /**
   * Obtient l'id du contrôle actif. Si le contrôle actif n'a pas d'id, on lui en assigne un.
   * @returns L'id du contrôle actif.
   */
  function obtenirIdControleActif() {
      if (document.activeElement) {
          let id = document.activeElement.id;

          if (!id) {
              id = genererId();
              document.activeElement.id = id;
          }

          return id;
      }

      return null;
  }


  /**
   * 
   * @param {Object} cible Objet dans lequel on doit copier les données. 
   * @param {Object} source Objet contenant les infos à copier dans l'objet cible. 
   * @returns 
   */
  function extend(cible, source) {
      for (var sourceProp in source) {
          var sourceVal = source[sourceProp];
          // Is this value an object?  If so, iterate over its properties, copying them over
          if (sourceVal && Object.prototype.toString.call(sourceVal) === "[object Object]") {
              cible[sourceProp] = cible[sourceProp] || {};
              extend(cible[sourceProp], sourceVal);
          }
          else {
              cible[sourceProp] = sourceVal;
          }
      }
      return cible;
  }

  /**
   * Génère un id unique.
   * @returns Un id unique.
   */
  function genererId() {
      return Date.now().toString(36) + '-' + Math.random().toString(36).substr(2, 9);
  }

  /**
   * Obtient la langue de la page courante.
   * @returns {string} Code de langue de la page courante (fr/en).
   */
   function obtenirLanguePage() {
      return document.getElementsByTagName("html")[0].getAttribute("lang") || "fr";
  }


  function ajusterAccessibiliteLiens(texteAccessibilite) {
      texteAccessibilite = texteAccessibilite || obtenirLanguePage() === 'fr' ? ". Ce lien sera ouvert dans un nouvel onglet." : ". This link will open in a new tab.";

      document.querySelectorAll('main a[target="_blank"]').forEach(lien => { 

          //Ne pas traiter les liens sans href et les liens
          if (!lien.getAttribute('href')) {
              return;
          }
          //Ne pas traiter les liens vers des fichiers pdf ou les liens ayant explicitement une classe indiquant de ne pas les considérer comme lien externe(sans-lien-externe).  TODO éventuellement rafiner la condition afin de traiter uniquement les liens vers des pages web...
          if (lien.getAttribute('href').endsWith(".pdf") || lien.classList.contains("utd-sans-lien-externe")) {
              return;
          }

          //Ajouter la classe lien-externe afin d'afficher l'icône d'ouverture dans une nouvelle fenêtre.
          if (!lien.classList.contains("utd-lien-externe") && !lien.querySelector('.utd-lien-externe')) {
              lien.classList.add("utd-lien-externe");
          }

          //Ajouter le texte pour accessibilité nouvelle fenêtre si on détecte qu'il n'est pas là. TODO rafiner cette vérification éventuellement au besoin, il pourrait arriver qu'un .sr-only soit là pour autre chose dans le lien (très peu probable)
          if (!lien.querySelector(".utd-sr-only")) {
              lien.innerHTML = lien.innerHTML + `<span class="utd-sr-only">${texteAccessibilite}</span>`;
          }
      });

  }

  function noop() { }
  const identity = x => x;
  function assign(tar, src) {
      // @ts-ignore
      for (const k in src)
          tar[k] = src[k];
      return tar;
  }
  function add_location(element, file, line, column, char) {
      element.__svelte_meta = {
          loc: { file, line, column, char }
      };
  }
  function run(fn) {
      return fn();
  }
  function blank_object() {
      return Object.create(null);
  }
  function run_all(fns) {
      fns.forEach(run);
  }
  function is_function(thing) {
      return typeof thing === 'function';
  }
  function safe_not_equal(a, b) {
      return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
  }
  let src_url_equal_anchor;
  function src_url_equal(element_src, url) {
      if (!src_url_equal_anchor) {
          src_url_equal_anchor = document.createElement('a');
      }
      src_url_equal_anchor.href = url;
      return element_src === src_url_equal_anchor.href;
  }
  function is_empty(obj) {
      return Object.keys(obj).length === 0;
  }
  function compute_slots(slots) {
      const result = {};
      for (const key in slots) {
          result[key] = true;
      }
      return result;
  }

  const is_client = typeof window !== 'undefined';
  let now = is_client
      ? () => window.performance.now()
      : () => Date.now();
  let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

  const tasks = new Set();
  function run_tasks(now) {
      tasks.forEach(task => {
          if (!task.c(now)) {
              tasks.delete(task);
              task.f();
          }
      });
      if (tasks.size !== 0)
          raf(run_tasks);
  }
  /**
   * Creates a new task that runs on each raf frame
   * until it returns a falsy value or is aborted
   */
  function loop(callback) {
      let task;
      if (tasks.size === 0)
          raf(run_tasks);
      return {
          promise: new Promise(fulfill => {
              tasks.add(task = { c: callback, f: fulfill });
          }),
          abort() {
              tasks.delete(task);
          }
      };
  }
  function append(target, node) {
      target.appendChild(node);
  }
  function get_root_for_style(node) {
      if (!node)
          return document;
      const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
      if (root && root.host) {
          return root;
      }
      return node.ownerDocument;
  }
  function append_empty_stylesheet(node) {
      const style_element = element('style');
      append_stylesheet(get_root_for_style(node), style_element);
      return style_element.sheet;
  }
  function append_stylesheet(node, style) {
      append(node.head || node, style);
      return style.sheet;
  }
  function insert(target, node, anchor) {
      target.insertBefore(node, anchor || null);
  }
  function detach(node) {
      node.parentNode.removeChild(node);
  }
  function destroy_each(iterations, detaching) {
      for (let i = 0; i < iterations.length; i += 1) {
          if (iterations[i])
              iterations[i].d(detaching);
      }
  }
  function element(name) {
      return document.createElement(name);
  }
  function svg_element(name) {
      return document.createElementNS('http://www.w3.org/2000/svg', name);
  }
  function text(data) {
      return document.createTextNode(data);
  }
  function space() {
      return text(' ');
  }
  function empty() {
      return text('');
  }
  function listen(node, event, handler, options) {
      node.addEventListener(event, handler, options);
      return () => node.removeEventListener(event, handler, options);
  }
  function prevent_default(fn) {
      return function (event) {
          event.preventDefault();
          // @ts-ignore
          return fn.call(this, event);
      };
  }
  function attr(node, attribute, value) {
      if (value == null)
          node.removeAttribute(attribute);
      else if (node.getAttribute(attribute) !== value)
          node.setAttribute(attribute, value);
  }
  function set_attributes(node, attributes) {
      // @ts-ignore
      const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
      for (const key in attributes) {
          if (attributes[key] == null) {
              node.removeAttribute(key);
          }
          else if (key === 'style') {
              node.style.cssText = attributes[key];
          }
          else if (key === '__value') {
              node.value = node[key] = attributes[key];
          }
          else if (descriptors[key] && descriptors[key].set) {
              node[key] = attributes[key];
          }
          else {
              attr(node, key, attributes[key]);
          }
      }
  }
  function children(element) {
      return Array.from(element.childNodes);
  }
  function toggle_class(element, name, toggle) {
      element.classList[toggle ? 'add' : 'remove'](name);
  }
  function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
      const e = document.createEvent('CustomEvent');
      e.initCustomEvent(type, bubbles, cancelable, detail);
      return e;
  }
  class HtmlTag {
      constructor(is_svg = false) {
          this.is_svg = false;
          this.is_svg = is_svg;
          this.e = this.n = null;
      }
      c(html) {
          this.h(html);
      }
      m(html, target, anchor = null) {
          if (!this.e) {
              if (this.is_svg)
                  this.e = svg_element(target.nodeName);
              else
                  this.e = element(target.nodeName);
              this.t = target;
              this.c(html);
          }
          this.i(anchor);
      }
      h(html) {
          this.e.innerHTML = html;
          this.n = Array.from(this.e.childNodes);
      }
      i(anchor) {
          for (let i = 0; i < this.n.length; i += 1) {
              insert(this.t, this.n[i], anchor);
          }
      }
      p(html) {
          this.d();
          this.h(html);
          this.i(this.a);
      }
      d() {
          this.n.forEach(detach);
      }
  }
  function attribute_to_object(attributes) {
      const result = {};
      for (const attribute of attributes) {
          result[attribute.name] = attribute.value;
      }
      return result;
  }
  function get_custom_elements_slots(element) {
      const result = {};
      element.childNodes.forEach((node) => {
          result[node.slot || 'default'] = true;
      });
      return result;
  }

  // we need to store the information for multiple documents because a Svelte application could also contain iframes
  // https://github.com/sveltejs/svelte/issues/3624
  const managed_styles = new Map();
  let active = 0;
  // https://github.com/darkskyapp/string-hash/blob/master/index.js
  function hash(str) {
      let hash = 5381;
      let i = str.length;
      while (i--)
          hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
      return hash >>> 0;
  }
  function create_style_information(doc, node) {
      const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
      managed_styles.set(doc, info);
      return info;
  }
  function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
      const step = 16.666 / duration;
      let keyframes = '{\n';
      for (let p = 0; p <= 1; p += step) {
          const t = a + (b - a) * ease(p);
          keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
      }
      const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
      const name = `__svelte_${hash(rule)}_${uid}`;
      const doc = get_root_for_style(node);
      const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
      if (!rules[name]) {
          rules[name] = true;
          stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
      }
      const animation = node.style.animation || '';
      node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
      active += 1;
      return name;
  }
  function delete_rule(node, name) {
      const previous = (node.style.animation || '').split(', ');
      const next = previous.filter(name
          ? anim => anim.indexOf(name) < 0 // remove specific animation
          : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
      );
      const deleted = previous.length - next.length;
      if (deleted) {
          node.style.animation = next.join(', ');
          active -= deleted;
          if (!active)
              clear_rules();
      }
  }
  function clear_rules() {
      raf(() => {
          if (active)
              return;
          managed_styles.forEach(info => {
              const { ownerNode } = info.stylesheet;
              // there is no ownerNode if it runs on jsdom.
              if (ownerNode)
                  detach(ownerNode);
          });
          managed_styles.clear();
      });
  }

  let current_component;
  function set_current_component(component) {
      current_component = component;
  }
  function get_current_component() {
      if (!current_component)
          throw new Error('Function called outside component initialization');
      return current_component;
  }
  function onMount(fn) {
      get_current_component().$$.on_mount.push(fn);
  }

  const dirty_components = [];
  const binding_callbacks = [];
  const render_callbacks = [];
  const flush_callbacks = [];
  const resolved_promise = Promise.resolve();
  let update_scheduled = false;
  function schedule_update() {
      if (!update_scheduled) {
          update_scheduled = true;
          resolved_promise.then(flush);
      }
  }
  function add_render_callback(fn) {
      render_callbacks.push(fn);
  }
  // flush() calls callbacks in this order:
  // 1. All beforeUpdate callbacks, in order: parents before children
  // 2. All bind:this callbacks, in reverse order: children before parents.
  // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
  //    for afterUpdates called during the initial onMount, which are called in
  //    reverse order: children before parents.
  // Since callbacks might update component values, which could trigger another
  // call to flush(), the following steps guard against this:
  // 1. During beforeUpdate, any updated components will be added to the
  //    dirty_components array and will cause a reentrant call to flush(). Because
  //    the flush index is kept outside the function, the reentrant call will pick
  //    up where the earlier call left off and go through all dirty components. The
  //    current_component value is saved and restored so that the reentrant call will
  //    not interfere with the "parent" flush() call.
  // 2. bind:this callbacks cannot trigger new flush() calls.
  // 3. During afterUpdate, any updated components will NOT have their afterUpdate
  //    callback called a second time; the seen_callbacks set, outside the flush()
  //    function, guarantees this behavior.
  const seen_callbacks = new Set();
  let flushidx = 0; // Do *not* move this inside the flush() function
  function flush() {
      const saved_component = current_component;
      do {
          // first, call beforeUpdate functions
          // and update components
          while (flushidx < dirty_components.length) {
              const component = dirty_components[flushidx];
              flushidx++;
              set_current_component(component);
              update(component.$$);
          }
          set_current_component(null);
          dirty_components.length = 0;
          flushidx = 0;
          while (binding_callbacks.length)
              binding_callbacks.pop()();
          // then, once components are updated, call
          // afterUpdate functions. This may cause
          // subsequent updates...
          for (let i = 0; i < render_callbacks.length; i += 1) {
              const callback = render_callbacks[i];
              if (!seen_callbacks.has(callback)) {
                  // ...so guard against infinite loops
                  seen_callbacks.add(callback);
                  callback();
              }
          }
          render_callbacks.length = 0;
      } while (dirty_components.length);
      while (flush_callbacks.length) {
          flush_callbacks.pop()();
      }
      update_scheduled = false;
      seen_callbacks.clear();
      set_current_component(saved_component);
  }
  function update($$) {
      if ($$.fragment !== null) {
          $$.update();
          run_all($$.before_update);
          const dirty = $$.dirty;
          $$.dirty = [-1];
          $$.fragment && $$.fragment.p($$.ctx, dirty);
          $$.after_update.forEach(add_render_callback);
      }
  }

  let promise;
  function wait() {
      if (!promise) {
          promise = Promise.resolve();
          promise.then(() => {
              promise = null;
          });
      }
      return promise;
  }
  function dispatch(node, direction, kind) {
      node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
  }
  const outroing = new Set();
  let outros;
  function group_outros() {
      outros = {
          r: 0,
          c: [],
          p: outros // parent group
      };
  }
  function check_outros() {
      if (!outros.r) {
          run_all(outros.c);
      }
      outros = outros.p;
  }
  function transition_in(block, local) {
      if (block && block.i) {
          outroing.delete(block);
          block.i(local);
      }
  }
  function transition_out(block, local, detach, callback) {
      if (block && block.o) {
          if (outroing.has(block))
              return;
          outroing.add(block);
          outros.c.push(() => {
              outroing.delete(block);
              if (callback) {
                  if (detach)
                      block.d(1);
                  callback();
              }
          });
          block.o(local);
      }
      else if (callback) {
          callback();
      }
  }
  const null_transition = { duration: 0 };
  function create_in_transition(node, fn, params) {
      let config = fn(node, params);
      let running = false;
      let animation_name;
      let task;
      let uid = 0;
      function cleanup() {
          if (animation_name)
              delete_rule(node, animation_name);
      }
      function go() {
          const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
          if (css)
              animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
          tick(0, 1);
          const start_time = now() + delay;
          const end_time = start_time + duration;
          if (task)
              task.abort();
          running = true;
          add_render_callback(() => dispatch(node, true, 'start'));
          task = loop(now => {
              if (running) {
                  if (now >= end_time) {
                      tick(1, 0);
                      dispatch(node, true, 'end');
                      cleanup();
                      return running = false;
                  }
                  if (now >= start_time) {
                      const t = easing((now - start_time) / duration);
                      tick(t, 1 - t);
                  }
              }
              return running;
          });
      }
      let started = false;
      return {
          start() {
              if (started)
                  return;
              started = true;
              delete_rule(node);
              if (is_function(config)) {
                  config = config();
                  wait().then(go);
              }
              else {
                  go();
              }
          },
          invalidate() {
              started = false;
          },
          end() {
              if (running) {
                  cleanup();
                  running = false;
              }
          }
      };
  }
  function create_out_transition(node, fn, params) {
      let config = fn(node, params);
      let running = true;
      let animation_name;
      const group = outros;
      group.r += 1;
      function go() {
          const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
          if (css)
              animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
          const start_time = now() + delay;
          const end_time = start_time + duration;
          add_render_callback(() => dispatch(node, false, 'start'));
          loop(now => {
              if (running) {
                  if (now >= end_time) {
                      tick(0, 1);
                      dispatch(node, false, 'end');
                      if (!--group.r) {
                          // this will result in `end()` being called,
                          // so we don't need to clean up here
                          run_all(group.c);
                      }
                      return false;
                  }
                  if (now >= start_time) {
                      const t = easing((now - start_time) / duration);
                      tick(1 - t, t);
                  }
              }
              return running;
          });
      }
      if (is_function(config)) {
          wait().then(() => {
              // @ts-ignore
              config = config();
              go();
          });
      }
      else {
          go();
      }
      return {
          end(reset) {
              if (reset && config.tick) {
                  config.tick(1, 0);
              }
              if (running) {
                  if (animation_name)
                      delete_rule(node, animation_name);
                  running = false;
              }
          }
      };
  }
  function create_bidirectional_transition(node, fn, params, intro) {
      let config = fn(node, params);
      let t = intro ? 0 : 1;
      let running_program = null;
      let pending_program = null;
      let animation_name = null;
      function clear_animation() {
          if (animation_name)
              delete_rule(node, animation_name);
      }
      function init(program, duration) {
          const d = (program.b - t);
          duration *= Math.abs(d);
          return {
              a: t,
              b: program.b,
              d,
              duration,
              start: program.start,
              end: program.start + duration,
              group: program.group
          };
      }
      function go(b) {
          const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
          const program = {
              start: now() + delay,
              b
          };
          if (!b) {
              // @ts-ignore todo: improve typings
              program.group = outros;
              outros.r += 1;
          }
          if (running_program || pending_program) {
              pending_program = program;
          }
          else {
              // if this is an intro, and there's a delay, we need to do
              // an initial tick and/or apply CSS animation immediately
              if (css) {
                  clear_animation();
                  animation_name = create_rule(node, t, b, duration, delay, easing, css);
              }
              if (b)
                  tick(0, 1);
              running_program = init(program, duration);
              add_render_callback(() => dispatch(node, b, 'start'));
              loop(now => {
                  if (pending_program && now > pending_program.start) {
                      running_program = init(pending_program, duration);
                      pending_program = null;
                      dispatch(node, running_program.b, 'start');
                      if (css) {
                          clear_animation();
                          animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                      }
                  }
                  if (running_program) {
                      if (now >= running_program.end) {
                          tick(t = running_program.b, 1 - t);
                          dispatch(node, running_program.b, 'end');
                          if (!pending_program) {
                              // we're done
                              if (running_program.b) {
                                  // intro — we can tidy up immediately
                                  clear_animation();
                              }
                              else {
                                  // outro — needs to be coordinated
                                  if (!--running_program.group.r)
                                      run_all(running_program.group.c);
                              }
                          }
                          running_program = null;
                      }
                      else if (now >= running_program.start) {
                          const p = now - running_program.start;
                          t = running_program.a + running_program.d * easing(p / running_program.duration);
                          tick(t, 1 - t);
                      }
                  }
                  return !!(running_program || pending_program);
              });
          }
      }
      return {
          run(b) {
              if (is_function(config)) {
                  wait().then(() => {
                      // @ts-ignore
                      config = config();
                      go(b);
                  });
              }
              else {
                  go(b);
              }
          },
          end() {
              clear_animation();
              running_program = pending_program = null;
          }
      };
  }

  const globals = (typeof window !== 'undefined'
      ? window
      : typeof globalThis !== 'undefined'
          ? globalThis
          : global);

  function get_spread_update(levels, updates) {
      const update = {};
      const to_null_out = {};
      const accounted_for = { $$scope: 1 };
      let i = levels.length;
      while (i--) {
          const o = levels[i];
          const n = updates[i];
          if (n) {
              for (const key in o) {
                  if (!(key in n))
                      to_null_out[key] = 1;
              }
              for (const key in n) {
                  if (!accounted_for[key]) {
                      update[key] = n[key];
                      accounted_for[key] = 1;
                  }
              }
              levels[i] = n;
          }
          else {
              for (const key in o) {
                  accounted_for[key] = 1;
              }
          }
      }
      for (const key in to_null_out) {
          if (!(key in update))
              update[key] = undefined;
      }
      return update;
  }

  /** regex of all html void element names */
  const void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
  function is_void(name) {
      return void_element_names.test(name) || name.toLowerCase() === '!doctype';
  }
  function mount_component(component, target, anchor, customElement) {
      const { fragment, on_mount, on_destroy, after_update } = component.$$;
      fragment && fragment.m(target, anchor);
      if (!customElement) {
          // onMount happens before the initial afterUpdate
          add_render_callback(() => {
              const new_on_destroy = on_mount.map(run).filter(is_function);
              if (on_destroy) {
                  on_destroy.push(...new_on_destroy);
              }
              else {
                  // Edge case - component was destroyed immediately,
                  // most likely as a result of a binding initialising
                  run_all(new_on_destroy);
              }
              component.$$.on_mount = [];
          });
      }
      after_update.forEach(add_render_callback);
  }
  function destroy_component(component, detaching) {
      const $$ = component.$$;
      if ($$.fragment !== null) {
          run_all($$.on_destroy);
          $$.fragment && $$.fragment.d(detaching);
          // TODO null out other refs, including component.$$ (but need to
          // preserve final state?)
          $$.on_destroy = $$.fragment = null;
          $$.ctx = [];
      }
  }
  function make_dirty(component, i) {
      if (component.$$.dirty[0] === -1) {
          dirty_components.push(component);
          schedule_update();
          component.$$.dirty.fill(0);
      }
      component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
  }
  function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
      const parent_component = current_component;
      set_current_component(component);
      const $$ = component.$$ = {
          fragment: null,
          ctx: null,
          // state
          props,
          update: noop,
          not_equal,
          bound: blank_object(),
          // lifecycle
          on_mount: [],
          on_destroy: [],
          on_disconnect: [],
          before_update: [],
          after_update: [],
          context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
          // everything else
          callbacks: blank_object(),
          dirty,
          skip_bound: false,
          root: options.target || parent_component.$$.root
      };
      append_styles && append_styles($$.root);
      let ready = false;
      $$.ctx = instance
          ? instance(component, options.props || {}, (i, ret, ...rest) => {
              const value = rest.length ? rest[0] : ret;
              if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                  if (!$$.skip_bound && $$.bound[i])
                      $$.bound[i](value);
                  if (ready)
                      make_dirty(component, i);
              }
              return ret;
          })
          : [];
      $$.update();
      ready = true;
      run_all($$.before_update);
      // `false` as a special case of no DOM component
      $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
      if (options.target) {
          if (options.hydrate) {
              const nodes = children(options.target);
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              $$.fragment && $$.fragment.l(nodes);
              nodes.forEach(detach);
          }
          else {
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              $$.fragment && $$.fragment.c();
          }
          if (options.intro)
              transition_in(component.$$.fragment);
          mount_component(component, options.target, options.anchor, options.customElement);
          flush();
      }
      set_current_component(parent_component);
  }
  let SvelteElement;
  if (typeof HTMLElement === 'function') {
      SvelteElement = class extends HTMLElement {
          constructor() {
              super();
              this.attachShadow({ mode: 'open' });
          }
          connectedCallback() {
              const { on_mount } = this.$$;
              this.$$.on_disconnect = on_mount.map(run).filter(is_function);
              // @ts-ignore todo: improve typings
              for (const key in this.$$.slotted) {
                  // @ts-ignore todo: improve typings
                  this.appendChild(this.$$.slotted[key]);
              }
          }
          attributeChangedCallback(attr, _oldValue, newValue) {
              this[attr] = newValue;
          }
          disconnectedCallback() {
              run_all(this.$$.on_disconnect);
          }
          $destroy() {
              destroy_component(this, 1);
              this.$destroy = noop;
          }
          $on(type, callback) {
              // TODO should this delegate to addEventListener?
              const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
              callbacks.push(callback);
              return () => {
                  const index = callbacks.indexOf(callback);
                  if (index !== -1)
                      callbacks.splice(index, 1);
              };
          }
          $set($$props) {
              if (this.$$set && !is_empty($$props)) {
                  this.$$.skip_bound = true;
                  this.$$set($$props);
                  this.$$.skip_bound = false;
              }
          }
      };
  }

  function dispatch_dev(type, detail) {
      document.dispatchEvent(custom_event(type, Object.assign({ version: '3.50.1' }, detail), { bubbles: true }));
  }
  function append_dev(target, node) {
      dispatch_dev('SvelteDOMInsert', { target, node });
      append(target, node);
  }
  function insert_dev(target, node, anchor) {
      dispatch_dev('SvelteDOMInsert', { target, node, anchor });
      insert(target, node, anchor);
  }
  function detach_dev(node) {
      dispatch_dev('SvelteDOMRemove', { node });
      detach(node);
  }
  function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
      const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
      if (has_prevent_default)
          modifiers.push('preventDefault');
      if (has_stop_propagation)
          modifiers.push('stopPropagation');
      dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
      const dispose = listen(node, event, handler, options);
      return () => {
          dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
          dispose();
      };
  }
  function attr_dev(node, attribute, value) {
      attr(node, attribute, value);
      if (value == null)
          dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
      else
          dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
  }
  function set_data_dev(text, data) {
      data = '' + data;
      if (text.wholeText === data)
          return;
      dispatch_dev('SvelteDOMSetData', { node: text, data });
      text.data = data;
  }
  function validate_each_argument(arg) {
      if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
          let msg = '{#each} only iterates over array-like objects.';
          if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
              msg += ' You can use a spread to convert this iterable into an array.';
          }
          throw new Error(msg);
      }
  }
  function validate_slots(name, slot, keys) {
      for (const slot_key of Object.keys(slot)) {
          if (!~keys.indexOf(slot_key)) {
              console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
          }
      }
  }
  function validate_dynamic_element(tag) {
      const is_string = typeof tag === 'string';
      if (tag && !is_string) {
          throw new Error('<svelte:element> expects "this" attribute to be a string.');
      }
  }
  function validate_void_dynamic_element(tag) {
      if (tag && is_void(tag)) {
          throw new Error(`<svelte:element this="${tag}"> is self-closing and cannot have content.`);
      }
  }

  function cubicOut(t) {
      const f = t - 1.0;
      return f * f * f + 1.0;
  }

  function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
      const o = +getComputedStyle(node).opacity;
      return {
          delay,
          duration,
          easing,
          css: t => `opacity: ${t * o}`
      };
  }
  function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
      const style = getComputedStyle(node);
      const target_opacity = +style.opacity;
      const transform = style.transform === 'none' ? '' : style.transform;
      const od = target_opacity * (1 - opacity);
      return {
          delay,
          duration,
          easing,
          css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
      };
  }
  function slide(node, { delay = 0, duration = 400, easing = cubicOut } = {}) {
      const style = getComputedStyle(node);
      const opacity = +style.opacity;
      const height = parseFloat(style.height);
      const padding_top = parseFloat(style.paddingTop);
      const padding_bottom = parseFloat(style.paddingBottom);
      const margin_top = parseFloat(style.marginTop);
      const margin_bottom = parseFloat(style.marginBottom);
      const border_top_width = parseFloat(style.borderTopWidth);
      const border_bottom_width = parseFloat(style.borderBottomWidth);
      return {
          delay,
          duration,
          easing,
          css: t => 'overflow: hidden;' +
              `opacity: ${Math.min(t * 20, 1) * opacity};` +
              `height: ${t * height}px;` +
              `padding-top: ${t * padding_top}px;` +
              `padding-bottom: ${t * padding_bottom}px;` +
              `margin-top: ${t * margin_top}px;` +
              `margin-bottom: ${t * margin_bottom}px;` +
              `border-top-width: ${t * border_top_width}px;` +
              `border-bottom-width: ${t * border_bottom_width}px;`
      };
  }

  class Utils {
      static relativeBasePath = document.currentScript.getAttribute('relative-base-path') || '/';
      static cssRelativePath = `${this.relativeBasePath}/css/`.replace('//','/')
      static imagesRelativePath = `${this.relativeBasePath}/images/`.replace('//','/')
      static cssFullPath = `${this.cssRelativePath}utd-webcomponents.min.css?v=1.7.6`

      static conserverFocusElement(componentShadow, componentRoot) {
          const elementsFocusablesShadow = Array.from(this.obtenirElementsFocusables(componentShadow));
          const elementsFocusablesRoot = Array.from(this.obtenirElementsFocusables(componentRoot));
          const elementsFocusables = elementsFocusablesShadow.concat(elementsFocusablesRoot);

          const premierElementFocusable = elementsFocusables[0];
          const dernierElementFocusable = elementsFocusables[elementsFocusables.length - 1];
          const KEYCODE_TAB = 9;

          componentShadow.addEventListener('keydown', function(e) {
              let estToucheTab = (e.key === 'Tab' || e.keyCode === KEYCODE_TAB);

              if (!estToucheTab) {
                  return
              }
      
              const elementActif = document.activeElement.shadowRoot ? document.activeElement.shadowRoot.activeElement : document.activeElement;
              if (e.shiftKey) /* shift + tab */ {
                  if (elementActif === premierElementFocusable) {
                      dernierElementFocusable.focus();
                      e.preventDefault();
                  }
              } else /* tab */ {
                  if (elementsFocusables.length === 1 || elementActif === dernierElementFocusable ) {
                      premierElementFocusable.focus();
                      e.preventDefault();
                  }
              }    
          });
      }
      static obtenirElementsFocusables(element) {
              return element.querySelectorAll('a[href]:not([disabled]), button:not([disabled]), textarea:not([disabled]), input:not([type="hidden"]):not([disabled]), select:not([disabled])')
          }
          /**
           * Génère un id unique.
           * @returns L'id unique généré.
           */
      static genererId() {
          return Date.now().toString(36) + '-' + Math.random().toString(36).substr(2, 9);
      }
      /**
       * Créé un événement custom pour un webComponent.
       * @param {*} component Objet associé à notre composant (objet DOM).
       * @param {*} nomEvenement Nom de l'événement. 
       * @param {*} detailsEvenement Détails de l'événement.
       */
      static dispatchWcEvent = (component, nomEvenement, detailsEvenement) => {
          component.dispatchEvent(new CustomEvent(nomEvenement, {
              detail: detailsEvenement,
              composed: true // propage l'événement à travers le shadow DOM (Remonte au document)
          }));
      }

      static estMobile() {
          return navigator.maxTouchPoints || 'ontouchstart' in document.documentElement
      }

      static ajusterInterfaceAvantAffichageModale(html, body) {
          
          if(!this.estMobile()){
              const largeurScrollbarHtml = window.innerWidth - html.offsetWidth;

              if(largeurScrollbarHtml > 0){
                  html.style['padding-right'] = largeurScrollbarHtml + 'px';
              } 
              else {
                  const largeurScrollbarBody = window.innerWidth - body.offsetWidth;
                  if(largeurScrollbarBody > 0){
                      body.style['padding-right'] = largeurScrollbarBody + 'px';
                  }
              }
          }      
          /* On s'assure que le scroll ne changera pas une fois le body modifié avec position fixe */
          const scrollY = window.scrollY;
          html.classList.add("utd-modale-ouverte");
          document.body.style.top = `-${scrollY}px`;
      }

      static ajusterInterfacePendantAffichageModale(body, modale) {

          if(!this.estMobile()){
              const largeurScrollbarModale = window.innerWidth - modale.offsetWidth;
              if(largeurScrollbarModale > 0){
                  body.style['padding-right'] = largeurScrollbarModale + 'px';
              }     
          }         
      }

      static ajusterInterfaceApresFermetureModale(html, body) {        
          html.style.removeProperty('padding-right');
          body.style.removeProperty('padding-right');
          html.classList.remove("utd-modale-ouverte");

          /* Repositionner l'écran où il était avant l'affichage de la modale. */    
          const scrollY = document.body.style.top;
          document.body.style.position = '';
          document.body.style.top = '';
          window.scrollTo(0, parseInt(scrollY || '0') * -1);
      }

      static slotExiste(slots, nomSlot) {
          return slots.some(s => s.slot === nomSlot)
      }

      static obtenirSlot(slots, nomSlot) {
          return slots.find(s => s.slot === nomSlot)
      }

      static obtenirTextesDefaut() {
          const textes = {
              texteSrOuvertureNouvelOnglet: this.obtenirLanguePage() === 'fr' ? `. Ce lien sera ouvert dans un nouvel onglet.` : `. This link will open in a new tab.`
          };
          return textes
      }
      /**
       * Obtient la langue de la page courante.
       * @returns {string} Code de langue de la page courante (fr/en).
       */
      static obtenirLanguePage() {
          return document.getElementsByTagName("html")[0].getAttribute("lang") || "fr";
      }
  }

  /* src\components\accordeon.svelte generated by Svelte v3.50.1 */
  const file$c = "src\\components\\accordeon.svelte";

  // (29:10) {#if titre}
  function create_if_block_2$4(ctx) {
  	let t;

  	const block = {
  		c: function create() {
  			t = text(/*titre*/ ctx[1]);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*titre*/ 2) set_data_dev(t, /*titre*/ ctx[1]);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2$4.name,
  		type: "if",
  		source: "(29:10) {#if titre}",
  		ctx
  	});

  	return block;
  }

  // (26:4) <svelte:element this={tagTitre} class="titre">
  function create_dynamic_element$1(ctx) {
  	let svelte_element;
  	let button;
  	let span0;
  	let t0;
  	let slot;
  	let t1;
  	let span1;
  	let span1_class_value;
  	let button_aria_expanded_value;
  	let mounted;
  	let dispose;
  	let if_block = /*titre*/ ctx[1] && create_if_block_2$4(ctx);
  	let svelte_element_levels = [{ class: "titre" }];
  	let svelte_element_data = {};

  	for (let i = 0; i < svelte_element_levels.length; i += 1) {
  		svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  	}

  	const block = {
  		c: function create() {
  			svelte_element = element(/*tagTitre*/ ctx[3]);
  			button = element("button");
  			span0 = element("span");
  			if (if_block) if_block.c();
  			t0 = space();
  			slot = element("slot");
  			t1 = space();
  			span1 = element("span");
  			attr_dev(slot, "name", "titre");
  			add_location(slot, file$c, 31, 10, 1014);
  			attr_dev(span0, "class", "titre");
  			add_location(span0, file$c, 27, 8, 921);
  			attr_dev(span1, "class", span1_class_value = "utd-icone-svg " + (/*reduit*/ ctx[0] === 'false' ? 'moins' : 'plus'));
  			add_location(span1, file$c, 33, 8, 1068);
  			attr_dev(button, "type", "button");
  			attr_dev(button, "class", "");
  			attr_dev(button, "aria-controls", /*idContenu*/ ctx[4]);
  			attr_dev(button, "aria-expanded", button_aria_expanded_value = /*reduit*/ ctx[0] === 'false');
  			add_location(button, file$c, 26, 6, 781);
  			set_attributes(svelte_element, svelte_element_data);
  			add_location(svelte_element, file$c, 25, 4, 726);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, svelte_element, anchor);
  			append_dev(svelte_element, button);
  			append_dev(button, span0);
  			if (if_block) if_block.m(span0, null);
  			append_dev(span0, t0);
  			append_dev(span0, slot);
  			append_dev(button, t1);
  			append_dev(button, span1);

  			if (!mounted) {
  				dispose = listen_dev(button, "click", /*toggleAffichageContenu*/ ctx[5], false, false, false);
  				mounted = true;
  			}
  		},
  		p: function update(ctx, dirty) {
  			if (/*titre*/ ctx[1]) {
  				if (if_block) {
  					if_block.p(ctx, dirty);
  				} else {
  					if_block = create_if_block_2$4(ctx);
  					if_block.c();
  					if_block.m(span0, t0);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}

  			if (dirty & /*reduit*/ 1 && span1_class_value !== (span1_class_value = "utd-icone-svg " + (/*reduit*/ ctx[0] === 'false' ? 'moins' : 'plus'))) {
  				attr_dev(span1, "class", span1_class_value);
  			}

  			if (dirty & /*reduit*/ 1 && button_aria_expanded_value !== (button_aria_expanded_value = /*reduit*/ ctx[0] === 'false')) {
  				attr_dev(button, "aria-expanded", button_aria_expanded_value);
  			}

  			set_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [{ class: "titre" }]));
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(svelte_element);
  			if (if_block) if_block.d();
  			mounted = false;
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_dynamic_element$1.name,
  		type: "child_dynamic_element",
  		source: "(26:4) <svelte:element this={tagTitre} class=\\\"titre\\\">",
  		ctx
  	});

  	return block;
  }

  // (40:6) {#if reduit === 'false'}
  function create_if_block$9(ctx) {
  	let div;
  	let div_transition;
  	let current;

  	function select_block_type(ctx, dirty) {
  		if (/*contenu*/ ctx[2]) return create_if_block_1$5;
  		return create_else_block$2;
  	}

  	let current_block_type = select_block_type(ctx);
  	let if_block = current_block_type(ctx);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if_block.c();
  			attr_dev(div, "class", "conteneur");
  			add_location(div, file$c, 40, 8, 1289);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			if_block.m(div, null);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
  				if_block.p(ctx, dirty);
  			} else {
  				if_block.d(1);
  				if_block = current_block_type(ctx);

  				if (if_block) {
  					if_block.c();
  					if_block.m(div, null);
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;

  			add_render_callback(() => {
  				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 250 }, true);
  				div_transition.run(1);
  			});

  			current = true;
  		},
  		o: function outro(local) {
  			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 250 }, false);
  			div_transition.run(0);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if_block.d();
  			if (detaching && div_transition) div_transition.end();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$9.name,
  		type: "if",
  		source: "(40:6) {#if reduit === 'false'}",
  		ctx
  	});

  	return block;
  }

  // (44:10) {:else}
  function create_else_block$2(ctx) {
  	let slot0;
  	let t;
  	let slot1;

  	const block = {
  		c: function create() {
  			slot0 = element("slot");
  			t = space();
  			slot1 = element("slot");
  			add_location(slot0, file$c, 44, 12, 1435);
  			attr_dev(slot1, "name", "contenu");
  			add_location(slot1, file$c, 45, 12, 1458);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, slot0, anchor);
  			insert_dev(target, t, anchor);
  			insert_dev(target, slot1, anchor);
  		},
  		p: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(slot0);
  			if (detaching) detach_dev(t);
  			if (detaching) detach_dev(slot1);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block$2.name,
  		type: "else",
  		source: "(44:10) {:else}",
  		ctx
  	});

  	return block;
  }

  // (42:10) {#if contenu}
  function create_if_block_1$5(ctx) {
  	let html_tag;
  	let html_anchor;

  	const block = {
  		c: function create() {
  			html_tag = new HtmlTag(false);
  			html_anchor = empty();
  			html_tag.a = html_anchor;
  		},
  		m: function mount(target, anchor) {
  			html_tag.m(/*contenu*/ ctx[2], target, anchor);
  			insert_dev(target, html_anchor, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*contenu*/ 4) html_tag.p(/*contenu*/ ctx[2]);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(html_anchor);
  			if (detaching) html_tag.d();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$5.name,
  		type: "if",
  		source: "(42:10) {#if contenu}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$c(ctx) {
  	let div2;
  	let div0;
  	let previous_tag = /*tagTitre*/ ctx[3];
  	let t2;
  	let div1;
  	let div2_class_value;
  	let t3;
  	let link;
  	let current;
  	validate_dynamic_element(/*tagTitre*/ ctx[3]);
  	validate_void_dynamic_element(/*tagTitre*/ ctx[3]);
  	let svelte_element = /*tagTitre*/ ctx[3] && create_dynamic_element$1(ctx);
  	let if_block1 = /*reduit*/ ctx[0] === 'false' && create_if_block$9(ctx);

  	const block = {
  		c: function create() {
  			div2 = element("div");
  			div0 = element("div");
  			if (svelte_element) svelte_element.c();
  			t2 = space();
  			div1 = element("div");
  			if (if_block1) if_block1.c();
  			t3 = space();
  			link = element("link");
  			this.c = noop;
  			attr_dev(div0, "class", "entete");
  			add_location(div0, file$c, 24, 2, 700);
  			attr_dev(div1, "id", /*idContenu*/ ctx[4]);
  			attr_dev(div1, "class", "contenu");
  			add_location(div1, file$c, 38, 4, 1208);
  			attr_dev(div2, "class", div2_class_value = "utd-component utd-accordeon " + (/*reduit*/ ctx[0] === 'false' ? 'ouvert' : ''));
  			add_location(div2, file$c, 23, 0, 617);
  			attr_dev(link, "rel", "stylesheet");
  			attr_dev(link, "href", Utils.cssFullPath);
  			add_location(link, file$c, 53, 0, 1553);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div2, anchor);
  			append_dev(div2, div0);
  			if (svelte_element) svelte_element.m(div0, null);
  			append_dev(div2, t2);
  			append_dev(div2, div1);
  			if (if_block1) if_block1.m(div1, null);
  			insert_dev(target, t3, anchor);
  			insert_dev(target, link, anchor);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			if (/*tagTitre*/ ctx[3]) {
  				if (!previous_tag) {
  					svelte_element = create_dynamic_element$1(ctx);
  					svelte_element.c();
  					svelte_element.m(div0, null);
  				} else if (safe_not_equal(previous_tag, /*tagTitre*/ ctx[3])) {
  					svelte_element.d(1);
  					validate_dynamic_element(/*tagTitre*/ ctx[3]);
  					validate_void_dynamic_element(/*tagTitre*/ ctx[3]);
  					svelte_element = create_dynamic_element$1(ctx);
  					svelte_element.c();
  					svelte_element.m(div0, null);
  				} else {
  					svelte_element.p(ctx, dirty);
  				}
  			} else if (previous_tag) {
  				svelte_element.d(1);
  				svelte_element = null;
  			}

  			previous_tag = /*tagTitre*/ ctx[3];

  			if (/*reduit*/ ctx[0] === 'false') {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty & /*reduit*/ 1) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block$9(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div1, null);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (!current || dirty & /*reduit*/ 1 && div2_class_value !== (div2_class_value = "utd-component utd-accordeon " + (/*reduit*/ ctx[0] === 'false' ? 'ouvert' : ''))) {
  				attr_dev(div2, "class", div2_class_value);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block1);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block1);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div2);
  			if (svelte_element) svelte_element.d(detaching);
  			if (if_block1) if_block1.d();
  			if (detaching) detach_dev(t3);
  			if (detaching) detach_dev(link);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$c.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$c($$self, $$props, $$invalidate) {
  	let { $$slots: slots = {}, $$scope } = $$props;
  	validate_slots('utd-accordeon', slots, []);
  	let { reduit = "true" } = $$props;
  	let { titre = "" } = $$props;
  	let { contenu = "" } = $$props;
  	let { tagTitre = "h2" } = $$props;
  	const idEntete = Utils.genererId();
  	const idContenu = 'corps' + idEntete;

  	function toggleAffichageContenu() {
  		$$invalidate(0, reduit = reduit === 'true' ? 'false' : 'true');
  	}

  	const writable_props = ['reduit', 'titre', 'contenu', 'tagTitre'];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<utd-accordeon> was created with unknown prop '${key}'`);
  	});

  	$$self.$$set = $$props => {
  		if ('reduit' in $$props) $$invalidate(0, reduit = $$props.reduit);
  		if ('titre' in $$props) $$invalidate(1, titre = $$props.titre);
  		if ('contenu' in $$props) $$invalidate(2, contenu = $$props.contenu);
  		if ('tagTitre' in $$props) $$invalidate(3, tagTitre = $$props.tagTitre);
  	};

  	$$self.$capture_state = () => ({
  		slide,
  		Utils,
  		reduit,
  		titre,
  		contenu,
  		tagTitre,
  		idEntete,
  		idContenu,
  		toggleAffichageContenu
  	});

  	$$self.$inject_state = $$props => {
  		if ('reduit' in $$props) $$invalidate(0, reduit = $$props.reduit);
  		if ('titre' in $$props) $$invalidate(1, titre = $$props.titre);
  		if ('contenu' in $$props) $$invalidate(2, contenu = $$props.contenu);
  		if ('tagTitre' in $$props) $$invalidate(3, tagTitre = $$props.tagTitre);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [reduit, titre, contenu, tagTitre, idContenu, toggleAffichageContenu];
  }

  class Accordeon extends SvelteElement {
  	constructor(options) {
  		super();

  		init(
  			this,
  			{
  				target: this.shadowRoot,
  				props: attribute_to_object(this.attributes),
  				customElement: true
  			},
  			instance$c,
  			create_fragment$c,
  			safe_not_equal,
  			{
  				reduit: 0,
  				titre: 1,
  				contenu: 2,
  				tagTitre: 3
  			},
  			null
  		);

  		if (options) {
  			if (options.target) {
  				insert_dev(options.target, this, options.anchor);
  			}

  			if (options.props) {
  				this.$set(options.props);
  				flush();
  			}
  		}
  	}

  	static get observedAttributes() {
  		return ["reduit", "titre", "contenu", "tagTitre"];
  	}

  	get reduit() {
  		return this.$$.ctx[0];
  	}

  	set reduit(reduit) {
  		this.$$set({ reduit });
  		flush();
  	}

  	get titre() {
  		return this.$$.ctx[1];
  	}

  	set titre(titre) {
  		this.$$set({ titre });
  		flush();
  	}

  	get contenu() {
  		return this.$$.ctx[2];
  	}

  	set contenu(contenu) {
  		this.$$set({ contenu });
  		flush();
  	}

  	get tagTitre() {
  		return this.$$.ctx[3];
  	}

  	set tagTitre(tagTitre) {
  		this.$$set({ tagTitre });
  		flush();
  	}
  }

  customElements.define("utd-accordeon", Accordeon);

  /* src\components\avis.svelte generated by Svelte v3.50.1 */
  const file$b = "src\\components\\avis.svelte";

  // (22:6) {#if contenu}
  function create_if_block$8(ctx) {
  	let html_tag;
  	let html_anchor;

  	const block = {
  		c: function create() {
  			html_tag = new HtmlTag(false);
  			html_anchor = empty();
  			html_tag.a = html_anchor;
  		},
  		m: function mount(target, anchor) {
  			html_tag.m(/*contenu*/ ctx[2], target, anchor);
  			insert_dev(target, html_anchor, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*contenu*/ 4) html_tag.p(/*contenu*/ ctx[2]);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(html_anchor);
  			if (detaching) html_tag.d();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$8.name,
  		type: "if",
  		source: "(22:6) {#if contenu}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$b(ctx) {
  	let div4;
  	let div1;
  	let div0;
  	let div0_class_value;
  	let t0;
  	let div3;
  	let h2;
  	let t1;
  	let t2;
  	let div2;
  	let t3;
  	let slot0;
  	let t4;
  	let slot1;
  	let div4_class_value;
  	let t5;
  	let link;
  	let if_block = /*contenu*/ ctx[2] && create_if_block$8(ctx);

  	const block = {
  		c: function create() {
  			div4 = element("div");
  			div1 = element("div");
  			div0 = element("div");
  			t0 = space();
  			div3 = element("div");
  			h2 = element("h2");
  			t1 = text(/*titre*/ ctx[0]);
  			t2 = space();
  			div2 = element("div");
  			if (if_block) if_block.c();
  			t3 = space();
  			slot0 = element("slot");
  			t4 = space();
  			slot1 = element("slot");
  			t5 = space();
  			link = element("link");
  			this.c = noop;
  			attr_dev(div0, "aria-hidden", "true");
  			attr_dev(div0, "class", div0_class_value = "utd-icone-svg " + /*type*/ ctx[1]);
  			add_location(div0, file$b, 14, 4, 383);
  			attr_dev(div1, "class", "zone-icone");
  			add_location(div1, file$b, 13, 2, 353);
  			attr_dev(h2, "class", "titre");
  			add_location(h2, file$b, 17, 4, 493);
  			add_location(slot0, file$b, 24, 6, 635);
  			attr_dev(slot1, "name", "contenu");
  			add_location(slot1, file$b, 25, 6, 651);
  			attr_dev(div2, "class", "texte");
  			add_location(div2, file$b, 20, 4, 543);
  			attr_dev(div3, "class", "contenu zone-html");
  			add_location(div3, file$b, 16, 2, 456);
  			attr_dev(div4, "class", div4_class_value = "utd-component utd-avis " + /*type*/ ctx[1]);
  			attr_dev(div4, "tabindex", "0");
  			add_location(div4, file$b, 12, 0, 293);
  			attr_dev(link, "rel", "stylesheet");
  			attr_dev(link, "href", Utils.cssFullPath);
  			add_location(link, file$b, 30, 0, 708);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div4, anchor);
  			append_dev(div4, div1);
  			append_dev(div1, div0);
  			append_dev(div4, t0);
  			append_dev(div4, div3);
  			append_dev(div3, h2);
  			append_dev(h2, t1);
  			append_dev(div3, t2);
  			append_dev(div3, div2);
  			if (if_block) if_block.m(div2, null);
  			append_dev(div2, t3);
  			append_dev(div2, slot0);
  			append_dev(div2, t4);
  			append_dev(div2, slot1);
  			insert_dev(target, t5, anchor);
  			insert_dev(target, link, anchor);
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*type*/ 2 && div0_class_value !== (div0_class_value = "utd-icone-svg " + /*type*/ ctx[1])) {
  				attr_dev(div0, "class", div0_class_value);
  			}

  			if (dirty & /*titre*/ 1) set_data_dev(t1, /*titre*/ ctx[0]);

  			if (/*contenu*/ ctx[2]) {
  				if (if_block) {
  					if_block.p(ctx, dirty);
  				} else {
  					if_block = create_if_block$8(ctx);
  					if_block.c();
  					if_block.m(div2, t3);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}

  			if (dirty & /*type*/ 2 && div4_class_value !== (div4_class_value = "utd-component utd-avis " + /*type*/ ctx[1])) {
  				attr_dev(div4, "class", div4_class_value);
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div4);
  			if (if_block) if_block.d();
  			if (detaching) detach_dev(t5);
  			if (detaching) detach_dev(link);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$b.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$b($$self, $$props, $$invalidate) {
  	let { $$slots: slots = {}, $$scope } = $$props;
  	validate_slots('utd-avis', slots, []);
  	let { titre = "" } = $$props;
  	let { type = "information" } = $$props;
  	let { contenu = "" } = $$props;
  	const writable_props = ['titre', 'type', 'contenu'];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<utd-avis> was created with unknown prop '${key}'`);
  	});

  	$$self.$$set = $$props => {
  		if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
  		if ('type' in $$props) $$invalidate(1, type = $$props.type);
  		if ('contenu' in $$props) $$invalidate(2, contenu = $$props.contenu);
  	};

  	$$self.$capture_state = () => ({ Utils, titre, type, contenu });

  	$$self.$inject_state = $$props => {
  		if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
  		if ('type' in $$props) $$invalidate(1, type = $$props.type);
  		if ('contenu' in $$props) $$invalidate(2, contenu = $$props.contenu);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [titre, type, contenu];
  }

  class Avis extends SvelteElement {
  	constructor(options) {
  		super();

  		init(
  			this,
  			{
  				target: this.shadowRoot,
  				props: attribute_to_object(this.attributes),
  				customElement: true
  			},
  			instance$b,
  			create_fragment$b,
  			safe_not_equal,
  			{ titre: 0, type: 1, contenu: 2 },
  			null
  		);

  		if (options) {
  			if (options.target) {
  				insert_dev(options.target, this, options.anchor);
  			}

  			if (options.props) {
  				this.$set(options.props);
  				flush();
  			}
  		}
  	}

  	static get observedAttributes() {
  		return ["titre", "type", "contenu"];
  	}

  	get titre() {
  		return this.$$.ctx[0];
  	}

  	set titre(titre) {
  		this.$$set({ titre });
  		flush();
  	}

  	get type() {
  		return this.$$.ctx[1];
  	}

  	set type(type) {
  		this.$$set({ type });
  		flush();
  	}

  	get contenu() {
  		return this.$$.ctx[2];
  	}

  	set contenu(contenu) {
  		this.$$set({ contenu });
  		flush();
  	}
  }

  customElements.define("utd-avis", Avis);

  /* src\components\champForm.svelte generated by Svelte v3.50.1 */
  const file$a = "src\\components\\champForm.svelte";

  function create_fragment$a(ctx) {
  	let slot;
  	let t;
  	let link;

  	const block = {
  		c: function create() {
  			slot = element("slot");
  			t = space();
  			link = element("link");
  			this.c = noop;
  			add_location(slot, file$a, 384, 0, 11428);
  			attr_dev(link, "rel", "stylesheet");
  			attr_dev(link, "href", Utils.cssFullPath);
  			add_location(link, file$a, 386, 0, 11439);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, slot, anchor);
  			insert_dev(target, t, anchor);
  			insert_dev(target, link, anchor);
  		},
  		p: noop,
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(slot);
  			if (detaching) detach_dev(t);
  			if (detaching) detach_dev(link);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$a.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$a($$self, $$props, $$invalidate) {
  	let { $$slots: slots = {}, $$scope } = $$props;
  	validate_slots('utd-champ-form', slots, []);
  	let { obligatoire = "false" } = $$props;
  	let { invalide = "false" } = $$props;
  	let { format = null } = $$props;
  	let { libelle = "" } = $$props;
  	let { precision = "" } = $$props;
  	let { messageErreur = "" } = $$props;
  	let mounted = false;
  	let typeChamp = null;
  	let elementLabel = null;
  	let elementWrapper = null;
  	let elementIndicateurObligatoire = null;
  	let elementObligatoireTexte = null;
  	let elementChamp = null;
  	let elementPrecision = null;
  	let elementErreur = null;
  	let idElementErreur = null;
  	const idChamp = Utils.genererId();
  	const idParentUtd = Utils.genererId();
  	const idLabelInitial = Utils.genererId();
  	const idPrecisionInitial = Utils.genererId();
  	const idErreurInitial = Utils.genererId();
  	const thisComponent = get_current_component();

  	const texteSrChampObligatoire = Utils.obtenirLanguePage() === 'fr'
  	? ' obligatoire '
  	: ' required ';

  	/* ===========================================================================================
    RÉFÉRENCES

    - Liste de boutons radio et checkbox
      https://blog.tenon.io/accessible-validation-of-checkbox-and-radiobutton-groups/

  =============================================================================================*/
  	onMount(() => {
  		typeChamp = obtenirTypeChamp();
  		mounted = true;

  		if (typeChamp) {
  			wrapperControles();
  			gererChamp();
  			gererLabel();
  			gererChampObligatoire();

  			if (typeChamp !== 'checkbox-seul') {
  				gererPrecision();
  			}

  			gererErreur();
  		}
  	});

  	function wrapperControles() {
  		elementWrapper = document.createElement('div');
  		const classeType = typeChamp === 'checkbox-seul' ? 'checkbox' : typeChamp;
  		elementWrapper.classList.add('utd-form-group', classeType);

  		thisComponent.childNodes.forEach(element => {
  			elementWrapper.append(element);

  			if (typeChamp === 'radio') {
  				elementWrapper.setAttribute('role', 'radiogroup');
  			}

  			if (typeChamp === 'checkbox') {
  				elementWrapper.setAttribute('role', 'group');
  			}
  		});

  		if (format) {
  			elementWrapper.classList.add(format);
  		}

  		thisComponent.prepend(elementWrapper);
  	}

  	function gererChamp() {
  		elementChamp.id = elementChamp.id || idChamp;
  		const idUtd = thisComponent.id || idParentUtd;
  		elementChamp.setAttribute('idutd', idUtd);
  		thisComponent.id = idUtd;

  		if (typeChamp === 'standard' || typeChamp === 'select' || typeChamp === 'textarea') {
  			elementChamp.classList.add('utd-form-control');

  			if (format) {
  				elementChamp.classList.add(format);
  			}
  		}
  	}

  	function obtenirTypeChamp() {
  		const input = thisComponent.querySelector("input");

  		if (input) {
  			elementChamp = input;
  			const type = input.getAttribute("type");

  			if (type === 'radio') {
  				return type;
  			} else if (type === 'checkbox') {
  				return thisComponent.querySelectorAll("input").length > 1
  				? 'checkbox'
  				: 'checkbox-seul';
  			} else if (type === 'button' || type === 'submit') {
  				return null;
  			} else {
  				return 'standard';
  			}
  		} else if (thisComponent.querySelector("textarea")) {
  			elementChamp = thisComponent.querySelector("textarea");
  			return 'standard';
  		} else if (thisComponent.querySelector("select")) {
  			elementChamp = thisComponent.querySelector("select");
  			return 'select';
  		} else {
  			return null;
  		}
  	}

  	function gererLabel() {
  		if (!mounted) {
  			return;
  		}

  		if (estGroupeControles()) {
  			elementLabel = thisComponent.querySelector(".label");
  		} else {
  			elementLabel = thisComponent.querySelector("label");
  		}

  		if (elementLabel) {
  			//Le label existe déjà. On s'assure qu'il est bien lié au champ.
  			if (estGroupeControles()) {
  				if (!elementLabel.id) {
  					elementLabel.id = idLabelInitial;
  				}

  				ajusterChampAriaDescribedBy('ajout', elementLabel.id);
  			} else {
  				elementLabel.setAttribute('for', elementChamp.id);
  			}

  			if (libelle) {
  				elementLabel.innerText = libelle;
  			}
  		} else if (libelle) {
  			//Le contrôle label n'existe pas      
  			let element;

  			if (estGroupeControles()) {
  				element = document.createElement('span');
  				element.classList.add('label');
  				element.id = idLabelInitial;
  				ajusterChampAriaDescribedBy('ajout', element.id, typeChamp === 'radio' ? 'aria-labelledby' : null);
  			} else {
  				element = document.createElement('label');
  				element.setAttribute('for', elementChamp.id);
  			}

  			element.innerText = libelle;
  			elementWrapper.prepend(element);
  			elementLabel = element;
  		}
  	}

  	function gererPrecision() {
  		if (!mounted) {
  			return;
  		}

  		if (elementLabel) {
  			elementPrecision = thisComponent.querySelector(".utd-precision");

  			if (precision) {
  				if (elementPrecision) {
  					elementPrecision.id = elementPrecision.id || idPrecisionInitial;
  				} else {
  					const span = document.createElement('span');
  					span.classList.add("utd-precision");
  					span.id = idPrecisionInitial;
  					elementPrecision = span;
  					elementLabel.after(elementPrecision);
  				}

  				elementPrecision.innerText = precision;
  				ajusterChampAriaDescribedBy('ajout', elementPrecision.id);
  			} else {
  				//Pas de précision en paramètre
  				if (elementPrecision) {
  					//Contrôle précision dans le HTML
  					elementPrecision.id = elementPrecision.id || idPrecisionInitial;

  					ajusterChampAriaDescribedBy('ajout', elementPrecision.id);
  				} else {
  					//Pas de contrôle de précision dans le html, on retire la précision du aria-describedby
  					ajusterChampAriaDescribedBy('retrait', idPrecisionInitial);
  				}
  			}
  		}
  	}

  	function ajusterChampAriaDescribedBy(operation = 'ajout', valeur, aria) {
  		let attribut;

  		if (aria) {
  			attribut = aria;
  		} else {
  			attribut = typeChamp === 'checkbox'
  			? 'aria-labelledby'
  			: 'aria-describedby';
  		}

  		let controle = elementChamp;

  		if (estGroupeControles()) {
  			controle = elementWrapper;
  		}

  		const valeurActuelle = controle.getAttribute(attribut) || '';
  		let nouvelleValeur = '';

  		if (operation === 'ajout') {
  			nouvelleValeur = valeurActuelle + (valeurActuelle.indexOf(valeur) >= 0 ? '' : ' ' + valeur);
  		} else {
  			nouvelleValeur = valeurActuelle.replace(valeur, '');
  		}

  		if (nouvelleValeur.trim()) {
  			controle.setAttribute(attribut, nouvelleValeur.trim());
  		} else {
  			controle.removeAttribute(attribut);
  		}
  	}

  	function gererChampObligatoire() {
  		if (!mounted) {
  			return;
  		}

  		if (elementLabel) {
  			elementIndicateurObligatoire = thisComponent.querySelector(".utd-icone-champ-requis");
  			elementObligatoireTexte = thisComponent.querySelector(".texte-obligatoire");

  			if (obligatoire === 'true') {
  				if (typeChamp === 'checkbox') {
  					//Pour les listes de checkbox, on doit ajouter un texte hors écran afin d'indiquer que le champ est obligatoire (aria-required ne fonctionne pas pour ces types de champs).
  					elementObligatoireTexte = thisComponent.querySelector(".texte-obligatoire");

  					if (!elementObligatoireTexte) {
  						elementObligatoireTexte = document.createElement('span');
  						elementObligatoireTexte.classList.add("texte-obligatoire", "utd-sr-only");
  						elementObligatoireTexte.innerHTML = texteSrChampObligatoire;
  						elementLabel.append(elementObligatoireTexte);
  					}
  				}

  				if (!elementIndicateurObligatoire) {
  					elementIndicateurObligatoire = document.createElement('span');
  					elementIndicateurObligatoire.classList.add("utd-icone-champ-requis");
  					elementIndicateurObligatoire.innerHTML = `*`;
  					elementLabel.append(elementIndicateurObligatoire);
  				}

  				elementIndicateurObligatoire.setAttribute('aria-hidden', 'true');
  			} else {
  				if (elementIndicateurObligatoire) {
  					elementIndicateurObligatoire.remove();
  				}

  				if (elementObligatoireTexte) {
  					elementObligatoireTexte.remove();
  				}
  			}
  		}

  		if (obligatoire === 'true' && typeChamp !== 'checkbox') {
  			if (typeChamp === 'radio') {
  				elementWrapper.setAttribute('aria-required', 'true');
  			} else {
  				elementChamp.setAttribute('aria-required', 'true');
  			}
  		} else {
  			if (typeChamp === 'radio') {
  				elementWrapper.removeAttribute('aria-required');
  			} else {
  				elementChamp.removeAttribute('aria-required');
  			}
  		}
  	}

  	function gererErreur() {
  		if (!mounted) {
  			return;
  		}

  		let controle = elementChamp;

  		if (estGroupeControles()) {
  			controle = elementWrapper;
  		}

  		elementErreur = thisComponent.querySelector(".utd-erreur-champ");

  		if (invalide === 'true') {
  			if (elementErreur) {
  				elementErreur.id = elementErreur.id || idErreurInitial;
  			} else {
  				const span = document.createElement('span');
  				span.classList.add("utd-erreur-champ");
  				span.id = idErreurInitial;
  				elementErreur = span;

  				if (typeChamp === 'checkbox-seul') {
  					elementLabel.after(elementErreur);
  				} else {
  					if (estGroupeControles()) {
  						elementWrapper.append(elementErreur);
  					} else {
  						elementChamp.after(elementErreur);
  					}
  				}
  			}

  			if (messageErreur) {
  				elementErreur.innerText = messageErreur;
  			}

  			idElementErreur = elementErreur.id;

  			const attribut = typeChamp === 'checkbox'
  			? 'aria-labelledby'
  			: 'aria-describedby';

  			const descByAvant = controle.getAttribute(attribut);
  			controle.setAttribute(attribut, elementErreur.id);

  			if (typeChamp !== 'checkbox') {
  				controle.setAttribute('aria-invalid', 'true');
  			}

  			//setTimeout nécessaire pour lecteur écran
  			if (descByAvant) {
  				setTimeout(
  					() => {
  						controle.setAttribute(attribut, `${descByAvant} ${idElementErreur}`);
  					},
  					100
  				);
  			}

  			elementErreur.classList.remove('utd-d-none');
  		} else {
  			controle.removeAttribute('aria-invalid');

  			if (elementErreur) {
  				elementErreur.classList.add('utd-d-none');

  				if (messageErreur) {
  					elementErreur.innerText = messageErreur;
  				}
  			}

  			if (idElementErreur) {
  				setTimeout(
  					() => {
  						ajusterChampAriaDescribedBy('retrait', idElementErreur);
  					},
  					100
  				);
  			}
  		}
  	}

  	function estGroupeControles() {
  		return typeChamp === 'checkbox' || typeChamp === 'radio';
  	}

  	const writable_props = ['obligatoire', 'invalide', 'format', 'libelle', 'precision', 'messageErreur'];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<utd-champ-form> was created with unknown prop '${key}'`);
  	});

  	$$self.$$set = $$props => {
  		if ('obligatoire' in $$props) $$invalidate(0, obligatoire = $$props.obligatoire);
  		if ('invalide' in $$props) $$invalidate(1, invalide = $$props.invalide);
  		if ('format' in $$props) $$invalidate(2, format = $$props.format);
  		if ('libelle' in $$props) $$invalidate(3, libelle = $$props.libelle);
  		if ('precision' in $$props) $$invalidate(4, precision = $$props.precision);
  		if ('messageErreur' in $$props) $$invalidate(5, messageErreur = $$props.messageErreur);
  	};

  	$$self.$capture_state = () => ({
  		Utils,
  		get_current_component,
  		onMount,
  		obligatoire,
  		invalide,
  		format,
  		libelle,
  		precision,
  		messageErreur,
  		mounted,
  		typeChamp,
  		elementLabel,
  		elementWrapper,
  		elementIndicateurObligatoire,
  		elementObligatoireTexte,
  		elementChamp,
  		elementPrecision,
  		elementErreur,
  		idElementErreur,
  		idChamp,
  		idParentUtd,
  		idLabelInitial,
  		idPrecisionInitial,
  		idErreurInitial,
  		thisComponent,
  		texteSrChampObligatoire,
  		wrapperControles,
  		gererChamp,
  		obtenirTypeChamp,
  		gererLabel,
  		gererPrecision,
  		ajusterChampAriaDescribedBy,
  		gererChampObligatoire,
  		gererErreur,
  		estGroupeControles
  	});

  	$$self.$inject_state = $$props => {
  		if ('obligatoire' in $$props) $$invalidate(0, obligatoire = $$props.obligatoire);
  		if ('invalide' in $$props) $$invalidate(1, invalide = $$props.invalide);
  		if ('format' in $$props) $$invalidate(2, format = $$props.format);
  		if ('libelle' in $$props) $$invalidate(3, libelle = $$props.libelle);
  		if ('precision' in $$props) $$invalidate(4, precision = $$props.precision);
  		if ('messageErreur' in $$props) $$invalidate(5, messageErreur = $$props.messageErreur);
  		if ('mounted' in $$props) mounted = $$props.mounted;
  		if ('typeChamp' in $$props) typeChamp = $$props.typeChamp;
  		if ('elementLabel' in $$props) elementLabel = $$props.elementLabel;
  		if ('elementWrapper' in $$props) elementWrapper = $$props.elementWrapper;
  		if ('elementIndicateurObligatoire' in $$props) elementIndicateurObligatoire = $$props.elementIndicateurObligatoire;
  		if ('elementObligatoireTexte' in $$props) elementObligatoireTexte = $$props.elementObligatoireTexte;
  		if ('elementChamp' in $$props) elementChamp = $$props.elementChamp;
  		if ('elementPrecision' in $$props) elementPrecision = $$props.elementPrecision;
  		if ('elementErreur' in $$props) elementErreur = $$props.elementErreur;
  		if ('idElementErreur' in $$props) idElementErreur = $$props.idElementErreur;
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty[0] & /*libelle*/ 8) {
  			gererLabel();
  		}

  		if ($$self.$$.dirty[0] & /*obligatoire*/ 1) {
  			gererChampObligatoire();
  		}

  		if ($$self.$$.dirty[0] & /*precision*/ 16) {
  			gererPrecision();
  		}

  		if ($$self.$$.dirty[0] & /*messageErreur*/ 32) {
  			gererErreur();
  		}

  		if ($$self.$$.dirty[0] & /*invalide*/ 2) {
  			gererErreur();
  		}
  	};

  	return [obligatoire, invalide, format, libelle, precision, messageErreur];
  }

  class ChampForm extends SvelteElement {
  	constructor(options) {
  		super();

  		init(
  			this,
  			{
  				target: this.shadowRoot,
  				props: attribute_to_object(this.attributes),
  				customElement: true
  			},
  			instance$a,
  			create_fragment$a,
  			safe_not_equal,
  			{
  				obligatoire: 0,
  				invalide: 1,
  				format: 2,
  				libelle: 3,
  				precision: 4,
  				messageErreur: 5
  			},
  			null,
  			[-1, -1]
  		);

  		if (options) {
  			if (options.target) {
  				insert_dev(options.target, this, options.anchor);
  			}

  			if (options.props) {
  				this.$set(options.props);
  				flush();
  			}
  		}
  	}

  	static get observedAttributes() {
  		return ["obligatoire", "invalide", "format", "libelle", "precision", "messageErreur"];
  	}

  	get obligatoire() {
  		return this.$$.ctx[0];
  	}

  	set obligatoire(obligatoire) {
  		this.$$set({ obligatoire });
  		flush();
  	}

  	get invalide() {
  		return this.$$.ctx[1];
  	}

  	set invalide(invalide) {
  		this.$$set({ invalide });
  		flush();
  	}

  	get format() {
  		return this.$$.ctx[2];
  	}

  	set format(format) {
  		this.$$set({ format });
  		flush();
  	}

  	get libelle() {
  		return this.$$.ctx[3];
  	}

  	set libelle(libelle) {
  		this.$$set({ libelle });
  		flush();
  	}

  	get precision() {
  		return this.$$.ctx[4];
  	}

  	set precision(precision) {
  		this.$$set({ precision });
  		flush();
  	}

  	get messageErreur() {
  		return this.$$.ctx[5];
  	}

  	set messageErreur(messageErreur) {
  		this.$$set({ messageErreur });
  		flush();
  	}
  }

  customElements.define("utd-champ-form", ChampForm);

  /* src\components\dialogueModal.svelte generated by Svelte v3.50.1 */
  const file$9 = "src\\components\\dialogueModal.svelte";

  // (171:0) {#if estModaleAffichee}
  function create_if_block$7(ctx) {
  	let div0;
  	let t0;
  	let div5;
  	let div4;
  	let button;
  	let span;
  	let t1;
  	let div3;
  	let div1;
  	let t2;
  	let h1;
  	let t3;
  	let div1_class_value;
  	let t4;
  	let div2;
  	let slot0;
  	let t5;
  	let slot1;
  	let t6;
  	let show_if = Utils.slotExiste(/*slots*/ ctx[8], 'pied');
  	let div5_aria_describedby_value;
  	let div5_class_value;
  	let div5_intro;
  	let div5_outro;
  	let current;
  	let mounted;
  	let dispose;
  	let if_block0 = /*type*/ ctx[1] && create_if_block_2$3(ctx);
  	let if_block1 = show_if && create_if_block_1$4(ctx);

  	const block = {
  		c: function create() {
  			div0 = element("div");
  			t0 = space();
  			div5 = element("div");
  			div4 = element("div");
  			button = element("button");
  			span = element("span");
  			t1 = space();
  			div3 = element("div");
  			div1 = element("div");
  			if (if_block0) if_block0.c();
  			t2 = space();
  			h1 = element("h1");
  			t3 = text(/*titre*/ ctx[2]);
  			t4 = space();
  			div2 = element("div");
  			slot0 = element("slot");
  			t5 = space();
  			slot1 = element("slot");
  			t6 = space();
  			if (if_block1) if_block1.c();
  			attr_dev(div0, "class", "utd-backdrop");
  			add_location(div0, file$9, 171, 2, 6200);
  			attr_dev(span, "aria-hidden", "true");
  			attr_dev(span, "class", "utd-icone-svg x-fermer-bleu");
  			add_location(span, file$9, 195, 8, 7186);
  			attr_dev(button, "type", "button");
  			attr_dev(button, "class", "close");
  			attr_dev(button, "aria-label", /*srBoutonFermer*/ ctx[3]);
  			add_location(button, file$9, 189, 8, 7021);
  			attr_dev(h1, "id", /*idEntete*/ ctx[10]);
  			attr_dev(h1, "class", "titre-dialog");
  			add_location(h1, file$9, 205, 10, 7513);
  			attr_dev(div1, "class", div1_class_value = "entete " + (/*type*/ ctx[1] ? 'avec-type' : ''));
  			add_location(div1, file$9, 201, 8, 7338);
  			add_location(slot0, file$9, 210, 10, 7661);
  			attr_dev(slot1, "name", "contenu");
  			add_location(slot1, file$9, 211, 10, 7680);
  			attr_dev(div2, "class", "corps");
  			attr_dev(div2, "id", /*idCorps*/ ctx[11]);
  			add_location(div2, file$9, 209, 8, 7617);
  			attr_dev(div3, "class", "principal");
  			add_location(div3, file$9, 200, 6, 7305);
  			attr_dev(div4, "class", "conteneur");
  			add_location(div4, file$9, 188, 4, 6988);
  			attr_dev(div5, "aria-labelledby", /*idEntete*/ ctx[10]);

  			attr_dev(div5, "aria-describedby", div5_aria_describedby_value = /*estfenetremessage*/ ctx[0] === 'true'
  			? /*idCorps*/ ctx[11]
  			: null);

  			attr_dev(div5, "class", div5_class_value = "utd-component utd-dialog " + (/*estfenetremessage*/ ctx[0] === 'true'
  			? 'fenetre-message'
  			: '') + " " + (/*boutonsTexteLong*/ ctx[4] === 'true'
  			? 'boutons-texte-long'
  			: '') + " " + (/*affichageLateral*/ ctx[6] === 'true'
  			? 'affichage-lateral'
  			: '') + " " + (/*forcerBoutonsInline*/ ctx[5] === 'true'
  			? 'boutons-inline'
  			: ''));

  			attr_dev(div5, "id", /*idModale*/ ctx[9]);
  			attr_dev(div5, "aria-modal", "true");
  			attr_dev(div5, "role", "dialog");
  			add_location(div5, file$9, 172, 2, 6280);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div0, anchor);
  			insert_dev(target, t0, anchor);
  			insert_dev(target, div5, anchor);
  			append_dev(div5, div4);
  			append_dev(div4, button);
  			append_dev(button, span);
  			append_dev(div4, t1);
  			append_dev(div4, div3);
  			append_dev(div3, div1);
  			if (if_block0) if_block0.m(div1, null);
  			append_dev(div1, t2);
  			append_dev(div1, h1);
  			append_dev(h1, t3);
  			append_dev(div3, t4);
  			append_dev(div3, div2);
  			append_dev(div2, slot0);
  			append_dev(div2, t5);
  			append_dev(div2, slot1);
  			append_dev(div3, t6);
  			if (if_block1) if_block1.m(div3, null);
  			current = true;

  			if (!mounted) {
  				dispose = [
  					listen_dev(div0, "click", /*click_handler*/ ctx[24], false, false, false),
  					listen_dev(button, "click", /*click_handler_1*/ ctx[25], false, false, false),
  					listen_dev(div5, "click", /*clickModale*/ ctx[16], false, false, false),
  					listen_dev(div5, "keydown", /*keydown*/ ctx[15], false, false, false),
  					listen_dev(div5, "introstart", /*ajusterModaleDebutAffichage*/ ctx[18], false, false, false),
  					listen_dev(div5, "introend", /*ajusterModaleFinAffichage*/ ctx[19], false, false, false),
  					listen_dev(div5, "outroend", /*finAnimationFermeture*/ ctx[17], false, false, false)
  				];

  				mounted = true;
  			}
  		},
  		p: function update(ctx, dirty) {
  			if (!current || dirty[0] & /*srBoutonFermer*/ 8) {
  				attr_dev(button, "aria-label", /*srBoutonFermer*/ ctx[3]);
  			}

  			if (/*type*/ ctx[1]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);
  				} else {
  					if_block0 = create_if_block_2$3(ctx);
  					if_block0.c();
  					if_block0.m(div1, t2);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (!current || dirty[0] & /*titre*/ 4) set_data_dev(t3, /*titre*/ ctx[2]);

  			if (!current || dirty[0] & /*type*/ 2 && div1_class_value !== (div1_class_value = "entete " + (/*type*/ ctx[1] ? 'avec-type' : ''))) {
  				attr_dev(div1, "class", div1_class_value);
  			}

  			if (dirty[0] & /*slots*/ 256) show_if = Utils.slotExiste(/*slots*/ ctx[8], 'pied');

  			if (show_if) {
  				if (if_block1) ; else {
  					if_block1 = create_if_block_1$4(ctx);
  					if_block1.c();
  					if_block1.m(div3, null);
  				}
  			} else if (if_block1) {
  				if_block1.d(1);
  				if_block1 = null;
  			}

  			if (!current || dirty[0] & /*estfenetremessage*/ 1 && div5_aria_describedby_value !== (div5_aria_describedby_value = /*estfenetremessage*/ ctx[0] === 'true'
  			? /*idCorps*/ ctx[11]
  			: null)) {
  				attr_dev(div5, "aria-describedby", div5_aria_describedby_value);
  			}

  			if (!current || dirty[0] & /*estfenetremessage, boutonsTexteLong, affichageLateral, forcerBoutonsInline*/ 113 && div5_class_value !== (div5_class_value = "utd-component utd-dialog " + (/*estfenetremessage*/ ctx[0] === 'true'
  			? 'fenetre-message'
  			: '') + " " + (/*boutonsTexteLong*/ ctx[4] === 'true'
  			? 'boutons-texte-long'
  			: '') + " " + (/*affichageLateral*/ ctx[6] === 'true'
  			? 'affichage-lateral'
  			: '') + " " + (/*forcerBoutonsInline*/ ctx[5] === 'true'
  			? 'boutons-inline'
  			: ''))) {
  				attr_dev(div5, "class", div5_class_value);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;

  			add_render_callback(() => {
  				if (div5_outro) div5_outro.end(1);
  				div5_intro = create_in_transition(div5, /*animationAffichageOuverture*/ ctx[13], {});
  				div5_intro.start();
  			});

  			current = true;
  		},
  		o: function outro(local) {
  			if (div5_intro) div5_intro.invalidate();
  			div5_outro = create_out_transition(div5, /*animationAffichageFermeture*/ ctx[14], {});
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div0);
  			if (detaching) detach_dev(t0);
  			if (detaching) detach_dev(div5);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (detaching && div5_outro) div5_outro.end();
  			mounted = false;
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$7.name,
  		type: "if",
  		source: "(171:0) {#if estModaleAffichee}",
  		ctx
  	});

  	return block;
  }

  // (203:10) {#if type}
  function create_if_block_2$3(ctx) {
  	let span;
  	let span_class_value;

  	const block = {
  		c: function create() {
  			span = element("span");
  			attr_dev(span, "class", span_class_value = "utd-icone-svg " + /*type*/ ctx[1]);
  			attr_dev(span, "aria-hidden", "true");
  			add_location(span, file$9, 203, 12, 7420);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*type*/ 2 && span_class_value !== (span_class_value = "utd-icone-svg " + /*type*/ ctx[1])) {
  				attr_dev(span, "class", span_class_value);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2$3.name,
  		type: "if",
  		source: "(203:10) {#if type}",
  		ctx
  	});

  	return block;
  }

  // (214:8) {#if Utils.slotExiste(slots, 'pied')}
  function create_if_block_1$4(ctx) {
  	let div;
  	let slot;

  	const block = {
  		c: function create() {
  			div = element("div");
  			slot = element("slot");
  			attr_dev(slot, "name", "pied");
  			add_location(slot, file$9, 215, 12, 7810);
  			attr_dev(div, "class", "pied");
  			add_location(div, file$9, 214, 10, 7778);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, slot);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$4.name,
  		type: "if",
  		source: "(214:8) {#if Utils.slotExiste(slots, 'pied')}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$9(ctx) {
  	let t;
  	let link;
  	let current;
  	let if_block = /*estModaleAffichee*/ ctx[7] && create_if_block$7(ctx);

  	const block = {
  		c: function create() {
  			if (if_block) if_block.c();
  			t = space();
  			link = element("link");
  			this.c = noop;
  			attr_dev(link, "rel", "stylesheet");
  			attr_dev(link, "href", Utils.cssFullPath);
  			add_location(link, file$9, 223, 0, 7920);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			if (if_block) if_block.m(target, anchor);
  			insert_dev(target, t, anchor);
  			insert_dev(target, link, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (/*estModaleAffichee*/ ctx[7]) {
  				if (if_block) {
  					if_block.p(ctx, dirty);

  					if (dirty[0] & /*estModaleAffichee*/ 128) {
  						transition_in(if_block, 1);
  					}
  				} else {
  					if_block = create_if_block$7(ctx);
  					if_block.c();
  					transition_in(if_block, 1);
  					if_block.m(t.parentNode, t);
  				}
  			} else if (if_block) {
  				group_outros();

  				transition_out(if_block, 1, 1, () => {
  					if_block = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (if_block) if_block.d(detaching);
  			if (detaching) detach_dev(t);
  			if (detaching) detach_dev(link);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$9.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function estBouton(element) {
  	const tag = element.tagName.toLowerCase();
  	return tag === 'button' || element.getAttribute('type') === 'submit';
  }

  function instance$9($$self, $$props, $$invalidate) {
  	let { $$slots: slots$1 = {}, $$scope } = $$props;
  	validate_slots('utd-dialog', slots$1, []);
  	let { afficher = 'false' } = $$props;
  	let { type = '' } = $$props;
  	let { estfenetremessage = 'false' } = $$props; //Privée (utilisée dans notre plugin message)
  	let { raisonFermeture = '' } = $$props; //Privée (utilisée dans notre plugin message)
  	let { titre = '' } = $$props;
  	let { srBoutonFermer = Utils.obtenirLanguePage() === "fr" ? "Fermer" : "Close" } = $$props;
  	let { idFocusOuverture = '' } = $$props;
  	let { idFocusFermeture = '' } = $$props;
  	let { boutonsTexteLong = 'false' } = $$props;
  	let { forcerBoutonsInline = 'false' } = $$props;
  	let { affichageLateral = 'false' } = $$props;
  	const idModale = Utils.genererId();
  	const idEntete = Utils.genererId();
  	const idCorps = Utils.genererId();
  	let estModaleAffichee = afficher === 'true';
  	const thisComponent = get_current_component();
  	let html;
  	let body;
  	let slots = [];
  	let mounted = false;

  	onMount(() => {
  		html = thisComponent.getRootNode().getElementsByTagName("html")[0];
  		body = thisComponent.getRootNode().getElementsByTagName("body")[0];
  		$$invalidate(8, slots = Array.from(thisComponent.querySelectorAll('[slot]')));
  		mounted = true;

  		if (Utils.estMobile()) {
  			html.classList.add("est-mobile");
  		}
  	});

  	function masquerModale(raisonFermetureModale) {
  		$$invalidate(7, estModaleAffichee = false);
  		$$invalidate(20, afficher = 'false');

  		//Si une raison de fermeture est reçue en param, on l'utilise sinon on prend la raison de fermeture qui est sur la modale "raisonFermeture" qui va contenir une raison de fermeture externe à la modale (ex. clic sur bouton primaire ou secondaire)
  		const raison = raisonFermetureModale || raisonFermeture;

  		//On redonne le focus au contrôle spécifié (normalement celui qui a initié l'affichage de la fenêtre modale)
  		const controleFocus = thisComponent.getRootNode().getElementById(idFocusFermeture);

  		if (controleFocus) {
  			controleFocus.focus();
  		}

  		Utils.dispatchWcEvent(thisComponent, "fermeture", { raisonFermeture: raison });
  	}

  	function animationAffichageOuverture(node) {
  		return affichageLateral === 'false'
  		? fade(node, { duration: 250 })
  		: fly(node, { x: 200, duration: 250 });
  	}

  	function animationAffichageFermeture(node) {
  		return affichageLateral === 'false'
  		? fade(node, { y: 200, duration: 250 })
  		: fly(node, { x: 200, duration: 250 });
  	}

  	// Exécuté lorsque la valeur de la prop "afficher" change
  	function toggleAfficher() {
  		if (mounted) {
  			if (afficher === 'true') {
  				$$invalidate(21, raisonFermeture = '');
  				Utils.ajusterInterfaceAvantAffichageModale(html, body);
  				$$invalidate(7, estModaleAffichee = true);
  			} else {
  				if (estModaleAffichee) {
  					masquerModale();
  				}
  			}
  		}
  	}

  	function keydown(e) {
  		if (e.key === "Escape") {
  			masquerModale('escape');
  		}
  	}

  	function clickModale(e) {
  		if (e.target === e.currentTarget) {
  			masquerModale('clickBackdrop');
  		}
  	}

  	function finAnimationFermeture(e) {
  		Utils.ajusterInterfaceApresFermetureModale(html, body, thisComponent.shadowRoot.getElementById(idModale));
  		Utils.dispatchWcEvent(thisComponent, "apresFermeture");
  	}

  	function ajusterModaleDebutAffichage(e) {
  		const modale = thisComponent.shadowRoot.getElementById(idModale);
  		donnerfocusPremierElementFocusable(modale);
  		Utils.conserverFocusElement(modale, thisComponent);
  	}

  	function ajusterModaleFinAffichage(e) {
  		const modale = thisComponent.shadowRoot.getElementById(idModale);
  		Utils.ajusterInterfacePendantAffichageModale(body, modale);

  		//On force un scrollTop ici car Android ne semble pas supporter le preventScroll de la méthode focus (mais selon la doc il devrait). SOLUTION EN ATTENDANT MIEUX.
  		modale.scrollTop = 0;
  	}

  	function donnerfocusPremierElementFocusable(modale) {
  		let premierElementFocusable = null;

  		if (estfenetremessage === 'true') {
  			premierElementFocusable = thisComponent.querySelector('.utd-btn.primaire');
  		} else {
  			if (idFocusOuverture) {
  				const controleFocusOuverture = document.getElementById(idFocusOuverture);

  				if (controleFocusOuverture) {
  					premierElementFocusable = controleFocusOuverture;
  				}
  			}

  			if (!premierElementFocusable) {
  				const elementsFocusablesShadow = Array.from(Utils.obtenirElementsFocusables(modale));
  				const elementsFocusablesRoot = Array.from(Utils.obtenirElementsFocusables(thisComponent));
  				const elementsFocusables = elementsFocusablesRoot.concat(elementsFocusablesShadow);
  				premierElementFocusable = elementsFocusables[0];

  				//On force le mode "fenêtre de message" si le premier élément focusable est un bouton de la slot "pied"
  				if (estBouton(premierElementFocusable)) {
  					const slotPied = Utils.obtenirSlot(slots, 'pied');

  					if (slotPied) {
  						const boutonsSlotPied = slotPied.querySelectorAll('button, input[type="submit"]');

  						if (boutonsSlotPied.length) {
  							for (let i = 0; i < boutonsSlotPied.length - 1; i++) {
  								if (boutonsSlotPied[i] === premierElementFocusable) {
  									premierElementFocusable = thisComponent.querySelector('.utd-btn.primaire') || premierElementFocusable;
  									$$invalidate(0, estfenetremessage = 'true');
  									break;
  								}
  							}
  						}
  					}
  				}
  			}
  		}

  		premierElementFocusable.focus({ preventScroll: true });
  	} //premierElementFocusable.focus()    

  	const writable_props = [
  		'afficher',
  		'type',
  		'estfenetremessage',
  		'raisonFermeture',
  		'titre',
  		'srBoutonFermer',
  		'idFocusOuverture',
  		'idFocusFermeture',
  		'boutonsTexteLong',
  		'forcerBoutonsInline',
  		'affichageLateral'
  	];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<utd-dialog> was created with unknown prop '${key}'`);
  	});

  	const click_handler = () => masquerModale('clickBackdrop');
  	const click_handler_1 = () => masquerModale('boutonFermer');

  	$$self.$$set = $$props => {
  		if ('afficher' in $$props) $$invalidate(20, afficher = $$props.afficher);
  		if ('type' in $$props) $$invalidate(1, type = $$props.type);
  		if ('estfenetremessage' in $$props) $$invalidate(0, estfenetremessage = $$props.estfenetremessage);
  		if ('raisonFermeture' in $$props) $$invalidate(21, raisonFermeture = $$props.raisonFermeture);
  		if ('titre' in $$props) $$invalidate(2, titre = $$props.titre);
  		if ('srBoutonFermer' in $$props) $$invalidate(3, srBoutonFermer = $$props.srBoutonFermer);
  		if ('idFocusOuverture' in $$props) $$invalidate(22, idFocusOuverture = $$props.idFocusOuverture);
  		if ('idFocusFermeture' in $$props) $$invalidate(23, idFocusFermeture = $$props.idFocusFermeture);
  		if ('boutonsTexteLong' in $$props) $$invalidate(4, boutonsTexteLong = $$props.boutonsTexteLong);
  		if ('forcerBoutonsInline' in $$props) $$invalidate(5, forcerBoutonsInline = $$props.forcerBoutonsInline);
  		if ('affichageLateral' in $$props) $$invalidate(6, affichageLateral = $$props.affichageLateral);
  	};

  	$$self.$capture_state = () => ({
  		onMount,
  		fly,
  		fade,
  		get_current_component,
  		Utils,
  		afficher,
  		type,
  		estfenetremessage,
  		raisonFermeture,
  		titre,
  		srBoutonFermer,
  		idFocusOuverture,
  		idFocusFermeture,
  		boutonsTexteLong,
  		forcerBoutonsInline,
  		affichageLateral,
  		idModale,
  		idEntete,
  		idCorps,
  		estModaleAffichee,
  		thisComponent,
  		html,
  		body,
  		slots,
  		mounted,
  		masquerModale,
  		animationAffichageOuverture,
  		animationAffichageFermeture,
  		toggleAfficher,
  		keydown,
  		clickModale,
  		finAnimationFermeture,
  		ajusterModaleDebutAffichage,
  		ajusterModaleFinAffichage,
  		estBouton,
  		donnerfocusPremierElementFocusable
  	});

  	$$self.$inject_state = $$props => {
  		if ('afficher' in $$props) $$invalidate(20, afficher = $$props.afficher);
  		if ('type' in $$props) $$invalidate(1, type = $$props.type);
  		if ('estfenetremessage' in $$props) $$invalidate(0, estfenetremessage = $$props.estfenetremessage);
  		if ('raisonFermeture' in $$props) $$invalidate(21, raisonFermeture = $$props.raisonFermeture);
  		if ('titre' in $$props) $$invalidate(2, titre = $$props.titre);
  		if ('srBoutonFermer' in $$props) $$invalidate(3, srBoutonFermer = $$props.srBoutonFermer);
  		if ('idFocusOuverture' in $$props) $$invalidate(22, idFocusOuverture = $$props.idFocusOuverture);
  		if ('idFocusFermeture' in $$props) $$invalidate(23, idFocusFermeture = $$props.idFocusFermeture);
  		if ('boutonsTexteLong' in $$props) $$invalidate(4, boutonsTexteLong = $$props.boutonsTexteLong);
  		if ('forcerBoutonsInline' in $$props) $$invalidate(5, forcerBoutonsInline = $$props.forcerBoutonsInline);
  		if ('affichageLateral' in $$props) $$invalidate(6, affichageLateral = $$props.affichageLateral);
  		if ('estModaleAffichee' in $$props) $$invalidate(7, estModaleAffichee = $$props.estModaleAffichee);
  		if ('html' in $$props) html = $$props.html;
  		if ('body' in $$props) body = $$props.body;
  		if ('slots' in $$props) $$invalidate(8, slots = $$props.slots);
  		if ('mounted' in $$props) mounted = $$props.mounted;
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty[0] & /*afficher*/ 1048576) {
  			// Watch sur la prop afficher
  			toggleAfficher();
  		}
  	};

  	return [
  		estfenetremessage,
  		type,
  		titre,
  		srBoutonFermer,
  		boutonsTexteLong,
  		forcerBoutonsInline,
  		affichageLateral,
  		estModaleAffichee,
  		slots,
  		idModale,
  		idEntete,
  		idCorps,
  		masquerModale,
  		animationAffichageOuverture,
  		animationAffichageFermeture,
  		keydown,
  		clickModale,
  		finAnimationFermeture,
  		ajusterModaleDebutAffichage,
  		ajusterModaleFinAffichage,
  		afficher,
  		raisonFermeture,
  		idFocusOuverture,
  		idFocusFermeture,
  		click_handler,
  		click_handler_1
  	];
  }

  class DialogueModal extends SvelteElement {
  	constructor(options) {
  		super();

  		init(
  			this,
  			{
  				target: this.shadowRoot,
  				props: attribute_to_object(this.attributes),
  				customElement: true
  			},
  			instance$9,
  			create_fragment$9,
  			safe_not_equal,
  			{
  				afficher: 20,
  				type: 1,
  				estfenetremessage: 0,
  				raisonFermeture: 21,
  				titre: 2,
  				srBoutonFermer: 3,
  				idFocusOuverture: 22,
  				idFocusFermeture: 23,
  				boutonsTexteLong: 4,
  				forcerBoutonsInline: 5,
  				affichageLateral: 6
  			},
  			null,
  			[-1, -1]
  		);

  		if (options) {
  			if (options.target) {
  				insert_dev(options.target, this, options.anchor);
  			}

  			if (options.props) {
  				this.$set(options.props);
  				flush();
  			}
  		}
  	}

  	static get observedAttributes() {
  		return [
  			"afficher",
  			"type",
  			"estfenetremessage",
  			"raisonFermeture",
  			"titre",
  			"srBoutonFermer",
  			"idFocusOuverture",
  			"idFocusFermeture",
  			"boutonsTexteLong",
  			"forcerBoutonsInline",
  			"affichageLateral"
  		];
  	}

  	get afficher() {
  		return this.$$.ctx[20];
  	}

  	set afficher(afficher) {
  		this.$$set({ afficher });
  		flush();
  	}

  	get type() {
  		return this.$$.ctx[1];
  	}

  	set type(type) {
  		this.$$set({ type });
  		flush();
  	}

  	get estfenetremessage() {
  		return this.$$.ctx[0];
  	}

  	set estfenetremessage(estfenetremessage) {
  		this.$$set({ estfenetremessage });
  		flush();
  	}

  	get raisonFermeture() {
  		return this.$$.ctx[21];
  	}

  	set raisonFermeture(raisonFermeture) {
  		this.$$set({ raisonFermeture });
  		flush();
  	}

  	get titre() {
  		return this.$$.ctx[2];
  	}

  	set titre(titre) {
  		this.$$set({ titre });
  		flush();
  	}

  	get srBoutonFermer() {
  		return this.$$.ctx[3];
  	}

  	set srBoutonFermer(srBoutonFermer) {
  		this.$$set({ srBoutonFermer });
  		flush();
  	}

  	get idFocusOuverture() {
  		return this.$$.ctx[22];
  	}

  	set idFocusOuverture(idFocusOuverture) {
  		this.$$set({ idFocusOuverture });
  		flush();
  	}

  	get idFocusFermeture() {
  		return this.$$.ctx[23];
  	}

  	set idFocusFermeture(idFocusFermeture) {
  		this.$$set({ idFocusFermeture });
  		flush();
  	}

  	get boutonsTexteLong() {
  		return this.$$.ctx[4];
  	}

  	set boutonsTexteLong(boutonsTexteLong) {
  		this.$$set({ boutonsTexteLong });
  		flush();
  	}

  	get forcerBoutonsInline() {
  		return this.$$.ctx[5];
  	}

  	set forcerBoutonsInline(forcerBoutonsInline) {
  		this.$$set({ forcerBoutonsInline });
  		flush();
  	}

  	get affichageLateral() {
  		return this.$$.ctx[6];
  	}

  	set affichageLateral(affichageLateral) {
  		this.$$set({ affichageLateral });
  		flush();
  	}
  }

  customElements.define("utd-dialog", DialogueModal);

  /* src\components\hautPage.svelte generated by Svelte v3.50.1 */
  const file$8 = "src\\components\\hautPage.svelte";

  function create_fragment$8(ctx) {
  	let div1;
  	let button;
  	let div0;
  	let span;
  	let t;
  	let link;
  	let mounted;
  	let dispose;

  	const block = {
  		c: function create() {
  			div1 = element("div");
  			button = element("button");
  			div0 = element("div");
  			span = element("span");
  			t = space();
  			link = element("link");
  			this.c = noop;
  			attr_dev(span, "aria-hidden", "true");
  			attr_dev(span, "class", "utd-icone-svg fleche-haut-blanche");
  			add_location(span, file$8, 72, 6, 2143);
  			attr_dev(div0, "class", "contenu");
  			add_location(div0, file$8, 71, 4, 2114);
  			attr_dev(button, "type", "button");
  			attr_dev(button, "class", "utd-btn primaire");
  			attr_dev(button, "title", /*title*/ ctx[0]);
  			add_location(button, file$8, 70, 2, 2017);
  			attr_dev(div1, "class", "utd-component utd-hautpage");
  			add_location(div1, file$8, 69, 0, 1973);
  			attr_dev(link, "rel", "stylesheet");
  			attr_dev(link, "href", Utils.cssFullPath);
  			add_location(link, file$8, 77, 0, 2257);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div1, anchor);
  			append_dev(div1, button);
  			append_dev(button, div0);
  			append_dev(div0, span);
  			insert_dev(target, t, anchor);
  			insert_dev(target, link, anchor);

  			if (!mounted) {
  				dispose = listen_dev(button, "click", scrollerHautPage, false, false, false);
  				mounted = true;
  			}
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*title*/ 1) {
  				attr_dev(button, "title", /*title*/ ctx[0]);
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div1);
  			if (detaching) detach_dev(t);
  			if (detaching) detach_dev(link);
  			mounted = false;
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$8.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function scrollerHautPage(e) {
  	window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  function instance$8($$self, $$props, $$invalidate) {
  	let { $$slots: slots = {}, $$scope } = $$props;
  	validate_slots('utd-hautpage', slots, []);

  	let { title = Utils.obtenirLanguePage() === 'fr'
  	? "Retour en haut de page."
  	: "Return to the top of the page." } = $$props;

  	let { hauteurMinimaleSroll = 555 } = $$props;
  	const thisComponent = get_current_component();
  	let html;
  	let controle;
  	let ticking = false;

  	onMount(() => {
  		html = thisComponent.getRootNode().getElementsByTagName("html")[0];
  		controle = thisComponent.shadowRoot.querySelector('.utd-hautpage');
  		controle.classList.add("utd-d-none");
  	});

  	window.addEventListener('scroll', function (e) {
  		if (!ticking) {
  			window.requestAnimationFrame(function () {
  				gererAffichageBouton();
  				ticking = false;
  			});
  		}

  		ticking = true;
  	});

  	function gererAffichageBouton() {
  		const dureeAnimationMs = 500;

  		if (html.classList.contains('utd-modale-ouverte')) {
  			//Si une fenêtre modale est ouverte, on ne fait rien pour le bouton de retour haut de page
  			return;
  		}

  		if (document.body.scrollTop > hauteurMinimaleSroll || document.documentElement.scrollTop > hauteurMinimaleSroll) {
  			if (controle.classList.contains('utd-d-none')) {
  				controle.classList.remove('utd-d-none');

  				setTimeout(
  					() => {
  						html.setAttribute('retourhautpagevisible', 'true');
  						controle.classList.add('visible');
  					},
  					10
  				);
  			}
  		} else {
  			if (controle.classList.contains("visible")) {
  				setTimeout(
  					() => {
  						controle.classList.add('utd-d-none');
  						html.setAttribute('retourhautpagevisible', 'false');
  					},
  					dureeAnimationMs
  				);
  			}

  			controle.classList.remove('visible');
  		}
  	}

  	const writable_props = ['title', 'hauteurMinimaleSroll'];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<utd-hautpage> was created with unknown prop '${key}'`);
  	});

  	$$self.$$set = $$props => {
  		if ('title' in $$props) $$invalidate(0, title = $$props.title);
  		if ('hauteurMinimaleSroll' in $$props) $$invalidate(1, hauteurMinimaleSroll = $$props.hauteurMinimaleSroll);
  	};

  	$$self.$capture_state = () => ({
  		onMount,
  		Utils,
  		get_current_component,
  		title,
  		hauteurMinimaleSroll,
  		thisComponent,
  		html,
  		controle,
  		ticking,
  		gererAffichageBouton,
  		scrollerHautPage
  	});

  	$$self.$inject_state = $$props => {
  		if ('title' in $$props) $$invalidate(0, title = $$props.title);
  		if ('hauteurMinimaleSroll' in $$props) $$invalidate(1, hauteurMinimaleSroll = $$props.hauteurMinimaleSroll);
  		if ('html' in $$props) html = $$props.html;
  		if ('controle' in $$props) controle = $$props.controle;
  		if ('ticking' in $$props) ticking = $$props.ticking;
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [title, hauteurMinimaleSroll];
  }

  class HautPage extends SvelteElement {
  	constructor(options) {
  		super();

  		init(
  			this,
  			{
  				target: this.shadowRoot,
  				props: attribute_to_object(this.attributes),
  				customElement: true
  			},
  			instance$8,
  			create_fragment$8,
  			safe_not_equal,
  			{ title: 0, hauteurMinimaleSroll: 1 },
  			null
  		);

  		if (options) {
  			if (options.target) {
  				insert_dev(options.target, this, options.anchor);
  			}

  			if (options.props) {
  				this.$set(options.props);
  				flush();
  			}
  		}
  	}

  	static get observedAttributes() {
  		return ["title", "hauteurMinimaleSroll"];
  	}

  	get title() {
  		return this.$$.ctx[0];
  	}

  	set title(title) {
  		this.$$set({ title });
  		flush();
  	}

  	get hauteurMinimaleSroll() {
  		return this.$$.ctx[1];
  	}

  	set hauteurMinimaleSroll(hauteurMinimaleSroll) {
  		this.$$set({ hauteurMinimaleSroll });
  		flush();
  	}
  }

  customElements.define("utd-hautpage", HautPage);

  /* src\components\infobulle.svelte generated by Svelte v3.50.1 */
  const file$7 = "src\\components\\infobulle.svelte";

  // (97:2) {#if $$slots["texte-lie"]}
  function create_if_block_4$2(ctx) {
  	let span;
  	let slot;
  	let mounted;
  	let dispose;

  	const block = {
  		c: function create() {
  			span = element("span");
  			slot = element("slot");
  			attr_dev(slot, "name", "texte-lie");
  			add_location(slot, file$7, 97, 54, 3612);
  			attr_dev(span, "class", "texte-lie");
  			add_location(span, file$7, 97, 4, 3562);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, slot);

  			if (!mounted) {
  				dispose = listen_dev(span, "click", /*afficherModale*/ ctx[12], false, false, false);
  				mounted = true;
  			}
  		},
  		p: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  			mounted = false;
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_4$2.name,
  		type: "if",
  		source: "(97:2) {#if $$slots[\\\"texte-lie\\\"]}",
  		ctx
  	});

  	return block;
  }

  // (112:2) {#if afficher}
  function create_if_block$6(ctx) {
  	let div;
  	let t0;
  	let span6;
  	let span3;
  	let h1;
  	let span0;
  	let t1;
  	let span1;
  	let t2;
  	let button;
  	let span2;
  	let t3;
  	let span5;
  	let span4;
  	let show_if;
  	let span6_intro;
  	let span6_outro;
  	let current;
  	let mounted;
  	let dispose;
  	let if_block0 = /*titre*/ ctx[1] && create_if_block_3$1(ctx);

  	function select_block_type(ctx, dirty) {
  		if (dirty & /*slots*/ 64) show_if = null;
  		if (show_if == null) show_if = !!Utils.slotExiste(/*slots*/ ctx[6], 'contenu');
  		if (show_if) return create_if_block_1$3;
  		if (/*contenu*/ ctx[5]) return create_if_block_2$2;
  	}

  	let current_block_type = select_block_type(ctx, -1);
  	let if_block1 = current_block_type && current_block_type(ctx);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = space();
  			span6 = element("span");
  			span3 = element("span");
  			h1 = element("h1");
  			span0 = element("span");
  			t1 = space();
  			span1 = element("span");
  			if (if_block0) if_block0.c();
  			t2 = space();
  			button = element("button");
  			span2 = element("span");
  			t3 = space();
  			span5 = element("span");
  			span4 = element("span");
  			if (if_block1) if_block1.c();
  			attr_dev(div, "class", "utd-backdrop");
  			add_location(div, file$7, 112, 4, 4092);
  			attr_dev(span0, "class", "utd-sr-only");
  			add_location(span0, file$7, 127, 10, 4570);
  			add_location(span1, file$7, 128, 10, 4630);
  			attr_dev(h1, "id", /*idEntete*/ ctx[10]);
  			add_location(h1, file$7, 126, 8, 4540);
  			attr_dev(span2, "aria-hidden", "true");
  			attr_dev(span2, "class", "utd-icone-svg x-fermer-bleu");
  			add_location(span2, file$7, 140, 10, 4902);
  			attr_dev(button, "type", "button");
  			attr_dev(button, "class", "close");
  			attr_dev(button, "aria-label", /*srBoutonFermer*/ ctx[4]);
  			add_location(button, file$7, 134, 8, 4747);
  			attr_dev(span3, "class", "utd-container entete");
  			add_location(span3, file$7, 125, 6, 4495);
  			attr_dev(span4, "class", "corps");
  			attr_dev(span4, "id", /*idCorps*/ ctx[11]);
  			attr_dev(span4, "tabindex", "-1");
  			add_location(span4, file$7, 147, 8, 5098);
  			attr_dev(span5, "class", "utd-container conteneur-corps");
  			add_location(span5, file$7, 146, 6, 5044);
  			attr_dev(span6, "aria-labelledby", /*idEntete*/ ctx[10]);
  			attr_dev(span6, "class", "modale");
  			attr_dev(span6, "id", /*idModale*/ ctx[9]);
  			attr_dev(span6, "aria-modal", "true");
  			attr_dev(span6, "role", "dialog");
  			add_location(span6, file$7, 113, 4, 4151);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			insert_dev(target, t0, anchor);
  			insert_dev(target, span6, anchor);
  			append_dev(span6, span3);
  			append_dev(span3, h1);
  			append_dev(h1, span0);
  			span0.innerHTML = /*srTitre*/ ctx[2];
  			append_dev(h1, t1);
  			append_dev(h1, span1);
  			if (if_block0) if_block0.m(span1, null);
  			append_dev(span3, t2);
  			append_dev(span3, button);
  			append_dev(button, span2);
  			append_dev(span6, t3);
  			append_dev(span6, span5);
  			append_dev(span5, span4);
  			if (if_block1) if_block1.m(span4, null);
  			current = true;

  			if (!mounted) {
  				dispose = [
  					listen_dev(div, "click", /*masquerModale*/ ctx[13], false, false, false),
  					listen_dev(button, "click", /*masquerModale*/ ctx[13], false, false, false),
  					listen_dev(span6, "keydown", /*keydown*/ ctx[14], false, false, false),
  					listen_dev(span6, "introend", /*conserverFocusInfobulle*/ ctx[16], false, false, false),
  					listen_dev(span6, "outroend", /*finAnimationFermeture*/ ctx[15], false, false, false)
  				];

  				mounted = true;
  			}
  		},
  		p: function update(ctx, dirty) {
  			if (!current || dirty & /*srTitre*/ 4) span0.innerHTML = /*srTitre*/ ctx[2];
  			if (/*titre*/ ctx[1]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);
  				} else {
  					if_block0 = create_if_block_3$1(ctx);
  					if_block0.c();
  					if_block0.m(span1, null);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (!current || dirty & /*srBoutonFermer*/ 16) {
  				attr_dev(button, "aria-label", /*srBoutonFermer*/ ctx[4]);
  			}

  			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block1) {
  				if_block1.p(ctx, dirty);
  			} else {
  				if (if_block1) if_block1.d(1);
  				if_block1 = current_block_type && current_block_type(ctx);

  				if (if_block1) {
  					if_block1.c();
  					if_block1.m(span4, null);
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;

  			add_render_callback(() => {
  				if (span6_outro) span6_outro.end(1);
  				span6_intro = create_in_transition(span6, fly, { y: 200, duration: 500 });
  				span6_intro.start();
  			});

  			current = true;
  		},
  		o: function outro(local) {
  			if (span6_intro) span6_intro.invalidate();
  			span6_outro = create_out_transition(span6, fly, { y: 200, duration: 250 });
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (detaching) detach_dev(t0);
  			if (detaching) detach_dev(span6);
  			if (if_block0) if_block0.d();

  			if (if_block1) {
  				if_block1.d();
  			}

  			if (detaching && span6_outro) span6_outro.end();
  			mounted = false;
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$6.name,
  		type: "if",
  		source: "(112:2) {#if afficher}",
  		ctx
  	});

  	return block;
  }

  // (130:12) {#if titre}
  function create_if_block_3$1(ctx) {
  	let t;

  	const block = {
  		c: function create() {
  			t = text(/*titre*/ ctx[1]);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*titre*/ 2) set_data_dev(t, /*titre*/ ctx[1]);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_3$1.name,
  		type: "if",
  		source: "(130:12) {#if titre}",
  		ctx
  	});

  	return block;
  }

  // (155:14) {#if contenu}
  function create_if_block_2$2(ctx) {
  	let html_tag;
  	let html_anchor;

  	const block = {
  		c: function create() {
  			html_tag = new HtmlTag(false);
  			html_anchor = empty();
  			html_tag.a = html_anchor;
  		},
  		m: function mount(target, anchor) {
  			html_tag.m(/*contenu*/ ctx[5], target, anchor);
  			insert_dev(target, html_anchor, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*contenu*/ 32) html_tag.p(/*contenu*/ ctx[5]);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(html_anchor);
  			if (detaching) html_tag.d();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2$2.name,
  		type: "if",
  		source: "(155:14) {#if contenu}",
  		ctx
  	});

  	return block;
  }

  // (149:12) {#if Utils.slotExiste(slots, 'contenu')}
  function create_if_block_1$3(ctx) {
  	let slot;
  	let t;
  	let span;

  	const block = {
  		c: function create() {
  			slot = element("slot");
  			t = space();
  			span = element("span");
  			attr_dev(slot, "name", "contenu");
  			attr_dev(slot, "class", "utd-d-none");
  			add_location(slot, file$7, 149, 14, 5215);
  			add_location(span, file$7, 150, 14, 5272);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, slot, anchor);
  			insert_dev(target, t, anchor);
  			insert_dev(target, span, anchor);
  			span.innerHTML = /*htmlSlotContenu*/ ctx[7];
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*htmlSlotContenu*/ 128) span.innerHTML = /*htmlSlotContenu*/ ctx[7];		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(slot);
  			if (detaching) detach_dev(t);
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$3.name,
  		type: "if",
  		source: "(149:12) {#if Utils.slotExiste(slots, 'contenu')}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$7(ctx) {
  	let span4;
  	let t0;
  	let span3;
  	let t1;
  	let button;
  	let span2;
  	let span1;
  	let span0;
  	let t2;
  	let t3;
  	let link;
  	let current;
  	let mounted;
  	let dispose;
  	let if_block0 = /*$$slots*/ ctx[17]["texte-lie"] && create_if_block_4$2(ctx);
  	let if_block1 = /*afficher*/ ctx[0] && create_if_block$6(ctx);

  	const block = {
  		c: function create() {
  			span4 = element("span");
  			if (if_block0) if_block0.c();
  			t0 = space();
  			span3 = element("span");
  			t1 = space();
  			button = element("button");
  			span2 = element("span");
  			span1 = element("span");
  			span0 = element("span");
  			t2 = space();
  			if (if_block1) if_block1.c();
  			t3 = space();
  			link = element("link");
  			this.c = noop;
  			attr_dev(span0, "aria-hidden", "true");
  			attr_dev(span0, "class", "utd-icone-svg question");
  			add_location(span0, file$7, 102, 10, 3913);
  			attr_dev(span1, "aria-hidden", "true");
  			attr_dev(span1, "class", "puce");
  			add_location(span1, file$7, 101, 8, 3863);
  			attr_dev(span2, "class", "conteneur-puce");
  			add_location(span2, file$7, 100, 6, 3824);
  			attr_dev(button, "type", "button");
  			attr_dev(button, "id", /*idBoutonToggle*/ ctx[8]);
  			attr_dev(button, "aria-label", /*srBoutonOuvrir*/ ctx[3]);
  			attr_dev(button, "class", "tooltip-toggle");
  			add_location(button, file$7, 99, 42, 3697);
  			attr_dev(span3, "class", "conteneur-tooltip");
  			add_location(span3, file$7, 99, 2, 3657);
  			attr_dev(span4, "class", "utd-component utd-infobulle");
  			add_location(span4, file$7, 95, 0, 3484);
  			attr_dev(link, "rel", "stylesheet");
  			attr_dev(link, "href", Utils.cssFullPath);
  			add_location(link, file$7, 164, 0, 5568);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span4, anchor);
  			if (if_block0) if_block0.m(span4, null);
  			append_dev(span4, t0);
  			append_dev(span4, span3);
  			append_dev(span3, t1);
  			append_dev(span3, button);
  			append_dev(button, span2);
  			append_dev(span2, span1);
  			append_dev(span1, span0);
  			append_dev(span4, t2);
  			if (if_block1) if_block1.m(span4, null);
  			insert_dev(target, t3, anchor);
  			insert_dev(target, link, anchor);
  			current = true;

  			if (!mounted) {
  				dispose = listen_dev(button, "click", /*afficherModale*/ ctx[12], false, false, false);
  				mounted = true;
  			}
  		},
  		p: function update(ctx, [dirty]) {
  			if (/*$$slots*/ ctx[17]["texte-lie"]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);
  				} else {
  					if_block0 = create_if_block_4$2(ctx);
  					if_block0.c();
  					if_block0.m(span4, t0);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (!current || dirty & /*srBoutonOuvrir*/ 8) {
  				attr_dev(button, "aria-label", /*srBoutonOuvrir*/ ctx[3]);
  			}

  			if (/*afficher*/ ctx[0]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty & /*afficher*/ 1) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block$6(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(span4, null);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block1);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block1);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span4);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (detaching) detach_dev(t3);
  			if (detaching) detach_dev(link);
  			mounted = false;
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$7.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$7($$self, $$props, $$invalidate) {
  	let { $$slots: slots$1 = {}, $$scope } = $$props;
  	validate_slots('utd-infobulle', slots$1, []);
  	const $$slots = compute_slots(slots$1);
  	let { afficher = false } = $$props;
  	let { titre = "" } = $$props;

  	let { srTitre = Utils.obtenirLanguePage() === "fr"
  	? "Aide à propos de&nbsp;"
  	: "Help about&nbsp;" } = $$props;

  	let { srBoutonOuvrir = Utils.obtenirLanguePage() === "fr"
  	? "Afficher l'aide contextuelle"
  	: "Show help about" } = $$props;

  	let { srBoutonFermer = Utils.obtenirLanguePage() === "fr" ? "Fermer" : "Close" } = $$props;
  	let { contenu = "" } = $$props;
  	const idBoutonToggle = Utils.genererId();
  	const idModale = Utils.genererId();
  	const idEntete = Utils.genererId();
  	const idCorps = Utils.genererId();
  	const thisComponent = get_current_component();
  	let html;
  	let body;
  	let slots = [];
  	let htmlSlotContenu;

  	onMount(() => {
  		html = thisComponent.getRootNode().getElementsByTagName("html")[0];
  		body = thisComponent.getRootNode().getElementsByTagName("body")[0];
  		$$invalidate(6, slots = Array.from(thisComponent.querySelectorAll('[slot]')));
  		assignerHtmlSlotContenu();

  		if (Utils.estMobile()) {
  			html.classList.add("est-mobile");
  		}
  	});

  	/**
   * Permet de pallier à un problème de perte de focus à l'intérieur de la modale. En effet, si on clique dans le contenu de la slot "contenu" et qu'on fait TAB, le focus
   * tombe dans la page en dessous car le keydown est sur le body de la page (probablement car nous sommes dans une slot).
   * Nous cachons donc le contenu de la slot, récupérons son html et l'assignons nous-même au contrôle. De cette façon nous allons nous réglons le problème et en bonus
   * nous nous assurons d'une conformité visuelle, puisque c'est le css de notre composant qui va s'appliquer et non celui de l'application.
   * NOTE. Le problème ne semble pas se produire avec le composant utd-dialog. On dirait que le fait que d'autres contrôles focusables sont présents empêche le problème. Je ne comprends pas vraiment.
   */
  	function assignerHtmlSlotContenu() {
  		if (slots.length) {
  			const slotContenu = thisComponent.querySelector("[slot=contenu]");

  			if (slotContenu) {
  				const contenuHtml = thisComponent.querySelector("[slot=contenu]").innerHTML;

  				if (contenuHtml) {
  					$$invalidate(7, htmlSlotContenu = contenuHtml);
  				}
  			}
  		}
  	}

  	function afficherModale(e) {
  		Utils.ajusterInterfaceAvantAffichageModale(html, body);
  		$$invalidate(0, afficher = true);
  	}

  	function masquerModale(e) {
  		$$invalidate(0, afficher = false);
  		redonnerFocusBoutonToggle();
  	}

  	function redonnerFocusBoutonToggle() {
  		const controleFocus = thisComponent.shadowRoot.getElementById(idBoutonToggle);

  		if (controleFocus) {
  			//On redonne le focus au contrôle spécifié (normalement le bouton toggle de l'infobulle)
  			controleFocus.focus();
  		}
  	}

  	function keydown(e) {
  		if (e.key === "Escape") {
  			masquerModale();
  		}
  	}

  	function finAnimationFermeture(e) {
  		Utils.ajusterInterfaceApresFermetureModale(html, body);
  	}

  	function conserverFocusInfobulle(e) {
  		thisComponent.shadowRoot.getElementById(idCorps).focus();
  		Utils.conserverFocusElement(thisComponent.shadowRoot.getElementById(idModale), thisComponent);
  	}

  	const writable_props = ['afficher', 'titre', 'srTitre', 'srBoutonOuvrir', 'srBoutonFermer', 'contenu'];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<utd-infobulle> was created with unknown prop '${key}'`);
  	});

  	$$self.$$set = $$props => {
  		if ('afficher' in $$props) $$invalidate(0, afficher = $$props.afficher);
  		if ('titre' in $$props) $$invalidate(1, titre = $$props.titre);
  		if ('srTitre' in $$props) $$invalidate(2, srTitre = $$props.srTitre);
  		if ('srBoutonOuvrir' in $$props) $$invalidate(3, srBoutonOuvrir = $$props.srBoutonOuvrir);
  		if ('srBoutonFermer' in $$props) $$invalidate(4, srBoutonFermer = $$props.srBoutonFermer);
  		if ('contenu' in $$props) $$invalidate(5, contenu = $$props.contenu);
  	};

  	$$self.$capture_state = () => ({
  		onMount,
  		fly,
  		get_current_component,
  		Utils,
  		afficher,
  		titre,
  		srTitre,
  		srBoutonOuvrir,
  		srBoutonFermer,
  		contenu,
  		idBoutonToggle,
  		idModale,
  		idEntete,
  		idCorps,
  		thisComponent,
  		html,
  		body,
  		slots,
  		htmlSlotContenu,
  		assignerHtmlSlotContenu,
  		afficherModale,
  		masquerModale,
  		redonnerFocusBoutonToggle,
  		keydown,
  		finAnimationFermeture,
  		conserverFocusInfobulle
  	});

  	$$self.$inject_state = $$props => {
  		if ('afficher' in $$props) $$invalidate(0, afficher = $$props.afficher);
  		if ('titre' in $$props) $$invalidate(1, titre = $$props.titre);
  		if ('srTitre' in $$props) $$invalidate(2, srTitre = $$props.srTitre);
  		if ('srBoutonOuvrir' in $$props) $$invalidate(3, srBoutonOuvrir = $$props.srBoutonOuvrir);
  		if ('srBoutonFermer' in $$props) $$invalidate(4, srBoutonFermer = $$props.srBoutonFermer);
  		if ('contenu' in $$props) $$invalidate(5, contenu = $$props.contenu);
  		if ('html' in $$props) html = $$props.html;
  		if ('body' in $$props) body = $$props.body;
  		if ('slots' in $$props) $$invalidate(6, slots = $$props.slots);
  		if ('htmlSlotContenu' in $$props) $$invalidate(7, htmlSlotContenu = $$props.htmlSlotContenu);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [
  		afficher,
  		titre,
  		srTitre,
  		srBoutonOuvrir,
  		srBoutonFermer,
  		contenu,
  		slots,
  		htmlSlotContenu,
  		idBoutonToggle,
  		idModale,
  		idEntete,
  		idCorps,
  		afficherModale,
  		masquerModale,
  		keydown,
  		finAnimationFermeture,
  		conserverFocusInfobulle,
  		$$slots
  	];
  }

  class Infobulle extends SvelteElement {
  	constructor(options) {
  		super();

  		init(
  			this,
  			{
  				target: this.shadowRoot,
  				props: {
  					...attribute_to_object(this.attributes),
  					$$slots: get_custom_elements_slots(this)
  				},
  				customElement: true
  			},
  			instance$7,
  			create_fragment$7,
  			safe_not_equal,
  			{
  				afficher: 0,
  				titre: 1,
  				srTitre: 2,
  				srBoutonOuvrir: 3,
  				srBoutonFermer: 4,
  				contenu: 5
  			},
  			null
  		);

  		if (options) {
  			if (options.target) {
  				insert_dev(options.target, this, options.anchor);
  			}

  			if (options.props) {
  				this.$set(options.props);
  				flush();
  			}
  		}
  	}

  	static get observedAttributes() {
  		return [
  			"afficher",
  			"titre",
  			"srTitre",
  			"srBoutonOuvrir",
  			"srBoutonFermer",
  			"contenu"
  		];
  	}

  	get afficher() {
  		return this.$$.ctx[0];
  	}

  	set afficher(afficher) {
  		this.$$set({ afficher });
  		flush();
  	}

  	get titre() {
  		return this.$$.ctx[1];
  	}

  	set titre(titre) {
  		this.$$set({ titre });
  		flush();
  	}

  	get srTitre() {
  		return this.$$.ctx[2];
  	}

  	set srTitre(srTitre) {
  		this.$$set({ srTitre });
  		flush();
  	}

  	get srBoutonOuvrir() {
  		return this.$$.ctx[3];
  	}

  	set srBoutonOuvrir(srBoutonOuvrir) {
  		this.$$set({ srBoutonOuvrir });
  		flush();
  	}

  	get srBoutonFermer() {
  		return this.$$.ctx[4];
  	}

  	set srBoutonFermer(srBoutonFermer) {
  		this.$$set({ srBoutonFermer });
  		flush();
  	}

  	get contenu() {
  		return this.$$.ctx[5];
  	}

  	set contenu(contenu) {
  		this.$$set({ contenu });
  		flush();
  	}
  }

  customElements.define("utd-infobulle", Infobulle);

  /* src\components\menuVertical.svelte generated by Svelte v3.50.1 */
  const file$6 = "src\\components\\menuVertical.svelte";

  function create_fragment$6(ctx) {
  	let nav;
  	let a;
  	let span0;
  	let t0;
  	let t1;
  	let span1;
  	let t2;
  	let span2;
  	let t4;
  	let span3;
  	let t5;
  	let span3_class_value;
  	let t6;
  	let div;
  	let slot;
  	let t7;
  	let link;
  	let mounted;
  	let dispose;

  	const block = {
  		c: function create() {
  			nav = element("nav");
  			a = element("a");
  			span0 = element("span");
  			t0 = text(/*titre*/ ctx[0]);
  			t1 = space();
  			span1 = element("span");
  			t2 = space();
  			span2 = element("span");
  			span2.textContent = `${/*srTexteSortirMenu*/ ctx[5]}`;
  			t4 = space();
  			span3 = element("span");
  			t5 = text(/*titre*/ ctx[0]);
  			t6 = space();
  			div = element("div");
  			slot = element("slot");
  			t7 = space();
  			link = element("link");
  			this.c = noop;
  			add_location(span0, file$6, 26, 4, 1142);
  			attr_dev(span1, "aria-hidden", "true");
  			attr_dev(span1, "class", "utd-icone-svg chevron-bleu-piv");
  			add_location(span1, file$6, 27, 4, 1168);
  			attr_dev(span2, "class", "utd-sr-only");
  			add_location(span2, file$6, 28, 4, 1239);
  			attr_dev(a, "role", "button");
  			attr_dev(a, "href", "#" + /*idMenu*/ ctx[3]);
  			attr_dev(a, "class", "toggle");
  			attr_dev(a, "aria-controls", /*idMenu*/ ctx[3]);
  			add_location(a, file$6, 25, 2, 1021);
  			attr_dev(span3, "class", span3_class_value = "titre " + (/*titreVisible*/ ctx[1] === 'true' ? '' : 'utd-sr-only'));
  			attr_dev(span3, "id", /*idTitreMenu*/ ctx[4]);
  			add_location(span3, file$6, 33, 2, 1321);
  			add_location(slot, file$6, 35, 4, 1498);
  			attr_dev(div, "id", /*idMenu*/ ctx[3]);
  			attr_dev(div, "role", "menu");
  			attr_dev(div, "class", "menu");
  			toggle_class(div, "visible", /*afficher*/ ctx[2]);
  			add_location(div, file$6, 34, 2, 1425);
  			attr_dev(nav, "class", "utd-menu-vertical");
  			attr_dev(nav, "aria-labelledby", /*idTitreMenu*/ ctx[4]);
  			toggle_class(nav, "visible", /*afficher*/ ctx[2]);
  			add_location(nav, file$6, 24, 0, 929);
  			attr_dev(link, "rel", "stylesheet");
  			attr_dev(link, "href", Utils.cssFullPath);
  			add_location(link, file$6, 38, 0, 1533);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, nav, anchor);
  			append_dev(nav, a);
  			append_dev(a, span0);
  			append_dev(span0, t0);
  			append_dev(a, t1);
  			append_dev(a, span1);
  			append_dev(a, t2);
  			append_dev(a, span2);
  			append_dev(nav, t4);
  			append_dev(nav, span3);
  			append_dev(span3, t5);
  			append_dev(nav, t6);
  			append_dev(nav, div);
  			append_dev(div, slot);
  			insert_dev(target, t7, anchor);
  			insert_dev(target, link, anchor);

  			if (!mounted) {
  				dispose = listen_dev(a, "click", prevent_default(/*toggleAfficher*/ ctx[6]), false, true, false);
  				mounted = true;
  			}
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*titre*/ 1) set_data_dev(t0, /*titre*/ ctx[0]);
  			if (dirty & /*titre*/ 1) set_data_dev(t5, /*titre*/ ctx[0]);

  			if (dirty & /*titreVisible*/ 2 && span3_class_value !== (span3_class_value = "titre " + (/*titreVisible*/ ctx[1] === 'true' ? '' : 'utd-sr-only'))) {
  				attr_dev(span3, "class", span3_class_value);
  			}

  			if (dirty & /*afficher*/ 4) {
  				toggle_class(div, "visible", /*afficher*/ ctx[2]);
  			}

  			if (dirty & /*afficher*/ 4) {
  				toggle_class(nav, "visible", /*afficher*/ ctx[2]);
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(nav);
  			if (detaching) detach_dev(t7);
  			if (detaching) detach_dev(link);
  			mounted = false;
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$6.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$6($$self, $$props, $$invalidate) {
  	let { $$slots: slots = {}, $$scope } = $$props;
  	validate_slots('utd-menu-vertical', slots, []);

  	let { titre = Utils.obtenirLanguePage() === 'en'
  	? 'Secondary menu'
  	: 'Menu secondaire' } = $$props;

  	let { titreVisible = "true" } = $$props;
  	let afficher = false;
  	const idMenu = Utils.genererId();
  	const idTitreMenu = Utils.genererId();

  	const srTexteSortirMenu = Utils.obtenirLanguePage() === "en"
  	? "Press ESC key to exit menu."
  	: "Appuyez sur la touche Échappe pour sortir du menu.";

  	//TODO implémnenter gestion langue (aller chercher dans balise html? lang=?)
  	// Références pour accessibilité
  	// https://www.w3.org/WAI/ARIA/apg/example-index/menubar/menubar-navigation, https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/menu_role et https://usability.yale.edu/web-accessibility/articles/focus-keyboard-operability
  	function toggleAfficher() {
  		$$invalidate(2, afficher = !afficher);
  	}

  	const writable_props = ['titre', 'titreVisible'];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<utd-menu-vertical> was created with unknown prop '${key}'`);
  	});

  	$$self.$$set = $$props => {
  		if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
  		if ('titreVisible' in $$props) $$invalidate(1, titreVisible = $$props.titreVisible);
  	};

  	$$self.$capture_state = () => ({
  		Utils,
  		titre,
  		titreVisible,
  		afficher,
  		idMenu,
  		idTitreMenu,
  		srTexteSortirMenu,
  		toggleAfficher
  	});

  	$$self.$inject_state = $$props => {
  		if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
  		if ('titreVisible' in $$props) $$invalidate(1, titreVisible = $$props.titreVisible);
  		if ('afficher' in $$props) $$invalidate(2, afficher = $$props.afficher);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [
  		titre,
  		titreVisible,
  		afficher,
  		idMenu,
  		idTitreMenu,
  		srTexteSortirMenu,
  		toggleAfficher
  	];
  }

  class MenuVertical extends SvelteElement {
  	constructor(options) {
  		super();

  		init(
  			this,
  			{
  				target: this.shadowRoot,
  				props: attribute_to_object(this.attributes),
  				customElement: true
  			},
  			instance$6,
  			create_fragment$6,
  			safe_not_equal,
  			{ titre: 0, titreVisible: 1 },
  			null
  		);

  		if (options) {
  			if (options.target) {
  				insert_dev(options.target, this, options.anchor);
  			}

  			if (options.props) {
  				this.$set(options.props);
  				flush();
  			}
  		}
  	}

  	static get observedAttributes() {
  		return ["titre", "titreVisible"];
  	}

  	get titre() {
  		return this.$$.ctx[0];
  	}

  	set titre(titre) {
  		this.$$set({ titre });
  		flush();
  	}

  	get titreVisible() {
  		return this.$$.ctx[1];
  	}

  	set titreVisible(titreVisible) {
  		this.$$set({ titreVisible });
  		flush();
  	}
  }

  customElements.define("utd-menu-vertical", MenuVertical);

  /* src\components\menuVerticalItem.svelte generated by Svelte v3.50.1 */

  const { console: console_1 } = globals;
  const file$5 = "src\\components\\menuVerticalItem.svelte";

  // (213:2) {:else}
  function create_else_block$1(ctx) {
  	let a;
  	let span;
  	let t;
  	let a_aria_current_value;
  	let mounted;
  	let dispose;

  	const block = {
  		c: function create() {
  			a = element("a");
  			span = element("span");
  			t = text(/*libelle*/ ctx[2]);
  			add_location(span, file$5, 214, 6, 6543);
  			attr_dev(a, "href", /*href*/ ctx[3]);
  			attr_dev(a, "role", "menuitem");
  			attr_dev(a, "aria-current", a_aria_current_value = /*actif*/ ctx[1] === 'true' ? 'page' : null);
  			attr_dev(a, "tabindex", /*indextab*/ ctx[4]);
  			add_location(a, file$5, 213, 4, 6388);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, a, anchor);
  			append_dev(a, span);
  			append_dev(span, t);

  			if (!mounted) {
  				dispose = [
  					listen_dev(a, "keydown", /*onKeyDown*/ ctx[10], false, false, false),
  					listen_dev(a, "focus", /*onFocus*/ ctx[11], false, false, false)
  				];

  				mounted = true;
  			}
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*libelle*/ 4) set_data_dev(t, /*libelle*/ ctx[2]);

  			if (dirty & /*href*/ 8) {
  				attr_dev(a, "href", /*href*/ ctx[3]);
  			}

  			if (dirty & /*actif*/ 2 && a_aria_current_value !== (a_aria_current_value = /*actif*/ ctx[1] === 'true' ? 'page' : null)) {
  				attr_dev(a, "aria-current", a_aria_current_value);
  			}

  			if (dirty & /*indextab*/ 16) {
  				attr_dev(a, "tabindex", /*indextab*/ ctx[4]);
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(a);
  			mounted = false;
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block$1.name,
  		type: "else",
  		source: "(213:2) {:else}",
  		ctx
  	});

  	return block;
  }

  // (203:2) {#if possedeEnfants}
  function create_if_block$5(ctx) {
  	let a;
  	let span0;
  	let t0;
  	let t1;
  	let span1;
  	let t2;
  	let if_block_anchor;
  	let current;
  	let mounted;
  	let dispose;
  	let if_block = /*afficher*/ ctx[0] === 'true' && create_if_block_1$2(ctx);

  	const block = {
  		c: function create() {
  			a = element("a");
  			span0 = element("span");
  			t0 = text(/*libelle*/ ctx[2]);
  			t1 = space();
  			span1 = element("span");
  			t2 = space();
  			if (if_block) if_block.c();
  			if_block_anchor = empty();
  			add_location(span0, file$5, 204, 6, 6067);
  			attr_dev(span1, "aria-hidden", "true");
  			attr_dev(span1, "class", "utd-icone-svg chevron-bleu-piv");
  			add_location(span1, file$5, 205, 6, 6097);
  			attr_dev(a, "role", "menuitem");
  			attr_dev(a, "href", /*href*/ ctx[3]);
  			attr_dev(a, "aria-expanded", /*afficher*/ ctx[0]);
  			attr_dev(a, "aria-haspopup", "menu");
  			attr_dev(a, "aria-controls", /*idSousMenu*/ ctx[8]);
  			attr_dev(a, "tabindex", /*indextab*/ ctx[4]);
  			add_location(a, file$5, 203, 4, 5844);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, a, anchor);
  			append_dev(a, span0);
  			append_dev(span0, t0);
  			append_dev(a, t1);
  			append_dev(a, span1);
  			insert_dev(target, t2, anchor);
  			if (if_block) if_block.m(target, anchor);
  			insert_dev(target, if_block_anchor, anchor);
  			current = true;

  			if (!mounted) {
  				dispose = [
  					listen_dev(a, "click", prevent_default(/*toggleAfficher*/ ctx[9]), false, true, false),
  					listen_dev(a, "keydown", /*onKeyDown*/ ctx[10], false, false, false),
  					listen_dev(a, "focus", /*onFocus*/ ctx[11], false, false, false)
  				];

  				mounted = true;
  			}
  		},
  		p: function update(ctx, dirty) {
  			if (!current || dirty & /*libelle*/ 4) set_data_dev(t0, /*libelle*/ ctx[2]);

  			if (!current || dirty & /*href*/ 8) {
  				attr_dev(a, "href", /*href*/ ctx[3]);
  			}

  			if (!current || dirty & /*afficher*/ 1) {
  				attr_dev(a, "aria-expanded", /*afficher*/ ctx[0]);
  			}

  			if (!current || dirty & /*indextab*/ 16) {
  				attr_dev(a, "tabindex", /*indextab*/ ctx[4]);
  			}

  			if (/*afficher*/ ctx[0] === 'true') {
  				if (if_block) {
  					if_block.p(ctx, dirty);

  					if (dirty & /*afficher*/ 1) {
  						transition_in(if_block, 1);
  					}
  				} else {
  					if_block = create_if_block_1$2(ctx);
  					if_block.c();
  					transition_in(if_block, 1);
  					if_block.m(if_block_anchor.parentNode, if_block_anchor);
  				}
  			} else if (if_block) {
  				group_outros();

  				transition_out(if_block, 1, 1, () => {
  					if_block = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(a);
  			if (detaching) detach_dev(t2);
  			if (if_block) if_block.d(detaching);
  			if (detaching) detach_dev(if_block_anchor);
  			mounted = false;
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$5.name,
  		type: "if",
  		source: "(203:2) {#if possedeEnfants}",
  		ctx
  	});

  	return block;
  }

  // (208:4) {#if afficher === 'true'}
  function create_if_block_1$2(ctx) {
  	let div;
  	let slot;
  	let div_transition;
  	let current;

  	const block = {
  		c: function create() {
  			div = element("div");
  			slot = element("slot");
  			add_location(slot, file$5, 209, 8, 6333);
  			attr_dev(div, "id", /*idSousMenu*/ ctx[8]);
  			attr_dev(div, "role", "menu");
  			attr_dev(div, "class", "sous-menu");
  			add_location(div, file$5, 208, 6, 6211);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, slot);
  			current = true;
  		},
  		p: function update(new_ctx, dirty) {
  			ctx = new_ctx;
  		},
  		i: function intro(local) {
  			if (current) return;

  			add_render_callback(() => {
  				if (!div_transition) div_transition = create_bidirectional_transition(
  					div,
  					slide,
  					{
  						duration: /*animer*/ ctx[5] === 'true' ? 250 : 0
  					},
  					true
  				);

  				div_transition.run(1);
  			});

  			current = true;
  		},
  		o: function outro(local) {
  			if (!div_transition) div_transition = create_bidirectional_transition(
  				div,
  				slide,
  				{
  					duration: /*animer*/ ctx[5] === 'true' ? 250 : 0
  				},
  				false
  			);

  			div_transition.run(0);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (detaching && div_transition) div_transition.end();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$2.name,
  		type: "if",
  		source: "(208:4) {#if afficher === 'true'}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$5(ctx) {
  	let div;
  	let current_block_type_index;
  	let if_block;
  	let div_class_value;
  	let t;
  	let link;
  	let current;
  	const if_block_creators = [create_if_block$5, create_else_block$1];
  	const if_blocks = [];

  	function select_block_type(ctx, dirty) {
  		if (/*possedeEnfants*/ ctx[6]) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type(ctx);
  	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if_block.c();
  			t = space();
  			link = element("link");
  			this.c = noop;
  			attr_dev(div, "class", div_class_value = "utd-menu-vertical-item niv" + /*niveau*/ ctx[7] + " " + (/*afficher*/ ctx[0] === 'true' ? 'visible' : '') + " " + (/*actif*/ ctx[1] === 'true' ? 'active' : ''));
  			add_location(div, file$5, 201, 0, 5688);
  			attr_dev(link, "rel", "stylesheet");
  			attr_dev(link, "href", Utils.cssFullPath);
  			add_location(link, file$5, 218, 0, 6610);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			if_blocks[current_block_type_index].m(div, null);
  			insert_dev(target, t, anchor);
  			insert_dev(target, link, anchor);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block = if_blocks[current_block_type_index];

  				if (!if_block) {
  					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block.c();
  				} else {
  					if_block.p(ctx, dirty);
  				}

  				transition_in(if_block, 1);
  				if_block.m(div, null);
  			}

  			if (!current || dirty & /*niveau, afficher, actif*/ 131 && div_class_value !== (div_class_value = "utd-menu-vertical-item niv" + /*niveau*/ ctx[7] + " " + (/*afficher*/ ctx[0] === 'true' ? 'visible' : '') + " " + (/*actif*/ ctx[1] === 'true' ? 'active' : ''))) {
  				attr_dev(div, "class", div_class_value);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if_blocks[current_block_type_index].d();
  			if (detaching) detach_dev(t);
  			if (detaching) detach_dev(link);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$5.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function estMenuItem(element) {
  	return element && element.tagName.toLowerCase() === 'utd-menu-vertical-item';
  }

  function instance$5($$self, $$props, $$invalidate) {
  	let { $$slots: slots = {}, $$scope } = $$props;
  	validate_slots('utd-menu-vertical-item', slots, []);
  	let { libelle = '' } = $$props;
  	let { href = '' } = $$props;
  	let { afficher = 'false' } = $$props;
  	let { indextab = '0' } = $$props;
  	let { animer = 'true' } = $$props;
  	let { focus = 'false' } = $$props;
  	let { actif = 'false' } = $$props;
  	let possedeEnfants = false;
  	let niveau = 1;
  	const thisComponent = get_current_component();
  	const idSousMenu = Utils.genererId();

  	onMount(() => {
  		$$invalidate(1, actif = estElementActif());
  		$$invalidate(7, niveau = obtenirNiveau());
  		$$invalidate(6, possedeEnfants = !!thisComponent.querySelector('utd-menu-vertical-item'));
  	});

  	function toggleFocus() {
  		if (focus === 'true') {
  			thisComponent.shadowRoot.querySelector('a').focus();
  			$$invalidate(12, focus = 'false');
  		}
  	}

  	function toggleAfficher() {
  		$$invalidate(0, afficher = afficher === 'true' ? 'false' : 'true');
  	}

  	function estElementActif() {
  		if (href) {
  			return (window.location.pathname === href).toString();
  		}
  	}

  	function obtenirNiveau() {
  		let niveau = 1;
  		let elementParent = thisComponent.parentElement;

  		while (elementParent.tagName.toLowerCase() === 'utd-menu-vertical-item') {
  			++niveau;

  			if (actif === 'true') {
  				elementParent.setAttribute('actif', 'true');
  				elementParent.setAttribute('animer', 'false');
  				elementParent.setAttribute('afficher', 'true');
  				elementParent.setAttribute('animer', 'true');
  			}

  			elementParent = elementParent.parentElement;
  		}

  		return niveau;
  	}

  	function obtenirMenuVertical() {
  		let elementParent = thisComponent.parentElement;

  		while (elementParent.tagName.toLowerCase() !== 'utd-menu-vertical') {
  			elementParent = elementParent.parentElement;
  		}

  		return elementParent;
  	}

  	function onKeyDown(e) {
  		console.log(e.keyCode);
  		const parent = thisComponent.parentElement;

  		switch (e.keyCode) {
  			case 27:
  				if (estMenuItem(parent)) {
  					parent.setAttribute('afficher', 'false');
  					parent.setAttribute('focus', 'true');
  				}
  				e.preventDefault();
  				break;
  			case 13:
  			case 32:
  				if (possedeEnfants) {
  					if (afficher === 'false') {
  						$$invalidate(0, afficher = 'true');
  						thisComponent.querySelector('utd-menu-vertical-item').setAttribute('focus', 'true');
  					}

  					e.preventDefault();
  				}
  				break;
  			case 37:
  				accederMenuPrecedent();
  				e.preventDefault();
  				break;
  			case 38:
  				accederMenuPrecedent(true);
  				e.preventDefault();
  				break;
  			case 39:
  				if (possedeEnfants) {
  					if (afficher === 'false') {
  						$$invalidate(0, afficher = 'true');
  						thisComponent.querySelector('utd-menu-vertical-item').setAttribute('focus', 'true');
  					} else {
  						accederMenuSuivant();
  					}
  				} else {
  					accederMenuSuivant();
  				}
  				e.preventDefault();
  				break;
  			case 40:
  				accederMenuSuivant(true);
  				e.preventDefault();
  				break;
  		}
  	}

  	function accederMenuSuivant(doitBoucler) {
  		const parent = thisComponent.parentElement;
  		let prochainMenu;
  		$$invalidate(0, afficher = 'false');

  		if (!doitBoucler && estMenuItem(parent)) {
  			parent.setAttribute('afficher', 'false');
  			prochainMenu = parent.nextElementSibling;
  		} else {
  			prochainMenu = thisComponent.nextElementSibling;
  		}

  		if (estMenuItem(prochainMenu)) {
  			prochainMenu.setAttribute('focus', 'true');
  		} else {
  			if (doitBoucler) {
  				parent.querySelector('utd-menu-vertical-item').setAttribute('focus', 'true');
  			} else {
  				parent.parentElement.querySelector('utd-menu-vertical-item').setAttribute('focus', 'true');
  			}
  		}
  	}

  	function accederMenuPrecedent(doitBoucler) {
  		const parent = thisComponent.parentElement;
  		let menuPrecedent;
  		$$invalidate(0, afficher = 'false');

  		if (!doitBoucler && estMenuItem(parent)) {
  			parent.setAttribute('afficher', 'false');
  			parent.setAttribute('focus', 'true');
  		} else {
  			menuPrecedent = thisComponent.previousElementSibling;
  		}

  		if (estMenuItem(menuPrecedent)) {
  			menuPrecedent.setAttribute('focus', 'true');
  		} else {
  			const elements = parent.children;
  			elements[elements.length - 1].setAttribute('focus', 'true');
  		}
  	}

  	function onFocus() {
  		// Tab roving!!! On gère le tabindex des éléments du menu afin que seul l'élément actif puisse être focusable (via tab) de sorte qu'on gère le focus via les flèches du clavier et 
  		// un TAB provoque la sortie du menu.
  		retirerPossibiliteFocusElementsMenu();

  		thisComponent.setAttribute('indextab', '0');
  	}

  	function retirerPossibiliteFocusElementsMenu() {
  		const menuVertical = obtenirMenuVertical();
  		const elements = menuVertical.querySelectorAll('utd-menu-vertical-item');

  		elements.forEach(element => {
  			element.setAttribute('indextab', '-1');
  		});
  	}

  	const writable_props = ['libelle', 'href', 'afficher', 'indextab', 'animer', 'focus', 'actif'];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<utd-menu-vertical-item> was created with unknown prop '${key}'`);
  	});

  	$$self.$$set = $$props => {
  		if ('libelle' in $$props) $$invalidate(2, libelle = $$props.libelle);
  		if ('href' in $$props) $$invalidate(3, href = $$props.href);
  		if ('afficher' in $$props) $$invalidate(0, afficher = $$props.afficher);
  		if ('indextab' in $$props) $$invalidate(4, indextab = $$props.indextab);
  		if ('animer' in $$props) $$invalidate(5, animer = $$props.animer);
  		if ('focus' in $$props) $$invalidate(12, focus = $$props.focus);
  		if ('actif' in $$props) $$invalidate(1, actif = $$props.actif);
  	};

  	$$self.$capture_state = () => ({
  		onMount,
  		Utils,
  		slide,
  		get_current_component,
  		libelle,
  		href,
  		afficher,
  		indextab,
  		animer,
  		focus,
  		actif,
  		possedeEnfants,
  		niveau,
  		thisComponent,
  		idSousMenu,
  		toggleFocus,
  		toggleAfficher,
  		estElementActif,
  		obtenirNiveau,
  		obtenirMenuVertical,
  		onKeyDown,
  		accederMenuSuivant,
  		accederMenuPrecedent,
  		estMenuItem,
  		onFocus,
  		retirerPossibiliteFocusElementsMenu
  	});

  	$$self.$inject_state = $$props => {
  		if ('libelle' in $$props) $$invalidate(2, libelle = $$props.libelle);
  		if ('href' in $$props) $$invalidate(3, href = $$props.href);
  		if ('afficher' in $$props) $$invalidate(0, afficher = $$props.afficher);
  		if ('indextab' in $$props) $$invalidate(4, indextab = $$props.indextab);
  		if ('animer' in $$props) $$invalidate(5, animer = $$props.animer);
  		if ('focus' in $$props) $$invalidate(12, focus = $$props.focus);
  		if ('actif' in $$props) $$invalidate(1, actif = $$props.actif);
  		if ('possedeEnfants' in $$props) $$invalidate(6, possedeEnfants = $$props.possedeEnfants);
  		if ('niveau' in $$props) $$invalidate(7, niveau = $$props.niveau);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*focus*/ 4096) {
  			// Watch sur la prop focus
  			toggleFocus();
  		}
  	};

  	return [
  		afficher,
  		actif,
  		libelle,
  		href,
  		indextab,
  		animer,
  		possedeEnfants,
  		niveau,
  		idSousMenu,
  		toggleAfficher,
  		onKeyDown,
  		onFocus,
  		focus
  	];
  }

  class MenuVerticalItem extends SvelteElement {
  	constructor(options) {
  		super();

  		init(
  			this,
  			{
  				target: this.shadowRoot,
  				props: attribute_to_object(this.attributes),
  				customElement: true
  			},
  			instance$5,
  			create_fragment$5,
  			safe_not_equal,
  			{
  				libelle: 2,
  				href: 3,
  				afficher: 0,
  				indextab: 4,
  				animer: 5,
  				focus: 12,
  				actif: 1
  			},
  			null
  		);

  		if (options) {
  			if (options.target) {
  				insert_dev(options.target, this, options.anchor);
  			}

  			if (options.props) {
  				this.$set(options.props);
  				flush();
  			}
  		}
  	}

  	static get observedAttributes() {
  		return ["libelle", "href", "afficher", "indextab", "animer", "focus", "actif"];
  	}

  	get libelle() {
  		return this.$$.ctx[2];
  	}

  	set libelle(libelle) {
  		this.$$set({ libelle });
  		flush();
  	}

  	get href() {
  		return this.$$.ctx[3];
  	}

  	set href(href) {
  		this.$$set({ href });
  		flush();
  	}

  	get afficher() {
  		return this.$$.ctx[0];
  	}

  	set afficher(afficher) {
  		this.$$set({ afficher });
  		flush();
  	}

  	get indextab() {
  		return this.$$.ctx[4];
  	}

  	set indextab(indextab) {
  		this.$$set({ indextab });
  		flush();
  	}

  	get animer() {
  		return this.$$.ctx[5];
  	}

  	set animer(animer) {
  		this.$$set({ animer });
  		flush();
  	}

  	get focus() {
  		return this.$$.ctx[12];
  	}

  	set focus(focus) {
  		this.$$set({ focus });
  		flush();
  	}

  	get actif() {
  		return this.$$.ctx[1];
  	}

  	set actif(actif) {
  		this.$$set({ actif });
  		flush();
  	}
  }

  customElements.define("utd-menu-vertical-item", MenuVerticalItem);

  /* src\components\section.svelte generated by Svelte v3.50.1 */
  const file$4 = "src\\components\\section.svelte";

  // (37:4) {:else}
  function create_else_block(ctx) {
  	let previous_tag = /*tagTitre*/ ctx[4];
  	let svelte_element_anchor;
  	validate_dynamic_element(/*tagTitre*/ ctx[4]);
  	validate_void_dynamic_element(/*tagTitre*/ ctx[4]);
  	let svelte_element = /*tagTitre*/ ctx[4] && create_dynamic_element_1(ctx);

  	const block = {
  		c: function create() {
  			if (svelte_element) svelte_element.c();
  			svelte_element_anchor = empty();
  		},
  		m: function mount(target, anchor) {
  			if (svelte_element) svelte_element.m(target, anchor);
  			insert_dev(target, svelte_element_anchor, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (/*tagTitre*/ ctx[4]) {
  				if (!previous_tag) {
  					svelte_element = create_dynamic_element_1(ctx);
  					svelte_element.c();
  					svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
  				} else if (safe_not_equal(previous_tag, /*tagTitre*/ ctx[4])) {
  					svelte_element.d(1);
  					validate_dynamic_element(/*tagTitre*/ ctx[4]);
  					validate_void_dynamic_element(/*tagTitre*/ ctx[4]);
  					svelte_element = create_dynamic_element_1(ctx);
  					svelte_element.c();
  					svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
  				} else {
  					svelte_element.p(ctx, dirty);
  				}
  			} else if (previous_tag) {
  				svelte_element.d(1);
  				svelte_element = null;
  			}

  			previous_tag = /*tagTitre*/ ctx[4];
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(svelte_element_anchor);
  			if (svelte_element) svelte_element.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block.name,
  		type: "else",
  		source: "(37:4) {:else}",
  		ctx
  	});

  	return block;
  }

  // (27:4) {#if extensible === 'true'}
  function create_if_block_1$1(ctx) {
  	let previous_tag = /*tagTitre*/ ctx[4];
  	let svelte_element_anchor;
  	validate_dynamic_element(/*tagTitre*/ ctx[4]);
  	validate_void_dynamic_element(/*tagTitre*/ ctx[4]);
  	let svelte_element = /*tagTitre*/ ctx[4] && create_dynamic_element(ctx);

  	const block = {
  		c: function create() {
  			if (svelte_element) svelte_element.c();
  			svelte_element_anchor = empty();
  		},
  		m: function mount(target, anchor) {
  			if (svelte_element) svelte_element.m(target, anchor);
  			insert_dev(target, svelte_element_anchor, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (/*tagTitre*/ ctx[4]) {
  				if (!previous_tag) {
  					svelte_element = create_dynamic_element(ctx);
  					svelte_element.c();
  					svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
  				} else if (safe_not_equal(previous_tag, /*tagTitre*/ ctx[4])) {
  					svelte_element.d(1);
  					validate_dynamic_element(/*tagTitre*/ ctx[4]);
  					validate_void_dynamic_element(/*tagTitre*/ ctx[4]);
  					svelte_element = create_dynamic_element(ctx);
  					svelte_element.c();
  					svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
  				} else {
  					svelte_element.p(ctx, dirty);
  				}
  			} else if (previous_tag) {
  				svelte_element.d(1);
  				svelte_element = null;
  			}

  			previous_tag = /*tagTitre*/ ctx[4];
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(svelte_element_anchor);
  			if (svelte_element) svelte_element.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$1.name,
  		type: "if",
  		source: "(27:4) {#if extensible === 'true'}",
  		ctx
  	});

  	return block;
  }

  // (39:8) {#if titre}
  function create_if_block_4$1(ctx) {
  	let t;

  	const block = {
  		c: function create() {
  			t = text(/*titre*/ ctx[2]);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*titre*/ 4) set_data_dev(t, /*titre*/ ctx[2]);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_4$1.name,
  		type: "if",
  		source: "(39:8) {#if titre}",
  		ctx
  	});

  	return block;
  }

  // (38:6) <svelte:element this={tagTitre} class="titre">
  function create_dynamic_element_1(ctx) {
  	let svelte_element;
  	let t;
  	let slot;
  	let if_block = /*titre*/ ctx[2] && create_if_block_4$1(ctx);
  	let svelte_element_levels = [{ class: "titre" }];
  	let svelte_element_data = {};

  	for (let i = 0; i < svelte_element_levels.length; i += 1) {
  		svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  	}

  	const block = {
  		c: function create() {
  			svelte_element = element(/*tagTitre*/ ctx[4]);
  			if (if_block) if_block.c();
  			t = space();
  			slot = element("slot");
  			attr_dev(slot, "name", "titre");
  			add_location(slot, file$4, 41, 8, 1427);
  			set_attributes(svelte_element, svelte_element_data);
  			add_location(svelte_element, file$4, 37, 6, 1315);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, svelte_element, anchor);
  			if (if_block) if_block.m(svelte_element, null);
  			append_dev(svelte_element, t);
  			append_dev(svelte_element, slot);
  		},
  		p: function update(ctx, dirty) {
  			if (/*titre*/ ctx[2]) {
  				if (if_block) {
  					if_block.p(ctx, dirty);
  				} else {
  					if_block = create_if_block_4$1(ctx);
  					if_block.c();
  					if_block.m(svelte_element, t);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}

  			set_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [{ class: "titre" }]));
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(svelte_element);
  			if (if_block) if_block.d();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_dynamic_element_1.name,
  		type: "child_dynamic_element",
  		source: "(38:6) <svelte:element this={tagTitre} class=\\\"titre\\\">",
  		ctx
  	});

  	return block;
  }

  // (30:10) {#if titre}
  function create_if_block_2$1(ctx) {
  	let t;

  	const block = {
  		c: function create() {
  			t = text(/*titre*/ ctx[2]);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*titre*/ 4) set_data_dev(t, /*titre*/ ctx[2]);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2$1.name,
  		type: "if",
  		source: "(30:10) {#if titre}",
  		ctx
  	});

  	return block;
  }

  // (28:4) <svelte:element this={tagTitre} class="titre">
  function create_dynamic_element(ctx) {
  	let svelte_element;
  	let button;
  	let t0;
  	let slot;
  	let t1;
  	let span;
  	let button_aria_expanded_value;
  	let mounted;
  	let dispose;
  	let if_block = /*titre*/ ctx[2] && create_if_block_2$1(ctx);
  	let svelte_element_levels = [{ class: "titre" }];
  	let svelte_element_data = {};

  	for (let i = 0; i < svelte_element_levels.length; i += 1) {
  		svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  	}

  	const block = {
  		c: function create() {
  			svelte_element = element(/*tagTitre*/ ctx[4]);
  			button = element("button");
  			if (if_block) if_block.c();
  			t0 = space();
  			slot = element("slot");
  			t1 = space();
  			span = element("span");
  			attr_dev(slot, "name", "titre");
  			add_location(slot, file$4, 32, 10, 1153);
  			attr_dev(span, "class", "utd-icone-svg chevron-blanc");
  			add_location(span, file$4, 33, 8, 1196);
  			attr_dev(button, "type", "button");
  			attr_dev(button, "class", "");
  			attr_dev(button, "aria-controls", /*idContenu*/ ctx[5]);
  			attr_dev(button, "aria-expanded", button_aria_expanded_value = /*reduit*/ ctx[0] === 'false');
  			add_location(button, file$4, 28, 6, 950);
  			set_attributes(svelte_element, svelte_element_data);
  			add_location(svelte_element, file$4, 27, 4, 895);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, svelte_element, anchor);
  			append_dev(svelte_element, button);
  			if (if_block) if_block.m(button, null);
  			append_dev(button, t0);
  			append_dev(button, slot);
  			append_dev(button, t1);
  			append_dev(button, span);

  			if (!mounted) {
  				dispose = listen_dev(button, "click", /*toggleAffichageContenu*/ ctx[6], false, false, false);
  				mounted = true;
  			}
  		},
  		p: function update(ctx, dirty) {
  			if (/*titre*/ ctx[2]) {
  				if (if_block) {
  					if_block.p(ctx, dirty);
  				} else {
  					if_block = create_if_block_2$1(ctx);
  					if_block.c();
  					if_block.m(button, t0);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}

  			if (dirty & /*reduit*/ 1 && button_aria_expanded_value !== (button_aria_expanded_value = /*reduit*/ ctx[0] === 'false')) {
  				attr_dev(button, "aria-expanded", button_aria_expanded_value);
  			}

  			set_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [{ class: "titre" }]));
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(svelte_element);
  			if (if_block) if_block.d();
  			mounted = false;
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_dynamic_element.name,
  		type: "child_dynamic_element",
  		source: "(28:4) <svelte:element this={tagTitre} class=\\\"titre\\\">",
  		ctx
  	});

  	return block;
  }

  // (49:4) {#if extensible === 'false' || reduit === 'false'}
  function create_if_block$4(ctx) {
  	let div;
  	let slot;
  	let div_transition;
  	let current;

  	const block = {
  		c: function create() {
  			div = element("div");
  			slot = element("slot");
  			add_location(slot, file$4, 50, 6, 1659);
  			add_location(div, file$4, 49, 4, 1610);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, slot);
  			current = true;
  		},
  		i: function intro(local) {
  			if (current) return;

  			add_render_callback(() => {
  				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 250 }, true);
  				div_transition.run(1);
  			});

  			current = true;
  		},
  		o: function outro(local) {
  			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 250 }, false);
  			div_transition.run(0);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (detaching && div_transition) div_transition.end();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$4.name,
  		type: "if",
  		source: "(49:4) {#if extensible === 'false' || reduit === 'false'}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$4(ctx) {
  	let div2;
  	let div0;
  	let t0;
  	let div1;
  	let div2_class_value;
  	let t1;
  	let link;
  	let current;

  	function select_block_type(ctx, dirty) {
  		if (/*extensible*/ ctx[1] === 'true') return create_if_block_1$1;
  		return create_else_block;
  	}

  	let current_block_type = select_block_type(ctx);
  	let if_block0 = current_block_type(ctx);
  	let if_block1 = (/*extensible*/ ctx[1] === 'false' || /*reduit*/ ctx[0] === 'false') && create_if_block$4(ctx);

  	const block = {
  		c: function create() {
  			div2 = element("div");
  			div0 = element("div");
  			if_block0.c();
  			t0 = space();
  			div1 = element("div");
  			if (if_block1) if_block1.c();
  			t1 = space();
  			link = element("link");
  			this.c = noop;
  			attr_dev(div0, "class", "entete");
  			add_location(div0, file$4, 25, 2, 836);
  			attr_dev(div1, "id", /*idContenu*/ ctx[5]);
  			attr_dev(div1, "class", "contenu");
  			add_location(div1, file$4, 47, 2, 1509);
  			attr_dev(div2, "class", div2_class_value = "utd-component utd-section " + (/*extensible*/ ctx[1] === 'true' ? 'extensible' : '') + " " + (/*reduit*/ ctx[0] === 'false' ? 'ouvert' : '') + " " + (/*bordure*/ ctx[3] === 'true' ? 'bordure' : ''));
  			add_location(div2, file$4, 24, 0, 673);
  			attr_dev(link, "rel", "stylesheet");
  			attr_dev(link, "href", Utils.cssFullPath);
  			add_location(link, file$4, 57, 0, 1713);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div2, anchor);
  			append_dev(div2, div0);
  			if_block0.m(div0, null);
  			append_dev(div2, t0);
  			append_dev(div2, div1);
  			if (if_block1) if_block1.m(div1, null);
  			insert_dev(target, t1, anchor);
  			insert_dev(target, link, anchor);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
  				if_block0.p(ctx, dirty);
  			} else {
  				if_block0.d(1);
  				if_block0 = current_block_type(ctx);

  				if (if_block0) {
  					if_block0.c();
  					if_block0.m(div0, null);
  				}
  			}

  			if (/*extensible*/ ctx[1] === 'false' || /*reduit*/ ctx[0] === 'false') {
  				if (if_block1) {
  					if (dirty & /*extensible, reduit*/ 3) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block$4(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div1, null);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (!current || dirty & /*extensible, reduit, bordure*/ 11 && div2_class_value !== (div2_class_value = "utd-component utd-section " + (/*extensible*/ ctx[1] === 'true' ? 'extensible' : '') + " " + (/*reduit*/ ctx[0] === 'false' ? 'ouvert' : '') + " " + (/*bordure*/ ctx[3] === 'true' ? 'bordure' : ''))) {
  				attr_dev(div2, "class", div2_class_value);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block1);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block1);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div2);
  			if_block0.d();
  			if (if_block1) if_block1.d();
  			if (detaching) detach_dev(t1);
  			if (detaching) detach_dev(link);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$4.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$4($$self, $$props, $$invalidate) {
  	let { $$slots: slots = {}, $$scope } = $$props;
  	validate_slots('utd-section', slots, []);
  	let { extensible = "true" } = $$props;
  	let { reduit = "true" } = $$props;
  	let { titre = "" } = $$props;
  	let { bordure = "true" } = $$props;
  	let { tagTitre = "h2" } = $$props;
  	const idEntete = Utils.genererId();
  	const idContenu = 'corps' + idEntete;

  	//TODO éventuellement déterminer automatiquement le niveau de header via un script? 
  	function toggleAffichageContenu() {
  		$$invalidate(0, reduit = reduit === 'true' ? 'false' : 'true');
  	}

  	const writable_props = ['extensible', 'reduit', 'titre', 'bordure', 'tagTitre'];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<utd-section> was created with unknown prop '${key}'`);
  	});

  	$$self.$$set = $$props => {
  		if ('extensible' in $$props) $$invalidate(1, extensible = $$props.extensible);
  		if ('reduit' in $$props) $$invalidate(0, reduit = $$props.reduit);
  		if ('titre' in $$props) $$invalidate(2, titre = $$props.titre);
  		if ('bordure' in $$props) $$invalidate(3, bordure = $$props.bordure);
  		if ('tagTitre' in $$props) $$invalidate(4, tagTitre = $$props.tagTitre);
  	};

  	$$self.$capture_state = () => ({
  		slide,
  		Utils,
  		extensible,
  		reduit,
  		titre,
  		bordure,
  		tagTitre,
  		idEntete,
  		idContenu,
  		toggleAffichageContenu
  	});

  	$$self.$inject_state = $$props => {
  		if ('extensible' in $$props) $$invalidate(1, extensible = $$props.extensible);
  		if ('reduit' in $$props) $$invalidate(0, reduit = $$props.reduit);
  		if ('titre' in $$props) $$invalidate(2, titre = $$props.titre);
  		if ('bordure' in $$props) $$invalidate(3, bordure = $$props.bordure);
  		if ('tagTitre' in $$props) $$invalidate(4, tagTitre = $$props.tagTitre);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [
  		reduit,
  		extensible,
  		titre,
  		bordure,
  		tagTitre,
  		idContenu,
  		toggleAffichageContenu
  	];
  }

  class Section extends SvelteElement {
  	constructor(options) {
  		super();

  		init(
  			this,
  			{
  				target: this.shadowRoot,
  				props: attribute_to_object(this.attributes),
  				customElement: true
  			},
  			instance$4,
  			create_fragment$4,
  			safe_not_equal,
  			{
  				extensible: 1,
  				reduit: 0,
  				titre: 2,
  				bordure: 3,
  				tagTitre: 4
  			},
  			null
  		);

  		if (options) {
  			if (options.target) {
  				insert_dev(options.target, this, options.anchor);
  			}

  			if (options.props) {
  				this.$set(options.props);
  				flush();
  			}
  		}
  	}

  	static get observedAttributes() {
  		return ["extensible", "reduit", "titre", "bordure", "tagTitre"];
  	}

  	get extensible() {
  		return this.$$.ctx[1];
  	}

  	set extensible(extensible) {
  		this.$$set({ extensible });
  		flush();
  	}

  	get reduit() {
  		return this.$$.ctx[0];
  	}

  	set reduit(reduit) {
  		this.$$set({ reduit });
  		flush();
  	}

  	get titre() {
  		return this.$$.ctx[2];
  	}

  	set titre(titre) {
  		this.$$set({ titre });
  		flush();
  	}

  	get bordure() {
  		return this.$$.ctx[3];
  	}

  	set bordure(bordure) {
  		this.$$set({ bordure });
  		flush();
  	}

  	get tagTitre() {
  		return this.$$.ctx[4];
  	}

  	set tagTitre(tagTitre) {
  		this.$$set({ tagTitre });
  		flush();
  	}
  }

  customElements.define("utd-section", Section);

  /* src\components\menuAncres.svelte generated by Svelte v3.50.1 */
  const file$3 = "src\\components\\menuAncres.svelte";

  function get_each_context(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[4] = list[i];
  	return child_ctx;
  }

  // (34:0) {#if ancres && ancres.length}
  function create_if_block$3(ctx) {
  	let div;
  	let h2;
  	let t0;
  	let t1;
  	let nav;
  	let ul;
  	let each_value = /*ancres*/ ctx[1];
  	validate_each_argument(each_value);
  	let each_blocks = [];

  	for (let i = 0; i < each_value.length; i += 1) {
  		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  	}

  	const block = {
  		c: function create() {
  			div = element("div");
  			h2 = element("h2");
  			t0 = text(/*titre*/ ctx[0]);
  			t1 = space();
  			nav = element("nav");
  			ul = element("ul");

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			attr_dev(h2, "id", "titreTableMatieres");
  			add_location(h2, file$3, 35, 4, 790);
  			add_location(ul, file$3, 37, 6, 887);
  			attr_dev(nav, "aria-describedby", "titreTableMatieres");
  			add_location(nav, file$3, 36, 4, 836);
  			attr_dev(div, "class", "utd-component utd-menu-ancres");
  			add_location(div, file$3, 34, 2, 741);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, h2);
  			append_dev(h2, t0);
  			append_dev(div, t1);
  			append_dev(div, nav);
  			append_dev(nav, ul);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(ul, null);
  			}
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*titre*/ 1) set_data_dev(t0, /*titre*/ ctx[0]);

  			if (dirty & /*ancres*/ 2) {
  				each_value = /*ancres*/ ctx[1];
  				validate_each_argument(each_value);
  				let i;

  				for (i = 0; i < each_value.length; i += 1) {
  					const child_ctx = get_each_context(ctx, each_value, i);

  					if (each_blocks[i]) {
  						each_blocks[i].p(child_ctx, dirty);
  					} else {
  						each_blocks[i] = create_each_block(child_ctx);
  						each_blocks[i].c();
  						each_blocks[i].m(ul, null);
  					}
  				}

  				for (; i < each_blocks.length; i += 1) {
  					each_blocks[i].d(1);
  				}

  				each_blocks.length = each_value.length;
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			destroy_each(each_blocks, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$3.name,
  		type: "if",
  		source: "(34:0) {#if ancres && ancres.length}",
  		ctx
  	});

  	return block;
  }

  // (39:8) {#each ancres as ancre}
  function create_each_block(ctx) {
  	let li;
  	let a;
  	let t0_value = /*ancre*/ ctx[4].innerText + "";
  	let t0;
  	let a_href_value;
  	let t1;

  	const block = {
  		c: function create() {
  			li = element("li");
  			a = element("a");
  			t0 = text(t0_value);
  			t1 = space();
  			attr_dev(a, "href", a_href_value = "#" + /*ancre*/ ctx[4].id);
  			add_location(a, file$3, 40, 12, 954);
  			add_location(li, file$3, 39, 10, 936);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, li, anchor);
  			append_dev(li, a);
  			append_dev(a, t0);
  			append_dev(li, t1);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*ancres*/ 2 && t0_value !== (t0_value = /*ancre*/ ctx[4].innerText + "")) set_data_dev(t0, t0_value);

  			if (dirty & /*ancres*/ 2 && a_href_value !== (a_href_value = "#" + /*ancre*/ ctx[4].id)) {
  				attr_dev(a, "href", a_href_value);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(li);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block.name,
  		type: "each",
  		source: "(39:8) {#each ancres as ancre}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$3(ctx) {
  	let t;
  	let link;
  	let if_block = /*ancres*/ ctx[1] && /*ancres*/ ctx[1].length && create_if_block$3(ctx);

  	const block = {
  		c: function create() {
  			if (if_block) if_block.c();
  			t = space();
  			link = element("link");
  			this.c = noop;
  			attr_dev(link, "rel", "stylesheet");
  			attr_dev(link, "href", Utils.cssFullPath);
  			add_location(link, file$3, 48, 0, 1101);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			if (if_block) if_block.m(target, anchor);
  			insert_dev(target, t, anchor);
  			insert_dev(target, link, anchor);
  		},
  		p: function update(ctx, [dirty]) {
  			if (/*ancres*/ ctx[1] && /*ancres*/ ctx[1].length) {
  				if (if_block) {
  					if_block.p(ctx, dirty);
  				} else {
  					if_block = create_if_block$3(ctx);
  					if_block.c();
  					if_block.m(t.parentNode, t);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (if_block) if_block.d(detaching);
  			if (detaching) detach_dev(t);
  			if (detaching) detach_dev(link);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$3.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$3($$self, $$props, $$invalidate) {
  	let { $$slots: slots = {}, $$scope } = $$props;
  	validate_slots('utd-menu-ancres', slots, []);

  	let { titre = Utils.obtenirLanguePage() === 'fr'
  	? "Dans cette page :"
  	: "On this page:" } = $$props;

  	let { selecteur = '.ancre' } = $$props;
  	let ancres;

  	onMount(() => {
  		$$invalidate(1, ancres = obtenirAncres());
  	});

  	function obtenirAncres() {
  		const ancres = document.querySelectorAll(selecteur);

  		//Ajouter un id aux ancres qui n'en n'auraient pas
  		ancres.forEach(ancre => {
  			if (!ancre.id) {
  				ancre.id = Utils.genererId();
  			}
  		});

  		return ancres;
  	}

  	const writable_props = ['titre', 'selecteur'];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<utd-menu-ancres> was created with unknown prop '${key}'`);
  	});

  	$$self.$$set = $$props => {
  		if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
  		if ('selecteur' in $$props) $$invalidate(2, selecteur = $$props.selecteur);
  	};

  	$$self.$capture_state = () => ({
  		onMount,
  		Utils,
  		titre,
  		selecteur,
  		ancres,
  		obtenirAncres
  	});

  	$$self.$inject_state = $$props => {
  		if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
  		if ('selecteur' in $$props) $$invalidate(2, selecteur = $$props.selecteur);
  		if ('ancres' in $$props) $$invalidate(1, ancres = $$props.ancres);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [titre, ancres, selecteur];
  }

  class MenuAncres extends SvelteElement {
  	constructor(options) {
  		super();

  		init(
  			this,
  			{
  				target: this.shadowRoot,
  				props: attribute_to_object(this.attributes),
  				customElement: true
  			},
  			instance$3,
  			create_fragment$3,
  			safe_not_equal,
  			{ titre: 0, selecteur: 2 },
  			null
  		);

  		if (options) {
  			if (options.target) {
  				insert_dev(options.target, this, options.anchor);
  			}

  			if (options.props) {
  				this.$set(options.props);
  				flush();
  			}
  		}
  	}

  	static get observedAttributes() {
  		return ["titre", "selecteur"];
  	}

  	get titre() {
  		return this.$$.ctx[0];
  	}

  	set titre(titre) {
  		this.$$set({ titre });
  		flush();
  	}

  	get selecteur() {
  		return this.$$.ctx[2];
  	}

  	set selecteur(selecteur) {
  		this.$$set({ selecteur });
  		flush();
  	}
  }

  customElements.define("utd-menu-ancres", MenuAncres);

  /* src\components\pivEntete.svelte generated by Svelte v3.50.1 */
  const file$2 = "src\\components\\pivEntete.svelte";

  // (38:0) {#if passerContenu === 'true'}
  function create_if_block_9(ctx) {
  	let div1;
  	let div0;
  	let a;
  	let t;
  	let mounted;
  	let dispose;

  	const block = {
  		c: function create() {
  			div1 = element("div");
  			div0 = element("div");
  			a = element("a");
  			t = text(/*textePasserContenu*/ ctx[12]);
  			attr_dev(a, "href", /*urlPasserContenu*/ ctx[11]);
  			attr_dev(a, "class", "utd-passer-contenu");
  			add_location(a, file$2, 40, 8, 1454);
  			attr_dev(div0, "class", "utd-passer-contenu");
  			add_location(div0, file$2, 39, 4, 1412);
  			attr_dev(div1, "class", "utd-conteneur-passer-contenu");
  			add_location(div1, file$2, 38, 2, 1364);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div1, anchor);
  			append_dev(div1, div0);
  			append_dev(div0, a);
  			append_dev(a, t);

  			if (!mounted) {
  				dispose = listen_dev(a, "click", /*clickLien*/ ctx[14], false, false, false);
  				mounted = true;
  			}
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*textePasserContenu*/ 4096) set_data_dev(t, /*textePasserContenu*/ ctx[12]);

  			if (dirty & /*urlPasserContenu*/ 2048) {
  				attr_dev(a, "href", /*urlPasserContenu*/ ctx[11]);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div1);
  			mounted = false;
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_9.name,
  		type: "if",
  		source: "(38:0) {#if passerContenu === 'true'}",
  		ctx
  	});

  	return block;
  }

  // (57:10) {#if titreSite2}
  function create_if_block_8(ctx) {
  	let span;
  	let t;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t = text(/*titreSite2*/ ctx[4]);
  			attr_dev(span, "class", "description");
  			add_location(span, file$2, 57, 12, 2023);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*titreSite2*/ 16) set_data_dev(t, /*titreSite2*/ ctx[4]);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_8.name,
  		type: "if",
  		source: "(57:10) {#if titreSite2}",
  		ctx
  	});

  	return block;
  }

  // (64:8) {#if Utils.slotExiste(slots, 'boutonRecherche')}
  function create_if_block_7(ctx) {
  	let div;
  	let slot;

  	const block = {
  		c: function create() {
  			div = element("div");
  			slot = element("slot");
  			attr_dev(slot, "name", "boutonRecherche");
  			add_location(slot, file$2, 65, 12, 2276);
  			attr_dev(div, "class", "bouton-recherche");
  			add_location(div, file$2, 64, 10, 2232);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, slot);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_7.name,
  		type: "if",
  		source: "(64:8) {#if Utils.slotExiste(slots, 'boutonRecherche')}",
  		ctx
  	});

  	return block;
  }

  // (74:10) {#if urlNousJoindre || urlLangueAlternative}
  function create_if_block_4(ctx) {
  	let ul;
  	let t;
  	let if_block0 = /*urlLangueAlternative*/ ctx[7] && create_if_block_6(ctx);
  	let if_block1 = /*urlNousJoindre*/ ctx[9] && create_if_block_5(ctx);

  	const block = {
  		c: function create() {
  			ul = element("ul");
  			if (if_block0) if_block0.c();
  			t = space();
  			if (if_block1) if_block1.c();
  			add_location(ul, file$2, 74, 12, 2524);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, ul, anchor);
  			if (if_block0) if_block0.m(ul, null);
  			append_dev(ul, t);
  			if (if_block1) if_block1.m(ul, null);
  		},
  		p: function update(ctx, dirty) {
  			if (/*urlLangueAlternative*/ ctx[7]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);
  				} else {
  					if_block0 = create_if_block_6(ctx);
  					if_block0.c();
  					if_block0.m(ul, t);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (/*urlNousJoindre*/ ctx[9]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);
  				} else {
  					if_block1 = create_if_block_5(ctx);
  					if_block1.c();
  					if_block1.m(ul, null);
  				}
  			} else if (if_block1) {
  				if_block1.d(1);
  				if_block1 = null;
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(ul);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_4.name,
  		type: "if",
  		source: "(74:10) {#if urlNousJoindre || urlLangueAlternative}",
  		ctx
  	});

  	return block;
  }

  // (71:8) {#if Utils.slotExiste(slots, 'liens')}
  function create_if_block_3(ctx) {
  	let slot;

  	const block = {
  		c: function create() {
  			slot = element("slot");
  			attr_dev(slot, "name", "liens");
  			add_location(slot, file$2, 71, 10, 2412);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, slot, anchor);
  		},
  		p: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(slot);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_3.name,
  		type: "if",
  		source: "(71:8) {#if Utils.slotExiste(slots, 'liens')}",
  		ctx
  	});

  	return block;
  }

  // (76:14) {#if urlLangueAlternative}
  function create_if_block_6(ctx) {
  	let li;
  	let a;
  	let t;

  	const block = {
  		c: function create() {
  			li = element("li");
  			a = element("a");
  			t = text(/*texteLangueAlternative*/ ctx[6]);
  			attr_dev(a, "href", /*urlLangueAlternative*/ ctx[7]);
  			add_location(a, file$2, 76, 20, 2592);
  			add_location(li, file$2, 76, 16, 2588);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, li, anchor);
  			append_dev(li, a);
  			append_dev(a, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*texteLangueAlternative*/ 64) set_data_dev(t, /*texteLangueAlternative*/ ctx[6]);

  			if (dirty & /*urlLangueAlternative*/ 128) {
  				attr_dev(a, "href", /*urlLangueAlternative*/ ctx[7]);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(li);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_6.name,
  		type: "if",
  		source: "(76:14) {#if urlLangueAlternative}",
  		ctx
  	});

  	return block;
  }

  // (79:14) {#if urlNousJoindre}
  function create_if_block_5(ctx) {
  	let li;
  	let a;
  	let t;

  	const block = {
  		c: function create() {
  			li = element("li");
  			a = element("a");
  			t = text(/*texteNousJoindre*/ ctx[8]);
  			attr_dev(a, "href", /*urlNousJoindre*/ ctx[9]);
  			add_location(a, file$2, 79, 20, 2753);
  			add_location(li, file$2, 79, 16, 2749);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, li, anchor);
  			append_dev(li, a);
  			append_dev(a, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*texteNousJoindre*/ 256) set_data_dev(t, /*texteNousJoindre*/ ctx[8]);

  			if (dirty & /*urlNousJoindre*/ 512) {
  				attr_dev(a, "href", /*urlNousJoindre*/ ctx[9]);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(li);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_5.name,
  		type: "if",
  		source: "(79:14) {#if urlNousJoindre}",
  		ctx
  	});

  	return block;
  }

  // (90:8) {#if titreSite2}
  function create_if_block_2(ctx) {
  	let span;
  	let t;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t = text(/*titreSite2*/ ctx[4]);
  			attr_dev(span, "class", "description");
  			add_location(span, file$2, 90, 10, 3062);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*titreSite2*/ 16) set_data_dev(t, /*titreSite2*/ ctx[4]);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2.name,
  		type: "if",
  		source: "(90:8) {#if titreSite2}",
  		ctx
  	});

  	return block;
  }

  // (95:6) {#if Utils.slotExiste(slots, 'boutonRechercheMobile')}
  function create_if_block_1(ctx) {
  	let div;
  	let slot;

  	const block = {
  		c: function create() {
  			div = element("div");
  			slot = element("slot");
  			attr_dev(slot, "name", "boutonRechercheMobile");
  			add_location(slot, file$2, 96, 10, 3254);
  			attr_dev(div, "class", "bouton-recherche");
  			add_location(div, file$2, 95, 8, 3212);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, slot);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1.name,
  		type: "if",
  		source: "(95:6) {#if Utils.slotExiste(slots, 'boutonRechercheMobile')}",
  		ctx
  	});

  	return block;
  }

  // (101:4) {#if Utils.slotExiste(slots, 'zoneRecherche')}
  function create_if_block$2(ctx) {
  	let div;
  	let slot;

  	const block = {
  		c: function create() {
  			div = element("div");
  			slot = element("slot");
  			attr_dev(slot, "name", "zoneRecherche");
  			add_location(slot, file$2, 102, 8, 3448);
  			attr_dev(div, "class", "zone-recherche");
  			add_location(div, file$2, 101, 6, 3410);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, slot);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$2.name,
  		type: "if",
  		source: "(101:4) {#if Utils.slotExiste(slots, 'zoneRecherche')}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$2(ctx) {
  	let t0;
  	let div7;
  	let div6;
  	let div3;
  	let div0;
  	let a0;
  	let img;
  	let img_src_value;
  	let t1;
  	let div1;
  	let a1;
  	let span0;
  	let t2;
  	let t3;
  	let t4;
  	let div2;
  	let show_if_3 = Utils.slotExiste(/*slots*/ ctx[13], 'boutonRecherche');
  	let t5;
  	let show_if_2;
  	let t6;
  	let div5;
  	let div4;
  	let span1;
  	let t7;
  	let t8;
  	let t9;
  	let show_if_1 = Utils.slotExiste(/*slots*/ ctx[13], 'boutonRechercheMobile');
  	let t10;
  	let show_if = Utils.slotExiste(/*slots*/ ctx[13], 'zoneRecherche');
  	let t11;
  	let link;
  	let if_block0 = /*passerContenu*/ ctx[10] === 'true' && create_if_block_9(ctx);
  	let if_block1 = /*titreSite2*/ ctx[4] && create_if_block_8(ctx);
  	let if_block2 = show_if_3 && create_if_block_7(ctx);

  	function select_block_type(ctx, dirty) {
  		if (dirty & /*slots*/ 8192) show_if_2 = null;
  		if (show_if_2 == null) show_if_2 = !!Utils.slotExiste(/*slots*/ ctx[13], 'liens');
  		if (show_if_2) return create_if_block_3;
  		if (/*urlNousJoindre*/ ctx[9] || /*urlLangueAlternative*/ ctx[7]) return create_if_block_4;
  	}

  	let current_block_type = select_block_type(ctx, -1);
  	let if_block3 = current_block_type && current_block_type(ctx);
  	let if_block4 = /*titreSite2*/ ctx[4] && create_if_block_2(ctx);
  	let if_block5 = show_if_1 && create_if_block_1(ctx);
  	let if_block6 = show_if && create_if_block$2(ctx);

  	const block = {
  		c: function create() {
  			if (if_block0) if_block0.c();
  			t0 = space();
  			div7 = element("div");
  			div6 = element("div");
  			div3 = element("div");
  			div0 = element("div");
  			a0 = element("a");
  			img = element("img");
  			t1 = space();
  			div1 = element("div");
  			a1 = element("a");
  			span0 = element("span");
  			t2 = text(/*titreSite1*/ ctx[3]);
  			t3 = space();
  			if (if_block1) if_block1.c();
  			t4 = space();
  			div2 = element("div");
  			if (if_block2) if_block2.c();
  			t5 = space();
  			if (if_block3) if_block3.c();
  			t6 = space();
  			div5 = element("div");
  			div4 = element("div");
  			span1 = element("span");
  			t7 = text(/*titreSite1*/ ctx[3]);
  			t8 = space();
  			if (if_block4) if_block4.c();
  			t9 = space();
  			if (if_block5) if_block5.c();
  			t10 = space();
  			if (if_block6) if_block6.c();
  			t11 = space();
  			link = element("link");
  			this.c = noop;
  			attr_dev(img, "alt", /*altLogo*/ ctx[2]);
  			if (!src_url_equal(img.src, img_src_value = /*srcLogo*/ ctx[1])) attr_dev(img, "src", img_src_value);
  			add_location(img, file$2, 50, 10, 1789);
  			attr_dev(a0, "href", /*urlLogo*/ ctx[0]);
  			add_location(a0, file$2, 49, 8, 1757);
  			attr_dev(div0, "class", "section-gauche signature-gouvernement");
  			add_location(div0, file$2, 48, 6, 1696);
  			add_location(span0, file$2, 55, 10, 1956);
  			attr_dev(a1, "href", /*urlTitreSite*/ ctx[5]);
  			attr_dev(a1, "class", "titre-site");
  			add_location(a1, file$2, 54, 8, 1900);
  			attr_dev(div1, "class", "section-centre");
  			add_location(div1, file$2, 53, 6, 1862);
  			attr_dev(div2, "class", "section-droite");
  			add_location(div2, file$2, 62, 6, 2134);
  			attr_dev(div3, "class", "conteneur-sections");
  			add_location(div3, file$2, 47, 4, 1656);
  			add_location(span1, file$2, 88, 8, 2999);
  			attr_dev(div4, "class", "titre-site");
  			add_location(div4, file$2, 87, 6, 2965);
  			attr_dev(div5, "class", "zone-titre-recherche");
  			add_location(div5, file$2, 86, 4, 2923);
  			attr_dev(div6, "class", "utd-container");
  			add_location(div6, file$2, 46, 2, 1623);
  			attr_dev(div7, "class", "utd-piv-entete");
  			add_location(div7, file$2, 45, 0, 1591);
  			attr_dev(link, "rel", "stylesheet");
  			attr_dev(link, "href", Utils.cssFullPath);
  			add_location(link, file$2, 111, 0, 3538);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			if (if_block0) if_block0.m(target, anchor);
  			insert_dev(target, t0, anchor);
  			insert_dev(target, div7, anchor);
  			append_dev(div7, div6);
  			append_dev(div6, div3);
  			append_dev(div3, div0);
  			append_dev(div0, a0);
  			append_dev(a0, img);
  			append_dev(div3, t1);
  			append_dev(div3, div1);
  			append_dev(div1, a1);
  			append_dev(a1, span0);
  			append_dev(span0, t2);
  			append_dev(a1, t3);
  			if (if_block1) if_block1.m(a1, null);
  			append_dev(div3, t4);
  			append_dev(div3, div2);
  			if (if_block2) if_block2.m(div2, null);
  			append_dev(div2, t5);
  			if (if_block3) if_block3.m(div2, null);
  			append_dev(div6, t6);
  			append_dev(div6, div5);
  			append_dev(div5, div4);
  			append_dev(div4, span1);
  			append_dev(span1, t7);
  			append_dev(div4, t8);
  			if (if_block4) if_block4.m(div4, null);
  			append_dev(div5, t9);
  			if (if_block5) if_block5.m(div5, null);
  			append_dev(div6, t10);
  			if (if_block6) if_block6.m(div6, null);
  			insert_dev(target, t11, anchor);
  			insert_dev(target, link, anchor);
  		},
  		p: function update(ctx, [dirty]) {
  			if (/*passerContenu*/ ctx[10] === 'true') {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);
  				} else {
  					if_block0 = create_if_block_9(ctx);
  					if_block0.c();
  					if_block0.m(t0.parentNode, t0);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (dirty & /*altLogo*/ 4) {
  				attr_dev(img, "alt", /*altLogo*/ ctx[2]);
  			}

  			if (dirty & /*srcLogo*/ 2 && !src_url_equal(img.src, img_src_value = /*srcLogo*/ ctx[1])) {
  				attr_dev(img, "src", img_src_value);
  			}

  			if (dirty & /*urlLogo*/ 1) {
  				attr_dev(a0, "href", /*urlLogo*/ ctx[0]);
  			}

  			if (dirty & /*titreSite1*/ 8) set_data_dev(t2, /*titreSite1*/ ctx[3]);

  			if (/*titreSite2*/ ctx[4]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);
  				} else {
  					if_block1 = create_if_block_8(ctx);
  					if_block1.c();
  					if_block1.m(a1, null);
  				}
  			} else if (if_block1) {
  				if_block1.d(1);
  				if_block1 = null;
  			}

  			if (dirty & /*urlTitreSite*/ 32) {
  				attr_dev(a1, "href", /*urlTitreSite*/ ctx[5]);
  			}

  			if (dirty & /*slots*/ 8192) show_if_3 = Utils.slotExiste(/*slots*/ ctx[13], 'boutonRecherche');

  			if (show_if_3) {
  				if (if_block2) ; else {
  					if_block2 = create_if_block_7(ctx);
  					if_block2.c();
  					if_block2.m(div2, t5);
  				}
  			} else if (if_block2) {
  				if_block2.d(1);
  				if_block2 = null;
  			}

  			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block3) {
  				if_block3.p(ctx, dirty);
  			} else {
  				if (if_block3) if_block3.d(1);
  				if_block3 = current_block_type && current_block_type(ctx);

  				if (if_block3) {
  					if_block3.c();
  					if_block3.m(div2, null);
  				}
  			}

  			if (dirty & /*titreSite1*/ 8) set_data_dev(t7, /*titreSite1*/ ctx[3]);

  			if (/*titreSite2*/ ctx[4]) {
  				if (if_block4) {
  					if_block4.p(ctx, dirty);
  				} else {
  					if_block4 = create_if_block_2(ctx);
  					if_block4.c();
  					if_block4.m(div4, null);
  				}
  			} else if (if_block4) {
  				if_block4.d(1);
  				if_block4 = null;
  			}

  			if (dirty & /*slots*/ 8192) show_if_1 = Utils.slotExiste(/*slots*/ ctx[13], 'boutonRechercheMobile');

  			if (show_if_1) {
  				if (if_block5) ; else {
  					if_block5 = create_if_block_1(ctx);
  					if_block5.c();
  					if_block5.m(div5, null);
  				}
  			} else if (if_block5) {
  				if_block5.d(1);
  				if_block5 = null;
  			}

  			if (dirty & /*slots*/ 8192) show_if = Utils.slotExiste(/*slots*/ ctx[13], 'zoneRecherche');

  			if (show_if) {
  				if (if_block6) ; else {
  					if_block6 = create_if_block$2(ctx);
  					if_block6.c();
  					if_block6.m(div6, null);
  				}
  			} else if (if_block6) {
  				if_block6.d(1);
  				if_block6 = null;
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (if_block0) if_block0.d(detaching);
  			if (detaching) detach_dev(t0);
  			if (detaching) detach_dev(div7);
  			if (if_block1) if_block1.d();
  			if (if_block2) if_block2.d();

  			if (if_block3) {
  				if_block3.d();
  			}

  			if (if_block4) if_block4.d();
  			if (if_block5) if_block5.d();
  			if (if_block6) if_block6.d();
  			if (detaching) detach_dev(t11);
  			if (detaching) detach_dev(link);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$2.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$2($$self, $$props, $$invalidate) {
  	let { $$slots: slots$1 = {}, $$scope } = $$props;
  	validate_slots('utd-piv-entete', slots$1, []);
  	let { urlLogo = '/' } = $$props;
  	let { srcLogo = `${Utils.imagesRelativePath}utd-sprite.svg?v=1.7.6#QUEBEC_blanc` } = $$props;

  	let { altLogo = Utils.obtenirLanguePage() === 'fr'
  	? 'Signature du gouvernement du Québec.'
  	: 'Québec government signature.' } = $$props;

  	let { titreSite1 = '' } = $$props;
  	let { titreSite2 = '' } = $$props;
  	let { urlTitreSite = '/' } = $$props;

  	let { texteLangueAlternative = Utils.obtenirLanguePage() === 'fr'
  	? 'English'
  	: 'Français' } = $$props;

  	let { urlLangueAlternative = '' } = $$props;

  	let { texteNousJoindre = Utils.obtenirLanguePage() === 'fr'
  	? 'Nous joindre'
  	: 'Contact us' } = $$props;

  	let { urlNousJoindre = '' } = $$props;
  	let { passerContenu = 'true' } = $$props;
  	let { urlPasserContenu = '#main' } = $$props;

  	let { textePasserContenu = Utils.obtenirLanguePage() === 'fr'
  	? 'Passer au contenu'
  	: 'Skip to content' } = $$props;

  	const thisComponent = get_current_component();
  	let slots = [];

  	onMount(() => {
  		$$invalidate(13, slots = Array.from(thisComponent.querySelectorAll('[slot]')));
  	});

  	function clickLien() {
  		Utils.dispatchWcEvent(thisComponent, "clickLien");
  	}

  	const writable_props = [
  		'urlLogo',
  		'srcLogo',
  		'altLogo',
  		'titreSite1',
  		'titreSite2',
  		'urlTitreSite',
  		'texteLangueAlternative',
  		'urlLangueAlternative',
  		'texteNousJoindre',
  		'urlNousJoindre',
  		'passerContenu',
  		'urlPasserContenu',
  		'textePasserContenu'
  	];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<utd-piv-entete> was created with unknown prop '${key}'`);
  	});

  	$$self.$$set = $$props => {
  		if ('urlLogo' in $$props) $$invalidate(0, urlLogo = $$props.urlLogo);
  		if ('srcLogo' in $$props) $$invalidate(1, srcLogo = $$props.srcLogo);
  		if ('altLogo' in $$props) $$invalidate(2, altLogo = $$props.altLogo);
  		if ('titreSite1' in $$props) $$invalidate(3, titreSite1 = $$props.titreSite1);
  		if ('titreSite2' in $$props) $$invalidate(4, titreSite2 = $$props.titreSite2);
  		if ('urlTitreSite' in $$props) $$invalidate(5, urlTitreSite = $$props.urlTitreSite);
  		if ('texteLangueAlternative' in $$props) $$invalidate(6, texteLangueAlternative = $$props.texteLangueAlternative);
  		if ('urlLangueAlternative' in $$props) $$invalidate(7, urlLangueAlternative = $$props.urlLangueAlternative);
  		if ('texteNousJoindre' in $$props) $$invalidate(8, texteNousJoindre = $$props.texteNousJoindre);
  		if ('urlNousJoindre' in $$props) $$invalidate(9, urlNousJoindre = $$props.urlNousJoindre);
  		if ('passerContenu' in $$props) $$invalidate(10, passerContenu = $$props.passerContenu);
  		if ('urlPasserContenu' in $$props) $$invalidate(11, urlPasserContenu = $$props.urlPasserContenu);
  		if ('textePasserContenu' in $$props) $$invalidate(12, textePasserContenu = $$props.textePasserContenu);
  	};

  	$$self.$capture_state = () => ({
  		onMount,
  		Utils,
  		get_current_component,
  		urlLogo,
  		srcLogo,
  		altLogo,
  		titreSite1,
  		titreSite2,
  		urlTitreSite,
  		texteLangueAlternative,
  		urlLangueAlternative,
  		texteNousJoindre,
  		urlNousJoindre,
  		passerContenu,
  		urlPasserContenu,
  		textePasserContenu,
  		thisComponent,
  		slots,
  		clickLien
  	});

  	$$self.$inject_state = $$props => {
  		if ('urlLogo' in $$props) $$invalidate(0, urlLogo = $$props.urlLogo);
  		if ('srcLogo' in $$props) $$invalidate(1, srcLogo = $$props.srcLogo);
  		if ('altLogo' in $$props) $$invalidate(2, altLogo = $$props.altLogo);
  		if ('titreSite1' in $$props) $$invalidate(3, titreSite1 = $$props.titreSite1);
  		if ('titreSite2' in $$props) $$invalidate(4, titreSite2 = $$props.titreSite2);
  		if ('urlTitreSite' in $$props) $$invalidate(5, urlTitreSite = $$props.urlTitreSite);
  		if ('texteLangueAlternative' in $$props) $$invalidate(6, texteLangueAlternative = $$props.texteLangueAlternative);
  		if ('urlLangueAlternative' in $$props) $$invalidate(7, urlLangueAlternative = $$props.urlLangueAlternative);
  		if ('texteNousJoindre' in $$props) $$invalidate(8, texteNousJoindre = $$props.texteNousJoindre);
  		if ('urlNousJoindre' in $$props) $$invalidate(9, urlNousJoindre = $$props.urlNousJoindre);
  		if ('passerContenu' in $$props) $$invalidate(10, passerContenu = $$props.passerContenu);
  		if ('urlPasserContenu' in $$props) $$invalidate(11, urlPasserContenu = $$props.urlPasserContenu);
  		if ('textePasserContenu' in $$props) $$invalidate(12, textePasserContenu = $$props.textePasserContenu);
  		if ('slots' in $$props) $$invalidate(13, slots = $$props.slots);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [
  		urlLogo,
  		srcLogo,
  		altLogo,
  		titreSite1,
  		titreSite2,
  		urlTitreSite,
  		texteLangueAlternative,
  		urlLangueAlternative,
  		texteNousJoindre,
  		urlNousJoindre,
  		passerContenu,
  		urlPasserContenu,
  		textePasserContenu,
  		slots,
  		clickLien
  	];
  }

  class PivEntete extends SvelteElement {
  	constructor(options) {
  		super();

  		init(
  			this,
  			{
  				target: this.shadowRoot,
  				props: attribute_to_object(this.attributes),
  				customElement: true
  			},
  			instance$2,
  			create_fragment$2,
  			safe_not_equal,
  			{
  				urlLogo: 0,
  				srcLogo: 1,
  				altLogo: 2,
  				titreSite1: 3,
  				titreSite2: 4,
  				urlTitreSite: 5,
  				texteLangueAlternative: 6,
  				urlLangueAlternative: 7,
  				texteNousJoindre: 8,
  				urlNousJoindre: 9,
  				passerContenu: 10,
  				urlPasserContenu: 11,
  				textePasserContenu: 12
  			},
  			null
  		);

  		if (options) {
  			if (options.target) {
  				insert_dev(options.target, this, options.anchor);
  			}

  			if (options.props) {
  				this.$set(options.props);
  				flush();
  			}
  		}
  	}

  	static get observedAttributes() {
  		return [
  			"urlLogo",
  			"srcLogo",
  			"altLogo",
  			"titreSite1",
  			"titreSite2",
  			"urlTitreSite",
  			"texteLangueAlternative",
  			"urlLangueAlternative",
  			"texteNousJoindre",
  			"urlNousJoindre",
  			"passerContenu",
  			"urlPasserContenu",
  			"textePasserContenu"
  		];
  	}

  	get urlLogo() {
  		return this.$$.ctx[0];
  	}

  	set urlLogo(urlLogo) {
  		this.$$set({ urlLogo });
  		flush();
  	}

  	get srcLogo() {
  		return this.$$.ctx[1];
  	}

  	set srcLogo(srcLogo) {
  		this.$$set({ srcLogo });
  		flush();
  	}

  	get altLogo() {
  		return this.$$.ctx[2];
  	}

  	set altLogo(altLogo) {
  		this.$$set({ altLogo });
  		flush();
  	}

  	get titreSite1() {
  		return this.$$.ctx[3];
  	}

  	set titreSite1(titreSite1) {
  		this.$$set({ titreSite1 });
  		flush();
  	}

  	get titreSite2() {
  		return this.$$.ctx[4];
  	}

  	set titreSite2(titreSite2) {
  		this.$$set({ titreSite2 });
  		flush();
  	}

  	get urlTitreSite() {
  		return this.$$.ctx[5];
  	}

  	set urlTitreSite(urlTitreSite) {
  		this.$$set({ urlTitreSite });
  		flush();
  	}

  	get texteLangueAlternative() {
  		return this.$$.ctx[6];
  	}

  	set texteLangueAlternative(texteLangueAlternative) {
  		this.$$set({ texteLangueAlternative });
  		flush();
  	}

  	get urlLangueAlternative() {
  		return this.$$.ctx[7];
  	}

  	set urlLangueAlternative(urlLangueAlternative) {
  		this.$$set({ urlLangueAlternative });
  		flush();
  	}

  	get texteNousJoindre() {
  		return this.$$.ctx[8];
  	}

  	set texteNousJoindre(texteNousJoindre) {
  		this.$$set({ texteNousJoindre });
  		flush();
  	}

  	get urlNousJoindre() {
  		return this.$$.ctx[9];
  	}

  	set urlNousJoindre(urlNousJoindre) {
  		this.$$set({ urlNousJoindre });
  		flush();
  	}

  	get passerContenu() {
  		return this.$$.ctx[10];
  	}

  	set passerContenu(passerContenu) {
  		this.$$set({ passerContenu });
  		flush();
  	}

  	get urlPasserContenu() {
  		return this.$$.ctx[11];
  	}

  	set urlPasserContenu(urlPasserContenu) {
  		this.$$set({ urlPasserContenu });
  		flush();
  	}

  	get textePasserContenu() {
  		return this.$$.ctx[12];
  	}

  	set textePasserContenu(textePasserContenu) {
  		this.$$set({ textePasserContenu });
  		flush();
  	}
  }

  customElements.define("utd-piv-entete", PivEntete);

  /* src\components\pivPiedPage.svelte generated by Svelte v3.50.1 */
  const file$1 = "src\\components\\pivPiedPage.svelte";

  // (39:2) {#if Utils.slotExiste(slots, 'liens')}
  function create_if_block$1(ctx) {
  	let div;
  	let h2;
  	let t0;
  	let t1;
  	let nav;
  	let slot;

  	const block = {
  		c: function create() {
  			div = element("div");
  			h2 = element("h2");
  			t0 = text(/*texteTitreSrLiens*/ ctx[0]);
  			t1 = space();
  			nav = element("nav");
  			slot = element("slot");
  			attr_dev(h2, "class", "utd-sr-only");
  			attr_dev(h2, "id", "utdTitreLiensPivPiedPage");
  			add_location(h2, file$1, 40, 4, 1599);
  			attr_dev(slot, "name", "liens");
  			add_location(slot, file$1, 42, 6, 1739);
  			attr_dev(nav, "aria-labelledby", "utdTitreLiensPivPiedPage");
  			add_location(nav, file$1, 41, 4, 1683);
  			attr_dev(div, "class", "liens");
  			add_location(div, file$1, 39, 2, 1574);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, h2);
  			append_dev(h2, t0);
  			append_dev(div, t1);
  			append_dev(div, nav);
  			append_dev(nav, slot);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*texteTitreSrLiens*/ 1) set_data_dev(t0, /*texteTitreSrLiens*/ ctx[0]);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$1.name,
  		type: "if",
  		source: "(39:2) {#if Utils.slotExiste(slots, 'liens')}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$1(ctx) {
  	let div;
  	let show_if = Utils.slotExiste(/*slots*/ ctx[10], 'liens');
  	let t0;
  	let a0;
  	let img;
  	let img_alt_value;
  	let img_src_value;
  	let t1;
  	let span1;
  	let a1;
  	let t2;
  	let t3;
  	let t4;
  	let span0;
  	let t5;
  	let link;
  	let if_block = show_if && create_if_block$1(ctx);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (if_block) if_block.c();
  			t0 = space();
  			a0 = element("a");
  			img = element("img");
  			t1 = space();
  			span1 = element("span");
  			a1 = element("a");
  			t2 = text(/*texteCopyright*/ ctx[6]);
  			t3 = text(/*anneeCopyright*/ ctx[7]);
  			t4 = space();
  			span0 = element("span");
  			t5 = space();
  			link = element("link");
  			this.c = noop;
  			attr_dev(img, "class", "logo-mo");
  			attr_dev(img, "alt", img_alt_value = "" + (/*altLogo*/ ctx[2] + /*texteSrOuvertureNouvelOnglet*/ ctx[9]));
  			if (!src_url_equal(img.src, img_src_value = /*srcLogo*/ ctx[3])) attr_dev(img, "src", img_src_value);
  			attr_dev(img, "width", /*widthLogo*/ ctx[4]);
  			attr_dev(img, "height", /*heightLogo*/ ctx[5]);
  			add_location(img, file$1, 48, 6, 1864);
  			attr_dev(a0, "href", /*urlLogo*/ ctx[1]);
  			attr_dev(a0, "target", "_blank");
  			attr_dev(a0, "rel", "noopener");
  			add_location(a0, file$1, 47, 2, 1805);
  			attr_dev(span0, "class", "utd-sr-only");
  			add_location(span0, file$1, 54, 10, 2147);
  			attr_dev(a1, "href", /*urlCopyright*/ ctx[8]);
  			attr_dev(a1, "target", "_blank");
  			attr_dev(a1, "rel", "noopener");
  			add_location(a1, file$1, 52, 6, 2035);
  			attr_dev(span1, "class", "copyright");
  			add_location(span1, file$1, 51, 2, 2003);
  			attr_dev(div, "class", "utd-container utd-piv-pied-page");
  			add_location(div, file$1, 36, 0, 1479);
  			attr_dev(link, "rel", "stylesheet");
  			attr_dev(link, "href", Utils.cssFullPath);
  			add_location(link, file$1, 60, 0, 2253);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			if (if_block) if_block.m(div, null);
  			append_dev(div, t0);
  			append_dev(div, a0);
  			append_dev(a0, img);
  			append_dev(div, t1);
  			append_dev(div, span1);
  			append_dev(span1, a1);
  			append_dev(a1, t2);
  			append_dev(a1, t3);
  			append_dev(a1, t4);
  			append_dev(a1, span0);
  			span0.innerHTML = /*texteSrOuvertureNouvelOnglet*/ ctx[9];
  			insert_dev(target, t5, anchor);
  			insert_dev(target, link, anchor);
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*slots*/ 1024) show_if = Utils.slotExiste(/*slots*/ ctx[10], 'liens');

  			if (show_if) {
  				if (if_block) {
  					if_block.p(ctx, dirty);
  				} else {
  					if_block = create_if_block$1(ctx);
  					if_block.c();
  					if_block.m(div, t0);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}

  			if (dirty & /*altLogo, texteSrOuvertureNouvelOnglet*/ 516 && img_alt_value !== (img_alt_value = "" + (/*altLogo*/ ctx[2] + /*texteSrOuvertureNouvelOnglet*/ ctx[9]))) {
  				attr_dev(img, "alt", img_alt_value);
  			}

  			if (dirty & /*srcLogo*/ 8 && !src_url_equal(img.src, img_src_value = /*srcLogo*/ ctx[3])) {
  				attr_dev(img, "src", img_src_value);
  			}

  			if (dirty & /*widthLogo*/ 16) {
  				attr_dev(img, "width", /*widthLogo*/ ctx[4]);
  			}

  			if (dirty & /*heightLogo*/ 32) {
  				attr_dev(img, "height", /*heightLogo*/ ctx[5]);
  			}

  			if (dirty & /*urlLogo*/ 2) {
  				attr_dev(a0, "href", /*urlLogo*/ ctx[1]);
  			}

  			if (dirty & /*texteCopyright*/ 64) set_data_dev(t2, /*texteCopyright*/ ctx[6]);
  			if (dirty & /*anneeCopyright*/ 128) set_data_dev(t3, /*anneeCopyright*/ ctx[7]);
  			if (dirty & /*texteSrOuvertureNouvelOnglet*/ 512) span0.innerHTML = /*texteSrOuvertureNouvelOnglet*/ ctx[9];
  			if (dirty & /*urlCopyright*/ 256) {
  				attr_dev(a1, "href", /*urlCopyright*/ ctx[8]);
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (if_block) if_block.d();
  			if (detaching) detach_dev(t5);
  			if (detaching) detach_dev(link);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$1.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$1($$self, $$props, $$invalidate) {
  	let { $$slots: slots$1 = {}, $$scope } = $$props;
  	validate_slots('utd-piv-pied-page', slots$1, []);
  	const textesDefaut = Utils.obtenirTextesDefaut();
  	const languePage = Utils.obtenirLanguePage();

  	let { texteTitreSrLiens = languePage === 'fr'
  	? 'Liens vers informations complémentaires'
  	: 'Links to additional information' } = $$props;

  	let { urlLogo = languePage === 'fr'
  	? 'https://www.mtess.gouv.qc.ca/'
  	: 'https://www.mtess.gouv.qc.ca/index_en.asp' } = $$props;

  	let { altLogo = languePage === 'fr'
  	? `Ministère de l'Emploi et de la Solidarité sociale`
  	: `Ministère de l'Emploi et de la Solidarité sociale` } = $$props;

  	let { srcLogo = `${Utils.imagesRelativePath}logo_piv_bas_page.png` } = $$props;
  	let { widthLogo = '210' } = $$props;
  	let { heightLogo = '81' } = $$props;

  	let { texteCopyright = languePage === 'fr'
  	? '© Gouvernement du Québec, '
  	: '© Gouvernement du Québec, ' } = $$props;

  	let { anneeCopyright = '2022' } = $$props;

  	let { urlCopyright = languePage === 'fr'
  	? 'https://www.quebec.ca/droit-auteur'
  	: 'https://www.quebec.ca/en/copyright' } = $$props;

  	let { texteSrOuvertureNouvelOnglet = textesDefaut.texteSrOuvertureNouvelOnglet } = $$props;
  	const thisComponent = get_current_component();
  	let slots = [];

  	onMount(() => {
  		$$invalidate(10, slots = Array.from(thisComponent.querySelectorAll('[slot]')));
  	});

  	const writable_props = [
  		'texteTitreSrLiens',
  		'urlLogo',
  		'altLogo',
  		'srcLogo',
  		'widthLogo',
  		'heightLogo',
  		'texteCopyright',
  		'anneeCopyright',
  		'urlCopyright',
  		'texteSrOuvertureNouvelOnglet'
  	];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<utd-piv-pied-page> was created with unknown prop '${key}'`);
  	});

  	$$self.$$set = $$props => {
  		if ('texteTitreSrLiens' in $$props) $$invalidate(0, texteTitreSrLiens = $$props.texteTitreSrLiens);
  		if ('urlLogo' in $$props) $$invalidate(1, urlLogo = $$props.urlLogo);
  		if ('altLogo' in $$props) $$invalidate(2, altLogo = $$props.altLogo);
  		if ('srcLogo' in $$props) $$invalidate(3, srcLogo = $$props.srcLogo);
  		if ('widthLogo' in $$props) $$invalidate(4, widthLogo = $$props.widthLogo);
  		if ('heightLogo' in $$props) $$invalidate(5, heightLogo = $$props.heightLogo);
  		if ('texteCopyright' in $$props) $$invalidate(6, texteCopyright = $$props.texteCopyright);
  		if ('anneeCopyright' in $$props) $$invalidate(7, anneeCopyright = $$props.anneeCopyright);
  		if ('urlCopyright' in $$props) $$invalidate(8, urlCopyright = $$props.urlCopyright);
  		if ('texteSrOuvertureNouvelOnglet' in $$props) $$invalidate(9, texteSrOuvertureNouvelOnglet = $$props.texteSrOuvertureNouvelOnglet);
  	};

  	$$self.$capture_state = () => ({
  		onMount,
  		Utils,
  		get_current_component,
  		textesDefaut,
  		languePage,
  		texteTitreSrLiens,
  		urlLogo,
  		altLogo,
  		srcLogo,
  		widthLogo,
  		heightLogo,
  		texteCopyright,
  		anneeCopyright,
  		urlCopyright,
  		texteSrOuvertureNouvelOnglet,
  		thisComponent,
  		slots
  	});

  	$$self.$inject_state = $$props => {
  		if ('texteTitreSrLiens' in $$props) $$invalidate(0, texteTitreSrLiens = $$props.texteTitreSrLiens);
  		if ('urlLogo' in $$props) $$invalidate(1, urlLogo = $$props.urlLogo);
  		if ('altLogo' in $$props) $$invalidate(2, altLogo = $$props.altLogo);
  		if ('srcLogo' in $$props) $$invalidate(3, srcLogo = $$props.srcLogo);
  		if ('widthLogo' in $$props) $$invalidate(4, widthLogo = $$props.widthLogo);
  		if ('heightLogo' in $$props) $$invalidate(5, heightLogo = $$props.heightLogo);
  		if ('texteCopyright' in $$props) $$invalidate(6, texteCopyright = $$props.texteCopyright);
  		if ('anneeCopyright' in $$props) $$invalidate(7, anneeCopyright = $$props.anneeCopyright);
  		if ('urlCopyright' in $$props) $$invalidate(8, urlCopyright = $$props.urlCopyright);
  		if ('texteSrOuvertureNouvelOnglet' in $$props) $$invalidate(9, texteSrOuvertureNouvelOnglet = $$props.texteSrOuvertureNouvelOnglet);
  		if ('slots' in $$props) $$invalidate(10, slots = $$props.slots);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [
  		texteTitreSrLiens,
  		urlLogo,
  		altLogo,
  		srcLogo,
  		widthLogo,
  		heightLogo,
  		texteCopyright,
  		anneeCopyright,
  		urlCopyright,
  		texteSrOuvertureNouvelOnglet,
  		slots
  	];
  }

  class PivPiedPage extends SvelteElement {
  	constructor(options) {
  		super();

  		init(
  			this,
  			{
  				target: this.shadowRoot,
  				props: attribute_to_object(this.attributes),
  				customElement: true
  			},
  			instance$1,
  			create_fragment$1,
  			safe_not_equal,
  			{
  				texteTitreSrLiens: 0,
  				urlLogo: 1,
  				altLogo: 2,
  				srcLogo: 3,
  				widthLogo: 4,
  				heightLogo: 5,
  				texteCopyright: 6,
  				anneeCopyright: 7,
  				urlCopyright: 8,
  				texteSrOuvertureNouvelOnglet: 9
  			},
  			null
  		);

  		if (options) {
  			if (options.target) {
  				insert_dev(options.target, this, options.anchor);
  			}

  			if (options.props) {
  				this.$set(options.props);
  				flush();
  			}
  		}
  	}

  	static get observedAttributes() {
  		return [
  			"texteTitreSrLiens",
  			"urlLogo",
  			"altLogo",
  			"srcLogo",
  			"widthLogo",
  			"heightLogo",
  			"texteCopyright",
  			"anneeCopyright",
  			"urlCopyright",
  			"texteSrOuvertureNouvelOnglet"
  		];
  	}

  	get texteTitreSrLiens() {
  		return this.$$.ctx[0];
  	}

  	set texteTitreSrLiens(texteTitreSrLiens) {
  		this.$$set({ texteTitreSrLiens });
  		flush();
  	}

  	get urlLogo() {
  		return this.$$.ctx[1];
  	}

  	set urlLogo(urlLogo) {
  		this.$$set({ urlLogo });
  		flush();
  	}

  	get altLogo() {
  		return this.$$.ctx[2];
  	}

  	set altLogo(altLogo) {
  		this.$$set({ altLogo });
  		flush();
  	}

  	get srcLogo() {
  		return this.$$.ctx[3];
  	}

  	set srcLogo(srcLogo) {
  		this.$$set({ srcLogo });
  		flush();
  	}

  	get widthLogo() {
  		return this.$$.ctx[4];
  	}

  	set widthLogo(widthLogo) {
  		this.$$set({ widthLogo });
  		flush();
  	}

  	get heightLogo() {
  		return this.$$.ctx[5];
  	}

  	set heightLogo(heightLogo) {
  		this.$$set({ heightLogo });
  		flush();
  	}

  	get texteCopyright() {
  		return this.$$.ctx[6];
  	}

  	set texteCopyright(texteCopyright) {
  		this.$$set({ texteCopyright });
  		flush();
  	}

  	get anneeCopyright() {
  		return this.$$.ctx[7];
  	}

  	set anneeCopyright(anneeCopyright) {
  		this.$$set({ anneeCopyright });
  		flush();
  	}

  	get urlCopyright() {
  		return this.$$.ctx[8];
  	}

  	set urlCopyright(urlCopyright) {
  		this.$$set({ urlCopyright });
  		flush();
  	}

  	get texteSrOuvertureNouvelOnglet() {
  		return this.$$.ctx[9];
  	}

  	set texteSrOuvertureNouvelOnglet(texteSrOuvertureNouvelOnglet) {
  		this.$$set({ texteSrOuvertureNouvelOnglet });
  		flush();
  	}
  }

  customElements.define("utd-piv-pied-page", PivPiedPage);

  /* src\components\piedPageSite.svelte generated by Svelte v3.50.1 */
  const file = "src\\components\\piedPageSite.svelte";

  // (22:4) {#if Utils.slotExiste(slots, 'contenu')}
  function create_if_block(ctx) {
  	let slot;

  	const block = {
  		c: function create() {
  			slot = element("slot");
  			attr_dev(slot, "name", "contenu");
  			add_location(slot, file, 22, 6, 585);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, slot, anchor);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(slot);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block.name,
  		type: "if",
  		source: "(22:4) {#if Utils.slotExiste(slots, 'contenu')}",
  		ctx
  	});

  	return block;
  }

  function create_fragment(ctx) {
  	let div1;
  	let div0;
  	let show_if = Utils.slotExiste(/*slots*/ ctx[0], 'contenu');
  	let t;
  	let link;
  	let if_block = show_if && create_if_block(ctx);

  	const block = {
  		c: function create() {
  			div1 = element("div");
  			div0 = element("div");
  			if (if_block) if_block.c();
  			t = space();
  			link = element("link");
  			this.c = noop;
  			attr_dev(div0, "class", "utd-container");
  			add_location(div0, file, 20, 2, 504);
  			attr_dev(div1, "class", "utd-pied-page-site");
  			add_location(div1, file, 19, 0, 468);
  			attr_dev(link, "rel", "stylesheet");
  			attr_dev(link, "href", Utils.cssFullPath);
  			add_location(link, file, 27, 0, 645);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div1, anchor);
  			append_dev(div1, div0);
  			if (if_block) if_block.m(div0, null);
  			insert_dev(target, t, anchor);
  			insert_dev(target, link, anchor);
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*slots*/ 1) show_if = Utils.slotExiste(/*slots*/ ctx[0], 'contenu');

  			if (show_if) {
  				if (if_block) ; else {
  					if_block = create_if_block(ctx);
  					if_block.c();
  					if_block.m(div0, null);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div1);
  			if (if_block) if_block.d();
  			if (detaching) detach_dev(t);
  			if (detaching) detach_dev(link);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance($$self, $$props, $$invalidate) {
  	let { $$slots: slots$1 = {}, $$scope } = $$props;
  	validate_slots('utd-pied-page-site', slots$1, []);
  	const thisComponent = get_current_component();
  	let slots = [];

  	onMount(() => {
  		$$invalidate(0, slots = Array.from(thisComponent.querySelectorAll('[slot]')));
  	});

  	const writable_props = [];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<utd-pied-page-site> was created with unknown prop '${key}'`);
  	});

  	$$self.$capture_state = () => ({
  		onMount,
  		Utils,
  		get_current_component,
  		thisComponent,
  		slots
  	});

  	$$self.$inject_state = $$props => {
  		if ('slots' in $$props) $$invalidate(0, slots = $$props.slots);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [slots];
  }

  class PiedPageSite extends SvelteElement {
  	constructor(options) {
  		super();

  		init(
  			this,
  			{
  				target: this.shadowRoot,
  				props: attribute_to_object(this.attributes),
  				customElement: true
  			},
  			instance,
  			create_fragment,
  			safe_not_equal,
  			{},
  			null
  		);

  		if (options) {
  			if (options.target) {
  				insert_dev(options.target, this, options.anchor);
  			}
  		}
  	}
  }

  customElements.define("utd-pied-page-site", PiedPageSite);

  exports.ajusterAccessibiliteLiens = ajusterAccessibiliteLiens;
  exports.customElements = customElements;
  exports.dialogue = dialogue;
  exports.extend = extend;
  exports.genererId = genererId;
  exports.message = message;
  exports.notification = notification;
  exports.obtenirIdControleActif = obtenirIdControleActif;
  exports.obtenirLanguePage = obtenirLanguePage;
  exports.traitementEnCours = traitementEnCours;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
