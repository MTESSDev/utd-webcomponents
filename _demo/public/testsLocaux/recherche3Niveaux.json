[
    {
        "c": "Navigation",
        "sc": "Groupe de sections",
        "r": "Texte résultat Groupe de sections",
        "h": "#groupesection",
        "t": "Un formulaire est divise en groupes de sections chaque groupe de sections peut avoir son icone le menu de gauche affiche automatiquement les groupes de sections dans un format menu deroulant au chargement de la page, les groupes de sections sont fermes sauf le groupe de sections actif cliquer sur un groupe de sections ouvre ou ferme le groupe de sections il est possible d'ouvrir et de fermer plusieurs groupes de sections si un groupe de sections contient une erreur de validation (champ obligatoire, format... ), un indicateur rouge est affiche sur le groupe de sections voici le formulaire \"hello world! \" accesanonyme: true form: title: fr: bonjour le monde! En: hello world! Sectionsgroup: - sectiongroup: fr: bonjour en: hello v-if: 'true' === 'true' classes: icone user prefixid: prefixsection sections: - section: fr: titre de la section en: (eng) titre de la section id: sectionpresentation v-if: 'true' === 'true' components: - type: dynamic tag: div classes: page-texte text: fr: texte de salutation. En: (eng) texte de salutation. Fonctions avancees il est possible d'ajouter un prefixe aux composants d'un groupe de section a l'aide du  prefixid  il est possible de repeter les sections d'un groupe de sections et y faisant reference dans un nouveau groupe de sections identifiers le groupe de sections a repeter en ajoutant la cle apres la propriete sections (par exemple : sections: §ion1) copier les sections dans un nouveau groupe de sections en utilisant la cle (par exemple : sections: *section1) pour distinguer les composants d'un groupe de sections repete, utiliser le prefixid (par exemple : section1composant1)",    
        "mc": "découpage"
    },
    {
        "c": "Navigation",
        "sc": "Section",
        "h": "#section",
        "r": "Texte résultat Section",
        "t": "Un groupe de sections est divisé en sections le menu de gauche liste automatiquement les sections lorsqu'un groupe de sections est ouvert chaque section est automatiquement numérotée le numéro de la section courante est surligné après avoir été visitée si une section est complétée et ne contient pas d'erreur de validation, le numéro est remplacé par un crochet si une section contient une erreur de validation, le numéro est remplacé par un x rouge",    
        "mc": ""
    },
    {
        "c": "Navigation",
        "sc": "Section",
        "h": "#section2",
        "r": "Texte résultat Section 2",
        "t": "Un groupe de sections est divisé en sections le menu de gauche liste automatiquement les sections lorsqu'un groupe de sections est ouvert chaque section est automatiquement numérotée le numéro de la section courante est surligné après avoir été visitée si une section est complétée et ne contient pas d'erreur de validation, le numéro est remplacé par un crochet si une section contient une erreur de validation, le numéro est remplacé par un x rouge",    
        "mc": ""
    },
    {
        "c": "Avancé",
        "sc": "Validations personnalisées",
        "r": "Texte résultat Validations personnalisées",
        "h": "#validperso",
        "t": "Description Lorsque les validateurs de bases ne répondent pas au besoin, il est possible d'ajouter des validateurs personnalisés (\"custom\"). Il s'agit d'une fonctionnalité avancée qui nécessite des connaissances en javascript.      Détails        Une validation personnalisée est constituée principalement de 2 éléments, soit la validation et le message d'erreur qui lui est associé.        L'image et le tableau ci-après décrivent en détails les éléments qui constituent une validation personnalisée.",    
        "mc": "validation-rules, validation-message, scripts"
    },
    {
        "c": "Avancé",
        "sc": "Divers",        
        "r": "Texte résultat Divers",
        "h": "#resultatdivers",
        "t": "Cliquez sur l'infobulle pour voir son contenu  Exemple de champ texte avec une précision Exemple de précision Déplacer le focus dans le formulaire Utiliser la fonction effectuerNavigationParId(sectionID, champID) pour déplacer le focus vers un champ d'une section. Déplacer le focus sur le champ \"Exemple de champ texte petit\" de la page \"Taille de contrôle\"",    
        "mc": ""
    },
    {
        "c": "Avancé",
        "sc": "Injection de scripts",
        "r": "Débutant",
        "h": "#debutant",
        "t": "L'injection de script vuejs permet d'ajouter des fonctionnalites au formulaire. On peut injecter trois types de scripts, a savoir method, computed et watch. Method il s'agit ni plus ni moins que d'une fonction telle qu'on les connait. Elles peuvent avoir des parametres, performent des actions et/ou retournent un resultat. Circonstances d'utilisation a utiliser lorsque le traitement satisfait une des conditions suivantes: necessite un ou plusieurs parametres en entree; modifie une valeur du modele de donnees; execute un traitement asynchrone. Computed une computed est en fait une propriete. Elle n'a pas de parametre et son utilisation permet d'ameliorer la performance, car elle est executee au chargement de la page, elle conserve son resultat en cache, et n'est reeexecutee que lorsqu'un element reactif implique dans son traitement est modifie (ex. Une valeur du formulaire). Il est donc imperatif que le traitement qu'elle contient ne modifie jamais un element reactif, auquel cas une boucle infinie risque de tout faire exploser. A titre d'exemple, si on utilise une computed a l'interieur d'une boucle, la valeur en cache sera toujours retournee, donc aucune execution, contrairement a une method qui elle sera executee a chaque iteration de la boucle. Circonstances d'utilisation a utiliser lorsque le traitement satisfait toutes les conditions suivantes: ne necessite aucun parametre en entree; ne modifie pas une valeur du modele de donnees (tres important, car gros risque de boucle infinie); utilise au moins une propriete reactive (ex. Une valeur du modele), mais sans en modifier; n'execute aucun traitement asynchrone. Watch une watch est une methode qui est executee lorsque l'element reactif qu'elle \"surveille\" est modifie. Circonstances d'utilisation rarement utilise. Peut etre utile pour modifier la valeur d'un autre element du modele ou effectuer un traitement asynchrone suite au changement de valeur de l'element \"surveille\". A utiliser lorsque le traitement satisfait toutes les conditions suivantes: ne necessite aucun parametre en entree; doit modifier la valeur d'un element ou effectuer une tache precise suite au changement de la valeur surveillee; ne modifie pas la valeur surveillee (tres important, car gros risque de boucle infinie); watch 1- exemple method et computed dans cet exemple nous demandons a l'utilisateur une date, a laquelle nous ajoutons 30 jours. Nous calculons ensuite le nombre de jours entre cette date et la date du jour et l'affichons dans un message sous le champ date. Date a laquelle vous commence a utiliser frw * afin d'y parvenir, nous avons defini 2 method, soit \"ajouternbjoursdate\" et \"obtenirnbjoursentredeuxdates\". Remarquez que ces 2 method sont generiques et ne sont pas lies a des elements du modele de donnees. On pourrait les reutiliser, et c'est evidemment le but! On utilise aussi 2 computed, \"datedependancecompletefrw\" qui retourne la date de dependance complete a frw (date saisie + 30 jours) en utilisant la method \"ajouternbjoursdate\". L'autre computed, \"nbjoursdependancecompletefrw\" retourne le nombre de jours depuis ou avant la dependance complete a frw (nombre de jours entre la date du jour et la computed \"datedependancecompletefrw\"). Remarquez ici que les computed sont lies a des elements du modele, et ne peuvent donc pas etre reutilisees. Par contre nous avons un gain en performance.",    
        "mc": ""
    },
    {
        "c": "Avancé",
        "sc": "Injection de scripts",
        "r": "Intermédiaire",
        "h": "#intermediaire",
        "t": "L'injection de script vuejs permet d'ajouter des fonctionnalites au formulaire. On peut injecter trois types de scripts, a savoir method, computed et watch. Method il s'agit ni plus ni moins que d'une fonction telle qu'on les connait. Elles peuvent avoir des parametres, performent des actions et/ou retournent un resultat. Circonstances d'utilisation a utiliser lorsque le traitement satisfait une des conditions suivantes: necessite un ou plusieurs parametres en entree; modifie une valeur du modele de donnees; execute un traitement asynchrone. Computed une computed est en fait une propriete. Elle n'a pas de parametre et son utilisation permet d'ameliorer la performance, car elle est executee au chargement de la page, elle conserve son resultat en cache, et n'est reeexecutee que lorsqu'un element reactif implique dans son traitement est modifie (ex. Une valeur du formulaire). Il est donc imperatif que le traitement qu'elle contient ne modifie jamais un element reactif, auquel cas une boucle infinie risque de tout faire exploser. A titre d'exemple, si on utilise une computed a l'interieur d'une boucle, la valeur en cache sera toujours retournee, donc aucune execution, contrairement a une method qui elle sera executee a chaque iteration de la boucle. Circonstances d'utilisation a utiliser lorsque le traitement satisfait toutes les conditions suivantes: ne necessite aucun parametre en entree; ne modifie pas une valeur du modele de donnees (tres important, car gros risque de boucle infinie); utilise au moins une propriete reactive (ex. Une valeur du modele), mais sans en modifier; n'execute aucun traitement asynchrone. Watch une watch est une methode qui est executee lorsque l'element reactif qu'elle \"surveille\" est modifie. Circonstances d'utilisation rarement utilise. Peut etre utile pour modifier la valeur d'un autre element du modele ou effectuer un traitement asynchrone suite au changement de valeur de l'element \"surveille\". A utiliser lorsque le traitement satisfait toutes les conditions suivantes: ne necessite aucun parametre en entree; doit modifier la valeur d'un element ou effectuer une tache precise suite au changement de la valeur surveillee; ne modifie pas la valeur surveillee (tres important, car gros risque de boucle infinie); watch 1- exemple method et computed dans cet exemple nous demandons a l'utilisateur une date, a laquelle nous ajoutons 30 jours. Nous calculons ensuite le nombre de jours entre cette date et la date du jour et l'affichons dans un message sous le champ date. Date a laquelle vous commence a utiliser frw * afin d'y parvenir, nous avons defini 2 method, soit \"ajouternbjoursdate\" et \"obtenirnbjoursentredeuxdates\". Remarquez que ces 2 method sont generiques et ne sont pas lies a des elements du modele de donnees. On pourrait les reutiliser, et c'est evidemment le but! On utilise aussi 2 computed, \"datedependancecompletefrw\" qui retourne la date de dependance complete a frw (date saisie + 30 jours) en utilisant la method \"ajouternbjoursdate\". L'autre computed, \"nbjoursdependancecompletefrw\" retourne le nombre de jours depuis ou avant la dependance complete a frw (nombre de jours entre la date du jour et la computed \"datedependancecompletefrw\"). Remarquez ici que les computed sont lies a des elements du modele, et ne peuvent donc pas etre reutilisees. Par contre nous avons un gain en performance.",    
        "mc": ""
    },
    {
        "c": "Avancé",
        "sc": "Injection de scripts",
        "r": "Avancé",
        "h": "#avance",
        "t": "L'injection de script vuejs permet d'ajouter des fonctionnalites au formulaire. On peut injecter trois types de scripts, a savoir method, computed et watch. Method il s'agit ni plus ni moins que d'une fonction telle qu'on les connait. Elles peuvent avoir des parametres, performent des actions et/ou retournent un resultat. Circonstances d'utilisation a utiliser lorsque le traitement satisfait une des conditions suivantes: necessite un ou plusieurs parametres en entree; modifie une valeur du modele de donnees; execute un traitement asynchrone. Computed une computed est en fait une propriete. Elle n'a pas de parametre et son utilisation permet d'ameliorer la performance, car elle est executee au chargement de la page, elle conserve son resultat en cache, et n'est reeexecutee que lorsqu'un element reactif implique dans son traitement est modifie (ex. Une valeur du formulaire). Il est donc imperatif que le traitement qu'elle contient ne modifie jamais un element reactif, auquel cas une boucle infinie risque de tout faire exploser. A titre d'exemple, si on utilise une computed a l'interieur d'une boucle, la valeur en cache sera toujours retournee, donc aucune execution, contrairement a une method qui elle sera executee a chaque iteration de la boucle. Circonstances d'utilisation a utiliser lorsque le traitement satisfait toutes les conditions suivantes: ne necessite aucun parametre en entree; ne modifie pas une valeur du modele de donnees (tres important, car gros risque de boucle infinie); utilise au moins une propriete reactive (ex. Une valeur du modele), mais sans en modifier; n'execute aucun traitement asynchrone. Watch une watch est une methode qui est executee lorsque l'element reactif qu'elle \"surveille\" est modifie. Circonstances d'utilisation rarement utilise. Peut etre utile pour modifier la valeur d'un autre element du modele ou effectuer un traitement asynchrone suite au changement de valeur de l'element \"surveille\". A utiliser lorsque le traitement satisfait toutes les conditions suivantes: ne necessite aucun parametre en entree; doit modifier la valeur d'un element ou effectuer une tache precise suite au changement de la valeur surveillee; ne modifie pas la valeur surveillee (tres important, car gros risque de boucle infinie); watch 1- exemple method et computed dans cet exemple nous demandons a l'utilisateur une date, a laquelle nous ajoutons 30 jours. Nous calculons ensuite le nombre de jours entre cette date et la date du jour et l'affichons dans un message sous le champ date. Date a laquelle vous commence a utiliser frw * afin d'y parvenir, nous avons defini 2 method, soit \"ajouternbjoursdate\" et \"obtenirnbjoursentredeuxdates\". Remarquez que ces 2 method sont generiques et ne sont pas lies a des elements du modele de donnees. On pourrait les reutiliser, et c'est evidemment le but! On utilise aussi 2 computed, \"datedependancecompletefrw\" qui retourne la date de dependance complete a frw (date saisie + 30 jours) en utilisant la method \"ajouternbjoursdate\". L'autre computed, \"nbjoursdependancecompletefrw\" retourne le nombre de jours depuis ou avant la dependance complete a frw (nombre de jours entre la date du jour et la computed \"datedependancecompletefrw\"). Remarquez ici que les computed sont lies a des elements du modele, et ne peuvent donc pas etre reutilisees. Par contre nous avons un gain en performance.",    
        "mc": ""
    },
    {
        "c": "Personnalisation des formulaires",
        "sc": "Domaines de valeurs",
        "r": "Texte résultat Domaines de valeurs",
        "h": "#domaine",
        "t": "Qu'est-ce qu'un domaine de valeurs? Un domaine de valeurs correspond a une liste de valeurs reutilisables dans un formulaire precis, par tous les formulaires d'un systeme autorise ou meme par tout le systeme frw tout dependant a quel niveau il est configure. Les domaines peuvent etre utilises dans les controles suivants: case a cocher bouton radio liste deroulante hierarchie dans les domaines de valeurs lorsque le meme domaine de valeurs est defini dans plusieurs configurations, le niveau le plus precis a toujours preseance sur les autres. L'image suivante represente la hierarchie des configurations ou le niveau 'pre-remplissage' est le plus important. Definir un domaine via la configuration un domaine peut etre defini dans le bloc config d'un formulaire ou de votre systeme autorise en ajoutant une propriete domaines et en lui assignant les valeurs desirees pour chaque domaine. Definir un domaine via le pre-remplissage les domaines de valeurs fournis en pre-remplisssage ont preseance sur les domaines specifies au niveau de la configuration. Afin de fournir des domaines de valeurs en pre-remplissage, il faut ajouter au json une propriete domaine au meme niveau que form (qui contient les donnees pre-remplies du formulaire).",    
        "mc": ""
    },
    {
        "c": "Personnalisation des formulaires",
        "sc": "Domaines de valeurs",
        "r": "Texte résultat Domaines de valeurs 2",
        "h": "#domaine2",
        "t": "Qu'est-ce qu'un domaine de valeurs? Un domaine de valeurs correspond a une liste de valeurs reutilisables dans un formulaire precis, par tous les formulaires d'un systeme autorise ou meme par tout le systeme frw tout dependant a quel niveau il est configure. Les domaines peuvent etre utilises dans les controles suivants: case a cocher bouton radio liste deroulante hierarchie dans les domaines de valeurs lorsque le meme domaine de valeurs est defini dans plusieurs configurations, le niveau le plus precis a toujours preseance sur les autres. L'image suivante represente la hierarchie des configurations ou le niveau 'pre-remplissage' est le plus important. Definir un domaine via la configuration un domaine peut etre defini dans le bloc config d'un formulaire ou de votre systeme autorise en ajoutant une propriete domaines et en lui assignant les valeurs desirees pour chaque domaine. Definir un domaine via le pre-remplissage les domaines de valeurs fournis en pre-remplisssage ont preseance sur les domaines specifies au niveau de la configuration. Afin de fournir des domaines de valeurs en pre-remplissage, il faut ajouter au json une propriete domaine au meme niveau que form (qui contient les donnees pre-remplies du formulaire).",    
        "mc": ""
    },
    {
        "c": "Personnalisation des formulaires",
        "sc": "Page de révision/soumission",
        "r": "Texte résultat Page de révision/soumission",
        "h": "#domaine",
        "t": "1- personnalisation du texte affiche avant les boutons \"valider\" et \"soumettre\" la personnalisation de ces textes peut etre effectuee dans le fichier de configuration d'un formulaire, plus precisement dans la section \"revision\". Il est important de ne rien modifier d'autre que les elements \"text\" des deux components de type \"dynamic\" de cette section. Dans l'image qui suit, les blocs en jaune sont des exemples de cette personnalisation. 2- validation automatique il est possible d'executer immediatement la validation des que la page revision est accedee. Le bouton \"valider\" et le texte de la page ne sont alors pas affiches et la validation s'effectue comme si l'utilisateur avait clique le bouton \"valider\". Utile lorsqu'aucune consigne particuliere ne doit etre affichee avant la validation. 3- personnalisation du texte du bouton \"soumettre\" la personnalisation de ce texte peut etre effectuee dans le fichier de configuration d'un formulaire, plus precisement dans la section \"soumission\". Voici un exemple dans un contexte de formulaire d'aiguillage :",    
        "mc": "scripts"
    }    
]