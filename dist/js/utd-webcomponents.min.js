var utd = (function (exports) {
  'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }

    return _get.apply(this, arguments);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _createSuper$b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$c(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$c() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /*! Wrapper pour les customElements afin de supporter les attributs kebab case avec les customElements de svelte. 
      Référence : https://github.com/sveltejs/svelte/issues/3852
  */
  var customElements = {
    define: function define(tagName, CustomElement) {
      var CustomElementWrapper = /*#__PURE__*/function (_CustomElement) {
        _inherits(CustomElementWrapper, _CustomElement);

        var _super = _createSuper$b(CustomElementWrapper);

        function CustomElementWrapper() {
          _classCallCheck(this, CustomElementWrapper);

          return _super.apply(this, arguments);
        }

        _createClass(CustomElementWrapper, [{
          key: "attributeChangedCallback",
          value: function attributeChangedCallback(attrName, oldValue, newValue) {
            _get(_getPrototypeOf(CustomElementWrapper.prototype), "attributeChangedCallback", this).call(this, attrName.replace(/-([a-z])/g, function (_, up) {
              return up.toUpperCase();
            }), oldValue, newValue === '' ? true : newValue // [Tweaked] Value of omitted value attribute will be true
            );
          }
        }], [{
          key: "observedAttributes",
          get: function get() {
            return (_get(_getPrototypeOf(CustomElementWrapper), "observedAttributes", this) || []).map(function (attr) {
              return attr.replace(/([a-zA-Z])(?=[A-Z])/g, '$1-').toLowerCase();
            });
          }
        }]);

        return CustomElementWrapper;
      }(CustomElement);

      window.customElements.define(tagName, CustomElementWrapper); // <--- Call the actual customElements.define with our wrapper
    }
  };

  /*! utd-webcomponents v1.7.0 */
  //TODO ajouter possibilité que utd reçoive les textes de langue requis. De quelle façon?
  //A- En paramètre des méthodes qui en ont besoin
  //B- Globalement via une initialisation de texte UTD qui serait faite une fois.
  //IMPORTANT! Laisser ce commentaire, une fois le build terminé, il sera remplacé par une condition permettant de ne pas réexécuter le script (afin d'éviter les erreurs de custom elements dejà définis qui se produisent parfois. On suppose rechargement d'un onglet ou autre.)

  /*!_VerifierSiDejaCharge_*/

  /*======================================================================================================================*/

  /* -10- FENÊTRES DE MESSAGE
  /*======================================================================================================================*/
  var message = function () {
    var elementsPublics = {};
    /**
     * Affiche une fenêtre de message (dialog).
     * @param {Object} parametres Paramètres.
     * @param {Object} parametres.type Type de message ("erreur", "information", "avertissement", "succes"  pour l'instant, autres types à venir). Défaut "avertissement".
     * @param {Object} parametres.titre Titre du message. Texte brut ou HTML (ex. Annuler les modifications) Défaut "". 
     * @param {Object} parametres.corps Corps du message. Texte brut ou HTML (ex. Désirez-vous annuler les modifications ou poursuivre?.) Défaut "".
     * @param {Object} parametres.texteBoutonPrimaire Texte du bouton primaire. (Celui le plus à droite). Si vide n'est pas affiché.
     * @param {Object} parametres.texteBoutonSecondaire Texte du bouton secondaire. (Situé à la gauche du bouton primaire). Si vide n'est pas affiché.
     * @param {Object} parametres.texteBoutonFermer Texte du bouton de fermeture du message. Défaut "Fermer" ou "Close en anglais".
     * @param {Object} parametres.afficherBoutonFermer Afficher le bouton pour fermer la fenêtre de message. Défaut true.
     * @param {Object} parametres.idControleFocusFermeture Id du contrôle auquel on redonne le focus à la fermeture de la fenêtre de message. Si non spécifié, focus redonné à l'élément actif avant l'affichage du message.
     * @returns {Object} Une promesse jQuery qui contiendra éventuellement un objet contenant la raison de fermeture. (ex. objet.primaire ou objet.secondaire)
     * @example afficherMessage(parametres)
                .done(function (resultat) {
                    if (resultat.primaire) {
                        alert("Très bon choix! Poursuivre aurait pu causer une rupture du continuum espace temps!");
                    } else if (resultat.secondaire) {
                        alert("Mauvais choix! Vous auriez-du poursuivre. À cause de vous le continuum espace temps risque de se briser!");
                    } else {
                        alert("Vous vous êtes contenté de fermer la fenêtre sans faire de choix... La prochaine fois assumez-vous! L'avenir du monde est entre vos mains!");
                    }
                });
    * @references https://www.w3.org/TR/wai-aria-practices/examples/dialog-modal/alertdialog.html
    * @notes Le titre et les boutons sont lus 2 fois dans NVDA... ça semble faire partie du pattern (voir lien ci-dessus). 
    */

    elementsPublics.afficher = function (parametres) {
      var valeursDefaut = {
        type: "",
        titre: "",
        corps: "",
        texteBoutonPrimaire: "",
        texteBoutonSecondaire: "",
        texteBoutonFermer: obtenirLanguePage() === 'fr' ? "Fermer" : "Close",
        afficherBoutonFermer: false,
        estBoutonsTexteLong: false,
        idControleFocusFermeture: null
      };
      parametres = extend(valeursDefaut, parametres);
      parametres.idControleFocusFermeture = obtenirIdControleFocusFermeture(parametres);
      var conteneurFenetreMessage = ajouterControle(parametres);
      var fenetreMessage = conteneurFenetreMessage.querySelector('utd-dialog');
      var boutons = conteneurFenetreMessage.querySelectorAll('[slot="pied"] > button');
      boutons.forEach(function (btn) {
        btn.addEventListener("click", function () {
          var raison = this.getAttribute('raison-fermeture');
          fenetreMessage.setAttribute('raisonfermeture', raison);
          fenetreMessage.setAttribute('afficher', 'false');
        });
      }); //Définir une promesse qui sera résolue à la fermeture de la fenêtre.

      return new Promise(function (resolve) {
        definirEvenementFermeture(fenetreMessage, resolve);
        fenetreMessage.setAttribute('afficher', 'true');
      });
    };
    /**
     * (Privée)
     * Obtient l'id du contrôle auquel il faut redonner le focus lors de la fermeture.
     * @param {Object} parametres Paramètres de la function afficherMessage.
     * @returns Id du contrôle auquel il faut redonner le focus à la fermeture du message.
     */


    function obtenirIdControleFocusFermeture(parametres) {
      if (!parametres.idControleFocusFermeture) {
        if (document.activeElement) {
          var id = document.activeElement.id;

          if (!id) {
            id = genererId();
            document.activeElement.id = id;
          }

          parametres.idControleFocusFermeture = id;
          return id;
        }
      }

      return parametres.idControleFocusFermeture;
    }
    /**
     * (Privée)
     * Ajoute le contrôle de fenêtre de message au DOM.
     * @param {Object} parametres Paramètres de la function afficherMessage.
     * @returns Object correspondant au conteneur de la fenêtre de message.
     */


    function ajouterControle(parametres) {
      //    var classeIcone = obtenirClasseIcone(parametres.type);
      var type = parametres.type ? " type=\"".concat(parametres.type, "\" ") : '';
      var html = "\n        <utd-dialog titre=\"".concat(parametres.titre, "\" idfocus=\"").concat(parametres.idControleFocusFermeture, "\" estfenetremessage=\"true\" estboutonstextelong=\"").concat(parametres.estBoutonsTexteLong, "\" ").concat(type, ">\n            <div slot=\"contenu\">\n                ").concat(parametres.corps, "\n            </div>\n            <div slot=\"pied\">");
      var htmlBoutonPrimaire = "<button type=\"button\" class=\"utd-btn primaire compact\" raison-fermeture=\"primaire\" data-ga-action=\"".concat(parametres.titre, "\">").concat(parametres.texteBoutonPrimaire, "</button>");
      var htmlBoutonSecondaire = parametres.texteBoutonSecondaire ? "<button type=\"button\" class=\"utd-btn secondaire compact\" raison-fermeture=\"secondaire\" data-ga-action=\"".concat(parametres.titre, "\">").concat(parametres.texteBoutonSecondaire, "</button>") : '';
      html += "\n                ".concat(htmlBoutonSecondaire).concat(htmlBoutonPrimaire, "                        \n            </div>\n        </utd-dialog>");
      var id = genererId();
      var conteneurFenetreMessage = document.createElement('div');
      conteneurFenetreMessage.id = id;
      conteneurFenetreMessage.innerHTML = html;
      document.body.appendChild(conteneurFenetreMessage);
      return conteneurFenetreMessage;
    }
    /**
     * (Privéee)
     * Compléter la promesse indiquant de quelle façon la fenêtre s'est fermée et supprimer l'élément du DOM une fois qu'il n'est plus affiché.
     * @param {Object} fenetreMessage Objet correspondant à la fenêtre de message.
     * @param {Promise} resolve Résolution de promesse.
     */


    function definirEvenementFermeture(fenetreMessage, resolve) {
      fenetreMessage.addEventListener("fermeture", function (e) {
        resolve(e.detail.raisonFermeture); //setTimeout ici afin de s'assurer que svelte a terminé son traitement avant de retirer le compsant du DOM

        setTimeout(function () {
          fenetreMessage.parentElement.remove();
        });
      });
    }

    return elementsPublics;
  }();
  /*======================================================================================================================*/

  /* -11- DIALOGUE
  /*======================================================================================================================*/

  var dialogue = function () {
    var elementsPublics = {};
    /**
    * Affiche une fenêtre de dialogue modal.
    * @param {Object} parametres Paramètres.
    * @param {Object} parametres.idDialogue Id du contrôle utd-dialog à afficher.
    * @param {Object} parametres.idControleFocusFermeture Id du contrôle auquel on redonne le focus à la fermeture du dialogue. Si non spécifié, focus redonné à l'élément actif avant l'affichage du message.
    */

    elementsPublics.afficher = function (idDialogue, idControleFocusFermeture) {
      if (!idDialogue) {
        console.error('utd.dialogue.afficher -> Aucun id de dialogue spécifié.');
        return;
      }

      idControleFocusFermeture = idControleFocusFermeture || obtenirIdControleFocusFermeture();
      var dialogue = document.getElementById(idDialogue);

      if (dialogue) {
        dialogue.setAttribute('afficher', 'true');

        if (idControleFocusFermeture) {
          dialogue.setAttribute('idfocus', idControleFocusFermeture);
        }
      } else {
        console.error("utd.dialogue.afficher -> Contr\xF4le utd-dialog \"".concat(dialogue, "\" non trouv\xE9."));
      }
    };

    elementsPublics.masquer = function (idDialogue) {
      if (!idDialogue) {
        console.error('utd.dialogue.masquer -> Aucun id de dialogue spécifié.');
        return;
      }

      var dialogue = document.getElementById(idDialogue);

      if (dialogue) {
        dialogue.setAttribute('afficher', 'false');
        var idFocus = dialogue.getAttribute('idfocus');

        if (idFocus) {
          var controleFocus = document.getElementById(idFocus);

          if (controleFocus) {
            controleFocus.focus();
          } else {
            console.log("utd.dialogue.masquer -> Contr\xF4le \"".concat(idFocus, "\" \xE0 qui redonner le focus non trouv\xE9."));
          }
        }
      } else {
        console.error("utd.dialogue.masquer -> Contr\xF4le utd-dialog \"".concat(dialogue, "\" non trouv\xE9."));
      }
    };
    /**
     * (Privée)
     * Obtient l'id du contrôle auquel il faut redonner le focus lors de la fermeture.
     * @returns Id du contrôle auquel il faut redonner le focus à la fermeture du message.
     */


    function obtenirIdControleFocusFermeture() {
      if (document.activeElement) {
        var id = document.activeElement.id;

        if (!id) {
          id = genererId();
          document.activeElement.id = id;
        }

        return id;
      }

      return null;
    }

    return elementsPublics;
  }();
  /*======================================================================================================================*/

  /* -20- TRAITEMENT EN COURS
  /*======================================================================================================================*/

  var traitementEnCours = function () {
    var elementsPublics = {};

    elementsPublics.debuter = function (element, avecOverlay) {
      avecOverlay = avecOverlay !== undefined ? avecOverlay : true;

      if (element) {
        //Ajouter un overlay global pendant le traitement en cours s'il y a lieu (défaut oui)  
        if (avecOverlay) {
          var overlay = document.createElement("div"); //Si un overlay est déjà présent, on ajoute le nouveau mais on le masque (il sera peut-être éventuellement réaffiché dans le traitement terminer du traitement en cours)

          if (document.getElementsByClassName('utd-overlay').length > 0) {
            overlay.classList.add('utd-d-none');
          }

          overlay.classList.add('utd-overlay');
          document.body.appendChild(overlay);
        }

        element.setAttribute('overlay', avecOverlay ? 'true' : 'false');

        if (element.tagName.toLowerCase() === 'button' || element.tagName.toLowerCase() === 'input' && element.type.toLowerCase() === 'submit') {
          element.classList.add("utd-traitement-en-cours");
          var htmlTraitementEnCours = '<div class="utd-spinner"></div>';

          if (element.getElementsByClassName('utd-spinner').length === 0) {
            element.innerHTML += htmlTraitementEnCours;
          }

          element.disabled = true;
        }

        notifierTraitementEnCoursLecteurEcran(element);
      }
    };

    elementsPublics.terminer = function (element) {
      if (element) {
        var spinner = element.querySelector('.utd-spinner');

        if (spinner) {
          spinner.remove();
        }

        element.classList.remove("utd-traitement-en-cours");
        element.disabled = false;
        supprimerOverlay(element);
        element.removeAttribute('overlay');
        notifierTraitementEnCoursLecteurEcran(element, true);
      }
    };

    function supprimerOverlay(element) {
      //Si le traitement en cours sur l'élément avait un overlay on le retire.
      var avecOverlay = element.getAttribute('overlay');

      if (avecOverlay === 'true') {
        //Retrait du overlay 
        var overlayTraitementEnCours = document.getElementsByClassName('utd-overlay');

        if (overlayTraitementEnCours.length > 1) {
          //On enlève 1 overlay, si un masqué existe c'est lui qu'on enlève. S'il y en a d'autres ils seront fermés éventuellement.
          var overlayInvisibles = document.getElementsByClassName('utd-overlay utd-d-none');

          if (overlayInvisibles.length > 0) {
            overlayInvisibles[0].remove();
          } else {
            //Si aucun overlay invisible, on enlève le 1er trouvé.
            overlayTraitementEnCours[0].remove();
          }
        } else if (overlayTraitementEnCours.length === 1) {
          overlayTraitementEnCours[0].remove();
        }
      }
    }

    function notifierTraitementEnCoursLecteurEcran(element, estTraitementTermine) {
      //Générer un id à l'élément qui va contenir le spinner de traitement en cours
      if (!element.id) {
        element.id = genererId();
      }

      var idZoneNotification = "zoneNotification_".concat(element.id); //Ajouter la zone de notification hors écran si elle n'existe pas déjà.

      var zoneNotificationsLecteurEcran = document.getElementById(idZoneNotification);

      if (!zoneNotificationsLecteurEcran) {
        zoneNotificationsLecteurEcran = document.createElement("div");
        zoneNotificationsLecteurEcran.id = idZoneNotification;
        zoneNotificationsLecteurEcran.classList.add('utd-sr-only');
        document.body.appendChild(zoneNotificationsLecteurEcran);
      }

      var texte = "";

      if (estTraitementTermine) {
        texte = obtenirLanguePage() === 'fr' ? "Traitement terminé." : "Processing complete.";
      } else {
        texte = obtenirLanguePage() === 'fr' ? "Traitement en cours." : "Processing...";
      }

      zoneNotificationsLecteurEcran.innerHTML = texte;
    }

    return elementsPublics;
  }();
  /*======================================================================================================================*/

  /* -30- NOTIFICATIONS
  /*======================================================================================================================*/

  var notification = function () {
    var elementsPublics = {};
    /**
     * Affiche une notification (toast).
     * @param {Object} parametres Paramètres.
     * @param {Object} parametres.type Type de notification (positif, negatif ou neutre). Défaut "positif".
     * @param {Object} parametres.titre Titre de la notification (ex. Succès) Défaut "Succès" ou "Échec".
     * @param {Object} parametres.message Message de la notification (ex. Enregistrement effectué avec succès.) Défaut "".
     * @param {Object} parametres.texteBoutonFermer Texte du bouton de fermeture de la notification. Défaut "Fermer".
     * @param {Object} parametres.delaiFermeture Délai (en ms) de fermeture automatique de la notification. Défaut 5000.
     */

    elementsPublics.emettre = function (parametres) {
      var valeursDefaut = {
        type: "positif",
        titre: "",
        //parametres.type == "echec" ? "Échec" : "Succès",
        message: "",
        texteBoutonFermer: obtenirLanguePage() === 'fr' ? "Fermer" : "Close",
        delaiFermeture: 5000
      };
      parametres = extend(valeursDefaut, parametres);
      var zoneNotifications = obtenirZoneNotifications();
      var notification = ajouterNotification(zoneNotifications, parametres);
      retirerNotificationApresDelai(notification, parametres);
    };
    /**
     * Obtient la node correspondant à la zone de notifications utd.
     * @returns {object} La zone de notifications utd.
     */


    function obtenirZoneNotifications() {
      var zoneNotifications = document.getElementById('utdZoneNotifications');

      if (!zoneNotifications) {
        zoneNotifications = document.createElement('div');
        zoneNotifications.id = 'utdZoneNotifications';
        zoneNotifications.classList.add('utd-notifications');
        zoneNotifications.setAttribute('role', 'alert');
        zoneNotifications.setAttribute('aria-atomic', 'true');
        document.body.appendChild(zoneNotifications);
      }

      return zoneNotifications;
    }
    /**
     * (Privée)
     * Ajoute une notification dans la zone des notifications.
     * @param {Object} zoneNotifications Node correspondant à la zone de notifications.
     * @param {Object} parametres Paramètres de la méthode emettre (qui permet d'émettre une notification).
     * @returns {Object} Node correspondant à la notification ajoutée.
     */


    function ajouterNotification(zoneNotifications, parametres) {
      var notification = document.createElement('div');
      notification.classList.add("notification", parametres.type);
      var possedeTitre = !!parametres.titre;

      if (!possedeTitre) {
        notification.classList.add("sans-titre");
      }

      notification.innerHTML = obtenirHtmlNotification(parametres, possedeTitre);
      definirEvenementClick(notification);
      zoneNotifications.appendChild(notification);
      afficherNotification(notification);
      return notification;
    }
    /**
     * 
     * @param {Object} parametres Paramètres de la méthode emettre (qui permet d'émettre une notification).
     * @param {Boolean} possedeTitre Indique si la notification possède un titre ou non.
     * @returns 
     */


    function obtenirHtmlNotification(parametres, possedeTitre) {
      var html = "\n            <button type=\"button\">\n                <span class=\"utd-sr-only\">".concat(parametres.texteBoutonFermer, "</span>\n                <span class=\"utd-icone-svg x-fermer-blanc\" aria-hidden=\"true\"></span>\n            </button>");

      if (possedeTitre) {
        var classeIcone = obtenirClasseIcone(parametres.type);
        html += "\n                <div class=\"titre\">\n                    <span class=\"utd-icone-svg ".concat(classeIcone, " md\" aria-hidden=\"true\"></span>\n                    <span class=\"texte\">").concat(parametres.titre, "</span>\n                </div>            \n            ");
      }

      html += "\n            <div class=\"texte-message\">\n                ".concat(parametres.message, "\n            </div>");
      return html;
    }
    /**
     * Obtient la classe de l'icône de titre.
     * @param {string} type Type de notification
     * @returns {string} Classe de l'icône de titre pour le type spécifié.
     */


    function obtenirClasseIcone(type) {
      switch (type) {
        case "negatif":
          return "erreur-blanc";

        case "neutre":
          return "information-blanc";

        default:
          return "succes-blanc";
      }
    }
    /**
     * Affiche la notification en effectuant un fade in.
     * @param {Object} notification Node notification à afficher.
     */


    function afficherNotification(notification) {
      setTimeout(function () {
        notification.classList.add('visible');
      }, 10);
    }
    /**
     * Retire la notification après le délai prévu.
     * @param {Object} notification Node correspondant à la notification à retirer.
     * @param {Object} parametres Paramètres de la méthode emettre (qui permet d'émettre une notification).
     */


    function retirerNotificationApresDelai(notification, parametres) {
      setTimeout(function () {
        retirerNotification(notification);
      }, parametres.delaiFermeture);
    }
    /**
     * Retire la notification du dom et en effectuant un fade out.
     * @param {Object} notification Node correspondant à la notification à retirer.
     */


    function retirerNotification(notification) {
      var dureeAnimationMs = 500;
      notification.classList.remove('visible');
      setTimeout(function () {
        notification.remove();
      }, dureeAnimationMs);
    }
    /**
     * (Privéee)
     * Définit le traitement à effectuer sur le click d'une notification.
     * @param {Object} notification Node de notification sur laquelle on doit appliquer l'événement.
     */


    function definirEvenementClick(notification) {
      notification.addEventListener("click", function (e) {
        retirerNotification(notification);
      });
    }

    return elementsPublics;
  }();
  /* ============================================================= */

  /* ======================== UTILITAIRES ======================== */

  /* ============================================================= */

  /**
   * 
   * @param {Object} cible Objet dans lequel on doit copier les données. 
   * @param {Object} source Objet contenant les infos à copier dans l'objet cible. 
   * @returns 
   */

  function extend(cible, source) {
    for (var sourceProp in source) {
      var sourceVal = source[sourceProp]; // Is this value an object?  If so, iterate over its properties, copying them over

      if (sourceVal && Object.prototype.toString.call(sourceVal) === "[object Object]") {
        cible[sourceProp] = cible[sourceProp] || {};
        extend(cible[sourceProp], sourceVal);
      } else {
        cible[sourceProp] = sourceVal;
      }
    }

    return cible;
  }
  /**
   * Génère un id unique.
   * @returns Un id unique.
   */

  function genererId() {
    return Date.now().toString(36) + '-' + Math.random().toString(36).substr(2, 9);
  }
  /**
   * Obtient la langue de la page courante.
   * @returns {string} Code de langue de la page courante (fr/en).
   */

  function obtenirLanguePage() {
    return document.getElementsByTagName("html")[0].getAttribute("lang") || "fr";
  }
  function ajusterAccessibiliteLiens(texteAccessibilite) {
    texteAccessibilite = texteAccessibilite || obtenirLanguePage() === 'fr' ? ". Ce lien sera ouvert dans un nouvel onglet." : ". This link will open in a new tab.";
    document.querySelectorAll('main a[target="_blank"]').forEach(function (lien) {
      //Ne pas traiter les liens sans href et les liens
      if (!lien.getAttribute('href')) {
        return;
      } //Ne pas traiter les liens vers des fichiers pdf ou les liens ayant explicitement une classe indiquant de ne pas les considérer comme lien externe(sans-lien-externe).  TODO éventuellement rafiner la condition afin de traiter uniquement les liens vers des pages web...


      if (lien.getAttribute('href').endsWith(".pdf") || lien.classList.contains("utd-sans-lien-externe")) {
        return;
      } //Ajouter la classe lien-externe afin d'afficher l'icône d'ouverture dans une nouvelle fenêtre.


      if (!lien.classList.contains("utd-lien-externe") && !lien.querySelector('.utd-lien-externe')) {
        lien.classList.add("utd-lien-externe");
      } //Ajouter le texte pour accessibilité nouvelle fenêtre si on détecte qu'il n'est pas là. TODO rafiner cette vérification éventuellement au besoin, il pourrait arriver qu'un .sr-only soit là pour autre chose dans le lien (très peu probable)


      if (!lien.querySelector(".utd-sr-only")) {
        lien.innerHTML = lien.innerHTML + "<span class=\"utd-sr-only\">".concat(texteAccessibilite, "</span>");
      }
    });
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _unsupportedIterableToArray$1(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _isNativeReflectConstruct$b() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct$b()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
  }

  function _createSuper$a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$a(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$a() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function noop() {}

  var identity = function identity(x) {
    return x;
  };

  function assign(tar, src) {
    // @ts-ignore
    for (var k in src) {
      tar[k] = src[k];
    }

    return tar;
  }

  function add_location(element, file, line, column, char) {
    element.__svelte_meta = {
      loc: {
        file: file,
        line: line,
        column: column,
        char: char
      }
    };
  }

  function run(fn) {
    return fn();
  }

  function blank_object() {
    return Object.create(null);
  }

  function run_all(fns) {
    fns.forEach(run);
  }

  function is_function(thing) {
    return typeof thing === 'function';
  }

  function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || a && _typeof(a) === 'object' || typeof a === 'function';
  }

  function is_empty(obj) {
    return Object.keys(obj).length === 0;
  }

  function compute_slots(slots) {
    var result = {};

    for (var key in slots) {
      result[key] = true;
    }

    return result;
  }

  var is_client = typeof window !== 'undefined';
  var now = is_client ? function () {
    return window.performance.now();
  } : function () {
    return Date.now();
  };
  var raf = is_client ? function (cb) {
    return requestAnimationFrame(cb);
  } : noop; // used internally for testing

  var tasks = new Set();

  function run_tasks(now) {
    tasks.forEach(function (task) {
      if (!task.c(now)) {
        tasks.delete(task);
        task.f();
      }
    });
    if (tasks.size !== 0) raf(run_tasks);
  }
  /**
   * Creates a new task that runs on each raf frame
   * until it returns a falsy value or is aborted
   */


  function loop(callback) {
    var task;
    if (tasks.size === 0) raf(run_tasks);
    return {
      promise: new Promise(function (fulfill) {
        tasks.add(task = {
          c: callback,
          f: fulfill
        });
      }),
      abort: function abort() {
        tasks.delete(task);
      }
    };
  } // Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM

  function append(target, node) {
    target.appendChild(node);
  }

  function get_root_for_style(node) {
    if (!node) return document;
    var root = node.getRootNode ? node.getRootNode() : node.ownerDocument;

    if (root && root.host) {
      return root;
    }

    return node.ownerDocument;
  }

  function append_empty_stylesheet(node) {
    var style_element = element('style');
    append_stylesheet(get_root_for_style(node), style_element);
    return style_element.sheet;
  }

  function append_stylesheet(node, style) {
    append(node.head || node, style);
    return style.sheet;
  }

  function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
  }

  function detach(node) {
    node.parentNode.removeChild(node);
  }

  function destroy_each(iterations, detaching) {
    for (var i = 0; i < iterations.length; i += 1) {
      if (iterations[i]) iterations[i].d(detaching);
    }
  }

  function element(name) {
    return document.createElement(name);
  }

  function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
  }

  function text(data) {
    return document.createTextNode(data);
  }

  function space() {
    return text(' ');
  }

  function empty() {
    return text('');
  }

  function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return function () {
      return node.removeEventListener(event, handler, options);
    };
  }

  function prevent_default(fn) {
    return function (event) {
      event.preventDefault(); // @ts-ignore

      return fn.call(this, event);
    };
  }

  function attr(node, attribute, value) {
    if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
  }

  function set_attributes(node, attributes) {
    // @ts-ignore
    var descriptors = Object.getOwnPropertyDescriptors(node.__proto__);

    for (var key in attributes) {
      if (attributes[key] == null) {
        node.removeAttribute(key);
      } else if (key === 'style') {
        node.style.cssText = attributes[key];
      } else if (key === '__value') {
        node.value = node[key] = attributes[key];
      } else if (descriptors[key] && descriptors[key].set) {
        node[key] = attributes[key];
      } else {
        attr(node, key, attributes[key]);
      }
    }
  }

  function children(element) {
    return Array.from(element.childNodes);
  }

  function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
  }

  function custom_event(type, detail) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref$bubbles = _ref.bubbles,
        bubbles = _ref$bubbles === void 0 ? false : _ref$bubbles,
        _ref$cancelable = _ref.cancelable,
        cancelable = _ref$cancelable === void 0 ? false : _ref$cancelable;

    var e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, bubbles, cancelable, detail);
    return e;
  }

  var HtmlTag = /*#__PURE__*/function () {
    function HtmlTag() {
      var is_svg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      _classCallCheck(this, HtmlTag);

      this.is_svg = false;
      this.is_svg = is_svg;
      this.e = this.n = null;
    }

    _createClass(HtmlTag, [{
      key: "c",
      value: function c(html) {
        this.h(html);
      }
    }, {
      key: "m",
      value: function m(html, target) {
        var anchor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        if (!this.e) {
          if (this.is_svg) this.e = svg_element(target.nodeName);else this.e = element(target.nodeName);
          this.t = target;
          this.c(html);
        }

        this.i(anchor);
      }
    }, {
      key: "h",
      value: function h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
      }
    }, {
      key: "i",
      value: function i(anchor) {
        for (var i = 0; i < this.n.length; i += 1) {
          insert(this.t, this.n[i], anchor);
        }
      }
    }, {
      key: "p",
      value: function p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
      }
    }, {
      key: "d",
      value: function d() {
        this.n.forEach(detach);
      }
    }]);

    return HtmlTag;
  }();

  function attribute_to_object(attributes) {
    var result = {};

    var _iterator2 = _createForOfIteratorHelper(attributes),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var attribute = _step2.value;
        result[attribute.name] = attribute.value;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return result;
  }

  function get_custom_elements_slots(element) {
    var result = {};
    element.childNodes.forEach(function (node) {
      result[node.slot || 'default'] = true;
    });
    return result;
  } // we need to store the information for multiple documents because a Svelte application could also contain iframes
  // https://github.com/sveltejs/svelte/issues/3624


  var managed_styles = new Map();
  var active = 0; // https://github.com/darkskyapp/string-hash/blob/master/index.js

  function hash(str) {
    var hash = 5381;
    var i = str.length;

    while (i--) {
      hash = (hash << 5) - hash ^ str.charCodeAt(i);
    }

    return hash >>> 0;
  }

  function create_style_information(doc, node) {
    var info = {
      stylesheet: append_empty_stylesheet(node),
      rules: {}
    };
    managed_styles.set(doc, info);
    return info;
  }

  function create_rule(node, a, b, duration, delay, ease, fn) {
    var uid = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
    var step = 16.666 / duration;
    var keyframes = '{\n';

    for (var p = 0; p <= 1; p += step) {
      var t = a + (b - a) * ease(p);
      keyframes += p * 100 + "%{".concat(fn(t, 1 - t), "}\n");
    }

    var rule = keyframes + "100% {".concat(fn(b, 1 - b), "}\n}");
    var name = "__svelte_".concat(hash(rule), "_").concat(uid);
    var doc = get_root_for_style(node);

    var _ref2 = managed_styles.get(doc) || create_style_information(doc, node),
        stylesheet = _ref2.stylesheet,
        rules = _ref2.rules;

    if (!rules[name]) {
      rules[name] = true;
      stylesheet.insertRule("@keyframes ".concat(name, " ").concat(rule), stylesheet.cssRules.length);
    }

    var animation = node.style.animation || '';
    node.style.animation = "".concat(animation ? "".concat(animation, ", ") : '').concat(name, " ").concat(duration, "ms linear ").concat(delay, "ms 1 both");
    active += 1;
    return name;
  }

  function delete_rule(node, name) {
    var previous = (node.style.animation || '').split(', ');
    var next = previous.filter(name ? function (anim) {
      return anim.indexOf(name) < 0;
    } // remove specific animation
    : function (anim) {
      return anim.indexOf('__svelte') === -1;
    } // remove all Svelte animations
    );
    var deleted = previous.length - next.length;

    if (deleted) {
      node.style.animation = next.join(', ');
      active -= deleted;
      if (!active) clear_rules();
    }
  }

  function clear_rules() {
    raf(function () {
      if (active) return;
      managed_styles.forEach(function (info) {
        var ownerNode = info.stylesheet.ownerNode; // there is no ownerNode if it runs on jsdom.

        if (ownerNode) detach(ownerNode);
      });
      managed_styles.clear();
    });
  }

  var current_component;

  function set_current_component(component) {
    current_component = component;
  }

  function get_current_component() {
    if (!current_component) throw new Error('Function called outside component initialization');
    return current_component;
  }

  function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
  }

  var dirty_components = [];
  var binding_callbacks = [];
  var render_callbacks = [];
  var flush_callbacks = [];
  var resolved_promise = Promise.resolve();
  var update_scheduled = false;

  function schedule_update() {
    if (!update_scheduled) {
      update_scheduled = true;
      resolved_promise.then(flush);
    }
  }

  function add_render_callback(fn) {
    render_callbacks.push(fn);
  }
  // 1. All beforeUpdate callbacks, in order: parents before children
  // 2. All bind:this callbacks, in reverse order: children before parents.
  // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
  //    for afterUpdates called during the initial onMount, which are called in
  //    reverse order: children before parents.
  // Since callbacks might update component values, which could trigger another
  // call to flush(), the following steps guard against this:
  // 1. During beforeUpdate, any updated components will be added to the
  //    dirty_components array and will cause a reentrant call to flush(). Because
  //    the flush index is kept outside the function, the reentrant call will pick
  //    up where the earlier call left off and go through all dirty components. The
  //    current_component value is saved and restored so that the reentrant call will
  //    not interfere with the "parent" flush() call.
  // 2. bind:this callbacks cannot trigger new flush() calls.
  // 3. During afterUpdate, any updated components will NOT have their afterUpdate
  //    callback called a second time; the seen_callbacks set, outside the flush()
  //    function, guarantees this behavior.


  var seen_callbacks = new Set();
  var flushidx = 0; // Do *not* move this inside the flush() function

  function flush() {
    var saved_component = current_component;

    do {
      // first, call beforeUpdate functions
      // and update components
      while (flushidx < dirty_components.length) {
        var component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }

      set_current_component(null);
      dirty_components.length = 0;
      flushidx = 0;

      while (binding_callbacks.length) {
        binding_callbacks.pop()();
      } // then, once components are updated, call
      // afterUpdate functions. This may cause
      // subsequent updates...


      for (var i = 0; i < render_callbacks.length; i += 1) {
        var callback = render_callbacks[i];

        if (!seen_callbacks.has(callback)) {
          // ...so guard against infinite loops
          seen_callbacks.add(callback);
          callback();
        }
      }

      render_callbacks.length = 0;
    } while (dirty_components.length);

    while (flush_callbacks.length) {
      flush_callbacks.pop()();
    }

    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
  }

  function update($$) {
    if ($$.fragment !== null) {
      $$.update();
      run_all($$.before_update);
      var dirty = $$.dirty;
      $$.dirty = [-1];
      $$.fragment && $$.fragment.p($$.ctx, dirty);
      $$.after_update.forEach(add_render_callback);
    }
  }

  var promise;

  function wait() {
    if (!promise) {
      promise = Promise.resolve();
      promise.then(function () {
        promise = null;
      });
    }

    return promise;
  }

  function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event("".concat(direction ? 'intro' : 'outro').concat(kind)));
  }

  var outroing = new Set();
  var outros;

  function group_outros() {
    outros = {
      r: 0,
      c: [],
      p: outros // parent group

    };
  }

  function check_outros() {
    if (!outros.r) {
      run_all(outros.c);
    }

    outros = outros.p;
  }

  function transition_in(block, local) {
    if (block && block.i) {
      outroing.delete(block);
      block.i(local);
    }
  }

  function transition_out(block, local, detach, callback) {
    if (block && block.o) {
      if (outroing.has(block)) return;
      outroing.add(block);
      outros.c.push(function () {
        outroing.delete(block);

        if (callback) {
          if (detach) block.d(1);
          callback();
        }
      });
      block.o(local);
    } else if (callback) {
      callback();
    }
  }

  var null_transition = {
    duration: 0
  };

  function create_in_transition(node, fn, params) {
    var config = fn(node, params);
    var running = false;
    var animation_name;
    var task;
    var uid = 0;

    function cleanup() {
      if (animation_name) delete_rule(node, animation_name);
    }

    function go() {
      var _ref4 = config || null_transition,
          _ref4$delay = _ref4.delay,
          delay = _ref4$delay === void 0 ? 0 : _ref4$delay,
          _ref4$duration = _ref4.duration,
          duration = _ref4$duration === void 0 ? 300 : _ref4$duration,
          _ref4$easing = _ref4.easing,
          easing = _ref4$easing === void 0 ? identity : _ref4$easing,
          _ref4$tick = _ref4.tick,
          tick = _ref4$tick === void 0 ? noop : _ref4$tick,
          css = _ref4.css;

      if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
      tick(0, 1);
      var start_time = now() + delay;
      var end_time = start_time + duration;
      if (task) task.abort();
      running = true;
      add_render_callback(function () {
        return dispatch(node, true, 'start');
      });
      task = loop(function (now) {
        if (running) {
          if (now >= end_time) {
            tick(1, 0);
            dispatch(node, true, 'end');
            cleanup();
            return running = false;
          }

          if (now >= start_time) {
            var t = easing((now - start_time) / duration);
            tick(t, 1 - t);
          }
        }

        return running;
      });
    }

    var started = false;
    return {
      start: function start() {
        if (started) return;
        started = true;
        delete_rule(node);

        if (is_function(config)) {
          config = config();
          wait().then(go);
        } else {
          go();
        }
      },
      invalidate: function invalidate() {
        started = false;
      },
      end: function end() {
        if (running) {
          cleanup();
          running = false;
        }
      }
    };
  }

  function create_out_transition(node, fn, params) {
    var config = fn(node, params);
    var running = true;
    var animation_name;
    var group = outros;
    group.r += 1;

    function go() {
      var _ref5 = config || null_transition,
          _ref5$delay = _ref5.delay,
          delay = _ref5$delay === void 0 ? 0 : _ref5$delay,
          _ref5$duration = _ref5.duration,
          duration = _ref5$duration === void 0 ? 300 : _ref5$duration,
          _ref5$easing = _ref5.easing,
          easing = _ref5$easing === void 0 ? identity : _ref5$easing,
          _ref5$tick = _ref5.tick,
          tick = _ref5$tick === void 0 ? noop : _ref5$tick,
          css = _ref5.css;

      if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
      var start_time = now() + delay;
      var end_time = start_time + duration;
      add_render_callback(function () {
        return dispatch(node, false, 'start');
      });
      loop(function (now) {
        if (running) {
          if (now >= end_time) {
            tick(0, 1);
            dispatch(node, false, 'end');

            if (! --group.r) {
              // this will result in `end()` being called,
              // so we don't need to clean up here
              run_all(group.c);
            }

            return false;
          }

          if (now >= start_time) {
            var t = easing((now - start_time) / duration);
            tick(1 - t, t);
          }
        }

        return running;
      });
    }

    if (is_function(config)) {
      wait().then(function () {
        // @ts-ignore
        config = config();
        go();
      });
    } else {
      go();
    }

    return {
      end: function end(reset) {
        if (reset && config.tick) {
          config.tick(1, 0);
        }

        if (running) {
          if (animation_name) delete_rule(node, animation_name);
          running = false;
        }
      }
    };
  }

  function create_bidirectional_transition(node, fn, params, intro) {
    var config = fn(node, params);
    var t = intro ? 0 : 1;
    var running_program = null;
    var pending_program = null;
    var animation_name = null;

    function clear_animation() {
      if (animation_name) delete_rule(node, animation_name);
    }

    function init(program, duration) {
      var d = program.b - t;
      duration *= Math.abs(d);
      return {
        a: t,
        b: program.b,
        d: d,
        duration: duration,
        start: program.start,
        end: program.start + duration,
        group: program.group
      };
    }

    function go(b) {
      var _ref6 = config || null_transition,
          _ref6$delay = _ref6.delay,
          delay = _ref6$delay === void 0 ? 0 : _ref6$delay,
          _ref6$duration = _ref6.duration,
          duration = _ref6$duration === void 0 ? 300 : _ref6$duration,
          _ref6$easing = _ref6.easing,
          easing = _ref6$easing === void 0 ? identity : _ref6$easing,
          _ref6$tick = _ref6.tick,
          tick = _ref6$tick === void 0 ? noop : _ref6$tick,
          css = _ref6.css;

      var program = {
        start: now() + delay,
        b: b
      };

      if (!b) {
        // @ts-ignore todo: improve typings
        program.group = outros;
        outros.r += 1;
      }

      if (running_program || pending_program) {
        pending_program = program;
      } else {
        // if this is an intro, and there's a delay, we need to do
        // an initial tick and/or apply CSS animation immediately
        if (css) {
          clear_animation();
          animation_name = create_rule(node, t, b, duration, delay, easing, css);
        }

        if (b) tick(0, 1);
        running_program = init(program, duration);
        add_render_callback(function () {
          return dispatch(node, b, 'start');
        });
        loop(function (now) {
          if (pending_program && now > pending_program.start) {
            running_program = init(pending_program, duration);
            pending_program = null;
            dispatch(node, running_program.b, 'start');

            if (css) {
              clear_animation();
              animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
            }
          }

          if (running_program) {
            if (now >= running_program.end) {
              tick(t = running_program.b, 1 - t);
              dispatch(node, running_program.b, 'end');

              if (!pending_program) {
                // we're done
                if (running_program.b) {
                  // intro — we can tidy up immediately
                  clear_animation();
                } else {
                  // outro — needs to be coordinated
                  if (! --running_program.group.r) run_all(running_program.group.c);
                }
              }

              running_program = null;
            } else if (now >= running_program.start) {
              var p = now - running_program.start;
              t = running_program.a + running_program.d * easing(p / running_program.duration);
              tick(t, 1 - t);
            }
          }

          return !!(running_program || pending_program);
        });
      }
    }

    return {
      run: function run(b) {
        if (is_function(config)) {
          wait().then(function () {
            // @ts-ignore
            config = config();
            go(b);
          });
        } else {
          go(b);
        }
      },
      end: function end() {
        clear_animation();
        running_program = pending_program = null;
      }
    };
  }

  var globals = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : global;

  function get_spread_update(levels, updates) {
    var update = {};
    var to_null_out = {};
    var accounted_for = {
      $$scope: 1
    };
    var i = levels.length;

    while (i--) {
      var o = levels[i];
      var n = updates[i];

      if (n) {
        for (var key in o) {
          if (!(key in n)) to_null_out[key] = 1;
        }

        for (var _key3 in n) {
          if (!accounted_for[_key3]) {
            update[_key3] = n[_key3];
            accounted_for[_key3] = 1;
          }
        }

        levels[i] = n;
      } else {
        for (var _key4 in o) {
          accounted_for[_key4] = 1;
        }
      }
    }

    for (var _key5 in to_null_out) {
      if (!(_key5 in update)) update[_key5] = undefined;
    }

    return update;
  }
  /** regex of all html void element names */

  var void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;

  function is_void(name) {
    return void_element_names.test(name) || name.toLowerCase() === '!doctype';
  }

  function mount_component(component, target, anchor, customElement) {
    var _component$$$ = component.$$,
        fragment = _component$$$.fragment,
        on_mount = _component$$$.on_mount,
        on_destroy = _component$$$.on_destroy,
        after_update = _component$$$.after_update;
    fragment && fragment.m(target, anchor);

    if (!customElement) {
      // onMount happens before the initial afterUpdate
      add_render_callback(function () {
        var new_on_destroy = on_mount.map(run).filter(is_function);

        if (on_destroy) {
          on_destroy.push.apply(on_destroy, _toConsumableArray(new_on_destroy));
        } else {
          // Edge case - component was destroyed immediately,
          // most likely as a result of a binding initialising
          run_all(new_on_destroy);
        }

        component.$$.on_mount = [];
      });
    }

    after_update.forEach(add_render_callback);
  }

  function destroy_component(component, detaching) {
    var $$ = component.$$;

    if ($$.fragment !== null) {
      run_all($$.on_destroy);
      $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to
      // preserve final state?)

      $$.on_destroy = $$.fragment = null;
      $$.ctx = [];
    }
  }

  function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
      dirty_components.push(component);
      schedule_update();
      component.$$.dirty.fill(0);
    }

    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
  }

  function init(component, options, instance, create_fragment, not_equal, props, append_styles) {
    var dirty = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [-1];
    var parent_component = current_component;
    set_current_component(component);
    var $$ = component.$$ = {
      fragment: null,
      ctx: null,
      // state
      props: props,
      update: noop,
      not_equal: not_equal,
      bound: blank_object(),
      // lifecycle
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
      // everything else
      callbacks: blank_object(),
      dirty: dirty,
      skip_bound: false,
      root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    var ready = false;
    $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {
      var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;

      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
        if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
        if (ready) make_dirty(component, i);
      }

      return ret;
    }) : [];
    $$.update();
    ready = true;
    run_all($$.before_update); // `false` as a special case of no DOM component

    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;

    if (options.target) {
      if (options.hydrate) {
        var nodes = children(options.target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

        $$.fragment && $$.fragment.l(nodes);
        nodes.forEach(detach);
      } else {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        $$.fragment && $$.fragment.c();
      }

      if (options.intro) transition_in(component.$$.fragment);
      mount_component(component, options.target, options.anchor, options.customElement);
      flush();
    }

    set_current_component(parent_component);
  }

  var SvelteElement;

  if (typeof HTMLElement === 'function') {
    SvelteElement = /*#__PURE__*/function (_HTMLElement) {
      _inherits(SvelteElement, _HTMLElement);

      var _super2 = _createSuper$a(SvelteElement);

      function SvelteElement() {
        var _this3;

        _classCallCheck(this, SvelteElement);

        _this3 = _super2.call(this);

        _this3.attachShadow({
          mode: 'open'
        });

        return _this3;
      }

      _createClass(SvelteElement, [{
        key: "connectedCallback",
        value: function connectedCallback() {
          var on_mount = this.$$.on_mount;
          this.$$.on_disconnect = on_mount.map(run).filter(is_function); // @ts-ignore todo: improve typings

          for (var key in this.$$.slotted) {
            // @ts-ignore todo: improve typings
            this.appendChild(this.$$.slotted[key]);
          }
        }
      }, {
        key: "attributeChangedCallback",
        value: function attributeChangedCallback(attr, _oldValue, newValue) {
          this[attr] = newValue;
        }
      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          run_all(this.$$.on_disconnect);
        }
      }, {
        key: "$destroy",
        value: function $destroy() {
          destroy_component(this, 1);
          this.$destroy = noop;
        }
      }, {
        key: "$on",
        value: function $on(type, callback) {
          // TODO should this delegate to addEventListener?
          var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
          callbacks.push(callback);
          return function () {
            var index = callbacks.indexOf(callback);
            if (index !== -1) callbacks.splice(index, 1);
          };
        }
      }, {
        key: "$set",
        value: function $set($$props) {
          if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
          }
        }
      }]);

      return SvelteElement;
    }( /*#__PURE__*/_wrapNativeSuper(HTMLElement));
  }

  function dispatch_dev(type, detail) {
    document.dispatchEvent(custom_event(type, Object.assign({
      version: '3.50.1'
    }, detail), {
      bubbles: true
    }));
  }

  function append_dev(target, node) {
    dispatch_dev('SvelteDOMInsert', {
      target: target,
      node: node
    });
    append(target, node);
  }

  function insert_dev(target, node, anchor) {
    dispatch_dev('SvelteDOMInsert', {
      target: target,
      node: node,
      anchor: anchor
    });
    insert(target, node, anchor);
  }

  function detach_dev(node) {
    dispatch_dev('SvelteDOMRemove', {
      node: node
    });
    detach(node);
  }

  function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
    var modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
    if (has_prevent_default) modifiers.push('preventDefault');
    if (has_stop_propagation) modifiers.push('stopPropagation');
    dispatch_dev('SvelteDOMAddEventListener', {
      node: node,
      event: event,
      handler: handler,
      modifiers: modifiers
    });
    var dispose = listen(node, event, handler, options);
    return function () {
      dispatch_dev('SvelteDOMRemoveEventListener', {
        node: node,
        event: event,
        handler: handler,
        modifiers: modifiers
      });
      dispose();
    };
  }

  function attr_dev(node, attribute, value) {
    attr(node, attribute, value);
    if (value == null) dispatch_dev('SvelteDOMRemoveAttribute', {
      node: node,
      attribute: attribute
    });else dispatch_dev('SvelteDOMSetAttribute', {
      node: node,
      attribute: attribute,
      value: value
    });
  }

  function set_data_dev(text, data) {
    data = '' + data;
    if (text.wholeText === data) return;
    dispatch_dev('SvelteDOMSetData', {
      node: text,
      data: data
    });
    text.data = data;
  }

  function validate_each_argument(arg) {
    if (typeof arg !== 'string' && !(arg && _typeof(arg) === 'object' && 'length' in arg)) {
      var msg = '{#each} only iterates over array-like objects.';

      if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
        msg += ' You can use a spread to convert this iterable into an array.';
      }

      throw new Error(msg);
    }
  }

  function validate_slots(name, slot, keys) {
    for (var _i4 = 0, _Object$keys = Object.keys(slot); _i4 < _Object$keys.length; _i4++) {
      var slot_key = _Object$keys[_i4];

      if (!~keys.indexOf(slot_key)) {
        console.warn("<".concat(name, "> received an unexpected slot \"").concat(slot_key, "\"."));
      }
    }
  }

  function validate_dynamic_element(tag) {
    var is_string = typeof tag === 'string';

    if (tag && !is_string) {
      throw new Error('<svelte:element> expects "this" attribute to be a string.');
    }
  }

  function validate_void_dynamic_element(tag) {
    if (tag && is_void(tag)) {
      throw new Error("<svelte:element this=\"".concat(tag, "\"> is self-closing and cannot have content."));
    }
  }

  function cubicOut(t) {
    var f = t - 1.0;
    return f * f * f + 1.0;
  }

  function fade(node) {
    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === void 0 ? 0 : _ref2$delay,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === void 0 ? 400 : _ref2$duration,
        _ref2$easing = _ref2.easing,
        easing = _ref2$easing === void 0 ? identity : _ref2$easing;

    var o = +getComputedStyle(node).opacity;
    return {
      delay: delay,
      duration: duration,
      easing: easing,
      css: function css(t) {
        return "opacity: ".concat(t * o);
      }
    };
  }

  function fly(node) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref3$delay = _ref3.delay,
        delay = _ref3$delay === void 0 ? 0 : _ref3$delay,
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === void 0 ? 400 : _ref3$duration,
        _ref3$easing = _ref3.easing,
        easing = _ref3$easing === void 0 ? cubicOut : _ref3$easing,
        _ref3$x = _ref3.x,
        x = _ref3$x === void 0 ? 0 : _ref3$x,
        _ref3$y = _ref3.y,
        y = _ref3$y === void 0 ? 0 : _ref3$y,
        _ref3$opacity = _ref3.opacity,
        opacity = _ref3$opacity === void 0 ? 0 : _ref3$opacity;

    var style = getComputedStyle(node);
    var target_opacity = +style.opacity;
    var transform = style.transform === 'none' ? '' : style.transform;
    var od = target_opacity * (1 - opacity);
    return {
      delay: delay,
      duration: duration,
      easing: easing,
      css: function css(t, u) {
        return "\n\t\t\ttransform: ".concat(transform, " translate(").concat((1 - t) * x, "px, ").concat((1 - t) * y, "px);\n\t\t\topacity: ").concat(target_opacity - od * u);
      }
    };
  }

  function slide(node) {
    var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref4$delay = _ref4.delay,
        delay = _ref4$delay === void 0 ? 0 : _ref4$delay,
        _ref4$duration = _ref4.duration,
        duration = _ref4$duration === void 0 ? 400 : _ref4$duration,
        _ref4$easing = _ref4.easing,
        easing = _ref4$easing === void 0 ? cubicOut : _ref4$easing;

    var style = getComputedStyle(node);
    var opacity = +style.opacity;
    var height = parseFloat(style.height);
    var padding_top = parseFloat(style.paddingTop);
    var padding_bottom = parseFloat(style.paddingBottom);
    var margin_top = parseFloat(style.marginTop);
    var margin_bottom = parseFloat(style.marginBottom);
    var border_top_width = parseFloat(style.borderTopWidth);
    var border_bottom_width = parseFloat(style.borderBottomWidth);
    return {
      delay: delay,
      duration: duration,
      easing: easing,
      css: function css(t) {
        return 'overflow: hidden;' + "opacity: ".concat(Math.min(t * 20, 1) * opacity, ";") + "height: ".concat(t * height, "px;") + "padding-top: ".concat(t * padding_top, "px;") + "padding-bottom: ".concat(t * padding_bottom, "px;") + "margin-top: ".concat(t * margin_top, "px;") + "margin-bottom: ".concat(t * margin_bottom, "px;") + "border-top-width: ".concat(t * border_top_width, "px;") + "border-bottom-width: ".concat(t * border_bottom_width, "px;");
      }
    };
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var Utils = /*#__PURE__*/function () {
    function Utils() {
      _classCallCheck(this, Utils);
    }

    _createClass(Utils, null, [{
      key: "conserverFocusElement",
      value: function conserverFocusElement(componentShadow, componentRoot) {
        var elementsFocusablesShadow = Array.from(this.obtenirElementsFocusables(componentShadow));
        var elementsFocusablesRoot = Array.from(this.obtenirElementsFocusables(componentRoot));
        var elementsFocusables = elementsFocusablesShadow.concat(elementsFocusablesRoot);
        var premierElementFocusable = elementsFocusables[0];
        var dernierElementFocusable = elementsFocusables[elementsFocusables.length - 1];
        var KEYCODE_TAB = 9;
        componentShadow.addEventListener('keydown', function (e) {
          var estToucheTab = e.key === 'Tab' || e.keyCode === KEYCODE_TAB;

          if (!estToucheTab) {
            return;
          }

          var elementActif = document.activeElement.shadowRoot ? document.activeElement.shadowRoot.activeElement : document.activeElement;

          if (e.shiftKey)
            /* shift + tab */
            {
              if (elementActif === premierElementFocusable) {
                dernierElementFocusable.focus();
                e.preventDefault();
              }
            } else
            /* tab */
            {
              if (elementsFocusables.length === 1 || elementActif === dernierElementFocusable) {
                premierElementFocusable.focus();
                e.preventDefault();
              }
            }
        });
      }
    }, {
      key: "obtenirElementsFocusables",
      value: function obtenirElementsFocusables(element) {
        return element.querySelectorAll('a[href]:not([disabled]), button:not([disabled]), textarea:not([disabled]), input:not([type="hidden"]):not([disabled]), select:not([disabled])');
      }
      /**
       * Génère un id unique.
       * @returns L'id unique généré.
       */

    }, {
      key: "genererId",
      value: function genererId() {
        return Date.now().toString(36) + '-' + Math.random().toString(36).substr(2, 9);
      }
      /**
       * Créé un événement custom pour un webComponent.
       * @param {*} component Objet associé à notre composant (objet DOM).
       * @param {*} nomEvenement Nom de l'événement. 
       * @param {*} detailsEvenement Détails de l'événement.
       */

    }, {
      key: "estMobile",
      value: function estMobile() {
        return navigator.maxTouchPoints || 'ontouchstart' in document.documentElement;
      }
    }, {
      key: "ajusterInterfaceAvantAffichageModale",
      value: function ajusterInterfaceAvantAffichageModale(html, body) {
        if (!this.estMobile()) {
          var largeurScrollbarHtml = window.innerWidth - html.offsetWidth;

          if (largeurScrollbarHtml > 0) {
            html.style['padding-right'] = largeurScrollbarHtml + 'px';
          } else {
            var largeurScrollbarBody = window.innerWidth - body.offsetWidth;

            if (largeurScrollbarBody > 0) {
              body.style['padding-right'] = largeurScrollbarBody + 'px';
            }
          }
        }
        /* On s'assure que le scroll ne changera pas une fois le body modifié avec position fixe */


        var scrollY = window.scrollY;
        html.classList.add("utd-modale-ouverte");
        document.body.style.top = "-".concat(scrollY, "px");
      }
    }, {
      key: "ajusterInterfacePendantAffichageModale",
      value: function ajusterInterfacePendantAffichageModale(body, modale) {
        if (!this.estMobile()) {
          var largeurScrollbarModale = window.innerWidth - modale.offsetWidth;

          if (largeurScrollbarModale > 0) {
            body.style['padding-right'] = largeurScrollbarModale + 'px';
          }
        }
      }
    }, {
      key: "ajusterInterfaceApresFermetureModale",
      value: function ajusterInterfaceApresFermetureModale(html, body) {
        html.style.removeProperty('padding-right');
        body.style.removeProperty('padding-right');
        html.classList.remove("utd-modale-ouverte");
        /* Repositionner l'écran où il était avant l'affichage de la modale. */

        var scrollY = document.body.style.top;
        document.body.style.position = '';
        document.body.style.top = '';
        window.scrollTo(0, parseInt(scrollY || '0') * -1);
      }
    }, {
      key: "slotExiste",
      value: function slotExiste(slots, nomSlot) {
        return slots.some(function (s) {
          return s.slot === nomSlot;
        });
      }
      /**
       * Obtient la langue de la page courante.
       * @returns {string} Code de langue de la page courante (fr/en).
       */

    }, {
      key: "obtenirLanguePage",
      value: function obtenirLanguePage() {
        return document.getElementsByTagName("html")[0].getAttribute("lang") || "fr";
      }
    }]);

    return Utils;
  }();

  _defineProperty(Utils, "dispatchWcEvent", function (component, nomEvenement, detailsEvenement) {
    component.dispatchEvent(new CustomEvent(nomEvenement, {
      detail: detailsEvenement,
      composed: true // propage l'événement à travers le shadow DOM (Remonte au document)

    }));
  });

  function _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$9() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$9 = "src\\librairie\\components\\accordeon.svelte"; // (29:10) {#if titre}


  function create_if_block_2$3(ctx) {
    var t;
    var block = {
      c: function create() {
        t = text(
        /*titre*/
        ctx[1]);
      },
      m: function mount(target, anchor) {
        insert_dev(target, t, anchor);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*titre*/
        2) set_data_dev(t,
        /*titre*/
        ctx[1]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(t);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_2$3.name,
      type: "if",
      source: "(29:10) {#if titre}",
      ctx: ctx
    });
    return block;
  } // (26:4) <svelte:element this={tagTitre} class="titre">


  function create_dynamic_element$1(ctx) {
    var svelte_element;
    var button;
    var span0;
    var t0;
    var slot;
    var t1;
    var span1;
    var span1_class_value;
    var button_aria_expanded_value;
    var mounted;
    var dispose;
    var if_block =
    /*titre*/
    ctx[1] && create_if_block_2$3(ctx);
    var svelte_element_levels = [{
      class: "titre"
    }];
    var svelte_element_data = {};

    for (var i = 0; i < svelte_element_levels.length; i += 1) {
      svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
    }

    var block = {
      c: function create() {
        svelte_element = element(
        /*tagTitre*/
        ctx[3]);
        button = element("button");
        span0 = element("span");
        if (if_block) if_block.c();
        t0 = space();
        slot = element("slot");
        t1 = space();
        span1 = element("span");
        attr_dev(slot, "name", "titre");
        add_location(slot, file$9, 31, 10, 1011);
        attr_dev(span0, "class", "titre");
        add_location(span0, file$9, 27, 8, 918);
        attr_dev(span1, "class", span1_class_value = "utd-icone-svg " + (
        /*reduit*/
        ctx[0] === 'false' ? 'moins' : 'plus'));
        add_location(span1, file$9, 33, 8, 1065);
        attr_dev(button, "type", "button");
        attr_dev(button, "class", "");
        attr_dev(button, "aria-controls",
        /*idContenu*/
        ctx[4]);
        attr_dev(button, "aria-expanded", button_aria_expanded_value =
        /*reduit*/
        ctx[0] === 'false');
        add_location(button, file$9, 26, 6, 778);
        set_attributes(svelte_element, svelte_element_data);
        add_location(svelte_element, file$9, 25, 4, 723);
      },
      m: function mount(target, anchor) {
        insert_dev(target, svelte_element, anchor);
        append_dev(svelte_element, button);
        append_dev(button, span0);
        if (if_block) if_block.m(span0, null);
        append_dev(span0, t0);
        append_dev(span0, slot);
        append_dev(button, t1);
        append_dev(button, span1);

        if (!mounted) {
          dispose = listen_dev(button, "click",
          /*toggleAffichageContenu*/
          ctx[5], false, false, false);
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (
        /*titre*/
        ctx[1]) {
          if (if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block = create_if_block_2$3(ctx);
            if_block.c();
            if_block.m(span0, t0);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }

        if (dirty &
        /*reduit*/
        1 && span1_class_value !== (span1_class_value = "utd-icone-svg " + (
        /*reduit*/
        ctx[0] === 'false' ? 'moins' : 'plus'))) {
          attr_dev(span1, "class", span1_class_value);
        }

        if (dirty &
        /*reduit*/
        1 && button_aria_expanded_value !== (button_aria_expanded_value =
        /*reduit*/
        ctx[0] === 'false')) {
          attr_dev(button, "aria-expanded", button_aria_expanded_value);
        }

        set_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [{
          class: "titre"
        }]));
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(svelte_element);
        if (if_block) if_block.d();
        mounted = false;
        dispose();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_dynamic_element$1.name,
      type: "child_dynamic_element",
      source: "(26:4) <svelte:element this={tagTitre} class=\\\"titre\\\">",
      ctx: ctx
    });
    return block;
  } // (40:6) {#if reduit === 'false'}


  function create_if_block$6(ctx) {
    var div;
    var div_transition;
    var current;

    function select_block_type(ctx, dirty) {
      if (
      /*contenu*/
      ctx[2]) return create_if_block_1$4;
      return create_else_block$2;
    }

    var current_block_type = select_block_type(ctx);
    var if_block = current_block_type(ctx);
    var block = {
      c: function create() {
        div = element("div");
        if_block.c();
        attr_dev(div, "class", "conteneur");
        add_location(div, file$9, 40, 8, 1286);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        if_block.m(div, null);
        current = true;
      },
      p: function update(ctx, dirty) {
        if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block.d(1);
          if_block = current_block_type(ctx);

          if (if_block) {
            if_block.c();
            if_block.m(div, null);
          }
        }
      },
      i: function intro(local) {
        if (current) return;
        add_render_callback(function () {
          if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {
            duration: 250
          }, true);
          div_transition.run(1);
        });
        current = true;
      },
      o: function outro(local) {
        if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {
          duration: 250
        }, false);
        div_transition.run(0);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
        if_block.d();
        if (detaching && div_transition) div_transition.end();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block$6.name,
      type: "if",
      source: "(40:6) {#if reduit === 'false'}",
      ctx: ctx
    });
    return block;
  } // (44:10) {:else}


  function create_else_block$2(ctx) {
    var slot0;
    var t;
    var slot1;
    var block = {
      c: function create() {
        slot0 = element("slot");
        t = space();
        slot1 = element("slot");
        add_location(slot0, file$9, 44, 12, 1432);
        attr_dev(slot1, "name", "contenu");
        add_location(slot1, file$9, 45, 12, 1455);
      },
      m: function mount(target, anchor) {
        insert_dev(target, slot0, anchor);
        insert_dev(target, t, anchor);
        insert_dev(target, slot1, anchor);
      },
      p: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(slot0);
        if (detaching) detach_dev(t);
        if (detaching) detach_dev(slot1);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_else_block$2.name,
      type: "else",
      source: "(44:10) {:else}",
      ctx: ctx
    });
    return block;
  } // (42:10) {#if contenu}


  function create_if_block_1$4(ctx) {
    var html_tag;
    var html_anchor;
    var block = {
      c: function create() {
        html_tag = new HtmlTag(false);
        html_anchor = empty();
        html_tag.a = html_anchor;
      },
      m: function mount(target, anchor) {
        html_tag.m(
        /*contenu*/
        ctx[2], target, anchor);
        insert_dev(target, html_anchor, anchor);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*contenu*/
        4) html_tag.p(
        /*contenu*/
        ctx[2]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(html_anchor);
        if (detaching) html_tag.d();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_1$4.name,
      type: "if",
      source: "(42:10) {#if contenu}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment$9(ctx) {
    var div2;
    var div0;
    var previous_tag =
    /*tagTitre*/
    ctx[3];
    var t2;
    var div1;
    var div2_class_value;
    var t3;
    var link;
    var current;
    validate_dynamic_element(
    /*tagTitre*/
    ctx[3]);
    validate_void_dynamic_element(
    /*tagTitre*/
    ctx[3]);
    var svelte_element =
    /*tagTitre*/
    ctx[3] && create_dynamic_element$1(ctx);
    var if_block1 =
    /*reduit*/
    ctx[0] === 'false' && create_if_block$6(ctx);
    var block = {
      c: function create() {
        div2 = element("div");
        div0 = element("div");
        if (svelte_element) svelte_element.c();
        t2 = space();
        div1 = element("div");
        if (if_block1) if_block1.c();
        t3 = space();
        link = element("link");
        this.c = noop;
        attr_dev(div0, "class", "entete");
        add_location(div0, file$9, 24, 2, 697);
        attr_dev(div1, "id",
        /*idContenu*/
        ctx[4]);
        attr_dev(div1, "class", "contenu");
        add_location(div1, file$9, 38, 4, 1205);
        attr_dev(div2, "class", div2_class_value = "utd-component utd-accordeon " + (
        /*reduit*/
        ctx[0] === 'false' ? 'ouvert' : ''));
        add_location(div2, file$9, 23, 0, 614);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", "/css/utd-webcomponents.min.css");
        add_location(link, file$9, 53, 0, 1550);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div2, anchor);
        append_dev(div2, div0);
        if (svelte_element) svelte_element.m(div0, null);
        append_dev(div2, t2);
        append_dev(div2, div1);
        if (if_block1) if_block1.m(div1, null);
        insert_dev(target, t3, anchor);
        insert_dev(target, link, anchor);
        current = true;
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        if (
        /*tagTitre*/
        ctx[3]) {
          if (!previous_tag) {
            svelte_element = create_dynamic_element$1(ctx);
            svelte_element.c();
            svelte_element.m(div0, null);
          } else if (safe_not_equal(previous_tag,
          /*tagTitre*/
          ctx[3])) {
            svelte_element.d(1);
            validate_dynamic_element(
            /*tagTitre*/
            ctx[3]);
            validate_void_dynamic_element(
            /*tagTitre*/
            ctx[3]);
            svelte_element = create_dynamic_element$1(ctx);
            svelte_element.c();
            svelte_element.m(div0, null);
          } else {
            svelte_element.p(ctx, dirty);
          }
        } else if (previous_tag) {
          svelte_element.d(1);
          svelte_element = null;
        }

        previous_tag =
        /*tagTitre*/
        ctx[3];

        if (
        /*reduit*/
        ctx[0] === 'false') {
          if (if_block1) {
            if_block1.p(ctx, dirty);

            if (dirty &
            /*reduit*/
            1) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block$6(ctx);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(div1, null);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, function () {
            if_block1 = null;
          });
          check_outros();
        }

        if (!current || dirty &
        /*reduit*/
        1 && div2_class_value !== (div2_class_value = "utd-component utd-accordeon " + (
        /*reduit*/
        ctx[0] === 'false' ? 'ouvert' : ''))) {
          attr_dev(div2, "class", div2_class_value);
        }
      },
      i: function intro(local) {
        if (current) return;
        transition_in(if_block1);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block1);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div2);
        if (svelte_element) svelte_element.d(detaching);
        if (if_block1) if_block1.d();
        if (detaching) detach_dev(t3);
        if (detaching) detach_dev(link);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$9.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function instance$9($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-accordeon', slots, []);
    var _$$props$reduit = $$props.reduit,
        reduit = _$$props$reduit === void 0 ? "true" : _$$props$reduit;
    var _$$props$titre = $$props.titre,
        titre = _$$props$titre === void 0 ? "" : _$$props$titre;
    var _$$props$contenu = $$props.contenu,
        contenu = _$$props$contenu === void 0 ? "" : _$$props$contenu;
    var _$$props$tagTitre = $$props.tagTitre,
        tagTitre = _$$props$tagTitre === void 0 ? "h2" : _$$props$tagTitre;
    var idEntete = Utils.genererId();
    var idContenu = 'corps' + idEntete;

    function toggleAffichageContenu() {
      $$invalidate(0, reduit = reduit === 'true' ? 'false' : 'true');
    }

    var writable_props = ['reduit', 'titre', 'contenu', 'tagTitre'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-accordeon> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('reduit' in $$props) $$invalidate(0, reduit = $$props.reduit);
      if ('titre' in $$props) $$invalidate(1, titre = $$props.titre);
      if ('contenu' in $$props) $$invalidate(2, contenu = $$props.contenu);
      if ('tagTitre' in $$props) $$invalidate(3, tagTitre = $$props.tagTitre);
    };

    $$self.$capture_state = function () {
      return {
        slide: slide,
        Utils: Utils,
        reduit: reduit,
        titre: titre,
        contenu: contenu,
        tagTitre: tagTitre,
        idEntete: idEntete,
        idContenu: idContenu,
        toggleAffichageContenu: toggleAffichageContenu
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('reduit' in $$props) $$invalidate(0, reduit = $$props.reduit);
      if ('titre' in $$props) $$invalidate(1, titre = $$props.titre);
      if ('contenu' in $$props) $$invalidate(2, contenu = $$props.contenu);
      if ('tagTitre' in $$props) $$invalidate(3, tagTitre = $$props.tagTitre);
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    return [reduit, titre, contenu, tagTitre, idContenu, toggleAffichageContenu];
  }

  var Accordeon = /*#__PURE__*/function (_SvelteElement) {
    _inherits(Accordeon, _SvelteElement);

    var _super = _createSuper$9(Accordeon);

    function Accordeon(options) {
      var _this;

      _classCallCheck(this, Accordeon);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$9, create_fragment$9, safe_not_equal, {
        reduit: 0,
        titre: 1,
        contenu: 2,
        tagTitre: 3
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(Accordeon, [{
      key: "reduit",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(reduit) {
        this.$$set({
          reduit: reduit
        });
        flush();
      }
    }, {
      key: "titre",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(titre) {
        this.$$set({
          titre: titre
        });
        flush();
      }
    }, {
      key: "contenu",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(contenu) {
        this.$$set({
          contenu: contenu
        });
        flush();
      }
    }, {
      key: "tagTitre",
      get: function get() {
        return this.$$.ctx[3];
      },
      set: function set(tagTitre) {
        this.$$set({
          tagTitre: tagTitre
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["reduit", "titre", "contenu", "tagTitre"];
      }
    }]);

    return Accordeon;
  }(SvelteElement);

  customElements.define("utd-accordeon", Accordeon);

  function _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$8() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$8 = "src\\librairie\\components\\avis.svelte"; // (22:6) {#if contenu}

  function create_if_block$5(ctx) {
    var html_tag;
    var html_anchor;
    var block = {
      c: function create() {
        html_tag = new HtmlTag(false);
        html_anchor = empty();
        html_tag.a = html_anchor;
      },
      m: function mount(target, anchor) {
        html_tag.m(
        /*contenu*/
        ctx[2], target, anchor);
        insert_dev(target, html_anchor, anchor);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*contenu*/
        4) html_tag.p(
        /*contenu*/
        ctx[2]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(html_anchor);
        if (detaching) html_tag.d();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block$5.name,
      type: "if",
      source: "(22:6) {#if contenu}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment$8(ctx) {
    var div4;
    var div1;
    var div0;
    var div0_class_value;
    var t0;
    var div3;
    var h2;
    var t1;
    var t2;
    var div2;
    var t3;
    var slot;
    var div4_class_value;
    var div4_role_value;
    var t4;
    var link;
    var if_block =
    /*contenu*/
    ctx[2] && create_if_block$5(ctx);
    var block = {
      c: function create() {
        div4 = element("div");
        div1 = element("div");
        div0 = element("div");
        t0 = space();
        div3 = element("div");
        h2 = element("h2");
        t1 = text(
        /*titre*/
        ctx[0]);
        t2 = space();
        div2 = element("div");
        if (if_block) if_block.c();
        t3 = space();
        slot = element("slot");
        t4 = space();
        link = element("link");
        this.c = noop;
        attr_dev(div0, "aria-hidden", "true");
        attr_dev(div0, "class", div0_class_value = "utd-icone-svg " +
        /*type*/
        ctx[1]);
        add_location(div0, file$8, 14, 4, 406);
        attr_dev(div1, "class", "zone-icone");
        add_location(div1, file$8, 13, 2, 376);
        attr_dev(h2, "class", "titre");
        add_location(h2, file$8, 17, 4, 516);
        attr_dev(slot, "name", "contenu");
        add_location(slot, file$8, 24, 6, 658);
        attr_dev(div2, "class", "texte");
        add_location(div2, file$8, 20, 4, 566);
        attr_dev(div3, "class", "contenu zone-html");
        add_location(div3, file$8, 16, 2, 479);
        attr_dev(div4, "class", div4_class_value = "utd-component utd-avis " +
        /*type*/
        ctx[1]);
        attr_dev(div4, "role", div4_role_value =
        /*type*/
        ctx[1] === 'erreur' ||
        /*type*/
        ctx[1] === 'avertissement' ? 'alert' : null);
        add_location(div4, file$8, 12, 0, 257);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", "/css/utd-webcomponents.min.css");
        add_location(link, file$8, 29, 0, 715);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div4, anchor);
        append_dev(div4, div1);
        append_dev(div1, div0);
        append_dev(div4, t0);
        append_dev(div4, div3);
        append_dev(div3, h2);
        append_dev(h2, t1);
        append_dev(div3, t2);
        append_dev(div3, div2);
        if (if_block) if_block.m(div2, null);
        append_dev(div2, t3);
        append_dev(div2, slot);
        insert_dev(target, t4, anchor);
        insert_dev(target, link, anchor);
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        if (dirty &
        /*type*/
        2 && div0_class_value !== (div0_class_value = "utd-icone-svg " +
        /*type*/
        ctx[1])) {
          attr_dev(div0, "class", div0_class_value);
        }

        if (dirty &
        /*titre*/
        1) set_data_dev(t1,
        /*titre*/
        ctx[0]);

        if (
        /*contenu*/
        ctx[2]) {
          if (if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block = create_if_block$5(ctx);
            if_block.c();
            if_block.m(div2, t3);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }

        if (dirty &
        /*type*/
        2 && div4_class_value !== (div4_class_value = "utd-component utd-avis " +
        /*type*/
        ctx[1])) {
          attr_dev(div4, "class", div4_class_value);
        }

        if (dirty &
        /*type*/
        2 && div4_role_value !== (div4_role_value =
        /*type*/
        ctx[1] === 'erreur' ||
        /*type*/
        ctx[1] === 'avertissement' ? 'alert' : null)) {
          attr_dev(div4, "role", div4_role_value);
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(div4);
        if (if_block) if_block.d();
        if (detaching) detach_dev(t4);
        if (detaching) detach_dev(link);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$8.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function instance$8($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-avis', slots, []);
    var _$$props$titre = $$props.titre,
        titre = _$$props$titre === void 0 ? "" : _$$props$titre;
    var _$$props$type = $$props.type,
        type = _$$props$type === void 0 ? "information" : _$$props$type;
    var _$$props$contenu = $$props.contenu,
        contenu = _$$props$contenu === void 0 ? "" : _$$props$contenu;
    var writable_props = ['titre', 'type', 'contenu'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-avis> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
      if ('type' in $$props) $$invalidate(1, type = $$props.type);
      if ('contenu' in $$props) $$invalidate(2, contenu = $$props.contenu);
    };

    $$self.$capture_state = function () {
      return {
        titre: titre,
        type: type,
        contenu: contenu
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
      if ('type' in $$props) $$invalidate(1, type = $$props.type);
      if ('contenu' in $$props) $$invalidate(2, contenu = $$props.contenu);
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    return [titre, type, contenu];
  }

  var Avis = /*#__PURE__*/function (_SvelteElement) {
    _inherits(Avis, _SvelteElement);

    var _super = _createSuper$8(Avis);

    function Avis(options) {
      var _this;

      _classCallCheck(this, Avis);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$8, create_fragment$8, safe_not_equal, {
        titre: 0,
        type: 1,
        contenu: 2
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(Avis, [{
      key: "titre",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(titre) {
        this.$$set({
          titre: titre
        });
        flush();
      }
    }, {
      key: "type",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(type) {
        this.$$set({
          type: type
        });
        flush();
      }
    }, {
      key: "contenu",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(contenu) {
        this.$$set({
          contenu: contenu
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["titre", "type", "contenu"];
      }
    }]);

    return Avis;
  }(SvelteElement);

  customElements.define("utd-avis", Avis);

  function _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$7 = "src\\librairie\\components\\champForm.svelte";

  function create_fragment$7(ctx) {
    var slot;
    var t;
    var link;
    var block = {
      c: function create() {
        slot = element("slot");
        t = space();
        link = element("link");
        this.c = noop;
        add_location(slot, file$7, 380, 0, 11361);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", "/css/utd-webcomponents.min.css");
        add_location(link, file$7, 382, 0, 11372);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, slot, anchor);
        insert_dev(target, t, anchor);
        insert_dev(target, link, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(slot);
        if (detaching) detach_dev(t);
        if (detaching) detach_dev(link);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$7.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function instance$7($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-champ-form', slots, []);
    var _$$props$obligatoire = $$props.obligatoire,
        obligatoire = _$$props$obligatoire === void 0 ? "false" : _$$props$obligatoire;
    var _$$props$invalide = $$props.invalide,
        invalide = _$$props$invalide === void 0 ? "false" : _$$props$invalide;
    var _$$props$format = $$props.format,
        format = _$$props$format === void 0 ? null : _$$props$format;
    var _$$props$libelle = $$props.libelle,
        libelle = _$$props$libelle === void 0 ? "" : _$$props$libelle;
    var _$$props$precision = $$props.precision,
        precision = _$$props$precision === void 0 ? "" : _$$props$precision;
    var _$$props$messageErreu = $$props.messageErreur,
        messageErreur = _$$props$messageErreu === void 0 ? "" : _$$props$messageErreu;
    var mounted = false;
    var typeChamp = null;
    var elementLabel = null;
    var elementWrapper = null;
    var elementIndicateurObligatoire = null;
    var elementObligatoireTexte = null;
    var elementChamp = null;
    var elementPrecision = null;
    var elementErreur = null;
    var idElementErreur = null;
    var idChamp = Utils.genererId();
    var idParentUtd = Utils.genererId();
    var idLabelInitial = Utils.genererId();
    var idPrecisionInitial = Utils.genererId();
    var idErreurInitial = Utils.genererId();
    var thisComponent = get_current_component();
    var texteSrChampObligatoire = Utils.obtenirLanguePage() === 'fr' ? ' obligatoire ' : ' required ';
    /* ===========================================================================================
     RÉFÉRENCES
    
     - Liste de boutons radio et checkbox
       https://blog.tenon.io/accessible-validation-of-checkbox-and-radiobutton-groups/
    
    =============================================================================================*/

    onMount(function () {
      typeChamp = obtenirTypeChamp();
      mounted = true;

      if (typeChamp) {
        wrapperControles();
        gererChamp();
        gererLabel();
        gererChampObligatoire();

        if (typeChamp !== 'checkbox-seul') {
          gererPrecision();
        }

        gererErreur();
      }
    });

    function wrapperControles() {
      elementWrapper = document.createElement('div');
      var classeType = typeChamp === 'checkbox-seul' ? 'checkbox' : typeChamp;
      elementWrapper.classList.add('utd-form-group', classeType);
      thisComponent.childNodes.forEach(function (element) {
        elementWrapper.append(element);

        if (typeChamp === 'radio') {
          elementWrapper.setAttribute('role', 'radiogroup');
        }

        if (typeChamp === 'checkbox') {
          elementWrapper.setAttribute('role', 'group');
        }
      });
      thisComponent.prepend(elementWrapper);
    }

    function gererChamp() {
      elementChamp.id = elementChamp.id || idChamp;
      var idUtd = thisComponent.id || idParentUtd;
      elementChamp.setAttribute('idutd', idUtd);
      thisComponent.id = idUtd;

      if (typeChamp === 'standard' || typeChamp === 'select' || typeChamp === 'textarea') {
        elementChamp.classList.add('utd-form-control');

        if (format) {
          elementChamp.classList.add(format);
        }
      }
    }

    function obtenirTypeChamp() {
      var input = thisComponent.querySelector("input");

      if (input) {
        elementChamp = input;
        var type = input.getAttribute("type");

        if (type === 'radio') {
          return type;
        } else if (type === 'checkbox') {
          return thisComponent.querySelectorAll("input").length > 1 ? 'checkbox' : 'checkbox-seul';
        } else if (type === 'button' || type === 'submit') {
          return null;
        } else {
          return 'standard';
        }
      } else if (thisComponent.querySelector("textarea")) {
        elementChamp = thisComponent.querySelector("textarea");
        return 'standard';
      } else if (thisComponent.querySelector("select")) {
        elementChamp = thisComponent.querySelector("select");
        return 'select';
      } else {
        return null;
      }
    }

    function gererLabel() {
      if (!mounted) {
        return;
      }

      if (estGroupeControles()) {
        elementLabel = thisComponent.querySelector(".label");
      } else {
        elementLabel = thisComponent.querySelector("label");
      }

      if (elementLabel) {
        //Le label existe déjà. On s'assure qu'il est bien lié au champ.
        if (estGroupeControles()) {
          if (!elementLabel.id) {
            elementLabel.id = idLabelInitial;
          }

          ajusterChampAriaDescribedBy('ajout', elementLabel.id);
        } else {
          elementLabel.setAttribute('for', elementChamp.id);
        }

        if (libelle) {
          elementLabel.innerText = libelle;
        }
      } else if (libelle) {
        //Le contrôle label n'existe pas      
        var _element;

        if (estGroupeControles()) {
          _element = document.createElement('span');

          _element.classList.add('label');

          _element.id = idLabelInitial;
          ajusterChampAriaDescribedBy('ajout', _element.id, typeChamp === 'radio' ? 'aria-labelledby' : null);
        } else {
          _element = document.createElement('label');

          _element.setAttribute('for', elementChamp.id);
        }

        _element.innerText = libelle;
        elementWrapper.prepend(_element);
        elementLabel = _element;
      }
    }

    function gererPrecision() {
      if (!mounted) {
        return;
      }

      if (elementLabel) {
        elementPrecision = thisComponent.querySelector(".utd-precision");

        if (precision) {
          if (elementPrecision) {
            elementPrecision.id = elementPrecision.id || idPrecisionInitial;
          } else {
            var span = document.createElement('span');
            span.classList.add("utd-precision");
            span.id = idPrecisionInitial;
            elementPrecision = span;
            elementLabel.after(elementPrecision);
          }

          elementPrecision.innerText = precision;
          ajusterChampAriaDescribedBy('ajout', elementPrecision.id);
        } else {
          //Pas de précision en paramètre
          if (elementPrecision) {
            //Contrôle précision dans le HTML
            elementPrecision.id = elementPrecision.id || idPrecisionInitial;
            ajusterChampAriaDescribedBy('ajout', elementPrecision.id);
          } else {
            //Pas de contrôle de précision dans le html, on retire la précision du aria-describedby
            ajusterChampAriaDescribedBy('retrait', idPrecisionInitial);
          }
        }
      }
    }

    function ajusterChampAriaDescribedBy() {
      var operation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'ajout';
      var valeur = arguments.length > 1 ? arguments[1] : undefined;
      var aria = arguments.length > 2 ? arguments[2] : undefined;
      var attribut;

      if (aria) {
        attribut = aria;
      } else {
        attribut = typeChamp === 'checkbox' ? 'aria-labelledby' : 'aria-describedby';
      }

      var controle = elementChamp;

      if (estGroupeControles()) {
        controle = elementWrapper;
      }

      var valeurActuelle = controle.getAttribute(attribut) || '';
      var nouvelleValeur = '';

      if (operation === 'ajout') {
        nouvelleValeur = valeurActuelle + (valeurActuelle.indexOf(valeur) >= 0 ? '' : ' ' + valeur);
      } else {
        nouvelleValeur = valeurActuelle.replace(valeur, '');
      }

      if (nouvelleValeur.trim()) {
        controle.setAttribute(attribut, nouvelleValeur.trim());
      } else {
        controle.removeAttribute(attribut);
      }
    }

    function gererChampObligatoire() {
      if (!mounted) {
        return;
      }

      if (elementLabel) {
        elementIndicateurObligatoire = thisComponent.querySelector(".utd-icone-champ-requis");
        elementObligatoireTexte = thisComponent.querySelector(".texte-obligatoire");

        if (obligatoire === 'true') {
          if (typeChamp === 'checkbox') {
            //Pour les listes de checkbox, on doit ajouter un texte hors écran afin d'indiquer que le champ est obligatoire (aria-required ne fonctionne pas pour ces types de champs).
            elementObligatoireTexte = thisComponent.querySelector(".texte-obligatoire");

            if (!elementObligatoireTexte) {
              elementObligatoireTexte = document.createElement('span');
              elementObligatoireTexte.classList.add("texte-obligatoire", "utd-sr-only");
              elementObligatoireTexte.innerHTML = texteSrChampObligatoire;
              elementLabel.append(elementObligatoireTexte);
            }
          }

          if (!elementIndicateurObligatoire) {
            elementIndicateurObligatoire = document.createElement('span');
            elementIndicateurObligatoire.classList.add("utd-icone-champ-requis");
            elementIndicateurObligatoire.innerHTML = "*";
            elementLabel.append(elementIndicateurObligatoire);
          }

          elementIndicateurObligatoire.setAttribute('aria-hidden', 'true');
        } else {
          if (elementIndicateurObligatoire) {
            elementIndicateurObligatoire.remove();
          }

          if (elementObligatoireTexte) {
            elementObligatoireTexte.remove();
          }
        }
      }

      if (obligatoire === 'true' && typeChamp !== 'checkbox') {
        if (typeChamp === 'radio') {
          elementWrapper.setAttribute('aria-required', 'true');
        } else {
          elementChamp.setAttribute('aria-required', 'true');
        }
      } else {
        if (typeChamp === 'radio') {
          elementWrapper.removeAttribute('aria-required');
        } else {
          elementChamp.removeAttribute('aria-required');
        }
      }
    }

    function gererErreur() {
      if (!mounted) {
        return;
      }

      var controle = elementChamp;

      if (estGroupeControles()) {
        controle = elementWrapper;
      }

      elementErreur = thisComponent.querySelector(".utd-erreur-champ");

      if (invalide === 'true') {
        if (elementErreur) {
          elementErreur.id = elementErreur.id || idErreurInitial;
        } else {
          var span = document.createElement('span');
          span.classList.add("utd-erreur-champ");
          span.id = idErreurInitial;
          elementErreur = span;

          if (typeChamp === 'checkbox-seul') {
            elementLabel.after(elementErreur);
          } else {
            if (estGroupeControles()) {
              elementWrapper.append(elementErreur);
            } else {
              elementChamp.after(elementErreur);
            }
          }
        }

        if (messageErreur) {
          elementErreur.innerText = messageErreur;
        }

        idElementErreur = elementErreur.id;
        var attribut = typeChamp === 'checkbox' ? 'aria-labelledby' : 'aria-describedby';
        var descByAvant = controle.getAttribute(attribut);
        controle.setAttribute(attribut, elementErreur.id);

        if (typeChamp !== 'checkbox') {
          controle.setAttribute('aria-invalid', 'true');
        } //setTimeout nécessaire pour lecteur écran


        if (descByAvant) {
          setTimeout(function () {
            controle.setAttribute(attribut, "".concat(descByAvant, " ").concat(idElementErreur));
          }, 100);
        }

        elementErreur.classList.remove('utd-d-none');
      } else {
        controle.removeAttribute('aria-invalid');

        if (elementErreur) {
          elementErreur.classList.add('utd-d-none');

          if (messageErreur) {
            elementErreur.innerText = messageErreur;
          }
        }

        if (idElementErreur) {
          setTimeout(function () {
            ajusterChampAriaDescribedBy('retrait', idElementErreur);
          }, 100);
        }
      }
    }

    function estGroupeControles() {
      return typeChamp === 'checkbox' || typeChamp === 'radio';
    }

    var writable_props = ['obligatoire', 'invalide', 'format', 'libelle', 'precision', 'messageErreur'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-champ-form> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('obligatoire' in $$props) $$invalidate(0, obligatoire = $$props.obligatoire);
      if ('invalide' in $$props) $$invalidate(1, invalide = $$props.invalide);
      if ('format' in $$props) $$invalidate(2, format = $$props.format);
      if ('libelle' in $$props) $$invalidate(3, libelle = $$props.libelle);
      if ('precision' in $$props) $$invalidate(4, precision = $$props.precision);
      if ('messageErreur' in $$props) $$invalidate(5, messageErreur = $$props.messageErreur);
    };

    $$self.$capture_state = function () {
      return {
        Utils: Utils,
        get_current_component: get_current_component,
        onMount: onMount,
        obligatoire: obligatoire,
        invalide: invalide,
        format: format,
        libelle: libelle,
        precision: precision,
        messageErreur: messageErreur,
        mounted: mounted,
        typeChamp: typeChamp,
        elementLabel: elementLabel,
        elementWrapper: elementWrapper,
        elementIndicateurObligatoire: elementIndicateurObligatoire,
        elementObligatoireTexte: elementObligatoireTexte,
        elementChamp: elementChamp,
        elementPrecision: elementPrecision,
        elementErreur: elementErreur,
        idElementErreur: idElementErreur,
        idChamp: idChamp,
        idParentUtd: idParentUtd,
        idLabelInitial: idLabelInitial,
        idPrecisionInitial: idPrecisionInitial,
        idErreurInitial: idErreurInitial,
        thisComponent: thisComponent,
        texteSrChampObligatoire: texteSrChampObligatoire,
        wrapperControles: wrapperControles,
        gererChamp: gererChamp,
        obtenirTypeChamp: obtenirTypeChamp,
        gererLabel: gererLabel,
        gererPrecision: gererPrecision,
        ajusterChampAriaDescribedBy: ajusterChampAriaDescribedBy,
        gererChampObligatoire: gererChampObligatoire,
        gererErreur: gererErreur,
        estGroupeControles: estGroupeControles
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('obligatoire' in $$props) $$invalidate(0, obligatoire = $$props.obligatoire);
      if ('invalide' in $$props) $$invalidate(1, invalide = $$props.invalide);
      if ('format' in $$props) $$invalidate(2, format = $$props.format);
      if ('libelle' in $$props) $$invalidate(3, libelle = $$props.libelle);
      if ('precision' in $$props) $$invalidate(4, precision = $$props.precision);
      if ('messageErreur' in $$props) $$invalidate(5, messageErreur = $$props.messageErreur);
      if ('mounted' in $$props) mounted = $$props.mounted;
      if ('typeChamp' in $$props) typeChamp = $$props.typeChamp;
      if ('elementLabel' in $$props) elementLabel = $$props.elementLabel;
      if ('elementWrapper' in $$props) elementWrapper = $$props.elementWrapper;
      if ('elementIndicateurObligatoire' in $$props) elementIndicateurObligatoire = $$props.elementIndicateurObligatoire;
      if ('elementObligatoireTexte' in $$props) elementObligatoireTexte = $$props.elementObligatoireTexte;
      if ('elementChamp' in $$props) elementChamp = $$props.elementChamp;
      if ('elementPrecision' in $$props) elementPrecision = $$props.elementPrecision;
      if ('elementErreur' in $$props) elementErreur = $$props.elementErreur;
      if ('idElementErreur' in $$props) idElementErreur = $$props.idElementErreur;
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    $$self.$$.update = function () {
      if ($$self.$$.dirty[0] &
      /*libelle*/
      8) {
        gererLabel();
      }

      if ($$self.$$.dirty[0] &
      /*obligatoire*/
      1) {
        gererChampObligatoire();
      }

      if ($$self.$$.dirty[0] &
      /*precision*/
      16) {
        gererPrecision();
      }

      if ($$self.$$.dirty[0] &
      /*messageErreur*/
      32) {
        gererErreur();
      }

      if ($$self.$$.dirty[0] &
      /*invalide*/
      2) {
        gererErreur();
      }
    };

    return [obligatoire, invalide, format, libelle, precision, messageErreur];
  }

  var ChampForm = /*#__PURE__*/function (_SvelteElement) {
    _inherits(ChampForm, _SvelteElement);

    var _super = _createSuper$7(ChampForm);

    function ChampForm(options) {
      var _this;

      _classCallCheck(this, ChampForm);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$7, create_fragment$7, safe_not_equal, {
        obligatoire: 0,
        invalide: 1,
        format: 2,
        libelle: 3,
        precision: 4,
        messageErreur: 5
      }, null, [-1, -1]);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(ChampForm, [{
      key: "obligatoire",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(obligatoire) {
        this.$$set({
          obligatoire: obligatoire
        });
        flush();
      }
    }, {
      key: "invalide",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(invalide) {
        this.$$set({
          invalide: invalide
        });
        flush();
      }
    }, {
      key: "format",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(format) {
        this.$$set({
          format: format
        });
        flush();
      }
    }, {
      key: "libelle",
      get: function get() {
        return this.$$.ctx[3];
      },
      set: function set(libelle) {
        this.$$set({
          libelle: libelle
        });
        flush();
      }
    }, {
      key: "precision",
      get: function get() {
        return this.$$.ctx[4];
      },
      set: function set(precision) {
        this.$$set({
          precision: precision
        });
        flush();
      }
    }, {
      key: "messageErreur",
      get: function get() {
        return this.$$.ctx[5];
      },
      set: function set(messageErreur) {
        this.$$set({
          messageErreur: messageErreur
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["obligatoire", "invalide", "format", "libelle", "precision", "messageErreur"];
      }
    }]);

    return ChampForm;
  }(SvelteElement);

  customElements.define("utd-champ-form", ChampForm);

  function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$6 = "src\\librairie\\components\\dialogueModal.svelte"; // (146:0) {#if estModaleAffichee}

  function create_if_block$4(ctx) {
    var div0;
    var t0;
    var div5;
    var div4;
    var button;
    var span;
    var t1;
    var div3;
    var div1;
    var t2;
    var h1;
    var t3;
    var div1_class_value;
    var t4;
    var div2;
    var slot0;
    var t5;
    var slot1;
    var t6;
    var show_if = Utils.slotExiste(
    /*slots*/
    ctx[8], 'pied');
    var div5_aria_describedby_value;
    var div5_class_value;
    var div5_intro;
    var div5_outro;
    var current;
    var mounted;
    var dispose;
    var if_block0 =
    /*type*/
    ctx[0] && create_if_block_2$2(ctx);
    var if_block1 = show_if && create_if_block_1$3(ctx);
    var block = {
      c: function create() {
        div0 = element("div");
        t0 = space();
        div5 = element("div");
        div4 = element("div");
        button = element("button");
        span = element("span");
        t1 = space();
        div3 = element("div");
        div1 = element("div");
        if (if_block0) if_block0.c();
        t2 = space();
        h1 = element("h1");
        t3 = text(
        /*titre*/
        ctx[2]);
        t4 = space();
        div2 = element("div");
        slot0 = element("slot");
        t5 = space();
        slot1 = element("slot");
        t6 = space();
        if (if_block1) if_block1.c();
        attr_dev(div0, "class", "utd-backdrop");
        add_location(div0, file$6, 146, 2, 5062);
        attr_dev(span, "aria-hidden", "true");
        attr_dev(span, "class", "utd-icone-svg x-fermer-bleu");
        add_location(span, file$6, 171, 8, 6079);
        attr_dev(button, "type", "button");
        attr_dev(button, "class", "close");
        attr_dev(button, "aria-label",
        /*srBoutonFermer*/
        ctx[3]);
        add_location(button, file$6, 165, 8, 5914);
        attr_dev(h1, "id",
        /*idEntete*/
        ctx[10]);
        attr_dev(h1, "class", "titre-dialog");
        add_location(h1, file$6, 181, 10, 6406);
        attr_dev(div1, "class", div1_class_value = "entete " + (
        /*type*/
        ctx[0] ? 'avec-type' : ''));
        add_location(div1, file$6, 177, 8, 6231);
        add_location(slot0, file$6, 186, 10, 6554);
        attr_dev(slot1, "name", "contenu");
        add_location(slot1, file$6, 187, 10, 6573);
        attr_dev(div2, "class", "corps");
        attr_dev(div2, "id",
        /*idCorps*/
        ctx[11]);
        add_location(div2, file$6, 185, 8, 6510);
        attr_dev(div3, "class", "principal");
        add_location(div3, file$6, 176, 6, 6198);
        attr_dev(div4, "class", "conteneur");
        add_location(div4, file$6, 164, 4, 5881);
        attr_dev(div5, "tabindex", "-1");
        attr_dev(div5, "aria-labelledby",
        /*idEntete*/
        ctx[10]);
        attr_dev(div5, "aria-describedby", div5_aria_describedby_value =
        /*estfenetremessage*/
        ctx[1] === 'true' ?
        /*idCorps*/
        ctx[11] : null);
        attr_dev(div5, "class", div5_class_value = "utd-component utd-dialog " + (
        /*estfenetremessage*/
        ctx[1] === 'true' ? 'fenetre-message' : '') + " " + (
        /*estboutonstextelong*/
        ctx[4] === 'true' ? 'boutons-texte-long' : '') + " " + (
        /*estaffichagelateral*/
        ctx[6] === 'true' ? 'affichage-lateral' : '') + " " + (
        /*estaffichageboutonsinline*/
        ctx[5] === 'true' ? 'boutons-inline' : ''));
        attr_dev(div5, "id",
        /*idModale*/
        ctx[9]);
        attr_dev(div5, "aria-modal", "true");
        attr_dev(div5, "role", "dialog");
        add_location(div5, file$6, 147, 2, 5142);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div0, anchor);
        insert_dev(target, t0, anchor);
        insert_dev(target, div5, anchor);
        append_dev(div5, div4);
        append_dev(div4, button);
        append_dev(button, span);
        append_dev(div4, t1);
        append_dev(div4, div3);
        append_dev(div3, div1);
        if (if_block0) if_block0.m(div1, null);
        append_dev(div1, t2);
        append_dev(div1, h1);
        append_dev(h1, t3);
        append_dev(div3, t4);
        append_dev(div3, div2);
        append_dev(div2, slot0);
        append_dev(div2, t5);
        append_dev(div2, slot1);
        append_dev(div3, t6);
        if (if_block1) if_block1.m(div3, null);
        current = true;

        if (!mounted) {
          dispose = [listen_dev(div0, "click",
          /*click_handler*/
          ctx[25], false, false, false), listen_dev(button, "click",
          /*click_handler_1*/
          ctx[26], false, false, false), listen_dev(div5, "click",
          /*clickModale*/
          ctx[16], false, false, false), listen_dev(div5, "keydown",
          /*keydown*/
          ctx[15], false, false, false), listen_dev(div5, "introstart",
          /*ajusterModaleDebutAffichage*/
          ctx[18], false, false, false), listen_dev(div5, "introend",
          /*ajusterModaleFinAffichage*/
          ctx[19], false, false, false), listen_dev(div5, "outroend",
          /*finAnimationFermeture*/
          ctx[17], false, false, false)];
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (!current || dirty[0] &
        /*srBoutonFermer*/
        8) {
          attr_dev(button, "aria-label",
          /*srBoutonFermer*/
          ctx[3]);
        }

        if (
        /*type*/
        ctx[0]) {
          if (if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0 = create_if_block_2$2(ctx);
            if_block0.c();
            if_block0.m(div1, t2);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }

        if (!current || dirty[0] &
        /*titre*/
        4) set_data_dev(t3,
        /*titre*/
        ctx[2]);

        if (!current || dirty[0] &
        /*type*/
        1 && div1_class_value !== (div1_class_value = "entete " + (
        /*type*/
        ctx[0] ? 'avec-type' : ''))) {
          attr_dev(div1, "class", div1_class_value);
        }

        if (dirty[0] &
        /*slots*/
        256) show_if = Utils.slotExiste(
        /*slots*/
        ctx[8], 'pied');

        if (show_if) {
          if (if_block1) ; else {
            if_block1 = create_if_block_1$3(ctx);
            if_block1.c();
            if_block1.m(div3, null);
          }
        } else if (if_block1) {
          if_block1.d(1);
          if_block1 = null;
        }

        if (!current || dirty[0] &
        /*estfenetremessage*/
        2 && div5_aria_describedby_value !== (div5_aria_describedby_value =
        /*estfenetremessage*/
        ctx[1] === 'true' ?
        /*idCorps*/
        ctx[11] : null)) {
          attr_dev(div5, "aria-describedby", div5_aria_describedby_value);
        }

        if (!current || dirty[0] &
        /*estfenetremessage, estboutonstextelong, estaffichagelateral, estaffichageboutonsinline*/
        114 && div5_class_value !== (div5_class_value = "utd-component utd-dialog " + (
        /*estfenetremessage*/
        ctx[1] === 'true' ? 'fenetre-message' : '') + " " + (
        /*estboutonstextelong*/
        ctx[4] === 'true' ? 'boutons-texte-long' : '') + " " + (
        /*estaffichagelateral*/
        ctx[6] === 'true' ? 'affichage-lateral' : '') + " " + (
        /*estaffichageboutonsinline*/
        ctx[5] === 'true' ? 'boutons-inline' : ''))) {
          attr_dev(div5, "class", div5_class_value);
        }
      },
      i: function intro(local) {
        if (current) return;
        add_render_callback(function () {
          if (div5_outro) div5_outro.end(1);
          div5_intro = create_in_transition(div5,
          /*animationAffichageOuverture*/
          ctx[13], {});
          div5_intro.start();
        });
        current = true;
      },
      o: function outro(local) {
        if (div5_intro) div5_intro.invalidate();
        div5_outro = create_out_transition(div5,
        /*animationAffichageFermeture*/
        ctx[14], {});
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div0);
        if (detaching) detach_dev(t0);
        if (detaching) detach_dev(div5);
        if (if_block0) if_block0.d();
        if (if_block1) if_block1.d();
        if (detaching && div5_outro) div5_outro.end();
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block$4.name,
      type: "if",
      source: "(146:0) {#if estModaleAffichee}",
      ctx: ctx
    });
    return block;
  } // (179:10) {#if type}


  function create_if_block_2$2(ctx) {
    var span;
    var span_class_value;
    var block = {
      c: function create() {
        span = element("span");
        attr_dev(span, "class", span_class_value = "utd-icone-svg " +
        /*type*/
        ctx[0]);
        attr_dev(span, "aria-hidden", "true");
        add_location(span, file$6, 179, 12, 6313);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
      },
      p: function update(ctx, dirty) {
        if (dirty[0] &
        /*type*/
        1 && span_class_value !== (span_class_value = "utd-icone-svg " +
        /*type*/
        ctx[0])) {
          attr_dev(span, "class", span_class_value);
        }
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(span);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_2$2.name,
      type: "if",
      source: "(179:10) {#if type}",
      ctx: ctx
    });
    return block;
  } // (190:8) {#if Utils.slotExiste(slots, 'pied')}


  function create_if_block_1$3(ctx) {
    var div;
    var slot;
    var block = {
      c: function create() {
        div = element("div");
        slot = element("slot");
        attr_dev(slot, "name", "pied");
        add_location(slot, file$6, 191, 12, 6703);
        attr_dev(div, "class", "pied");
        add_location(div, file$6, 190, 10, 6671);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        append_dev(div, slot);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_1$3.name,
      type: "if",
      source: "(190:8) {#if Utils.slotExiste(slots, 'pied')}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment$6(ctx) {
    var t;
    var link;
    var current;
    var if_block =
    /*estModaleAffichee*/
    ctx[7] && create_if_block$4(ctx);
    var block = {
      c: function create() {
        if (if_block) if_block.c();
        t = space();
        link = element("link");
        this.c = noop;
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", "/css/utd-webcomponents.min.css");
        add_location(link, file$6, 199, 0, 6813);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (if_block) if_block.m(target, anchor);
        insert_dev(target, t, anchor);
        insert_dev(target, link, anchor);
        current = true;
      },
      p: function update(ctx, dirty) {
        if (
        /*estModaleAffichee*/
        ctx[7]) {
          if (if_block) {
            if_block.p(ctx, dirty);

            if (dirty[0] &
            /*estModaleAffichee*/
            128) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block$4(ctx);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(t.parentNode, t);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, function () {
            if_block = null;
          });
          check_outros();
        }
      },
      i: function intro(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block);
        current = false;
      },
      d: function destroy(detaching) {
        if (if_block) if_block.d(detaching);
        if (detaching) detach_dev(t);
        if (detaching) detach_dev(link);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$6.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function instance$6($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots$1 = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-dialog', slots$1, []);
    var _$$props$afficher = $$props.afficher,
        afficher = _$$props$afficher === void 0 ? 'false' : _$$props$afficher;
    var _$$props$type = $$props.type,
        type = _$$props$type === void 0 ? '' : _$$props$type;
    var _$$props$estfenetreme = $$props.estfenetremessage,
        estfenetremessage = _$$props$estfenetreme === void 0 ? 'false' : _$$props$estfenetreme;
    var _$$props$raisonfermet = $$props.raisonfermeture,
        raisonfermeture = _$$props$raisonfermet === void 0 ? '' : _$$props$raisonfermet;
    var _$$props$titre = $$props.titre,
        titre = _$$props$titre === void 0 ? '' : _$$props$titre;
    var _$$props$lang = $$props.lang,
        lang = _$$props$lang === void 0 ? 'fr' : _$$props$lang;
    var _$$props$srBoutonFerm = $$props.srBoutonFermer,
        srBoutonFermer = _$$props$srBoutonFerm === void 0 ? lang === "fr" ? "Fermer" : "Close" : _$$props$srBoutonFerm;
    var _$$props$idfocusouver = $$props.idfocusouverture,
        idfocusouverture = _$$props$idfocusouver === void 0 ? '' : _$$props$idfocusouver;
    var _$$props$idfocus = $$props.idfocus,
        idfocus = _$$props$idfocus === void 0 ? '' : _$$props$idfocus;
    var _$$props$estboutonste = $$props.estboutonstextelong,
        estboutonstextelong = _$$props$estboutonste === void 0 ? 'false' : _$$props$estboutonste;
    var _$$props$estaffichage = $$props.estaffichageboutonsinline,
        estaffichageboutonsinline = _$$props$estaffichage === void 0 ? 'false' : _$$props$estaffichage;
    var _$$props$estaffichage2 = $$props.estaffichagelateral,
        estaffichagelateral = _$$props$estaffichage2 === void 0 ? 'false' : _$$props$estaffichage2;
    var idModale = Utils.genererId();
    var idEntete = Utils.genererId();
    var idCorps = Utils.genererId();
    var estModaleAffichee = afficher === 'true';
    var thisComponent = get_current_component();
    var html;
    var body;
    var slots = [];
    var mounted = false;
    onMount(function () {
      html = thisComponent.getRootNode().getElementsByTagName("html")[0];
      body = thisComponent.getRootNode().getElementsByTagName("body")[0];
      $$invalidate(8, slots = Array.from(thisComponent.querySelectorAll('[slot]')));
      mounted = true;

      if (Utils.estMobile()) {
        html.classList.add("est-mobile");
      }
    });

    function masquerModale(raisonFermetureModale) {
      $$invalidate(7, estModaleAffichee = false);
      $$invalidate(20, afficher = 'false'); //Si une raison de fermeture est reçue en param, on l'utilise sinon on prend la raison de fermeture qui est sur la modale "raisonfermeture" qui va contenir une raison de fermeture externe à la modale (ex. clic sur bouton primaire ou secondaire)

      var raison = raisonFermetureModale || raisonfermeture; //On redonne le focus au contrôle spécifié (normalement celui qui a initié l'affichage de la fenêtre modale)

      var controleFocus = thisComponent.getRootNode().getElementById(idfocus);

      if (controleFocus) {
        controleFocus.focus();
      }

      Utils.dispatchWcEvent(thisComponent, "fermeture", {
        raisonFermeture: raison
      });
    }

    function animationAffichageOuverture(node) {
      return estaffichagelateral === 'false' ? fade(node, {
        duration: 250
      }) : fly(node, {
        x: 200,
        duration: 250
      });
    }

    function animationAffichageFermeture(node) {
      return estaffichagelateral === 'false' ? fade(node, {
        y: 200,
        duration: 250
      }) : fly(node, {
        x: 200,
        duration: 250
      });
    } // Exécuté lorsque la valeur de la prop "afficher" change


    function toggleAfficher() {
      if (mounted) {
        if (afficher === 'true') {
          $$invalidate(21, raisonfermeture = '');
          Utils.ajusterInterfaceAvantAffichageModale(html, body);
          $$invalidate(7, estModaleAffichee = true);
        } else {
          if (estModaleAffichee) {
            masquerModale();
          }
        }
      }
    }

    function keydown(e) {
      if (e.key === "Escape") {
        masquerModale('escape');
      }
    }

    function clickModale(e) {
      if (e.target === e.currentTarget) {
        masquerModale('clickBackdrop');
      }
    }

    function finAnimationFermeture(e) {
      Utils.ajusterInterfaceApresFermetureModale(html, body, thisComponent.shadowRoot.getElementById(idModale));
      Utils.dispatchWcEvent(thisComponent, "apresFermeture");
    }

    function ajusterModaleDebutAffichage(e) {
      var modale = thisComponent.shadowRoot.getElementById(idModale);
      donnerfocusPremierElementFocusable(modale);
      Utils.conserverFocusElement(modale, thisComponent);
    }

    function ajusterModaleFinAffichage(e) {
      var modale = thisComponent.shadowRoot.getElementById(idModale);
      Utils.ajusterInterfacePendantAffichageModale(body, modale); //On force un scrollTop ici car Android ne semble pas supporter le preventScroll de la méthode focus (mais selon la doc il devrait). SOLUTION EN ATTENDANT MIEUX.

      modale.scrollTop = 0;
    }

    function donnerfocusPremierElementFocusable(modale) {
      var premierElementFocusable = null;

      if (estfenetremessage === 'true') {
        premierElementFocusable = thisComponent.querySelector('.utd-btn.primaire');
      }

      if (!premierElementFocusable) {
        var elementsFocusablesShadow = Array.from(Utils.obtenirElementsFocusables(modale));
        var elementsFocusablesRoot = Array.from(Utils.obtenirElementsFocusables(thisComponent));
        var elementsFocusables = elementsFocusablesRoot.concat(elementsFocusablesShadow);

        if (idfocusouverture) {
          var controle = elementsFocusables.find(function (e) {
            return e.id == idfocusouverture;
          });
          premierElementFocusable = controle ? controle : elementsFocusables[0];
        } else {
          premierElementFocusable = elementsFocusables[0];
        }
      }

      premierElementFocusable.focus({
        preventScroll: true
      });
    } //premierElementFocusable.focus()    


    var writable_props = ['afficher', 'type', 'estfenetremessage', 'raisonfermeture', 'titre', 'lang', 'srBoutonFermer', 'idfocusouverture', 'idfocus', 'estboutonstextelong', 'estaffichageboutonsinline', 'estaffichagelateral'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-dialog> was created with unknown prop '".concat(key, "'"));
    });

    var click_handler = function click_handler() {
      return masquerModale('clickBackdrop');
    };

    var click_handler_1 = function click_handler_1() {
      return masquerModale('boutonFermer');
    };

    $$self.$$set = function ($$props) {
      if ('afficher' in $$props) $$invalidate(20, afficher = $$props.afficher);
      if ('type' in $$props) $$invalidate(0, type = $$props.type);
      if ('estfenetremessage' in $$props) $$invalidate(1, estfenetremessage = $$props.estfenetremessage);
      if ('raisonfermeture' in $$props) $$invalidate(21, raisonfermeture = $$props.raisonfermeture);
      if ('titre' in $$props) $$invalidate(2, titre = $$props.titre);
      if ('lang' in $$props) $$invalidate(22, lang = $$props.lang);
      if ('srBoutonFermer' in $$props) $$invalidate(3, srBoutonFermer = $$props.srBoutonFermer);
      if ('idfocusouverture' in $$props) $$invalidate(23, idfocusouverture = $$props.idfocusouverture);
      if ('idfocus' in $$props) $$invalidate(24, idfocus = $$props.idfocus);
      if ('estboutonstextelong' in $$props) $$invalidate(4, estboutonstextelong = $$props.estboutonstextelong);
      if ('estaffichageboutonsinline' in $$props) $$invalidate(5, estaffichageboutonsinline = $$props.estaffichageboutonsinline);
      if ('estaffichagelateral' in $$props) $$invalidate(6, estaffichagelateral = $$props.estaffichagelateral);
    };

    $$self.$capture_state = function () {
      return {
        onMount: onMount,
        fly: fly,
        fade: fade,
        get_current_component: get_current_component,
        Utils: Utils,
        afficher: afficher,
        type: type,
        estfenetremessage: estfenetremessage,
        raisonfermeture: raisonfermeture,
        titre: titre,
        lang: lang,
        srBoutonFermer: srBoutonFermer,
        idfocusouverture: idfocusouverture,
        idfocus: idfocus,
        estboutonstextelong: estboutonstextelong,
        estaffichageboutonsinline: estaffichageboutonsinline,
        estaffichagelateral: estaffichagelateral,
        idModale: idModale,
        idEntete: idEntete,
        idCorps: idCorps,
        estModaleAffichee: estModaleAffichee,
        thisComponent: thisComponent,
        html: html,
        body: body,
        slots: slots,
        mounted: mounted,
        masquerModale: masquerModale,
        animationAffichageOuverture: animationAffichageOuverture,
        animationAffichageFermeture: animationAffichageFermeture,
        toggleAfficher: toggleAfficher,
        keydown: keydown,
        clickModale: clickModale,
        finAnimationFermeture: finAnimationFermeture,
        ajusterModaleDebutAffichage: ajusterModaleDebutAffichage,
        ajusterModaleFinAffichage: ajusterModaleFinAffichage,
        donnerfocusPremierElementFocusable: donnerfocusPremierElementFocusable
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('afficher' in $$props) $$invalidate(20, afficher = $$props.afficher);
      if ('type' in $$props) $$invalidate(0, type = $$props.type);
      if ('estfenetremessage' in $$props) $$invalidate(1, estfenetremessage = $$props.estfenetremessage);
      if ('raisonfermeture' in $$props) $$invalidate(21, raisonfermeture = $$props.raisonfermeture);
      if ('titre' in $$props) $$invalidate(2, titre = $$props.titre);
      if ('lang' in $$props) $$invalidate(22, lang = $$props.lang);
      if ('srBoutonFermer' in $$props) $$invalidate(3, srBoutonFermer = $$props.srBoutonFermer);
      if ('idfocusouverture' in $$props) $$invalidate(23, idfocusouverture = $$props.idfocusouverture);
      if ('idfocus' in $$props) $$invalidate(24, idfocus = $$props.idfocus);
      if ('estboutonstextelong' in $$props) $$invalidate(4, estboutonstextelong = $$props.estboutonstextelong);
      if ('estaffichageboutonsinline' in $$props) $$invalidate(5, estaffichageboutonsinline = $$props.estaffichageboutonsinline);
      if ('estaffichagelateral' in $$props) $$invalidate(6, estaffichagelateral = $$props.estaffichagelateral);
      if ('estModaleAffichee' in $$props) $$invalidate(7, estModaleAffichee = $$props.estModaleAffichee);
      if ('html' in $$props) html = $$props.html;
      if ('body' in $$props) body = $$props.body;
      if ('slots' in $$props) $$invalidate(8, slots = $$props.slots);
      if ('mounted' in $$props) mounted = $$props.mounted;
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    $$self.$$.update = function () {
      if ($$self.$$.dirty[0] &
      /*afficher*/
      1048576) {
        // Watch sur la prop afficher
        toggleAfficher();
      }
    };

    return [type, estfenetremessage, titre, srBoutonFermer, estboutonstextelong, estaffichageboutonsinline, estaffichagelateral, estModaleAffichee, slots, idModale, idEntete, idCorps, masquerModale, animationAffichageOuverture, animationAffichageFermeture, keydown, clickModale, finAnimationFermeture, ajusterModaleDebutAffichage, ajusterModaleFinAffichage, afficher, raisonfermeture, lang, idfocusouverture, idfocus, click_handler, click_handler_1];
  }

  var DialogueModal = /*#__PURE__*/function (_SvelteElement) {
    _inherits(DialogueModal, _SvelteElement);

    var _super = _createSuper$6(DialogueModal);

    function DialogueModal(options) {
      var _this;

      _classCallCheck(this, DialogueModal);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$6, create_fragment$6, safe_not_equal, {
        afficher: 20,
        type: 0,
        estfenetremessage: 1,
        raisonfermeture: 21,
        titre: 2,
        lang: 22,
        srBoutonFermer: 3,
        idfocusouverture: 23,
        idfocus: 24,
        estboutonstextelong: 4,
        estaffichageboutonsinline: 5,
        estaffichagelateral: 6
      }, null, [-1, -1]);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(DialogueModal, [{
      key: "afficher",
      get: function get() {
        return this.$$.ctx[20];
      },
      set: function set(afficher) {
        this.$$set({
          afficher: afficher
        });
        flush();
      }
    }, {
      key: "type",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(type) {
        this.$$set({
          type: type
        });
        flush();
      }
    }, {
      key: "estfenetremessage",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(estfenetremessage) {
        this.$$set({
          estfenetremessage: estfenetremessage
        });
        flush();
      }
    }, {
      key: "raisonfermeture",
      get: function get() {
        return this.$$.ctx[21];
      },
      set: function set(raisonfermeture) {
        this.$$set({
          raisonfermeture: raisonfermeture
        });
        flush();
      }
    }, {
      key: "titre",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(titre) {
        this.$$set({
          titre: titre
        });
        flush();
      }
    }, {
      key: "lang",
      get: function get() {
        return this.$$.ctx[22];
      },
      set: function set(lang) {
        this.$$set({
          lang: lang
        });
        flush();
      }
    }, {
      key: "srBoutonFermer",
      get: function get() {
        return this.$$.ctx[3];
      },
      set: function set(srBoutonFermer) {
        this.$$set({
          srBoutonFermer: srBoutonFermer
        });
        flush();
      }
    }, {
      key: "idfocusouverture",
      get: function get() {
        return this.$$.ctx[23];
      },
      set: function set(idfocusouverture) {
        this.$$set({
          idfocusouverture: idfocusouverture
        });
        flush();
      }
    }, {
      key: "idfocus",
      get: function get() {
        return this.$$.ctx[24];
      },
      set: function set(idfocus) {
        this.$$set({
          idfocus: idfocus
        });
        flush();
      }
    }, {
      key: "estboutonstextelong",
      get: function get() {
        return this.$$.ctx[4];
      },
      set: function set(estboutonstextelong) {
        this.$$set({
          estboutonstextelong: estboutonstextelong
        });
        flush();
      }
    }, {
      key: "estaffichageboutonsinline",
      get: function get() {
        return this.$$.ctx[5];
      },
      set: function set(estaffichageboutonsinline) {
        this.$$set({
          estaffichageboutonsinline: estaffichageboutonsinline
        });
        flush();
      }
    }, {
      key: "estaffichagelateral",
      get: function get() {
        return this.$$.ctx[6];
      },
      set: function set(estaffichagelateral) {
        this.$$set({
          estaffichagelateral: estaffichagelateral
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["afficher", "type", "estfenetremessage", "raisonfermeture", "titre", "lang", "srBoutonFermer", "idfocusouverture", "idfocus", "estboutonstextelong", "estaffichageboutonsinline", "estaffichagelateral"];
      }
    }]);

    return DialogueModal;
  }(SvelteElement);

  customElements.define("utd-dialog", DialogueModal);

  function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$5 = "src\\librairie\\components\\hautPage.svelte";

  function create_fragment$5(ctx) {
    var div1;
    var button;
    var div0;
    var span;
    var t;
    var link;
    var mounted;
    var dispose;
    var block = {
      c: function create() {
        div1 = element("div");
        button = element("button");
        div0 = element("div");
        span = element("span");
        t = space();
        link = element("link");
        this.c = noop;
        attr_dev(span, "aria-hidden", "true");
        attr_dev(span, "class", "utd-icone-svg fleche-haut-blanche");
        add_location(span, file$5, 72, 6, 2140);
        attr_dev(div0, "class", "contenu");
        add_location(div0, file$5, 71, 4, 2111);
        attr_dev(button, "type", "button");
        attr_dev(button, "class", "utd-btn primaire");
        attr_dev(button, "title",
        /*title*/
        ctx[0]);
        add_location(button, file$5, 70, 2, 2014);
        attr_dev(div1, "class", "utd-component utd-hautpage");
        add_location(div1, file$5, 69, 0, 1970);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", "/css/utd-webcomponents.min.css");
        add_location(link, file$5, 77, 0, 2254);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div1, anchor);
        append_dev(div1, button);
        append_dev(button, div0);
        append_dev(div0, span);
        insert_dev(target, t, anchor);
        insert_dev(target, link, anchor);

        if (!mounted) {
          dispose = listen_dev(button, "click", scrollerHautPage, false, false, false);
          mounted = true;
        }
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        if (dirty &
        /*title*/
        1) {
          attr_dev(button, "title",
          /*title*/
          ctx[0]);
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(div1);
        if (detaching) detach_dev(t);
        if (detaching) detach_dev(link);
        mounted = false;
        dispose();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$5.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function scrollerHautPage(e) {
    window.scrollTo({
      top: 0,
      behavior: 'smooth'
    });
  }

  function instance$5($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-hautpage', slots, []);
    var _$$props$title = $$props.title,
        title = _$$props$title === void 0 ? Utils.obtenirLanguePage() === 'fr' ? "Retour en haut de page." : "Return to the top of the page." : _$$props$title;
    var _$$props$hauteurMinim = $$props.hauteurMinimaleSroll,
        hauteurMinimaleSroll = _$$props$hauteurMinim === void 0 ? 555 : _$$props$hauteurMinim;
    var thisComponent = get_current_component();
    var html;
    var controle;
    var ticking = false;
    onMount(function () {
      html = thisComponent.getRootNode().getElementsByTagName("html")[0];
      controle = thisComponent.shadowRoot.querySelector('.utd-hautpage');
      controle.classList.add("utd-d-none");
    });
    window.addEventListener('scroll', function (e) {
      if (!ticking) {
        window.requestAnimationFrame(function () {
          gererAffichageBouton();
          ticking = false;
        });
      }

      ticking = true;
    });

    function gererAffichageBouton() {
      var dureeAnimationMs = 500;

      if (html.classList.contains('utd-modale-ouverte')) {
        //Si une fenêtre modale est ouverte, on ne fait rien pour le bouton de retour haut de page
        return;
      }

      if (document.body.scrollTop > hauteurMinimaleSroll || document.documentElement.scrollTop > hauteurMinimaleSroll) {
        if (controle.classList.contains('utd-d-none')) {
          controle.classList.remove('utd-d-none');
          setTimeout(function () {
            html.setAttribute('retourhautpagevisible', 'true');
            controle.classList.add('visible');
          }, 10);
        }
      } else {
        if (controle.classList.contains("visible")) {
          setTimeout(function () {
            controle.classList.add('utd-d-none');
            html.setAttribute('retourhautpagevisible', 'false');
          }, dureeAnimationMs);
        }

        controle.classList.remove('visible');
      }
    }

    var writable_props = ['title', 'hauteurMinimaleSroll'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-hautpage> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('title' in $$props) $$invalidate(0, title = $$props.title);
      if ('hauteurMinimaleSroll' in $$props) $$invalidate(1, hauteurMinimaleSroll = $$props.hauteurMinimaleSroll);
    };

    $$self.$capture_state = function () {
      return {
        onMount: onMount,
        Utils: Utils,
        get_current_component: get_current_component,
        title: title,
        hauteurMinimaleSroll: hauteurMinimaleSroll,
        thisComponent: thisComponent,
        html: html,
        controle: controle,
        ticking: ticking,
        gererAffichageBouton: gererAffichageBouton,
        scrollerHautPage: scrollerHautPage
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('title' in $$props) $$invalidate(0, title = $$props.title);
      if ('hauteurMinimaleSroll' in $$props) $$invalidate(1, hauteurMinimaleSroll = $$props.hauteurMinimaleSroll);
      if ('html' in $$props) html = $$props.html;
      if ('controle' in $$props) controle = $$props.controle;
      if ('ticking' in $$props) ticking = $$props.ticking;
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    return [title, hauteurMinimaleSroll];
  }

  var HautPage = /*#__PURE__*/function (_SvelteElement) {
    _inherits(HautPage, _SvelteElement);

    var _super = _createSuper$5(HautPage);

    function HautPage(options) {
      var _this;

      _classCallCheck(this, HautPage);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$5, create_fragment$5, safe_not_equal, {
        title: 0,
        hauteurMinimaleSroll: 1
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(HautPage, [{
      key: "title",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(title) {
        this.$$set({
          title: title
        });
        flush();
      }
    }, {
      key: "hauteurMinimaleSroll",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(hauteurMinimaleSroll) {
        this.$$set({
          hauteurMinimaleSroll: hauteurMinimaleSroll
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["title", "hauteurMinimaleSroll"];
      }
    }]);

    return HautPage;
  }(SvelteElement);

  customElements.define("utd-hautpage", HautPage);

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$4 = "src\\librairie\\components\\infobulle.svelte"; // (86:2) {#if $$slots["texte-lie"]}

  function create_if_block_4$1(ctx) {
    var span;
    var slot;
    var mounted;
    var dispose;
    var block = {
      c: function create() {
        span = element("span");
        slot = element("slot");
        attr_dev(slot, "name", "texte-lie");
        add_location(slot, file$4, 86, 54, 3166);
        attr_dev(span, "class", "texte-lie");
        add_location(span, file$4, 86, 4, 3116);
      },
      m: function mount(target, anchor) {
        insert_dev(target, span, anchor);
        append_dev(span, slot);

        if (!mounted) {
          dispose = listen_dev(span, "click",
          /*afficherModale*/
          ctx[10], false, false, false);
          mounted = true;
        }
      },
      p: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(span);
        mounted = false;
        dispose();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_4$1.name,
      type: "if",
      source: "(86:2) {#if $$slots[\\\"texte-lie\\\"]}",
      ctx: ctx
    });
    return block;
  } // (101:2) {#if afficher}


  function create_if_block$3(ctx) {
    var div;
    var t0;
    var span6;
    var span3;
    var h1;
    var span0;
    var t1;
    var span1;
    var t2;
    var button;
    var span2;
    var t3;
    var span5;
    var span4;
    var show_if;
    var span6_intro;
    var span6_outro;
    var current;
    var mounted;
    var dispose;
    var if_block0 =
    /*titre*/
    ctx[1] && create_if_block_3(ctx);

    function select_block_type(ctx, dirty) {
      if (dirty &
      /*slots*/
      64) show_if = null;
      if (show_if == null) show_if = !!Utils.slotExiste(
      /*slots*/
      ctx[6], 'contenu');
      if (show_if) return create_if_block_1$2;
      if (
      /*contenu*/
      ctx[5]) return create_if_block_2$1;
    }

    var current_block_type = select_block_type(ctx, -1);
    var if_block1 = current_block_type && current_block_type(ctx);
    var block = {
      c: function create() {
        div = element("div");
        t0 = space();
        span6 = element("span");
        span3 = element("span");
        h1 = element("h1");
        span0 = element("span");
        t1 = space();
        span1 = element("span");
        if (if_block0) if_block0.c();
        t2 = space();
        button = element("button");
        span2 = element("span");
        t3 = space();
        span5 = element("span");
        span4 = element("span");
        if (if_block1) if_block1.c();
        attr_dev(div, "class", "utd-backdrop");
        add_location(div, file$4, 101, 4, 3626);
        attr_dev(span0, "class", "utd-sr-only");
        add_location(span0, file$4, 117, 10, 4139);
        add_location(span1, file$4, 118, 10, 4199);
        attr_dev(h1, "id",
        /*idEntete*/
        ctx[9]);
        attr_dev(h1, "tabindex", "-1");
        add_location(h1, file$4, 116, 8, 4095);
        attr_dev(span2, "aria-hidden", "true");
        attr_dev(span2, "class", "utd-icone-svg x-fermer-bleu");
        add_location(span2, file$4, 130, 10, 4471);
        attr_dev(button, "type", "button");
        attr_dev(button, "class", "close");
        attr_dev(button, "aria-label",
        /*srBoutonFermer*/
        ctx[4]);
        add_location(button, file$4, 124, 8, 4316);
        attr_dev(span3, "class", "utd-container entete");
        add_location(span3, file$4, 115, 6, 4050);
        attr_dev(span4, "class", "corps");
        add_location(span4, file$4, 137, 8, 4667);
        attr_dev(span5, "class", "utd-container conteneur-corps");
        add_location(span5, file$4, 136, 6, 4613);
        attr_dev(span6, "tabindex", "-1");
        attr_dev(span6, "aria-labelledby",
        /*idEntete*/
        ctx[9]);
        attr_dev(span6, "class", "modale");
        attr_dev(span6, "id",
        /*idModale*/
        ctx[8]);
        attr_dev(span6, "aria-modal", "true");
        attr_dev(span6, "role", "dialog");
        add_location(span6, file$4, 102, 4, 3685);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        insert_dev(target, t0, anchor);
        insert_dev(target, span6, anchor);
        append_dev(span6, span3);
        append_dev(span3, h1);
        append_dev(h1, span0);
        span0.innerHTML =
        /*srTitre*/
        ctx[2];
        append_dev(h1, t1);
        append_dev(h1, span1);
        if (if_block0) if_block0.m(span1, null);
        append_dev(span3, t2);
        append_dev(span3, button);
        append_dev(button, span2);
        append_dev(span6, t3);
        append_dev(span6, span5);
        append_dev(span5, span4);
        if (if_block1) if_block1.m(span4, null);
        current = true;

        if (!mounted) {
          dispose = [listen_dev(div, "click",
          /*masquerModale*/
          ctx[11], false, false, false), listen_dev(button, "click",
          /*masquerModale*/
          ctx[11], false, false, false), listen_dev(span6, "keydown",
          /*keydown*/
          ctx[12], false, false, false), listen_dev(span6, "introend",
          /*conserverFocusInfobulle*/
          ctx[14], false, false, false), listen_dev(span6, "outroend",
          /*finAnimationFermeture*/
          ctx[13], false, false, false)];
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (!current || dirty &
        /*srTitre*/
        4) span0.innerHTML =
        /*srTitre*/
        ctx[2];

        if (
        /*titre*/
        ctx[1]) {
          if (if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0 = create_if_block_3(ctx);
            if_block0.c();
            if_block0.m(span1, null);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }

        if (!current || dirty &
        /*srBoutonFermer*/
        16) {
          attr_dev(button, "aria-label",
          /*srBoutonFermer*/
          ctx[4]);
        }

        if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if (if_block1) if_block1.d(1);
          if_block1 = current_block_type && current_block_type(ctx);

          if (if_block1) {
            if_block1.c();
            if_block1.m(span4, null);
          }
        }
      },
      i: function intro(local) {
        if (current) return;
        add_render_callback(function () {
          if (span6_outro) span6_outro.end(1);
          span6_intro = create_in_transition(span6, fly, {
            y: 200,
            duration: 500
          });
          span6_intro.start();
        });
        current = true;
      },
      o: function outro(local) {
        if (span6_intro) span6_intro.invalidate();
        span6_outro = create_out_transition(span6, fly, {
          y: 200,
          duration: 250
        });
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
        if (detaching) detach_dev(t0);
        if (detaching) detach_dev(span6);
        if (if_block0) if_block0.d();

        if (if_block1) {
          if_block1.d();
        }

        if (detaching && span6_outro) span6_outro.end();
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block$3.name,
      type: "if",
      source: "(101:2) {#if afficher}",
      ctx: ctx
    });
    return block;
  } // (120:12) {#if titre}


  function create_if_block_3(ctx) {
    var t;
    var block = {
      c: function create() {
        t = text(
        /*titre*/
        ctx[1]);
      },
      m: function mount(target, anchor) {
        insert_dev(target, t, anchor);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*titre*/
        2) set_data_dev(t,
        /*titre*/
        ctx[1]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(t);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_3.name,
      type: "if",
      source: "(120:12) {#if titre}",
      ctx: ctx
    });
    return block;
  } // (145:12) {#if contenu}


  function create_if_block_2$1(ctx) {
    var html_tag;
    var html_anchor;
    var block = {
      c: function create() {
        html_tag = new HtmlTag(false);
        html_anchor = empty();
        html_tag.a = html_anchor;
      },
      m: function mount(target, anchor) {
        html_tag.m(
        /*contenu*/
        ctx[5], target, anchor);
        insert_dev(target, html_anchor, anchor);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*contenu*/
        32) html_tag.p(
        /*contenu*/
        ctx[5]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(html_anchor);
        if (detaching) html_tag.d();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_2$1.name,
      type: "if",
      source: "(145:12) {#if contenu}",
      ctx: ctx
    });
    return block;
  } // (139:10) {#if Utils.slotExiste(slots, 'contenu')}


  function create_if_block_1$2(ctx) {
    var slot;
    var t;
    var span;
    var block = {
      c: function create() {
        slot = element("slot");
        t = space();
        span = element("span");
        attr_dev(slot, "name", "contenu");
        attr_dev(slot, "class", "utd-d-none");
        add_location(slot, file$4, 139, 12, 4753);
        add_location(span, file$4, 140, 12, 4808);
      },
      m: function mount(target, anchor) {
        insert_dev(target, slot, anchor);
        insert_dev(target, t, anchor);
        insert_dev(target, span, anchor);
        span.innerHTML =
        /*htmlSlotContenu*/
        ctx[7];
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*htmlSlotContenu*/
        128) span.innerHTML =
        /*htmlSlotContenu*/
        ctx[7];
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(slot);
        if (detaching) detach_dev(t);
        if (detaching) detach_dev(span);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_1$2.name,
      type: "if",
      source: "(139:10) {#if Utils.slotExiste(slots, 'contenu')}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment$4(ctx) {
    var span4;
    var t0;
    var span3;
    var t1;
    var button;
    var span2;
    var span1;
    var span0;
    var t2;
    var t3;
    var link;
    var current;
    var mounted;
    var dispose;
    var if_block0 =
    /*$$slots*/
    ctx[15]["texte-lie"] && create_if_block_4$1(ctx);
    var if_block1 =
    /*afficher*/
    ctx[0] && create_if_block$3(ctx);
    var block = {
      c: function create() {
        span4 = element("span");
        if (if_block0) if_block0.c();
        t0 = space();
        span3 = element("span");
        t1 = space();
        button = element("button");
        span2 = element("span");
        span1 = element("span");
        span0 = element("span");
        t2 = space();
        if (if_block1) if_block1.c();
        t3 = space();
        link = element("link");
        this.c = noop;
        attr_dev(span0, "aria-hidden", "true");
        attr_dev(span0, "class", "utd-icone-svg question");
        add_location(span0, file$4, 91, 10, 3447);
        attr_dev(span1, "aria-hidden", "true");
        attr_dev(span1, "class", "puce");
        add_location(span1, file$4, 90, 8, 3397);
        attr_dev(span2, "class", "conteneur-puce");
        add_location(span2, file$4, 89, 6, 3358);
        attr_dev(button, "type", "button");
        attr_dev(button, "aria-label",
        /*srBoutonOuvrir*/
        ctx[3]);
        attr_dev(button, "class", "tooltip-toggle");
        add_location(button, file$4, 88, 42, 3251);
        attr_dev(span3, "class", "conteneur-tooltip");
        add_location(span3, file$4, 88, 2, 3211);
        attr_dev(span4, "class", "utd-component utd-infobulle");
        add_location(span4, file$4, 84, 0, 3038);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", "/css/utd-webcomponents.min.css");
        add_location(link, file$4, 154, 0, 5084);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, span4, anchor);
        if (if_block0) if_block0.m(span4, null);
        append_dev(span4, t0);
        append_dev(span4, span3);
        append_dev(span3, t1);
        append_dev(span3, button);
        append_dev(button, span2);
        append_dev(span2, span1);
        append_dev(span1, span0);
        append_dev(span4, t2);
        if (if_block1) if_block1.m(span4, null);
        insert_dev(target, t3, anchor);
        insert_dev(target, link, anchor);
        current = true;

        if (!mounted) {
          dispose = listen_dev(button, "click",
          /*afficherModale*/
          ctx[10], false, false, false);
          mounted = true;
        }
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        if (
        /*$$slots*/
        ctx[15]["texte-lie"]) {
          if (if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0 = create_if_block_4$1(ctx);
            if_block0.c();
            if_block0.m(span4, t0);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }

        if (!current || dirty &
        /*srBoutonOuvrir*/
        8) {
          attr_dev(button, "aria-label",
          /*srBoutonOuvrir*/
          ctx[3]);
        }

        if (
        /*afficher*/
        ctx[0]) {
          if (if_block1) {
            if_block1.p(ctx, dirty);

            if (dirty &
            /*afficher*/
            1) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block$3(ctx);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(span4, null);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, function () {
            if_block1 = null;
          });
          check_outros();
        }
      },
      i: function intro(local) {
        if (current) return;
        transition_in(if_block1);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block1);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(span4);
        if (if_block0) if_block0.d();
        if (if_block1) if_block1.d();
        if (detaching) detach_dev(t3);
        if (detaching) detach_dev(link);
        mounted = false;
        dispose();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$4.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function instance$4($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots$1 = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-infobulle', slots$1, []);
    var $$slots = compute_slots(slots$1);
    var _$$props$afficher = $$props.afficher,
        afficher = _$$props$afficher === void 0 ? false : _$$props$afficher;
    var _$$props$titre = $$props.titre,
        titre = _$$props$titre === void 0 ? "" : _$$props$titre;
    var _$$props$lang = $$props.lang,
        lang = _$$props$lang === void 0 ? "fr" : _$$props$lang;
    var _$$props$srTitre = $$props.srTitre,
        srTitre = _$$props$srTitre === void 0 ? lang === "fr" ? "Aide à propos de&nbsp;" : "Help about&nbsp;" : _$$props$srTitre;
    var _$$props$srBoutonOuvr = $$props.srBoutonOuvrir,
        srBoutonOuvrir = _$$props$srBoutonOuvr === void 0 ? lang === "fr" ? "Afficher l'aide contextuelle" : "Show help about" : _$$props$srBoutonOuvr;
    var _$$props$srBoutonFerm = $$props.srBoutonFermer,
        srBoutonFermer = _$$props$srBoutonFerm === void 0 ? lang === "fr" ? "Fermer" : "Close" : _$$props$srBoutonFerm;
    var _$$props$contenu = $$props.contenu,
        contenu = _$$props$contenu === void 0 ? "" : _$$props$contenu;
    var idModale = Utils.genererId();
    var idEntete = Utils.genererId();
    var thisComponent = get_current_component();
    var html;
    var body;
    var slots = [];
    var htmlSlotContenu;
    onMount(function () {
      html = thisComponent.getRootNode().getElementsByTagName("html")[0];
      body = thisComponent.getRootNode().getElementsByTagName("body")[0];
      $$invalidate(6, slots = Array.from(thisComponent.querySelectorAll('[slot]')));
      assignerHtmlSlotContenu();

      if (Utils.estMobile()) {
        html.classList.add("est-mobile");
      }
    });
    /**
    * Permet de pallier à un problème de perte de focus à l'intérieur de la modale. En effet, si on clique dans le contenu de la slot "contenu" et qu'on fait TAB, le focus
    * tombe dans la page en dessous car le keydown est sur le body de la page (probablement car nous sommes dans une slot).
    * Nous cachons donc le contenu de la slot, récupérons son html et l'assignons nous-même au contrôle. De cette façon nous allons nous réglons le problème et en bonus
    * nous nous assurons d'une conformité visuelle, puisque c'est le css de notre composant qui va s'appliquer et non celui de l'application.
    * NOTE. Le problème ne semble pas se produire avec le composant utd-dialog. On dirait que le fait que d'autres contrôles focusables sont présents empêche le problème. Je ne comprends pas vraiment.
    */

    function assignerHtmlSlotContenu() {
      if (slots.length) {
        var slotContenu = thisComponent.querySelector("[slot=contenu]");

        if (slotContenu) {
          var contenuHtml = thisComponent.querySelector("[slot=contenu]").innerHTML;

          if (contenuHtml) {
            $$invalidate(7, htmlSlotContenu = contenuHtml);
          }
        }
      }
    }

    function afficherModale(e) {
      Utils.ajusterInterfaceAvantAffichageModale(html, body);
      $$invalidate(0, afficher = true);
    }

    function masquerModale(e) {
      $$invalidate(0, afficher = false);
    }

    function keydown(e) {
      if (e.key === "Escape") {
        masquerModale();
      }
    }

    function finAnimationFermeture(e) {
      Utils.ajusterInterfaceApresFermetureModale(html, body);
    }

    function conserverFocusInfobulle(e) {
      thisComponent.shadowRoot.getElementById(idEntete).focus();
      Utils.conserverFocusElement(thisComponent.shadowRoot.getElementById(idModale), thisComponent);
    }

    var writable_props = ['afficher', 'titre', 'lang', 'srTitre', 'srBoutonOuvrir', 'srBoutonFermer', 'contenu'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-infobulle> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('afficher' in $$props) $$invalidate(0, afficher = $$props.afficher);
      if ('titre' in $$props) $$invalidate(1, titre = $$props.titre);
      if ('lang' in $$props) $$invalidate(16, lang = $$props.lang);
      if ('srTitre' in $$props) $$invalidate(2, srTitre = $$props.srTitre);
      if ('srBoutonOuvrir' in $$props) $$invalidate(3, srBoutonOuvrir = $$props.srBoutonOuvrir);
      if ('srBoutonFermer' in $$props) $$invalidate(4, srBoutonFermer = $$props.srBoutonFermer);
      if ('contenu' in $$props) $$invalidate(5, contenu = $$props.contenu);
    };

    $$self.$capture_state = function () {
      return {
        onMount: onMount,
        fly: fly,
        get_current_component: get_current_component,
        Utils: Utils,
        afficher: afficher,
        titre: titre,
        lang: lang,
        srTitre: srTitre,
        srBoutonOuvrir: srBoutonOuvrir,
        srBoutonFermer: srBoutonFermer,
        contenu: contenu,
        idModale: idModale,
        idEntete: idEntete,
        thisComponent: thisComponent,
        html: html,
        body: body,
        slots: slots,
        htmlSlotContenu: htmlSlotContenu,
        assignerHtmlSlotContenu: assignerHtmlSlotContenu,
        afficherModale: afficherModale,
        masquerModale: masquerModale,
        keydown: keydown,
        finAnimationFermeture: finAnimationFermeture,
        conserverFocusInfobulle: conserverFocusInfobulle
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('afficher' in $$props) $$invalidate(0, afficher = $$props.afficher);
      if ('titre' in $$props) $$invalidate(1, titre = $$props.titre);
      if ('lang' in $$props) $$invalidate(16, lang = $$props.lang);
      if ('srTitre' in $$props) $$invalidate(2, srTitre = $$props.srTitre);
      if ('srBoutonOuvrir' in $$props) $$invalidate(3, srBoutonOuvrir = $$props.srBoutonOuvrir);
      if ('srBoutonFermer' in $$props) $$invalidate(4, srBoutonFermer = $$props.srBoutonFermer);
      if ('contenu' in $$props) $$invalidate(5, contenu = $$props.contenu);
      if ('html' in $$props) html = $$props.html;
      if ('body' in $$props) body = $$props.body;
      if ('slots' in $$props) $$invalidate(6, slots = $$props.slots);
      if ('htmlSlotContenu' in $$props) $$invalidate(7, htmlSlotContenu = $$props.htmlSlotContenu);
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    return [afficher, titre, srTitre, srBoutonOuvrir, srBoutonFermer, contenu, slots, htmlSlotContenu, idModale, idEntete, afficherModale, masquerModale, keydown, finAnimationFermeture, conserverFocusInfobulle, $$slots, lang];
  }

  var Infobulle = /*#__PURE__*/function (_SvelteElement) {
    _inherits(Infobulle, _SvelteElement);

    var _super = _createSuper$4(Infobulle);

    function Infobulle(options) {
      var _this;

      _classCallCheck(this, Infobulle);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: _objectSpread(_objectSpread({}, attribute_to_object(_this.attributes)), {}, {
          $$slots: get_custom_elements_slots(_assertThisInitialized(_this))
        }),
        customElement: true
      }, instance$4, create_fragment$4, safe_not_equal, {
        afficher: 0,
        titre: 1,
        lang: 16,
        srTitre: 2,
        srBoutonOuvrir: 3,
        srBoutonFermer: 4,
        contenu: 5
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(Infobulle, [{
      key: "afficher",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(afficher) {
        this.$$set({
          afficher: afficher
        });
        flush();
      }
    }, {
      key: "titre",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(titre) {
        this.$$set({
          titre: titre
        });
        flush();
      }
    }, {
      key: "lang",
      get: function get() {
        return this.$$.ctx[16];
      },
      set: function set(lang) {
        this.$$set({
          lang: lang
        });
        flush();
      }
    }, {
      key: "srTitre",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(srTitre) {
        this.$$set({
          srTitre: srTitre
        });
        flush();
      }
    }, {
      key: "srBoutonOuvrir",
      get: function get() {
        return this.$$.ctx[3];
      },
      set: function set(srBoutonOuvrir) {
        this.$$set({
          srBoutonOuvrir: srBoutonOuvrir
        });
        flush();
      }
    }, {
      key: "srBoutonFermer",
      get: function get() {
        return this.$$.ctx[4];
      },
      set: function set(srBoutonFermer) {
        this.$$set({
          srBoutonFermer: srBoutonFermer
        });
        flush();
      }
    }, {
      key: "contenu",
      get: function get() {
        return this.$$.ctx[5];
      },
      set: function set(contenu) {
        this.$$set({
          contenu: contenu
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["afficher", "titre", "lang", "srTitre", "srBoutonOuvrir", "srBoutonFermer", "contenu"];
      }
    }]);

    return Infobulle;
  }(SvelteElement);

  customElements.define("utd-infobulle", Infobulle);

  function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$3 = "src\\librairie\\components\\menuVertical.svelte";

  function create_fragment$3(ctx) {
    var nav;
    var a;
    var span0;
    var t0;
    var t1;
    var span1;
    var t2;
    var span2;
    var t4;
    var span3;
    var t5;
    var span3_class_value;
    var t6;
    var div;
    var slot;
    var t7;
    var link;
    var mounted;
    var dispose;
    var block = {
      c: function create() {
        nav = element("nav");
        a = element("a");
        span0 = element("span");
        t0 = text(
        /*titre*/
        ctx[0]);
        t1 = space();
        span1 = element("span");
        t2 = space();
        span2 = element("span");
        span2.textContent = "".concat(
        /*srTexteSortirMenu*/
        ctx[5]);
        t4 = space();
        span3 = element("span");
        t5 = text(
        /*titre*/
        ctx[0]);
        t6 = space();
        div = element("div");
        slot = element("slot");
        t7 = space();
        link = element("link");
        this.c = noop;
        add_location(span0, file$3, 27, 4, 1150);
        attr_dev(span1, "aria-hidden", "true");
        attr_dev(span1, "class", "utd-icone-svg chevron-bleu-piv");
        add_location(span1, file$3, 28, 4, 1176);
        attr_dev(span2, "class", "utd-sr-only");
        add_location(span2, file$3, 29, 4, 1247);
        attr_dev(a, "role", "button");
        attr_dev(a, "href", "#" +
        /*idMenu*/
        ctx[3]);
        attr_dev(a, "class", "toggle");
        attr_dev(a, "aria-controls",
        /*idMenu*/
        ctx[3]);
        add_location(a, file$3, 26, 2, 1029);
        attr_dev(span3, "class", span3_class_value = "titre " + (
        /*titreVisible*/
        ctx[1] === 'true' ? '' : 'utd-sr-only'));
        attr_dev(span3, "id",
        /*idTitreMenu*/
        ctx[4]);
        add_location(span3, file$3, 34, 2, 1329);
        add_location(slot, file$3, 36, 4, 1506);
        attr_dev(div, "id",
        /*idMenu*/
        ctx[3]);
        attr_dev(div, "role", "menu");
        attr_dev(div, "class", "menu");
        toggle_class(div, "visible",
        /*afficher*/
        ctx[2]);
        add_location(div, file$3, 35, 2, 1433);
        attr_dev(nav, "class", "utd-menu-vertical");
        attr_dev(nav, "aria-labelledby",
        /*idTitreMenu*/
        ctx[4]);
        toggle_class(nav, "visible",
        /*afficher*/
        ctx[2]);
        add_location(nav, file$3, 25, 0, 937);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", "/css/utd-webcomponents.min.css");
        add_location(link, file$3, 39, 0, 1541);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, nav, anchor);
        append_dev(nav, a);
        append_dev(a, span0);
        append_dev(span0, t0);
        append_dev(a, t1);
        append_dev(a, span1);
        append_dev(a, t2);
        append_dev(a, span2);
        append_dev(nav, t4);
        append_dev(nav, span3);
        append_dev(span3, t5);
        append_dev(nav, t6);
        append_dev(nav, div);
        append_dev(div, slot);
        insert_dev(target, t7, anchor);
        insert_dev(target, link, anchor);

        if (!mounted) {
          dispose = listen_dev(a, "click", prevent_default(
          /*toggleAfficher*/
          ctx[6]), false, true, false);
          mounted = true;
        }
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        if (dirty &
        /*titre*/
        1) set_data_dev(t0,
        /*titre*/
        ctx[0]);
        if (dirty &
        /*titre*/
        1) set_data_dev(t5,
        /*titre*/
        ctx[0]);

        if (dirty &
        /*titreVisible*/
        2 && span3_class_value !== (span3_class_value = "titre " + (
        /*titreVisible*/
        ctx[1] === 'true' ? '' : 'utd-sr-only'))) {
          attr_dev(span3, "class", span3_class_value);
        }

        if (dirty &
        /*afficher*/
        4) {
          toggle_class(div, "visible",
          /*afficher*/
          ctx[2]);
        }

        if (dirty &
        /*afficher*/
        4) {
          toggle_class(nav, "visible",
          /*afficher*/
          ctx[2]);
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(nav);
        if (detaching) detach_dev(t7);
        if (detaching) detach_dev(link);
        mounted = false;
        dispose();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$3.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function instance$3($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-menu-vertical', slots, []);
    var _$$props$titre = $$props.titre,
        titre = _$$props$titre === void 0 ? lang === 'fr' ? 'Menu secondaire' : 'Secondary menu' : _$$props$titre;
    var _$$props$lang = $$props.lang,
        lang = _$$props$lang === void 0 ? "fr" : _$$props$lang;
    var _$$props$titreVisible = $$props.titreVisible,
        titreVisible = _$$props$titreVisible === void 0 ? "true" : _$$props$titreVisible;
    var afficher = false;
    var idMenu = Utils.genererId();
    var idTitreMenu = Utils.genererId();
    var srTexteSortirMenu = lang === "fr" ? "Appuyez sur la touche Échappe pour sortir du menu." : "Press ESC key to exit menu."; //TODO implémnenter gestion langue (aller chercher dans balise html? lang=?)
    // Références pour accessibilité
    // https://www.w3.org/WAI/ARIA/apg/example-index/menubar/menubar-navigation, https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/menu_role et https://usability.yale.edu/web-accessibility/articles/focus-keyboard-operability

    function toggleAfficher() {
      $$invalidate(2, afficher = !afficher);
    }

    var writable_props = ['titre', 'lang', 'titreVisible'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-menu-vertical> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
      if ('lang' in $$props) $$invalidate(7, lang = $$props.lang);
      if ('titreVisible' in $$props) $$invalidate(1, titreVisible = $$props.titreVisible);
    };

    $$self.$capture_state = function () {
      return {
        Utils: Utils,
        titre: titre,
        lang: lang,
        titreVisible: titreVisible,
        afficher: afficher,
        idMenu: idMenu,
        idTitreMenu: idTitreMenu,
        srTexteSortirMenu: srTexteSortirMenu,
        toggleAfficher: toggleAfficher
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
      if ('lang' in $$props) $$invalidate(7, lang = $$props.lang);
      if ('titreVisible' in $$props) $$invalidate(1, titreVisible = $$props.titreVisible);
      if ('afficher' in $$props) $$invalidate(2, afficher = $$props.afficher);
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    return [titre, titreVisible, afficher, idMenu, idTitreMenu, srTexteSortirMenu, toggleAfficher, lang];
  }

  var MenuVertical = /*#__PURE__*/function (_SvelteElement) {
    _inherits(MenuVertical, _SvelteElement);

    var _super = _createSuper$3(MenuVertical);

    function MenuVertical(options) {
      var _this;

      _classCallCheck(this, MenuVertical);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$3, create_fragment$3, safe_not_equal, {
        titre: 0,
        lang: 7,
        titreVisible: 1
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(MenuVertical, [{
      key: "titre",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(titre) {
        this.$$set({
          titre: titre
        });
        flush();
      }
    }, {
      key: "lang",
      get: function get() {
        return this.$$.ctx[7];
      },
      set: function set(lang) {
        this.$$set({
          lang: lang
        });
        flush();
      }
    }, {
      key: "titreVisible",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(titreVisible) {
        this.$$set({
          titreVisible: titreVisible
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["titre", "lang", "titreVisible"];
      }
    }]);

    return MenuVertical;
  }(SvelteElement);

  customElements.define("utd-menu-vertical", MenuVertical);

  function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var console_1 = globals.console;
  var file$2 = "src\\librairie\\components\\menuVerticalItem.svelte"; // (213:2) {:else}

  function create_else_block$1(ctx) {
    var a;
    var span;
    var t;
    var a_aria_current_value;
    var mounted;
    var dispose;
    var block = {
      c: function create() {
        a = element("a");
        span = element("span");
        t = text(
        /*libelle*/
        ctx[2]);
        add_location(span, file$2, 214, 6, 6552);
        attr_dev(a, "href",
        /*href*/
        ctx[3]);
        attr_dev(a, "role", "menuitem");
        attr_dev(a, "aria-current", a_aria_current_value =
        /*actif*/
        ctx[1] === 'true' ? 'page' : null);
        attr_dev(a, "tabindex",
        /*indextab*/
        ctx[4]);
        add_location(a, file$2, 213, 4, 6397);
      },
      m: function mount(target, anchor) {
        insert_dev(target, a, anchor);
        append_dev(a, span);
        append_dev(span, t);

        if (!mounted) {
          dispose = [listen_dev(a, "keydown",
          /*onKeyDown*/
          ctx[10], false, false, false), listen_dev(a, "focus",
          /*onFocus*/
          ctx[11], false, false, false)];
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*libelle*/
        4) set_data_dev(t,
        /*libelle*/
        ctx[2]);

        if (dirty &
        /*href*/
        8) {
          attr_dev(a, "href",
          /*href*/
          ctx[3]);
        }

        if (dirty &
        /*actif*/
        2 && a_aria_current_value !== (a_aria_current_value =
        /*actif*/
        ctx[1] === 'true' ? 'page' : null)) {
          attr_dev(a, "aria-current", a_aria_current_value);
        }

        if (dirty &
        /*indextab*/
        16) {
          attr_dev(a, "tabindex",
          /*indextab*/
          ctx[4]);
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (detaching) detach_dev(a);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_else_block$1.name,
      type: "else",
      source: "(213:2) {:else}",
      ctx: ctx
    });
    return block;
  } // (203:2) {#if possedeEnfants}


  function create_if_block$2(ctx) {
    var a;
    var span0;
    var t0;
    var t1;
    var span1;
    var t2;
    var if_block_anchor;
    var current;
    var mounted;
    var dispose;
    var if_block =
    /*afficher*/
    ctx[0] === 'true' && create_if_block_1$1(ctx);
    var block = {
      c: function create() {
        a = element("a");
        span0 = element("span");
        t0 = text(
        /*libelle*/
        ctx[2]);
        t1 = space();
        span1 = element("span");
        t2 = space();
        if (if_block) if_block.c();
        if_block_anchor = empty();
        add_location(span0, file$2, 204, 6, 6076);
        attr_dev(span1, "aria-hidden", "true");
        attr_dev(span1, "class", "utd-icone-svg chevron-bleu-piv");
        add_location(span1, file$2, 205, 6, 6106);
        attr_dev(a, "role", "menuitem");
        attr_dev(a, "href",
        /*href*/
        ctx[3]);
        attr_dev(a, "aria-expanded",
        /*afficher*/
        ctx[0]);
        attr_dev(a, "aria-haspopup", "menu");
        attr_dev(a, "aria-controls",
        /*idSousMenu*/
        ctx[8]);
        attr_dev(a, "tabindex",
        /*indextab*/
        ctx[4]);
        add_location(a, file$2, 203, 4, 5853);
      },
      m: function mount(target, anchor) {
        insert_dev(target, a, anchor);
        append_dev(a, span0);
        append_dev(span0, t0);
        append_dev(a, t1);
        append_dev(a, span1);
        insert_dev(target, t2, anchor);
        if (if_block) if_block.m(target, anchor);
        insert_dev(target, if_block_anchor, anchor);
        current = true;

        if (!mounted) {
          dispose = [listen_dev(a, "click", prevent_default(
          /*toggleAfficher*/
          ctx[9]), false, true, false), listen_dev(a, "keydown",
          /*onKeyDown*/
          ctx[10], false, false, false), listen_dev(a, "focus",
          /*onFocus*/
          ctx[11], false, false, false)];
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (!current || dirty &
        /*libelle*/
        4) set_data_dev(t0,
        /*libelle*/
        ctx[2]);

        if (!current || dirty &
        /*href*/
        8) {
          attr_dev(a, "href",
          /*href*/
          ctx[3]);
        }

        if (!current || dirty &
        /*afficher*/
        1) {
          attr_dev(a, "aria-expanded",
          /*afficher*/
          ctx[0]);
        }

        if (!current || dirty &
        /*indextab*/
        16) {
          attr_dev(a, "tabindex",
          /*indextab*/
          ctx[4]);
        }

        if (
        /*afficher*/
        ctx[0] === 'true') {
          if (if_block) {
            if_block.p(ctx, dirty);

            if (dirty &
            /*afficher*/
            1) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block_1$1(ctx);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, function () {
            if_block = null;
          });
          check_outros();
        }
      },
      i: function intro(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(a);
        if (detaching) detach_dev(t2);
        if (if_block) if_block.d(detaching);
        if (detaching) detach_dev(if_block_anchor);
        mounted = false;
        run_all(dispose);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block$2.name,
      type: "if",
      source: "(203:2) {#if possedeEnfants}",
      ctx: ctx
    });
    return block;
  } // (208:4) {#if afficher === 'true'}


  function create_if_block_1$1(ctx) {
    var div;
    var slot;
    var div_transition;
    var current;
    var block = {
      c: function create() {
        div = element("div");
        slot = element("slot");
        add_location(slot, file$2, 209, 8, 6342);
        attr_dev(div, "id",
        /*idSousMenu*/
        ctx[8]);
        attr_dev(div, "role", "menu");
        attr_dev(div, "class", "sous-menu");
        add_location(div, file$2, 208, 6, 6220);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        append_dev(div, slot);
        current = true;
      },
      p: function update(new_ctx, dirty) {
        ctx = new_ctx;
      },
      i: function intro(local) {
        if (current) return;
        add_render_callback(function () {
          if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {
            duration:
            /*animer*/
            ctx[5] === 'true' ? 250 : 0
          }, true);
          div_transition.run(1);
        });
        current = true;
      },
      o: function outro(local) {
        if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {
          duration:
          /*animer*/
          ctx[5] === 'true' ? 250 : 0
        }, false);
        div_transition.run(0);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
        if (detaching && div_transition) div_transition.end();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_1$1.name,
      type: "if",
      source: "(208:4) {#if afficher === 'true'}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment$2(ctx) {
    var div;
    var current_block_type_index;
    var if_block;
    var div_class_value;
    var t;
    var link;
    var current;
    var if_block_creators = [create_if_block$2, create_else_block$1];
    var if_blocks = [];

    function select_block_type(ctx, dirty) {
      if (
      /*possedeEnfants*/
      ctx[6]) return 0;
      return 1;
    }

    current_block_type_index = select_block_type(ctx);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    var block = {
      c: function create() {
        div = element("div");
        if_block.c();
        t = space();
        link = element("link");
        this.c = noop;
        attr_dev(div, "class", div_class_value = "utd-menu-vertical-item niv" +
        /*niveau*/
        ctx[7] + " " + (
        /*afficher*/
        ctx[0] === 'true' ? 'visible' : '') + " " + (
        /*actif*/
        ctx[1] === 'true' ? 'active' : ''));
        add_location(div, file$2, 201, 0, 5697);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", "/css/utd-webcomponents.min.css");
        add_location(link, file$2, 218, 0, 6619);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        if_blocks[current_block_type_index].m(div, null);
        insert_dev(target, t, anchor);
        insert_dev(target, link, anchor);
        current = true;
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        var previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx);

        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, function () {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];

          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block.c();
          } else {
            if_block.p(ctx, dirty);
          }

          transition_in(if_block, 1);
          if_block.m(div, null);
        }

        if (!current || dirty &
        /*niveau, afficher, actif*/
        131 && div_class_value !== (div_class_value = "utd-menu-vertical-item niv" +
        /*niveau*/
        ctx[7] + " " + (
        /*afficher*/
        ctx[0] === 'true' ? 'visible' : '') + " " + (
        /*actif*/
        ctx[1] === 'true' ? 'active' : ''))) {
          attr_dev(div, "class", div_class_value);
        }
      },
      i: function intro(local) {
        if (current) return;
        transition_in(if_block);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
        if_blocks[current_block_type_index].d();
        if (detaching) detach_dev(t);
        if (detaching) detach_dev(link);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$2.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function estMenuItem(element) {
    return element && element.tagName.toLowerCase() === 'utd-menu-vertical-item';
  }

  function instance$2($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-menu-vertical-item', slots, []);
    var _$$props$libelle = $$props.libelle,
        libelle = _$$props$libelle === void 0 ? '' : _$$props$libelle;
    var _$$props$href = $$props.href,
        href = _$$props$href === void 0 ? '' : _$$props$href;
    var _$$props$afficher = $$props.afficher,
        afficher = _$$props$afficher === void 0 ? 'false' : _$$props$afficher;
    var _$$props$indextab = $$props.indextab,
        indextab = _$$props$indextab === void 0 ? '0' : _$$props$indextab;
    var _$$props$animer = $$props.animer,
        animer = _$$props$animer === void 0 ? 'true' : _$$props$animer;
    var _$$props$focus = $$props.focus,
        focus = _$$props$focus === void 0 ? 'false' : _$$props$focus;
    var _$$props$actif = $$props.actif,
        actif = _$$props$actif === void 0 ? 'false' : _$$props$actif;
    var possedeEnfants = false;
    var niveau = 1;
    var thisComponent = get_current_component();
    var idSousMenu = Utils.genererId();
    onMount(function () {
      $$invalidate(1, actif = estElementActif());
      $$invalidate(7, niveau = obtenirNiveau());
      $$invalidate(6, possedeEnfants = !!thisComponent.querySelector('utd-menu-vertical-item'));
    });

    function toggleFocus() {
      if (focus === 'true') {
        thisComponent.shadowRoot.querySelector('a').focus();
        $$invalidate(12, focus = 'false');
      }
    }

    function toggleAfficher() {
      $$invalidate(0, afficher = afficher === 'true' ? 'false' : 'true');
    }

    function estElementActif() {
      if (href) {
        return (window.location.pathname === href).toString();
      }
    }

    function obtenirNiveau() {
      var niveau = 1;
      var elementParent = thisComponent.parentElement;

      while (elementParent.tagName.toLowerCase() === 'utd-menu-vertical-item') {
        ++niveau;

        if (actif === 'true') {
          elementParent.setAttribute('actif', 'true');
          elementParent.setAttribute('animer', 'false');
          elementParent.setAttribute('afficher', 'true');
          elementParent.setAttribute('animer', 'true');
        }

        elementParent = elementParent.parentElement;
      }

      return niveau;
    }

    function obtenirMenuVertical() {
      var elementParent = thisComponent.parentElement;

      while (elementParent.tagName.toLowerCase() !== 'utd-menu-vertical') {
        elementParent = elementParent.parentElement;
      }

      return elementParent;
    }

    function onKeyDown(e) {
      console.log(e.keyCode);
      var parent = thisComponent.parentElement;

      switch (e.keyCode) {
        case 27:
          if (estMenuItem(parent)) {
            parent.setAttribute('afficher', 'false');
            parent.setAttribute('focus', 'true');
          }

          e.preventDefault();
          break;

        case 13:
        case 32:
          if (possedeEnfants) {
            if (afficher === 'false') {
              $$invalidate(0, afficher = 'true');
              thisComponent.querySelector('utd-menu-vertical-item').setAttribute('focus', 'true');
            }

            e.preventDefault();
          }

          break;

        case 37:
          accederMenuPrecedent();
          e.preventDefault();
          break;

        case 38:
          accederMenuPrecedent(true);
          e.preventDefault();
          break;

        case 39:
          if (possedeEnfants) {
            if (afficher === 'false') {
              $$invalidate(0, afficher = 'true');
              thisComponent.querySelector('utd-menu-vertical-item').setAttribute('focus', 'true');
            } else {
              accederMenuSuivant();
            }
          } else {
            accederMenuSuivant();
          }

          e.preventDefault();
          break;

        case 40:
          accederMenuSuivant(true);
          e.preventDefault();
          break;
      }
    }

    function accederMenuSuivant(doitBoucler) {
      var parent = thisComponent.parentElement;
      var prochainMenu;
      $$invalidate(0, afficher = 'false');

      if (!doitBoucler && estMenuItem(parent)) {
        parent.setAttribute('afficher', 'false');
        prochainMenu = parent.nextElementSibling;
      } else {
        prochainMenu = thisComponent.nextElementSibling;
      }

      if (estMenuItem(prochainMenu)) {
        prochainMenu.setAttribute('focus', 'true');
      } else {
        if (doitBoucler) {
          parent.querySelector('utd-menu-vertical-item').setAttribute('focus', 'true');
        } else {
          parent.parentElement.querySelector('utd-menu-vertical-item').setAttribute('focus', 'true');
        }
      }
    }

    function accederMenuPrecedent(doitBoucler) {
      var parent = thisComponent.parentElement;
      var menuPrecedent;
      $$invalidate(0, afficher = 'false');

      if (!doitBoucler && estMenuItem(parent)) {
        parent.setAttribute('afficher', 'false');
        parent.setAttribute('focus', 'true');
      } else {
        menuPrecedent = thisComponent.previousElementSibling;
      }

      if (estMenuItem(menuPrecedent)) {
        menuPrecedent.setAttribute('focus', 'true');
      } else {
        var elements = parent.children;
        elements[elements.length - 1].setAttribute('focus', 'true');
      }
    }

    function onFocus() {
      // Tab roving!!! On gère le tabindex des éléments du menu afin que seul l'élément actif puisse être focusable (via tab) de sorte qu'on gère le focus via les flèches du clavier et 
      // un TAB provoque la sortie du menu.
      retirerPossibiliteFocusElementsMenu();
      thisComponent.setAttribute('indextab', '0');
    }

    function retirerPossibiliteFocusElementsMenu() {
      var menuVertical = obtenirMenuVertical();
      var elements = menuVertical.querySelectorAll('utd-menu-vertical-item');
      elements.forEach(function (element) {
        element.setAttribute('indextab', '-1');
      });
    }

    var writable_props = ['libelle', 'href', 'afficher', 'indextab', 'animer', 'focus', 'actif'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn("<utd-menu-vertical-item> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('libelle' in $$props) $$invalidate(2, libelle = $$props.libelle);
      if ('href' in $$props) $$invalidate(3, href = $$props.href);
      if ('afficher' in $$props) $$invalidate(0, afficher = $$props.afficher);
      if ('indextab' in $$props) $$invalidate(4, indextab = $$props.indextab);
      if ('animer' in $$props) $$invalidate(5, animer = $$props.animer);
      if ('focus' in $$props) $$invalidate(12, focus = $$props.focus);
      if ('actif' in $$props) $$invalidate(1, actif = $$props.actif);
    };

    $$self.$capture_state = function () {
      return {
        onMount: onMount,
        Utils: Utils,
        slide: slide,
        element: element,
        get_current_component: get_current_component,
        libelle: libelle,
        href: href,
        afficher: afficher,
        indextab: indextab,
        animer: animer,
        focus: focus,
        actif: actif,
        possedeEnfants: possedeEnfants,
        niveau: niveau,
        thisComponent: thisComponent,
        idSousMenu: idSousMenu,
        toggleFocus: toggleFocus,
        toggleAfficher: toggleAfficher,
        estElementActif: estElementActif,
        obtenirNiveau: obtenirNiveau,
        obtenirMenuVertical: obtenirMenuVertical,
        onKeyDown: onKeyDown,
        accederMenuSuivant: accederMenuSuivant,
        accederMenuPrecedent: accederMenuPrecedent,
        estMenuItem: estMenuItem,
        onFocus: onFocus,
        retirerPossibiliteFocusElementsMenu: retirerPossibiliteFocusElementsMenu
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('libelle' in $$props) $$invalidate(2, libelle = $$props.libelle);
      if ('href' in $$props) $$invalidate(3, href = $$props.href);
      if ('afficher' in $$props) $$invalidate(0, afficher = $$props.afficher);
      if ('indextab' in $$props) $$invalidate(4, indextab = $$props.indextab);
      if ('animer' in $$props) $$invalidate(5, animer = $$props.animer);
      if ('focus' in $$props) $$invalidate(12, focus = $$props.focus);
      if ('actif' in $$props) $$invalidate(1, actif = $$props.actif);
      if ('possedeEnfants' in $$props) $$invalidate(6, possedeEnfants = $$props.possedeEnfants);
      if ('niveau' in $$props) $$invalidate(7, niveau = $$props.niveau);
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    $$self.$$.update = function () {
      if ($$self.$$.dirty &
      /*focus*/
      4096) {
        // Watch sur la prop focus
        toggleFocus();
      }
    };

    return [afficher, actif, libelle, href, indextab, animer, possedeEnfants, niveau, idSousMenu, toggleAfficher, onKeyDown, onFocus, focus];
  }

  var MenuVerticalItem = /*#__PURE__*/function (_SvelteElement) {
    _inherits(MenuVerticalItem, _SvelteElement);

    var _super = _createSuper$2(MenuVerticalItem);

    function MenuVerticalItem(options) {
      var _this;

      _classCallCheck(this, MenuVerticalItem);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$2, create_fragment$2, safe_not_equal, {
        libelle: 2,
        href: 3,
        afficher: 0,
        indextab: 4,
        animer: 5,
        focus: 12,
        actif: 1
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(MenuVerticalItem, [{
      key: "libelle",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(libelle) {
        this.$$set({
          libelle: libelle
        });
        flush();
      }
    }, {
      key: "href",
      get: function get() {
        return this.$$.ctx[3];
      },
      set: function set(href) {
        this.$$set({
          href: href
        });
        flush();
      }
    }, {
      key: "afficher",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(afficher) {
        this.$$set({
          afficher: afficher
        });
        flush();
      }
    }, {
      key: "indextab",
      get: function get() {
        return this.$$.ctx[4];
      },
      set: function set(indextab) {
        this.$$set({
          indextab: indextab
        });
        flush();
      }
    }, {
      key: "animer",
      get: function get() {
        return this.$$.ctx[5];
      },
      set: function set(animer) {
        this.$$set({
          animer: animer
        });
        flush();
      }
    }, {
      key: "focus",
      get: function get() {
        return this.$$.ctx[12];
      },
      set: function set(focus) {
        this.$$set({
          focus: focus
        });
        flush();
      }
    }, {
      key: "actif",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(actif) {
        this.$$set({
          actif: actif
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["libelle", "href", "afficher", "indextab", "animer", "focus", "actif"];
      }
    }]);

    return MenuVerticalItem;
  }(SvelteElement);

  customElements.define("utd-menu-vertical-item", MenuVerticalItem);

  function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file$1 = "src\\librairie\\components\\section.svelte"; // (37:4) {:else}

  function create_else_block(ctx) {
    var previous_tag =
    /*tagTitre*/
    ctx[4];
    var svelte_element_anchor;
    validate_dynamic_element(
    /*tagTitre*/
    ctx[4]);
    validate_void_dynamic_element(
    /*tagTitre*/
    ctx[4]);
    var svelte_element =
    /*tagTitre*/
    ctx[4] && create_dynamic_element_1(ctx);
    var block = {
      c: function create() {
        if (svelte_element) svelte_element.c();
        svelte_element_anchor = empty();
      },
      m: function mount(target, anchor) {
        if (svelte_element) svelte_element.m(target, anchor);
        insert_dev(target, svelte_element_anchor, anchor);
      },
      p: function update(ctx, dirty) {
        if (
        /*tagTitre*/
        ctx[4]) {
          if (!previous_tag) {
            svelte_element = create_dynamic_element_1(ctx);
            svelte_element.c();
            svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
          } else if (safe_not_equal(previous_tag,
          /*tagTitre*/
          ctx[4])) {
            svelte_element.d(1);
            validate_dynamic_element(
            /*tagTitre*/
            ctx[4]);
            validate_void_dynamic_element(
            /*tagTitre*/
            ctx[4]);
            svelte_element = create_dynamic_element_1(ctx);
            svelte_element.c();
            svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
          } else {
            svelte_element.p(ctx, dirty);
          }
        } else if (previous_tag) {
          svelte_element.d(1);
          svelte_element = null;
        }

        previous_tag =
        /*tagTitre*/
        ctx[4];
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(svelte_element_anchor);
        if (svelte_element) svelte_element.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_else_block.name,
      type: "else",
      source: "(37:4) {:else}",
      ctx: ctx
    });
    return block;
  } // (27:4) {#if extensible === 'true'}


  function create_if_block_1(ctx) {
    var previous_tag =
    /*tagTitre*/
    ctx[4];
    var svelte_element_anchor;
    validate_dynamic_element(
    /*tagTitre*/
    ctx[4]);
    validate_void_dynamic_element(
    /*tagTitre*/
    ctx[4]);
    var svelte_element =
    /*tagTitre*/
    ctx[4] && create_dynamic_element(ctx);
    var block = {
      c: function create() {
        if (svelte_element) svelte_element.c();
        svelte_element_anchor = empty();
      },
      m: function mount(target, anchor) {
        if (svelte_element) svelte_element.m(target, anchor);
        insert_dev(target, svelte_element_anchor, anchor);
      },
      p: function update(ctx, dirty) {
        if (
        /*tagTitre*/
        ctx[4]) {
          if (!previous_tag) {
            svelte_element = create_dynamic_element(ctx);
            svelte_element.c();
            svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
          } else if (safe_not_equal(previous_tag,
          /*tagTitre*/
          ctx[4])) {
            svelte_element.d(1);
            validate_dynamic_element(
            /*tagTitre*/
            ctx[4]);
            validate_void_dynamic_element(
            /*tagTitre*/
            ctx[4]);
            svelte_element = create_dynamic_element(ctx);
            svelte_element.c();
            svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
          } else {
            svelte_element.p(ctx, dirty);
          }
        } else if (previous_tag) {
          svelte_element.d(1);
          svelte_element = null;
        }

        previous_tag =
        /*tagTitre*/
        ctx[4];
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(svelte_element_anchor);
        if (svelte_element) svelte_element.d(detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_1.name,
      type: "if",
      source: "(27:4) {#if extensible === 'true'}",
      ctx: ctx
    });
    return block;
  } // (39:8) {#if titre}


  function create_if_block_4(ctx) {
    var t;
    var block = {
      c: function create() {
        t = text(
        /*titre*/
        ctx[2]);
      },
      m: function mount(target, anchor) {
        insert_dev(target, t, anchor);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*titre*/
        4) set_data_dev(t,
        /*titre*/
        ctx[2]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(t);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_4.name,
      type: "if",
      source: "(39:8) {#if titre}",
      ctx: ctx
    });
    return block;
  } // (38:6) <svelte:element this={tagTitre} class="titre">


  function create_dynamic_element_1(ctx) {
    var svelte_element;
    var t;
    var slot;
    var if_block =
    /*titre*/
    ctx[2] && create_if_block_4(ctx);
    var svelte_element_levels = [{
      class: "titre"
    }];
    var svelte_element_data = {};

    for (var i = 0; i < svelte_element_levels.length; i += 1) {
      svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
    }

    var block = {
      c: function create() {
        svelte_element = element(
        /*tagTitre*/
        ctx[4]);
        if (if_block) if_block.c();
        t = space();
        slot = element("slot");
        attr_dev(slot, "name", "titre");
        add_location(slot, file$1, 41, 8, 1424);
        set_attributes(svelte_element, svelte_element_data);
        add_location(svelte_element, file$1, 37, 6, 1312);
      },
      m: function mount(target, anchor) {
        insert_dev(target, svelte_element, anchor);
        if (if_block) if_block.m(svelte_element, null);
        append_dev(svelte_element, t);
        append_dev(svelte_element, slot);
      },
      p: function update(ctx, dirty) {
        if (
        /*titre*/
        ctx[2]) {
          if (if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block = create_if_block_4(ctx);
            if_block.c();
            if_block.m(svelte_element, t);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }

        set_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [{
          class: "titre"
        }]));
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(svelte_element);
        if (if_block) if_block.d();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_dynamic_element_1.name,
      type: "child_dynamic_element",
      source: "(38:6) <svelte:element this={tagTitre} class=\\\"titre\\\">",
      ctx: ctx
    });
    return block;
  } // (30:10) {#if titre}


  function create_if_block_2(ctx) {
    var t;
    var block = {
      c: function create() {
        t = text(
        /*titre*/
        ctx[2]);
      },
      m: function mount(target, anchor) {
        insert_dev(target, t, anchor);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*titre*/
        4) set_data_dev(t,
        /*titre*/
        ctx[2]);
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(t);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block_2.name,
      type: "if",
      source: "(30:10) {#if titre}",
      ctx: ctx
    });
    return block;
  } // (28:4) <svelte:element this={tagTitre} class="titre">


  function create_dynamic_element(ctx) {
    var svelte_element;
    var button;
    var t0;
    var slot;
    var t1;
    var span;
    var button_aria_expanded_value;
    var mounted;
    var dispose;
    var if_block =
    /*titre*/
    ctx[2] && create_if_block_2(ctx);
    var svelte_element_levels = [{
      class: "titre"
    }];
    var svelte_element_data = {};

    for (var i = 0; i < svelte_element_levels.length; i += 1) {
      svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
    }

    var block = {
      c: function create() {
        svelte_element = element(
        /*tagTitre*/
        ctx[4]);
        button = element("button");
        if (if_block) if_block.c();
        t0 = space();
        slot = element("slot");
        t1 = space();
        span = element("span");
        attr_dev(slot, "name", "titre");
        add_location(slot, file$1, 32, 10, 1150);
        attr_dev(span, "class", "utd-icone-svg chevron-blanc");
        add_location(span, file$1, 33, 8, 1193);
        attr_dev(button, "type", "button");
        attr_dev(button, "class", "");
        attr_dev(button, "aria-controls",
        /*idContenu*/
        ctx[5]);
        attr_dev(button, "aria-expanded", button_aria_expanded_value =
        /*reduit*/
        ctx[0] === 'false');
        add_location(button, file$1, 28, 6, 947);
        set_attributes(svelte_element, svelte_element_data);
        add_location(svelte_element, file$1, 27, 4, 892);
      },
      m: function mount(target, anchor) {
        insert_dev(target, svelte_element, anchor);
        append_dev(svelte_element, button);
        if (if_block) if_block.m(button, null);
        append_dev(button, t0);
        append_dev(button, slot);
        append_dev(button, t1);
        append_dev(button, span);

        if (!mounted) {
          dispose = listen_dev(button, "click",
          /*toggleAffichageContenu*/
          ctx[6], false, false, false);
          mounted = true;
        }
      },
      p: function update(ctx, dirty) {
        if (
        /*titre*/
        ctx[2]) {
          if (if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block = create_if_block_2(ctx);
            if_block.c();
            if_block.m(button, t0);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }

        if (dirty &
        /*reduit*/
        1 && button_aria_expanded_value !== (button_aria_expanded_value =
        /*reduit*/
        ctx[0] === 'false')) {
          attr_dev(button, "aria-expanded", button_aria_expanded_value);
        }

        set_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [{
          class: "titre"
        }]));
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(svelte_element);
        if (if_block) if_block.d();
        mounted = false;
        dispose();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_dynamic_element.name,
      type: "child_dynamic_element",
      source: "(28:4) <svelte:element this={tagTitre} class=\\\"titre\\\">",
      ctx: ctx
    });
    return block;
  } // (49:4) {#if extensible === 'false' || reduit === 'false'}


  function create_if_block$1(ctx) {
    var div;
    var slot;
    var div_transition;
    var current;
    var block = {
      c: function create() {
        div = element("div");
        slot = element("slot");
        add_location(slot, file$1, 50, 6, 1656);
        add_location(div, file$1, 49, 4, 1607);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        append_dev(div, slot);
        current = true;
      },
      i: function intro(local) {
        if (current) return;
        add_render_callback(function () {
          if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {
            duration: 250
          }, true);
          div_transition.run(1);
        });
        current = true;
      },
      o: function outro(local) {
        if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {
          duration: 250
        }, false);
        div_transition.run(0);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
        if (detaching && div_transition) div_transition.end();
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block$1.name,
      type: "if",
      source: "(49:4) {#if extensible === 'false' || reduit === 'false'}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment$1(ctx) {
    var div2;
    var div0;
    var t0;
    var div1;
    var div2_class_value;
    var t1;
    var link;
    var current;

    function select_block_type(ctx, dirty) {
      if (
      /*extensible*/
      ctx[1] === 'true') return create_if_block_1;
      return create_else_block;
    }

    var current_block_type = select_block_type(ctx);
    var if_block0 = current_block_type(ctx);
    var if_block1 = (
    /*extensible*/
    ctx[1] === 'false' ||
    /*reduit*/
    ctx[0] === 'false') && create_if_block$1(ctx);
    var block = {
      c: function create() {
        div2 = element("div");
        div0 = element("div");
        if_block0.c();
        t0 = space();
        div1 = element("div");
        if (if_block1) if_block1.c();
        t1 = space();
        link = element("link");
        this.c = noop;
        attr_dev(div0, "class", "entete");
        add_location(div0, file$1, 25, 2, 833);
        attr_dev(div1, "id",
        /*idContenu*/
        ctx[5]);
        attr_dev(div1, "class", "contenu");
        add_location(div1, file$1, 47, 2, 1506);
        attr_dev(div2, "class", div2_class_value = "utd-component utd-section " + (
        /*extensible*/
        ctx[1] === 'true' ? 'extensible' : '') + " " + (
        /*reduit*/
        ctx[0] === 'false' ? 'ouvert' : '') + " " + (
        /*bordure*/
        ctx[3] === 'true' ? 'bordure' : ''));
        add_location(div2, file$1, 24, 0, 670);
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", "/css/utd-webcomponents.min.css");
        add_location(link, file$1, 57, 0, 1710);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        insert_dev(target, div2, anchor);
        append_dev(div2, div0);
        if_block0.m(div0, null);
        append_dev(div2, t0);
        append_dev(div2, div1);
        if (if_block1) if_block1.m(div1, null);
        insert_dev(target, t1, anchor);
        insert_dev(target, link, anchor);
        current = true;
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0.d(1);
          if_block0 = current_block_type(ctx);

          if (if_block0) {
            if_block0.c();
            if_block0.m(div0, null);
          }
        }

        if (
        /*extensible*/
        ctx[1] === 'false' ||
        /*reduit*/
        ctx[0] === 'false') {
          if (if_block1) {
            if (dirty &
            /*extensible, reduit*/
            3) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block$1(ctx);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(div1, null);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, function () {
            if_block1 = null;
          });
          check_outros();
        }

        if (!current || dirty &
        /*extensible, reduit, bordure*/
        11 && div2_class_value !== (div2_class_value = "utd-component utd-section " + (
        /*extensible*/
        ctx[1] === 'true' ? 'extensible' : '') + " " + (
        /*reduit*/
        ctx[0] === 'false' ? 'ouvert' : '') + " " + (
        /*bordure*/
        ctx[3] === 'true' ? 'bordure' : ''))) {
          attr_dev(div2, "class", div2_class_value);
        }
      },
      i: function intro(local) {
        if (current) return;
        transition_in(if_block1);
        current = true;
      },
      o: function outro(local) {
        transition_out(if_block1);
        current = false;
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div2);
        if_block0.d();
        if (if_block1) if_block1.d();
        if (detaching) detach_dev(t1);
        if (detaching) detach_dev(link);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment$1.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function instance$1($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-section', slots, []);
    var _$$props$extensible = $$props.extensible,
        extensible = _$$props$extensible === void 0 ? "true" : _$$props$extensible;
    var _$$props$reduit = $$props.reduit,
        reduit = _$$props$reduit === void 0 ? "true" : _$$props$reduit;
    var _$$props$titre = $$props.titre,
        titre = _$$props$titre === void 0 ? "" : _$$props$titre;
    var _$$props$bordure = $$props.bordure,
        bordure = _$$props$bordure === void 0 ? "true" : _$$props$bordure;
    var _$$props$tagTitre = $$props.tagTitre,
        tagTitre = _$$props$tagTitre === void 0 ? "h2" : _$$props$tagTitre;
    var idEntete = Utils.genererId();
    var idContenu = 'corps' + idEntete; //TODO éventuellement déterminer automatiquement le niveau de header via un script? 

    function toggleAffichageContenu() {
      $$invalidate(0, reduit = reduit === 'true' ? 'false' : 'true');
    }

    var writable_props = ['extensible', 'reduit', 'titre', 'bordure', 'tagTitre'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-section> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('extensible' in $$props) $$invalidate(1, extensible = $$props.extensible);
      if ('reduit' in $$props) $$invalidate(0, reduit = $$props.reduit);
      if ('titre' in $$props) $$invalidate(2, titre = $$props.titre);
      if ('bordure' in $$props) $$invalidate(3, bordure = $$props.bordure);
      if ('tagTitre' in $$props) $$invalidate(4, tagTitre = $$props.tagTitre);
    };

    $$self.$capture_state = function () {
      return {
        slide: slide,
        Utils: Utils,
        extensible: extensible,
        reduit: reduit,
        titre: titre,
        bordure: bordure,
        tagTitre: tagTitre,
        idEntete: idEntete,
        idContenu: idContenu,
        toggleAffichageContenu: toggleAffichageContenu
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('extensible' in $$props) $$invalidate(1, extensible = $$props.extensible);
      if ('reduit' in $$props) $$invalidate(0, reduit = $$props.reduit);
      if ('titre' in $$props) $$invalidate(2, titre = $$props.titre);
      if ('bordure' in $$props) $$invalidate(3, bordure = $$props.bordure);
      if ('tagTitre' in $$props) $$invalidate(4, tagTitre = $$props.tagTitre);
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    return [reduit, extensible, titre, bordure, tagTitre, idContenu, toggleAffichageContenu];
  }

  var Section = /*#__PURE__*/function (_SvelteElement) {
    _inherits(Section, _SvelteElement);

    var _super = _createSuper$1(Section);

    function Section(options) {
      var _this;

      _classCallCheck(this, Section);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance$1, create_fragment$1, safe_not_equal, {
        extensible: 1,
        reduit: 0,
        titre: 2,
        bordure: 3,
        tagTitre: 4
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(Section, [{
      key: "extensible",
      get: function get() {
        return this.$$.ctx[1];
      },
      set: function set(extensible) {
        this.$$set({
          extensible: extensible
        });
        flush();
      }
    }, {
      key: "reduit",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(reduit) {
        this.$$set({
          reduit: reduit
        });
        flush();
      }
    }, {
      key: "titre",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(titre) {
        this.$$set({
          titre: titre
        });
        flush();
      }
    }, {
      key: "bordure",
      get: function get() {
        return this.$$.ctx[3];
      },
      set: function set(bordure) {
        this.$$set({
          bordure: bordure
        });
        flush();
      }
    }, {
      key: "tagTitre",
      get: function get() {
        return this.$$.ctx[4];
      },
      set: function set(tagTitre) {
        this.$$set({
          tagTitre: tagTitre
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["extensible", "reduit", "titre", "bordure", "tagTitre"];
      }
    }]);

    return Section;
  }(SvelteElement);

  customElements.define("utd-section", Section);

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var file = "src\\librairie\\components\\menuAncres.svelte";

  function get_each_context(ctx, list, i) {
    var child_ctx = ctx.slice();
    child_ctx[4] = list[i];
    return child_ctx;
  } // (34:0) {#if ancres && ancres.length}


  function create_if_block(ctx) {
    var div;
    var h2;
    var t0;
    var t1;
    var nav;
    var ul;
    var each_value =
    /*ancres*/
    ctx[1];
    validate_each_argument(each_value);
    var each_blocks = [];

    for (var i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    }

    var block = {
      c: function create() {
        div = element("div");
        h2 = element("h2");
        t0 = text(
        /*titre*/
        ctx[0]);
        t1 = space();
        nav = element("nav");
        ul = element("ul");

        for (var _i = 0; _i < each_blocks.length; _i += 1) {
          each_blocks[_i].c();
        }

        attr_dev(h2, "id", "titreTableMatieres");
        add_location(h2, file, 35, 4, 787);
        add_location(ul, file, 37, 6, 884);
        attr_dev(nav, "aria-describedby", "titreTableMatieres");
        add_location(nav, file, 36, 4, 833);
        attr_dev(div, "class", "utd-component utd-menu-ancres");
        add_location(div, file, 34, 2, 738);
      },
      m: function mount(target, anchor) {
        insert_dev(target, div, anchor);
        append_dev(div, h2);
        append_dev(h2, t0);
        append_dev(div, t1);
        append_dev(div, nav);
        append_dev(nav, ul);

        for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {
          each_blocks[_i2].m(ul, null);
        }
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*titre*/
        1) set_data_dev(t0,
        /*titre*/
        ctx[0]);

        if (dirty &
        /*ancres*/
        2) {
          each_value =
          /*ancres*/
          ctx[1];
          validate_each_argument(each_value);

          var _i3;

          for (_i3 = 0; _i3 < each_value.length; _i3 += 1) {
            var child_ctx = get_each_context(ctx, each_value, _i3);

            if (each_blocks[_i3]) {
              each_blocks[_i3].p(child_ctx, dirty);
            } else {
              each_blocks[_i3] = create_each_block(child_ctx);

              each_blocks[_i3].c();

              each_blocks[_i3].m(ul, null);
            }
          }

          for (; _i3 < each_blocks.length; _i3 += 1) {
            each_blocks[_i3].d(1);
          }

          each_blocks.length = each_value.length;
        }
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(div);
        destroy_each(each_blocks, detaching);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_if_block.name,
      type: "if",
      source: "(34:0) {#if ancres && ancres.length}",
      ctx: ctx
    });
    return block;
  } // (39:8) {#each ancres as ancre}


  function create_each_block(ctx) {
    var li;
    var a;
    var t0_value =
    /*ancre*/
    ctx[4].innerText + "";
    var t0;
    var a_href_value;
    var t1;
    var block = {
      c: function create() {
        li = element("li");
        a = element("a");
        t0 = text(t0_value);
        t1 = space();
        attr_dev(a, "href", a_href_value = "#" +
        /*ancre*/
        ctx[4].id);
        add_location(a, file, 40, 12, 951);
        add_location(li, file, 39, 10, 933);
      },
      m: function mount(target, anchor) {
        insert_dev(target, li, anchor);
        append_dev(li, a);
        append_dev(a, t0);
        append_dev(li, t1);
      },
      p: function update(ctx, dirty) {
        if (dirty &
        /*ancres*/
        2 && t0_value !== (t0_value =
        /*ancre*/
        ctx[4].innerText + "")) set_data_dev(t0, t0_value);

        if (dirty &
        /*ancres*/
        2 && a_href_value !== (a_href_value = "#" +
        /*ancre*/
        ctx[4].id)) {
          attr_dev(a, "href", a_href_value);
        }
      },
      d: function destroy(detaching) {
        if (detaching) detach_dev(li);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_each_block.name,
      type: "each",
      source: "(39:8) {#each ancres as ancre}",
      ctx: ctx
    });
    return block;
  }

  function create_fragment(ctx) {
    var t;
    var link;
    var if_block =
    /*ancres*/
    ctx[1] &&
    /*ancres*/
    ctx[1].length && create_if_block(ctx);
    var block = {
      c: function create() {
        if (if_block) if_block.c();
        t = space();
        link = element("link");
        this.c = noop;
        attr_dev(link, "rel", "stylesheet");
        attr_dev(link, "href", "/css/utd-webcomponents.min.css");
        add_location(link, file, 48, 0, 1098);
      },
      l: function claim(nodes) {
        throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
      },
      m: function mount(target, anchor) {
        if (if_block) if_block.m(target, anchor);
        insert_dev(target, t, anchor);
        insert_dev(target, link, anchor);
      },
      p: function update(ctx, _ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            dirty = _ref2[0];

        if (
        /*ancres*/
        ctx[1] &&
        /*ancres*/
        ctx[1].length) {
          if (if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block = create_if_block(ctx);
            if_block.c();
            if_block.m(t.parentNode, t);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d: function destroy(detaching) {
        if (if_block) if_block.d(detaching);
        if (detaching) detach_dev(t);
        if (detaching) detach_dev(link);
      }
    };
    dispatch_dev("SvelteRegisterBlock", {
      block: block,
      id: create_fragment.name,
      type: "component",
      source: "",
      ctx: ctx
    });
    return block;
  }

  function instance($$self, $$props, $$invalidate) {
    var _$$props$$$slots = $$props.$$slots,
        slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots;
        $$props.$$scope;
    validate_slots('utd-menu-ancres', slots, []);
    var _$$props$titre = $$props.titre,
        titre = _$$props$titre === void 0 ? Utils.obtenirLanguePage() === 'fr' ? "Dans cette page :" : "On this page:" : _$$props$titre;
    var _$$props$selecteur = $$props.selecteur,
        selecteur = _$$props$selecteur === void 0 ? '.ancre' : _$$props$selecteur;
    var ancres;
    onMount(function () {
      $$invalidate(1, ancres = obtenirAncres());
    });

    function obtenirAncres() {
      var ancres = document.querySelectorAll(selecteur); //Ajouter un id aux ancres qui n'en n'auraient pas

      ancres.forEach(function (ancre) {
        if (!ancre.id) {
          ancre.id = Utils.genererId();
        }
      });
      return ancres;
    }

    var writable_props = ['titre', 'selecteur'];
    Object.keys($$props).forEach(function (key) {
      if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<utd-menu-ancres> was created with unknown prop '".concat(key, "'"));
    });

    $$self.$$set = function ($$props) {
      if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
      if ('selecteur' in $$props) $$invalidate(2, selecteur = $$props.selecteur);
    };

    $$self.$capture_state = function () {
      return {
        onMount: onMount,
        Utils: Utils,
        titre: titre,
        selecteur: selecteur,
        ancres: ancres,
        obtenirAncres: obtenirAncres
      };
    };

    $$self.$inject_state = function ($$props) {
      if ('titre' in $$props) $$invalidate(0, titre = $$props.titre);
      if ('selecteur' in $$props) $$invalidate(2, selecteur = $$props.selecteur);
      if ('ancres' in $$props) $$invalidate(1, ancres = $$props.ancres);
    };

    if ($$props && "$$inject" in $$props) {
      $$self.$inject_state($$props.$$inject);
    }

    return [titre, ancres, selecteur];
  }

  var MenuAncres = /*#__PURE__*/function (_SvelteElement) {
    _inherits(MenuAncres, _SvelteElement);

    var _super = _createSuper(MenuAncres);

    function MenuAncres(options) {
      var _this;

      _classCallCheck(this, MenuAncres);

      _this = _super.call(this);
      init(_assertThisInitialized(_this), {
        target: _this.shadowRoot,
        props: attribute_to_object(_this.attributes),
        customElement: true
      }, instance, create_fragment, safe_not_equal, {
        titre: 0,
        selecteur: 2
      }, null);

      if (options) {
        if (options.target) {
          insert_dev(options.target, _assertThisInitialized(_this), options.anchor);
        }

        if (options.props) {
          _this.$set(options.props);

          flush();
        }
      }

      return _this;
    }

    _createClass(MenuAncres, [{
      key: "titre",
      get: function get() {
        return this.$$.ctx[0];
      },
      set: function set(titre) {
        this.$$set({
          titre: titre
        });
        flush();
      }
    }, {
      key: "selecteur",
      get: function get() {
        return this.$$.ctx[2];
      },
      set: function set(selecteur) {
        this.$$set({
          selecteur: selecteur
        });
        flush();
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["titre", "selecteur"];
      }
    }]);

    return MenuAncres;
  }(SvelteElement);

  customElements.define("utd-menu-ancres", MenuAncres);

  exports.ajusterAccessibiliteLiens = ajusterAccessibiliteLiens;
  exports.customElements = customElements;
  exports.dialogue = dialogue;
  exports.extend = extend;
  exports.genererId = genererId;
  exports.message = message;
  exports.notification = notification;
  exports.obtenirLanguePage = obtenirLanguePage;
  exports.traitementEnCours = traitementEnCours;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
