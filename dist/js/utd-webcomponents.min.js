var utd = (function (exports) {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	var es_array_concat = {};

	var globalThis_1;
	var hasRequiredGlobalThis;

	function requireGlobalThis () {
		if (hasRequiredGlobalThis) return globalThis_1;
		hasRequiredGlobalThis = 1;
		var check = function (it) {
		  return it && it.Math === Math && it;
		};

		// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
		globalThis_1 =
		  // eslint-disable-next-line es/no-global-this -- safe
		  check(typeof globalThis == 'object' && globalThis) ||
		  check(typeof window == 'object' && window) ||
		  // eslint-disable-next-line no-restricted-globals -- safe
		  check(typeof self == 'object' && self) ||
		  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
		  check(typeof globalThis_1 == 'object' && globalThis_1) ||
		  // eslint-disable-next-line no-new-func -- fallback
		  (function () { return this; })() || Function('return this')();
		return globalThis_1;
	}

	var objectGetOwnPropertyDescriptor = {};

	var fails;
	var hasRequiredFails;

	function requireFails () {
		if (hasRequiredFails) return fails;
		hasRequiredFails = 1;
		fails = function (exec) {
		  try {
		    return !!exec();
		  } catch (error) {
		    return true;
		  }
		};
		return fails;
	}

	var descriptors;
	var hasRequiredDescriptors;

	function requireDescriptors () {
		if (hasRequiredDescriptors) return descriptors;
		hasRequiredDescriptors = 1;
		var fails = requireFails();

		// Detect IE8's incomplete defineProperty implementation
		descriptors = !fails(function () {
		  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
		  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
		});
		return descriptors;
	}

	var functionBindNative;
	var hasRequiredFunctionBindNative;

	function requireFunctionBindNative () {
		if (hasRequiredFunctionBindNative) return functionBindNative;
		hasRequiredFunctionBindNative = 1;
		var fails = requireFails();

		functionBindNative = !fails(function () {
		  // eslint-disable-next-line es/no-function-prototype-bind -- safe
		  var test = (function () { /* empty */ }).bind();
		  // eslint-disable-next-line no-prototype-builtins -- safe
		  return typeof test != 'function' || test.hasOwnProperty('prototype');
		});
		return functionBindNative;
	}

	var functionCall;
	var hasRequiredFunctionCall;

	function requireFunctionCall () {
		if (hasRequiredFunctionCall) return functionCall;
		hasRequiredFunctionCall = 1;
		var NATIVE_BIND = requireFunctionBindNative();

		var call = Function.prototype.call;
		// eslint-disable-next-line es/no-function-prototype-bind -- safe
		functionCall = NATIVE_BIND ? call.bind(call) : function () {
		  return call.apply(call, arguments);
		};
		return functionCall;
	}

	var objectPropertyIsEnumerable = {};

	var hasRequiredObjectPropertyIsEnumerable;

	function requireObjectPropertyIsEnumerable () {
		if (hasRequiredObjectPropertyIsEnumerable) return objectPropertyIsEnumerable;
		hasRequiredObjectPropertyIsEnumerable = 1;
		var $propertyIsEnumerable = {}.propertyIsEnumerable;
		// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
		var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

		// Nashorn ~ JDK8 bug
		var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

		// `Object.prototype.propertyIsEnumerable` method implementation
		// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
		objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
		  var descriptor = getOwnPropertyDescriptor(this, V);
		  return !!descriptor && descriptor.enumerable;
		} : $propertyIsEnumerable;
		return objectPropertyIsEnumerable;
	}

	var createPropertyDescriptor;
	var hasRequiredCreatePropertyDescriptor;

	function requireCreatePropertyDescriptor () {
		if (hasRequiredCreatePropertyDescriptor) return createPropertyDescriptor;
		hasRequiredCreatePropertyDescriptor = 1;
		createPropertyDescriptor = function (bitmap, value) {
		  return {
		    enumerable: !(bitmap & 1),
		    configurable: !(bitmap & 2),
		    writable: !(bitmap & 4),
		    value: value
		  };
		};
		return createPropertyDescriptor;
	}

	var functionUncurryThis;
	var hasRequiredFunctionUncurryThis;

	function requireFunctionUncurryThis () {
		if (hasRequiredFunctionUncurryThis) return functionUncurryThis;
		hasRequiredFunctionUncurryThis = 1;
		var NATIVE_BIND = requireFunctionBindNative();

		var FunctionPrototype = Function.prototype;
		var call = FunctionPrototype.call;
		// eslint-disable-next-line es/no-function-prototype-bind -- safe
		var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

		functionUncurryThis = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
		  return function () {
		    return call.apply(fn, arguments);
		  };
		};
		return functionUncurryThis;
	}

	var classofRaw;
	var hasRequiredClassofRaw;

	function requireClassofRaw () {
		if (hasRequiredClassofRaw) return classofRaw;
		hasRequiredClassofRaw = 1;
		var uncurryThis = requireFunctionUncurryThis();

		var toString = uncurryThis({}.toString);
		var stringSlice = uncurryThis(''.slice);

		classofRaw = function (it) {
		  return stringSlice(toString(it), 8, -1);
		};
		return classofRaw;
	}

	var indexedObject;
	var hasRequiredIndexedObject;

	function requireIndexedObject () {
		if (hasRequiredIndexedObject) return indexedObject;
		hasRequiredIndexedObject = 1;
		var uncurryThis = requireFunctionUncurryThis();
		var fails = requireFails();
		var classof = requireClassofRaw();

		var $Object = Object;
		var split = uncurryThis(''.split);

		// fallback for non-array-like ES3 and non-enumerable old V8 strings
		indexedObject = fails(function () {
		  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
		  // eslint-disable-next-line no-prototype-builtins -- safe
		  return !$Object('z').propertyIsEnumerable(0);
		}) ? function (it) {
		  return classof(it) === 'String' ? split(it, '') : $Object(it);
		} : $Object;
		return indexedObject;
	}

	var isNullOrUndefined;
	var hasRequiredIsNullOrUndefined;

	function requireIsNullOrUndefined () {
		if (hasRequiredIsNullOrUndefined) return isNullOrUndefined;
		hasRequiredIsNullOrUndefined = 1;
		// we can't use just `it == null` since of `document.all` special case
		// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
		isNullOrUndefined = function (it) {
		  return it === null || it === undefined;
		};
		return isNullOrUndefined;
	}

	var requireObjectCoercible;
	var hasRequiredRequireObjectCoercible;

	function requireRequireObjectCoercible () {
		if (hasRequiredRequireObjectCoercible) return requireObjectCoercible;
		hasRequiredRequireObjectCoercible = 1;
		var isNullOrUndefined = requireIsNullOrUndefined();

		var $TypeError = TypeError;

		// `RequireObjectCoercible` abstract operation
		// https://tc39.es/ecma262/#sec-requireobjectcoercible
		requireObjectCoercible = function (it) {
		  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
		  return it;
		};
		return requireObjectCoercible;
	}

	var toIndexedObject;
	var hasRequiredToIndexedObject;

	function requireToIndexedObject () {
		if (hasRequiredToIndexedObject) return toIndexedObject;
		hasRequiredToIndexedObject = 1;
		// toObject with fallback for non-array-like ES3 strings
		var IndexedObject = requireIndexedObject();
		var requireObjectCoercible = requireRequireObjectCoercible();

		toIndexedObject = function (it) {
		  return IndexedObject(requireObjectCoercible(it));
		};
		return toIndexedObject;
	}

	var isCallable;
	var hasRequiredIsCallable;

	function requireIsCallable () {
		if (hasRequiredIsCallable) return isCallable;
		hasRequiredIsCallable = 1;
		// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
		var documentAll = typeof document == 'object' && document.all;

		// `IsCallable` abstract operation
		// https://tc39.es/ecma262/#sec-iscallable
		// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
		isCallable = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
		  return typeof argument == 'function' || argument === documentAll;
		} : function (argument) {
		  return typeof argument == 'function';
		};
		return isCallable;
	}

	var isObject;
	var hasRequiredIsObject;

	function requireIsObject () {
		if (hasRequiredIsObject) return isObject;
		hasRequiredIsObject = 1;
		var isCallable = requireIsCallable();

		isObject = function (it) {
		  return typeof it == 'object' ? it !== null : isCallable(it);
		};
		return isObject;
	}

	var getBuiltIn;
	var hasRequiredGetBuiltIn;

	function requireGetBuiltIn () {
		if (hasRequiredGetBuiltIn) return getBuiltIn;
		hasRequiredGetBuiltIn = 1;
		var globalThis = requireGlobalThis();
		var isCallable = requireIsCallable();

		var aFunction = function (argument) {
		  return isCallable(argument) ? argument : undefined;
		};

		getBuiltIn = function (namespace, method) {
		  return arguments.length < 2 ? aFunction(globalThis[namespace]) : globalThis[namespace] && globalThis[namespace][method];
		};
		return getBuiltIn;
	}

	var objectIsPrototypeOf;
	var hasRequiredObjectIsPrototypeOf;

	function requireObjectIsPrototypeOf () {
		if (hasRequiredObjectIsPrototypeOf) return objectIsPrototypeOf;
		hasRequiredObjectIsPrototypeOf = 1;
		var uncurryThis = requireFunctionUncurryThis();

		objectIsPrototypeOf = uncurryThis({}.isPrototypeOf);
		return objectIsPrototypeOf;
	}

	var environmentUserAgent;
	var hasRequiredEnvironmentUserAgent;

	function requireEnvironmentUserAgent () {
		if (hasRequiredEnvironmentUserAgent) return environmentUserAgent;
		hasRequiredEnvironmentUserAgent = 1;
		var globalThis = requireGlobalThis();

		var navigator = globalThis.navigator;
		var userAgent = navigator && navigator.userAgent;

		environmentUserAgent = userAgent ? String(userAgent) : '';
		return environmentUserAgent;
	}

	var environmentV8Version;
	var hasRequiredEnvironmentV8Version;

	function requireEnvironmentV8Version () {
		if (hasRequiredEnvironmentV8Version) return environmentV8Version;
		hasRequiredEnvironmentV8Version = 1;
		var globalThis = requireGlobalThis();
		var userAgent = requireEnvironmentUserAgent();

		var process = globalThis.process;
		var Deno = globalThis.Deno;
		var versions = process && process.versions || Deno && Deno.version;
		var v8 = versions && versions.v8;
		var match, version;

		if (v8) {
		  match = v8.split('.');
		  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
		  // but their correct versions are not interesting for us
		  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
		}

		// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
		// so check `userAgent` even if `.v8` exists, but 0
		if (!version && userAgent) {
		  match = userAgent.match(/Edge\/(\d+)/);
		  if (!match || match[1] >= 74) {
		    match = userAgent.match(/Chrome\/(\d+)/);
		    if (match) version = +match[1];
		  }
		}

		environmentV8Version = version;
		return environmentV8Version;
	}

	var symbolConstructorDetection;
	var hasRequiredSymbolConstructorDetection;

	function requireSymbolConstructorDetection () {
		if (hasRequiredSymbolConstructorDetection) return symbolConstructorDetection;
		hasRequiredSymbolConstructorDetection = 1;
		/* eslint-disable es/no-symbol -- required for testing */
		var V8_VERSION = requireEnvironmentV8Version();
		var fails = requireFails();
		var globalThis = requireGlobalThis();

		var $String = globalThis.String;

		// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
		symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails(function () {
		  var symbol = Symbol('symbol detection');
		  // Chrome 38 Symbol has incorrect toString conversion
		  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
		  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
		  // of course, fail.
		  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
		    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
		    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
		});
		return symbolConstructorDetection;
	}

	var useSymbolAsUid;
	var hasRequiredUseSymbolAsUid;

	function requireUseSymbolAsUid () {
		if (hasRequiredUseSymbolAsUid) return useSymbolAsUid;
		hasRequiredUseSymbolAsUid = 1;
		/* eslint-disable es/no-symbol -- required for testing */
		var NATIVE_SYMBOL = requireSymbolConstructorDetection();

		useSymbolAsUid = NATIVE_SYMBOL &&
		  !Symbol.sham &&
		  typeof Symbol.iterator == 'symbol';
		return useSymbolAsUid;
	}

	var isSymbol;
	var hasRequiredIsSymbol;

	function requireIsSymbol () {
		if (hasRequiredIsSymbol) return isSymbol;
		hasRequiredIsSymbol = 1;
		var getBuiltIn = requireGetBuiltIn();
		var isCallable = requireIsCallable();
		var isPrototypeOf = requireObjectIsPrototypeOf();
		var USE_SYMBOL_AS_UID = requireUseSymbolAsUid();

		var $Object = Object;

		isSymbol = USE_SYMBOL_AS_UID ? function (it) {
		  return typeof it == 'symbol';
		} : function (it) {
		  var $Symbol = getBuiltIn('Symbol');
		  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
		};
		return isSymbol;
	}

	var tryToString;
	var hasRequiredTryToString;

	function requireTryToString () {
		if (hasRequiredTryToString) return tryToString;
		hasRequiredTryToString = 1;
		var $String = String;

		tryToString = function (argument) {
		  try {
		    return $String(argument);
		  } catch (error) {
		    return 'Object';
		  }
		};
		return tryToString;
	}

	var aCallable;
	var hasRequiredACallable;

	function requireACallable () {
		if (hasRequiredACallable) return aCallable;
		hasRequiredACallable = 1;
		var isCallable = requireIsCallable();
		var tryToString = requireTryToString();

		var $TypeError = TypeError;

		// `Assert: IsCallable(argument) is true`
		aCallable = function (argument) {
		  if (isCallable(argument)) return argument;
		  throw new $TypeError(tryToString(argument) + ' is not a function');
		};
		return aCallable;
	}

	var getMethod;
	var hasRequiredGetMethod;

	function requireGetMethod () {
		if (hasRequiredGetMethod) return getMethod;
		hasRequiredGetMethod = 1;
		var aCallable = requireACallable();
		var isNullOrUndefined = requireIsNullOrUndefined();

		// `GetMethod` abstract operation
		// https://tc39.es/ecma262/#sec-getmethod
		getMethod = function (V, P) {
		  var func = V[P];
		  return isNullOrUndefined(func) ? undefined : aCallable(func);
		};
		return getMethod;
	}

	var ordinaryToPrimitive;
	var hasRequiredOrdinaryToPrimitive;

	function requireOrdinaryToPrimitive () {
		if (hasRequiredOrdinaryToPrimitive) return ordinaryToPrimitive;
		hasRequiredOrdinaryToPrimitive = 1;
		var call = requireFunctionCall();
		var isCallable = requireIsCallable();
		var isObject = requireIsObject();

		var $TypeError = TypeError;

		// `OrdinaryToPrimitive` abstract operation
		// https://tc39.es/ecma262/#sec-ordinarytoprimitive
		ordinaryToPrimitive = function (input, pref) {
		  var fn, val;
		  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
		  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
		  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
		  throw new $TypeError("Can't convert object to primitive value");
		};
		return ordinaryToPrimitive;
	}

	var sharedStore = {exports: {}};

	var isPure;
	var hasRequiredIsPure;

	function requireIsPure () {
		if (hasRequiredIsPure) return isPure;
		hasRequiredIsPure = 1;
		isPure = false;
		return isPure;
	}

	var defineGlobalProperty;
	var hasRequiredDefineGlobalProperty;

	function requireDefineGlobalProperty () {
		if (hasRequiredDefineGlobalProperty) return defineGlobalProperty;
		hasRequiredDefineGlobalProperty = 1;
		var globalThis = requireGlobalThis();

		// eslint-disable-next-line es/no-object-defineproperty -- safe
		var defineProperty = Object.defineProperty;

		defineGlobalProperty = function (key, value) {
		  try {
		    defineProperty(globalThis, key, { value: value, configurable: true, writable: true });
		  } catch (error) {
		    globalThis[key] = value;
		  } return value;
		};
		return defineGlobalProperty;
	}

	var hasRequiredSharedStore;

	function requireSharedStore () {
		if (hasRequiredSharedStore) return sharedStore.exports;
		hasRequiredSharedStore = 1;
		var IS_PURE = requireIsPure();
		var globalThis = requireGlobalThis();
		var defineGlobalProperty = requireDefineGlobalProperty();

		var SHARED = '__core-js_shared__';
		var store = sharedStore.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});

		(store.versions || (store.versions = [])).push({
		  version: '3.45.1',
		  mode: IS_PURE ? 'pure' : 'global',
		  copyright: 'Â© 2014-2025 Denis Pushkarev (zloirock.ru)',
		  license: 'https://github.com/zloirock/core-js/blob/v3.45.1/LICENSE',
		  source: 'https://github.com/zloirock/core-js'
		});
		return sharedStore.exports;
	}

	var shared;
	var hasRequiredShared;

	function requireShared () {
		if (hasRequiredShared) return shared;
		hasRequiredShared = 1;
		var store = requireSharedStore();

		shared = function (key, value) {
		  return store[key] || (store[key] = value || {});
		};
		return shared;
	}

	var toObject;
	var hasRequiredToObject;

	function requireToObject () {
		if (hasRequiredToObject) return toObject;
		hasRequiredToObject = 1;
		var requireObjectCoercible = requireRequireObjectCoercible();

		var $Object = Object;

		// `ToObject` abstract operation
		// https://tc39.es/ecma262/#sec-toobject
		toObject = function (argument) {
		  return $Object(requireObjectCoercible(argument));
		};
		return toObject;
	}

	var hasOwnProperty_1;
	var hasRequiredHasOwnProperty;

	function requireHasOwnProperty () {
		if (hasRequiredHasOwnProperty) return hasOwnProperty_1;
		hasRequiredHasOwnProperty = 1;
		var uncurryThis = requireFunctionUncurryThis();
		var toObject = requireToObject();

		var hasOwnProperty = uncurryThis({}.hasOwnProperty);

		// `HasOwnProperty` abstract operation
		// https://tc39.es/ecma262/#sec-hasownproperty
		// eslint-disable-next-line es/no-object-hasown -- safe
		hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {
		  return hasOwnProperty(toObject(it), key);
		};
		return hasOwnProperty_1;
	}

	var uid;
	var hasRequiredUid;

	function requireUid () {
		if (hasRequiredUid) return uid;
		hasRequiredUid = 1;
		var uncurryThis = requireFunctionUncurryThis();

		var id = 0;
		var postfix = Math.random();
		var toString = uncurryThis(1.1.toString);

		uid = function (key) {
		  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
		};
		return uid;
	}

	var wellKnownSymbol;
	var hasRequiredWellKnownSymbol;

	function requireWellKnownSymbol () {
		if (hasRequiredWellKnownSymbol) return wellKnownSymbol;
		hasRequiredWellKnownSymbol = 1;
		var globalThis = requireGlobalThis();
		var shared = requireShared();
		var hasOwn = requireHasOwnProperty();
		var uid = requireUid();
		var NATIVE_SYMBOL = requireSymbolConstructorDetection();
		var USE_SYMBOL_AS_UID = requireUseSymbolAsUid();

		var Symbol = globalThis.Symbol;
		var WellKnownSymbolsStore = shared('wks');
		var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

		wellKnownSymbol = function (name) {
		  if (!hasOwn(WellKnownSymbolsStore, name)) {
		    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
		      ? Symbol[name]
		      : createWellKnownSymbol('Symbol.' + name);
		  } return WellKnownSymbolsStore[name];
		};
		return wellKnownSymbol;
	}

	var toPrimitive$1;
	var hasRequiredToPrimitive;

	function requireToPrimitive () {
		if (hasRequiredToPrimitive) return toPrimitive$1;
		hasRequiredToPrimitive = 1;
		var call = requireFunctionCall();
		var isObject = requireIsObject();
		var isSymbol = requireIsSymbol();
		var getMethod = requireGetMethod();
		var ordinaryToPrimitive = requireOrdinaryToPrimitive();
		var wellKnownSymbol = requireWellKnownSymbol();

		var $TypeError = TypeError;
		var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

		// `ToPrimitive` abstract operation
		// https://tc39.es/ecma262/#sec-toprimitive
		toPrimitive$1 = function (input, pref) {
		  if (!isObject(input) || isSymbol(input)) return input;
		  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
		  var result;
		  if (exoticToPrim) {
		    if (pref === undefined) pref = 'default';
		    result = call(exoticToPrim, input, pref);
		    if (!isObject(result) || isSymbol(result)) return result;
		    throw new $TypeError("Can't convert object to primitive value");
		  }
		  if (pref === undefined) pref = 'number';
		  return ordinaryToPrimitive(input, pref);
		};
		return toPrimitive$1;
	}

	var toPropertyKey$1;
	var hasRequiredToPropertyKey;

	function requireToPropertyKey () {
		if (hasRequiredToPropertyKey) return toPropertyKey$1;
		hasRequiredToPropertyKey = 1;
		var toPrimitive = requireToPrimitive();
		var isSymbol = requireIsSymbol();

		// `ToPropertyKey` abstract operation
		// https://tc39.es/ecma262/#sec-topropertykey
		toPropertyKey$1 = function (argument) {
		  var key = toPrimitive(argument, 'string');
		  return isSymbol(key) ? key : key + '';
		};
		return toPropertyKey$1;
	}

	var documentCreateElement;
	var hasRequiredDocumentCreateElement;

	function requireDocumentCreateElement () {
		if (hasRequiredDocumentCreateElement) return documentCreateElement;
		hasRequiredDocumentCreateElement = 1;
		var globalThis = requireGlobalThis();
		var isObject = requireIsObject();

		var document = globalThis.document;
		// typeof document.createElement is 'object' in old IE
		var EXISTS = isObject(document) && isObject(document.createElement);

		documentCreateElement = function (it) {
		  return EXISTS ? document.createElement(it) : {};
		};
		return documentCreateElement;
	}

	var ie8DomDefine;
	var hasRequiredIe8DomDefine;

	function requireIe8DomDefine () {
		if (hasRequiredIe8DomDefine) return ie8DomDefine;
		hasRequiredIe8DomDefine = 1;
		var DESCRIPTORS = requireDescriptors();
		var fails = requireFails();
		var createElement = requireDocumentCreateElement();

		// Thanks to IE8 for its funny defineProperty
		ie8DomDefine = !DESCRIPTORS && !fails(function () {
		  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
		  return Object.defineProperty(createElement('div'), 'a', {
		    get: function () { return 7; }
		  }).a !== 7;
		});
		return ie8DomDefine;
	}

	var hasRequiredObjectGetOwnPropertyDescriptor;

	function requireObjectGetOwnPropertyDescriptor () {
		if (hasRequiredObjectGetOwnPropertyDescriptor) return objectGetOwnPropertyDescriptor;
		hasRequiredObjectGetOwnPropertyDescriptor = 1;
		var DESCRIPTORS = requireDescriptors();
		var call = requireFunctionCall();
		var propertyIsEnumerableModule = requireObjectPropertyIsEnumerable();
		var createPropertyDescriptor = requireCreatePropertyDescriptor();
		var toIndexedObject = requireToIndexedObject();
		var toPropertyKey = requireToPropertyKey();
		var hasOwn = requireHasOwnProperty();
		var IE8_DOM_DEFINE = requireIe8DomDefine();

		// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
		var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

		// `Object.getOwnPropertyDescriptor` method
		// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
		objectGetOwnPropertyDescriptor.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
		  O = toIndexedObject(O);
		  P = toPropertyKey(P);
		  if (IE8_DOM_DEFINE) try {
		    return $getOwnPropertyDescriptor(O, P);
		  } catch (error) { /* empty */ }
		  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
		};
		return objectGetOwnPropertyDescriptor;
	}

	var objectDefineProperty = {};

	var v8PrototypeDefineBug;
	var hasRequiredV8PrototypeDefineBug;

	function requireV8PrototypeDefineBug () {
		if (hasRequiredV8PrototypeDefineBug) return v8PrototypeDefineBug;
		hasRequiredV8PrototypeDefineBug = 1;
		var DESCRIPTORS = requireDescriptors();
		var fails = requireFails();

		// V8 ~ Chrome 36-
		// https://bugs.chromium.org/p/v8/issues/detail?id=3334
		v8PrototypeDefineBug = DESCRIPTORS && fails(function () {
		  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
		  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
		    value: 42,
		    writable: false
		  }).prototype !== 42;
		});
		return v8PrototypeDefineBug;
	}

	var anObject;
	var hasRequiredAnObject;

	function requireAnObject () {
		if (hasRequiredAnObject) return anObject;
		hasRequiredAnObject = 1;
		var isObject = requireIsObject();

		var $String = String;
		var $TypeError = TypeError;

		// `Assert: Type(argument) is Object`
		anObject = function (argument) {
		  if (isObject(argument)) return argument;
		  throw new $TypeError($String(argument) + ' is not an object');
		};
		return anObject;
	}

	var hasRequiredObjectDefineProperty;

	function requireObjectDefineProperty () {
		if (hasRequiredObjectDefineProperty) return objectDefineProperty;
		hasRequiredObjectDefineProperty = 1;
		var DESCRIPTORS = requireDescriptors();
		var IE8_DOM_DEFINE = requireIe8DomDefine();
		var V8_PROTOTYPE_DEFINE_BUG = requireV8PrototypeDefineBug();
		var anObject = requireAnObject();
		var toPropertyKey = requireToPropertyKey();

		var $TypeError = TypeError;
		// eslint-disable-next-line es/no-object-defineproperty -- safe
		var $defineProperty = Object.defineProperty;
		// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
		var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
		var ENUMERABLE = 'enumerable';
		var CONFIGURABLE = 'configurable';
		var WRITABLE = 'writable';

		// `Object.defineProperty` method
		// https://tc39.es/ecma262/#sec-object.defineproperty
		objectDefineProperty.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
		  anObject(O);
		  P = toPropertyKey(P);
		  anObject(Attributes);
		  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
		    var current = $getOwnPropertyDescriptor(O, P);
		    if (current && current[WRITABLE]) {
		      O[P] = Attributes.value;
		      Attributes = {
		        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
		        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
		        writable: false
		      };
		    }
		  } return $defineProperty(O, P, Attributes);
		} : $defineProperty : function defineProperty(O, P, Attributes) {
		  anObject(O);
		  P = toPropertyKey(P);
		  anObject(Attributes);
		  if (IE8_DOM_DEFINE) try {
		    return $defineProperty(O, P, Attributes);
		  } catch (error) { /* empty */ }
		  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
		  if ('value' in Attributes) O[P] = Attributes.value;
		  return O;
		};
		return objectDefineProperty;
	}

	var createNonEnumerableProperty;
	var hasRequiredCreateNonEnumerableProperty;

	function requireCreateNonEnumerableProperty () {
		if (hasRequiredCreateNonEnumerableProperty) return createNonEnumerableProperty;
		hasRequiredCreateNonEnumerableProperty = 1;
		var DESCRIPTORS = requireDescriptors();
		var definePropertyModule = requireObjectDefineProperty();
		var createPropertyDescriptor = requireCreatePropertyDescriptor();

		createNonEnumerableProperty = DESCRIPTORS ? function (object, key, value) {
		  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
		} : function (object, key, value) {
		  object[key] = value;
		  return object;
		};
		return createNonEnumerableProperty;
	}

	var makeBuiltIn = {exports: {}};

	var functionName;
	var hasRequiredFunctionName;

	function requireFunctionName () {
		if (hasRequiredFunctionName) return functionName;
		hasRequiredFunctionName = 1;
		var DESCRIPTORS = requireDescriptors();
		var hasOwn = requireHasOwnProperty();

		var FunctionPrototype = Function.prototype;
		// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
		var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

		var EXISTS = hasOwn(FunctionPrototype, 'name');
		// additional protection from minified / mangled / dropped function names
		var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
		var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

		functionName = {
		  EXISTS: EXISTS,
		  PROPER: PROPER,
		  CONFIGURABLE: CONFIGURABLE
		};
		return functionName;
	}

	var inspectSource;
	var hasRequiredInspectSource;

	function requireInspectSource () {
		if (hasRequiredInspectSource) return inspectSource;
		hasRequiredInspectSource = 1;
		var uncurryThis = requireFunctionUncurryThis();
		var isCallable = requireIsCallable();
		var store = requireSharedStore();

		var functionToString = uncurryThis(Function.toString);

		// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
		if (!isCallable(store.inspectSource)) {
		  store.inspectSource = function (it) {
		    return functionToString(it);
		  };
		}

		inspectSource = store.inspectSource;
		return inspectSource;
	}

	var weakMapBasicDetection;
	var hasRequiredWeakMapBasicDetection;

	function requireWeakMapBasicDetection () {
		if (hasRequiredWeakMapBasicDetection) return weakMapBasicDetection;
		hasRequiredWeakMapBasicDetection = 1;
		var globalThis = requireGlobalThis();
		var isCallable = requireIsCallable();

		var WeakMap = globalThis.WeakMap;

		weakMapBasicDetection = isCallable(WeakMap) && /native code/.test(String(WeakMap));
		return weakMapBasicDetection;
	}

	var sharedKey;
	var hasRequiredSharedKey;

	function requireSharedKey () {
		if (hasRequiredSharedKey) return sharedKey;
		hasRequiredSharedKey = 1;
		var shared = requireShared();
		var uid = requireUid();

		var keys = shared('keys');

		sharedKey = function (key) {
		  return keys[key] || (keys[key] = uid(key));
		};
		return sharedKey;
	}

	var hiddenKeys;
	var hasRequiredHiddenKeys;

	function requireHiddenKeys () {
		if (hasRequiredHiddenKeys) return hiddenKeys;
		hasRequiredHiddenKeys = 1;
		hiddenKeys = {};
		return hiddenKeys;
	}

	var internalState;
	var hasRequiredInternalState;

	function requireInternalState () {
		if (hasRequiredInternalState) return internalState;
		hasRequiredInternalState = 1;
		var NATIVE_WEAK_MAP = requireWeakMapBasicDetection();
		var globalThis = requireGlobalThis();
		var isObject = requireIsObject();
		var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
		var hasOwn = requireHasOwnProperty();
		var shared = requireSharedStore();
		var sharedKey = requireSharedKey();
		var hiddenKeys = requireHiddenKeys();

		var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
		var TypeError = globalThis.TypeError;
		var WeakMap = globalThis.WeakMap;
		var set, get, has;

		var enforce = function (it) {
		  return has(it) ? get(it) : set(it, {});
		};

		var getterFor = function (TYPE) {
		  return function (it) {
		    var state;
		    if (!isObject(it) || (state = get(it)).type !== TYPE) {
		      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
		    } return state;
		  };
		};

		if (NATIVE_WEAK_MAP || shared.state) {
		  var store = shared.state || (shared.state = new WeakMap());
		  /* eslint-disable no-self-assign -- prototype methods protection */
		  store.get = store.get;
		  store.has = store.has;
		  store.set = store.set;
		  /* eslint-enable no-self-assign -- prototype methods protection */
		  set = function (it, metadata) {
		    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
		    metadata.facade = it;
		    store.set(it, metadata);
		    return metadata;
		  };
		  get = function (it) {
		    return store.get(it) || {};
		  };
		  has = function (it) {
		    return store.has(it);
		  };
		} else {
		  var STATE = sharedKey('state');
		  hiddenKeys[STATE] = true;
		  set = function (it, metadata) {
		    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
		    metadata.facade = it;
		    createNonEnumerableProperty(it, STATE, metadata);
		    return metadata;
		  };
		  get = function (it) {
		    return hasOwn(it, STATE) ? it[STATE] : {};
		  };
		  has = function (it) {
		    return hasOwn(it, STATE);
		  };
		}

		internalState = {
		  set: set,
		  get: get,
		  has: has,
		  enforce: enforce,
		  getterFor: getterFor
		};
		return internalState;
	}

	var hasRequiredMakeBuiltIn;

	function requireMakeBuiltIn () {
		if (hasRequiredMakeBuiltIn) return makeBuiltIn.exports;
		hasRequiredMakeBuiltIn = 1;
		var uncurryThis = requireFunctionUncurryThis();
		var fails = requireFails();
		var isCallable = requireIsCallable();
		var hasOwn = requireHasOwnProperty();
		var DESCRIPTORS = requireDescriptors();
		var CONFIGURABLE_FUNCTION_NAME = requireFunctionName().CONFIGURABLE;
		var inspectSource = requireInspectSource();
		var InternalStateModule = requireInternalState();

		var enforceInternalState = InternalStateModule.enforce;
		var getInternalState = InternalStateModule.get;
		var $String = String;
		// eslint-disable-next-line es/no-object-defineproperty -- safe
		var defineProperty = Object.defineProperty;
		var stringSlice = uncurryThis(''.slice);
		var replace = uncurryThis(''.replace);
		var join = uncurryThis([].join);

		var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
		  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
		});

		var TEMPLATE = String(String).split('String');

		var makeBuiltIn$1 = makeBuiltIn.exports = function (value, name, options) {
		  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
		    name = '[' + replace($String(name), /^Symbol\(([^)]*)\).*$/, '$1') + ']';
		  }
		  if (options && options.getter) name = 'get ' + name;
		  if (options && options.setter) name = 'set ' + name;
		  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
		    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
		    else value.name = name;
		  }
		  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
		    defineProperty(value, 'length', { value: options.arity });
		  }
		  try {
		    if (options && hasOwn(options, 'constructor') && options.constructor) {
		      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
		    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
		    } else if (value.prototype) value.prototype = undefined;
		  } catch (error) { /* empty */ }
		  var state = enforceInternalState(value);
		  if (!hasOwn(state, 'source')) {
		    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
		  } return value;
		};

		// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
		// eslint-disable-next-line no-extend-native -- required
		Function.prototype.toString = makeBuiltIn$1(function toString() {
		  return isCallable(this) && getInternalState(this).source || inspectSource(this);
		}, 'toString');
		return makeBuiltIn.exports;
	}

	var defineBuiltIn;
	var hasRequiredDefineBuiltIn;

	function requireDefineBuiltIn () {
		if (hasRequiredDefineBuiltIn) return defineBuiltIn;
		hasRequiredDefineBuiltIn = 1;
		var isCallable = requireIsCallable();
		var definePropertyModule = requireObjectDefineProperty();
		var makeBuiltIn = requireMakeBuiltIn();
		var defineGlobalProperty = requireDefineGlobalProperty();

		defineBuiltIn = function (O, key, value, options) {
		  if (!options) options = {};
		  var simple = options.enumerable;
		  var name = options.name !== undefined ? options.name : key;
		  if (isCallable(value)) makeBuiltIn(value, name, options);
		  if (options.global) {
		    if (simple) O[key] = value;
		    else defineGlobalProperty(key, value);
		  } else {
		    try {
		      if (!options.unsafe) delete O[key];
		      else if (O[key]) simple = true;
		    } catch (error) { /* empty */ }
		    if (simple) O[key] = value;
		    else definePropertyModule.f(O, key, {
		      value: value,
		      enumerable: false,
		      configurable: !options.nonConfigurable,
		      writable: !options.nonWritable
		    });
		  } return O;
		};
		return defineBuiltIn;
	}

	var objectGetOwnPropertyNames = {};

	var mathTrunc;
	var hasRequiredMathTrunc;

	function requireMathTrunc () {
		if (hasRequiredMathTrunc) return mathTrunc;
		hasRequiredMathTrunc = 1;
		var ceil = Math.ceil;
		var floor = Math.floor;

		// `Math.trunc` method
		// https://tc39.es/ecma262/#sec-math.trunc
		// eslint-disable-next-line es/no-math-trunc -- safe
		mathTrunc = Math.trunc || function trunc(x) {
		  var n = +x;
		  return (n > 0 ? floor : ceil)(n);
		};
		return mathTrunc;
	}

	var toIntegerOrInfinity;
	var hasRequiredToIntegerOrInfinity;

	function requireToIntegerOrInfinity () {
		if (hasRequiredToIntegerOrInfinity) return toIntegerOrInfinity;
		hasRequiredToIntegerOrInfinity = 1;
		var trunc = requireMathTrunc();

		// `ToIntegerOrInfinity` abstract operation
		// https://tc39.es/ecma262/#sec-tointegerorinfinity
		toIntegerOrInfinity = function (argument) {
		  var number = +argument;
		  // eslint-disable-next-line no-self-compare -- NaN check
		  return number !== number || number === 0 ? 0 : trunc(number);
		};
		return toIntegerOrInfinity;
	}

	var toAbsoluteIndex;
	var hasRequiredToAbsoluteIndex;

	function requireToAbsoluteIndex () {
		if (hasRequiredToAbsoluteIndex) return toAbsoluteIndex;
		hasRequiredToAbsoluteIndex = 1;
		var toIntegerOrInfinity = requireToIntegerOrInfinity();

		var max = Math.max;
		var min = Math.min;

		// Helper for a popular repeating case of the spec:
		// Let integer be ? ToInteger(index).
		// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
		toAbsoluteIndex = function (index, length) {
		  var integer = toIntegerOrInfinity(index);
		  return integer < 0 ? max(integer + length, 0) : min(integer, length);
		};
		return toAbsoluteIndex;
	}

	var toLength;
	var hasRequiredToLength;

	function requireToLength () {
		if (hasRequiredToLength) return toLength;
		hasRequiredToLength = 1;
		var toIntegerOrInfinity = requireToIntegerOrInfinity();

		var min = Math.min;

		// `ToLength` abstract operation
		// https://tc39.es/ecma262/#sec-tolength
		toLength = function (argument) {
		  var len = toIntegerOrInfinity(argument);
		  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
		};
		return toLength;
	}

	var lengthOfArrayLike;
	var hasRequiredLengthOfArrayLike;

	function requireLengthOfArrayLike () {
		if (hasRequiredLengthOfArrayLike) return lengthOfArrayLike;
		hasRequiredLengthOfArrayLike = 1;
		var toLength = requireToLength();

		// `LengthOfArrayLike` abstract operation
		// https://tc39.es/ecma262/#sec-lengthofarraylike
		lengthOfArrayLike = function (obj) {
		  return toLength(obj.length);
		};
		return lengthOfArrayLike;
	}

	var arrayIncludes;
	var hasRequiredArrayIncludes;

	function requireArrayIncludes () {
		if (hasRequiredArrayIncludes) return arrayIncludes;
		hasRequiredArrayIncludes = 1;
		var toIndexedObject = requireToIndexedObject();
		var toAbsoluteIndex = requireToAbsoluteIndex();
		var lengthOfArrayLike = requireLengthOfArrayLike();

		// `Array.prototype.{ indexOf, includes }` methods implementation
		var createMethod = function (IS_INCLUDES) {
		  return function ($this, el, fromIndex) {
		    var O = toIndexedObject($this);
		    var length = lengthOfArrayLike(O);
		    if (length === 0) return !IS_INCLUDES && -1;
		    var index = toAbsoluteIndex(fromIndex, length);
		    var value;
		    // Array#includes uses SameValueZero equality algorithm
		    // eslint-disable-next-line no-self-compare -- NaN check
		    if (IS_INCLUDES && el !== el) while (length > index) {
		      value = O[index++];
		      // eslint-disable-next-line no-self-compare -- NaN check
		      if (value !== value) return true;
		    // Array#indexOf ignores holes, Array#includes - not
		    } else for (;length > index; index++) {
		      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
		    } return !IS_INCLUDES && -1;
		  };
		};

		arrayIncludes = {
		  // `Array.prototype.includes` method
		  // https://tc39.es/ecma262/#sec-array.prototype.includes
		  includes: createMethod(true),
		  // `Array.prototype.indexOf` method
		  // https://tc39.es/ecma262/#sec-array.prototype.indexof
		  indexOf: createMethod(false)
		};
		return arrayIncludes;
	}

	var objectKeysInternal;
	var hasRequiredObjectKeysInternal;

	function requireObjectKeysInternal () {
		if (hasRequiredObjectKeysInternal) return objectKeysInternal;
		hasRequiredObjectKeysInternal = 1;
		var uncurryThis = requireFunctionUncurryThis();
		var hasOwn = requireHasOwnProperty();
		var toIndexedObject = requireToIndexedObject();
		var indexOf = requireArrayIncludes().indexOf;
		var hiddenKeys = requireHiddenKeys();

		var push = uncurryThis([].push);

		objectKeysInternal = function (object, names) {
		  var O = toIndexedObject(object);
		  var i = 0;
		  var result = [];
		  var key;
		  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
		  // Don't enum bug & hidden keys
		  while (names.length > i) if (hasOwn(O, key = names[i++])) {
		    ~indexOf(result, key) || push(result, key);
		  }
		  return result;
		};
		return objectKeysInternal;
	}

	var enumBugKeys;
	var hasRequiredEnumBugKeys;

	function requireEnumBugKeys () {
		if (hasRequiredEnumBugKeys) return enumBugKeys;
		hasRequiredEnumBugKeys = 1;
		// IE8- don't enum bug keys
		enumBugKeys = [
		  'constructor',
		  'hasOwnProperty',
		  'isPrototypeOf',
		  'propertyIsEnumerable',
		  'toLocaleString',
		  'toString',
		  'valueOf'
		];
		return enumBugKeys;
	}

	var hasRequiredObjectGetOwnPropertyNames;

	function requireObjectGetOwnPropertyNames () {
		if (hasRequiredObjectGetOwnPropertyNames) return objectGetOwnPropertyNames;
		hasRequiredObjectGetOwnPropertyNames = 1;
		var internalObjectKeys = requireObjectKeysInternal();
		var enumBugKeys = requireEnumBugKeys();

		var hiddenKeys = enumBugKeys.concat('length', 'prototype');

		// `Object.getOwnPropertyNames` method
		// https://tc39.es/ecma262/#sec-object.getownpropertynames
		// eslint-disable-next-line es/no-object-getownpropertynames -- safe
		objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
		  return internalObjectKeys(O, hiddenKeys);
		};
		return objectGetOwnPropertyNames;
	}

	var objectGetOwnPropertySymbols = {};

	var hasRequiredObjectGetOwnPropertySymbols;

	function requireObjectGetOwnPropertySymbols () {
		if (hasRequiredObjectGetOwnPropertySymbols) return objectGetOwnPropertySymbols;
		hasRequiredObjectGetOwnPropertySymbols = 1;
		// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
		objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
		return objectGetOwnPropertySymbols;
	}

	var ownKeys$s;
	var hasRequiredOwnKeys;

	function requireOwnKeys () {
		if (hasRequiredOwnKeys) return ownKeys$s;
		hasRequiredOwnKeys = 1;
		var getBuiltIn = requireGetBuiltIn();
		var uncurryThis = requireFunctionUncurryThis();
		var getOwnPropertyNamesModule = requireObjectGetOwnPropertyNames();
		var getOwnPropertySymbolsModule = requireObjectGetOwnPropertySymbols();
		var anObject = requireAnObject();

		var concat = uncurryThis([].concat);

		// all object keys, includes non-enumerable and symbols
		ownKeys$s = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
		  var keys = getOwnPropertyNamesModule.f(anObject(it));
		  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
		  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
		};
		return ownKeys$s;
	}

	var copyConstructorProperties;
	var hasRequiredCopyConstructorProperties;

	function requireCopyConstructorProperties () {
		if (hasRequiredCopyConstructorProperties) return copyConstructorProperties;
		hasRequiredCopyConstructorProperties = 1;
		var hasOwn = requireHasOwnProperty();
		var ownKeys = requireOwnKeys();
		var getOwnPropertyDescriptorModule = requireObjectGetOwnPropertyDescriptor();
		var definePropertyModule = requireObjectDefineProperty();

		copyConstructorProperties = function (target, source, exceptions) {
		  var keys = ownKeys(source);
		  var defineProperty = definePropertyModule.f;
		  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
		  for (var i = 0; i < keys.length; i++) {
		    var key = keys[i];
		    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
		      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
		    }
		  }
		};
		return copyConstructorProperties;
	}

	var isForced_1;
	var hasRequiredIsForced;

	function requireIsForced () {
		if (hasRequiredIsForced) return isForced_1;
		hasRequiredIsForced = 1;
		var fails = requireFails();
		var isCallable = requireIsCallable();

		var replacement = /#|\.prototype\./;

		var isForced = function (feature, detection) {
		  var value = data[normalize(feature)];
		  return value === POLYFILL ? true
		    : value === NATIVE ? false
		    : isCallable(detection) ? fails(detection)
		    : !!detection;
		};

		var normalize = isForced.normalize = function (string) {
		  return String(string).replace(replacement, '.').toLowerCase();
		};

		var data = isForced.data = {};
		var NATIVE = isForced.NATIVE = 'N';
		var POLYFILL = isForced.POLYFILL = 'P';

		isForced_1 = isForced;
		return isForced_1;
	}

	var _export;
	var hasRequired_export;

	function require_export () {
		if (hasRequired_export) return _export;
		hasRequired_export = 1;
		var globalThis = requireGlobalThis();
		var getOwnPropertyDescriptor = requireObjectGetOwnPropertyDescriptor().f;
		var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
		var defineBuiltIn = requireDefineBuiltIn();
		var defineGlobalProperty = requireDefineGlobalProperty();
		var copyConstructorProperties = requireCopyConstructorProperties();
		var isForced = requireIsForced();

		/*
		  options.target         - name of the target object
		  options.global         - target is the global object
		  options.stat           - export as static methods of target
		  options.proto          - export as prototype methods of target
		  options.real           - real prototype method for the `pure` version
		  options.forced         - export even if the native feature is available
		  options.bind           - bind methods to the target, required for the `pure` version
		  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
		  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
		  options.sham           - add a flag to not completely full polyfills
		  options.enumerable     - export as enumerable property
		  options.dontCallGetSet - prevent calling a getter on target
		  options.name           - the .name of the function if it does not match the key
		*/
		_export = function (options, source) {
		  var TARGET = options.target;
		  var GLOBAL = options.global;
		  var STATIC = options.stat;
		  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
		  if (GLOBAL) {
		    target = globalThis;
		  } else if (STATIC) {
		    target = globalThis[TARGET] || defineGlobalProperty(TARGET, {});
		  } else {
		    target = globalThis[TARGET] && globalThis[TARGET].prototype;
		  }
		  if (target) for (key in source) {
		    sourceProperty = source[key];
		    if (options.dontCallGetSet) {
		      descriptor = getOwnPropertyDescriptor(target, key);
		      targetProperty = descriptor && descriptor.value;
		    } else targetProperty = target[key];
		    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
		    // contained in target
		    if (!FORCED && targetProperty !== undefined) {
		      if (typeof sourceProperty == typeof targetProperty) continue;
		      copyConstructorProperties(sourceProperty, targetProperty);
		    }
		    // add a flag to not completely full polyfills
		    if (options.sham || (targetProperty && targetProperty.sham)) {
		      createNonEnumerableProperty(sourceProperty, 'sham', true);
		    }
		    defineBuiltIn(target, key, sourceProperty, options);
		  }
		};
		return _export;
	}

	var isArray;
	var hasRequiredIsArray;

	function requireIsArray () {
		if (hasRequiredIsArray) return isArray;
		hasRequiredIsArray = 1;
		var classof = requireClassofRaw();

		// `IsArray` abstract operation
		// https://tc39.es/ecma262/#sec-isarray
		// eslint-disable-next-line es/no-array-isarray -- safe
		isArray = Array.isArray || function isArray(argument) {
		  return classof(argument) === 'Array';
		};
		return isArray;
	}

	var doesNotExceedSafeInteger;
	var hasRequiredDoesNotExceedSafeInteger;

	function requireDoesNotExceedSafeInteger () {
		if (hasRequiredDoesNotExceedSafeInteger) return doesNotExceedSafeInteger;
		hasRequiredDoesNotExceedSafeInteger = 1;
		var $TypeError = TypeError;
		var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

		doesNotExceedSafeInteger = function (it) {
		  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
		  return it;
		};
		return doesNotExceedSafeInteger;
	}

	var createProperty;
	var hasRequiredCreateProperty;

	function requireCreateProperty () {
		if (hasRequiredCreateProperty) return createProperty;
		hasRequiredCreateProperty = 1;
		var DESCRIPTORS = requireDescriptors();
		var definePropertyModule = requireObjectDefineProperty();
		var createPropertyDescriptor = requireCreatePropertyDescriptor();

		createProperty = function (object, key, value) {
		  if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));
		  else object[key] = value;
		};
		return createProperty;
	}

	var toStringTagSupport;
	var hasRequiredToStringTagSupport;

	function requireToStringTagSupport () {
		if (hasRequiredToStringTagSupport) return toStringTagSupport;
		hasRequiredToStringTagSupport = 1;
		var wellKnownSymbol = requireWellKnownSymbol();

		var TO_STRING_TAG = wellKnownSymbol('toStringTag');
		var test = {};

		test[TO_STRING_TAG] = 'z';

		toStringTagSupport = String(test) === '[object z]';
		return toStringTagSupport;
	}

	var classof;
	var hasRequiredClassof;

	function requireClassof () {
		if (hasRequiredClassof) return classof;
		hasRequiredClassof = 1;
		var TO_STRING_TAG_SUPPORT = requireToStringTagSupport();
		var isCallable = requireIsCallable();
		var classofRaw = requireClassofRaw();
		var wellKnownSymbol = requireWellKnownSymbol();

		var TO_STRING_TAG = wellKnownSymbol('toStringTag');
		var $Object = Object;

		// ES3 wrong here
		var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';

		// fallback for IE11 Script Access Denied error
		var tryGet = function (it, key) {
		  try {
		    return it[key];
		  } catch (error) { /* empty */ }
		};

		// getting tag from ES6+ `Object.prototype.toString`
		classof = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
		  var O, tag, result;
		  return it === undefined ? 'Undefined' : it === null ? 'Null'
		    // @@toStringTag case
		    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
		    // builtinTag case
		    : CORRECT_ARGUMENTS ? classofRaw(O)
		    // ES3 arguments fallback
		    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
		};
		return classof;
	}

	var isConstructor;
	var hasRequiredIsConstructor;

	function requireIsConstructor () {
		if (hasRequiredIsConstructor) return isConstructor;
		hasRequiredIsConstructor = 1;
		var uncurryThis = requireFunctionUncurryThis();
		var fails = requireFails();
		var isCallable = requireIsCallable();
		var classof = requireClassof();
		var getBuiltIn = requireGetBuiltIn();
		var inspectSource = requireInspectSource();

		var noop = function () { /* empty */ };
		var construct = getBuiltIn('Reflect', 'construct');
		var constructorRegExp = /^\s*(?:class|function)\b/;
		var exec = uncurryThis(constructorRegExp.exec);
		var INCORRECT_TO_STRING = !constructorRegExp.test(noop);

		var isConstructorModern = function isConstructor(argument) {
		  if (!isCallable(argument)) return false;
		  try {
		    construct(noop, [], argument);
		    return true;
		  } catch (error) {
		    return false;
		  }
		};

		var isConstructorLegacy = function isConstructor(argument) {
		  if (!isCallable(argument)) return false;
		  switch (classof(argument)) {
		    case 'AsyncFunction':
		    case 'GeneratorFunction':
		    case 'AsyncGeneratorFunction': return false;
		  }
		  try {
		    // we can't check .prototype since constructors produced by .bind haven't it
		    // `Function#toString` throws on some built-it function in some legacy engines
		    // (for example, `DOMQuad` and similar in FF41-)
		    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
		  } catch (error) {
		    return true;
		  }
		};

		isConstructorLegacy.sham = true;

		// `IsConstructor` abstract operation
		// https://tc39.es/ecma262/#sec-isconstructor
		isConstructor = !construct || fails(function () {
		  var called;
		  return isConstructorModern(isConstructorModern.call)
		    || !isConstructorModern(Object)
		    || !isConstructorModern(function () { called = true; })
		    || called;
		}) ? isConstructorLegacy : isConstructorModern;
		return isConstructor;
	}

	var arraySpeciesConstructor;
	var hasRequiredArraySpeciesConstructor;

	function requireArraySpeciesConstructor () {
		if (hasRequiredArraySpeciesConstructor) return arraySpeciesConstructor;
		hasRequiredArraySpeciesConstructor = 1;
		var isArray = requireIsArray();
		var isConstructor = requireIsConstructor();
		var isObject = requireIsObject();
		var wellKnownSymbol = requireWellKnownSymbol();

		var SPECIES = wellKnownSymbol('species');
		var $Array = Array;

		// a part of `ArraySpeciesCreate` abstract operation
		// https://tc39.es/ecma262/#sec-arrayspeciescreate
		arraySpeciesConstructor = function (originalArray) {
		  var C;
		  if (isArray(originalArray)) {
		    C = originalArray.constructor;
		    // cross-realm fallback
		    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;
		    else if (isObject(C)) {
		      C = C[SPECIES];
		      if (C === null) C = undefined;
		    }
		  } return C === undefined ? $Array : C;
		};
		return arraySpeciesConstructor;
	}

	var arraySpeciesCreate;
	var hasRequiredArraySpeciesCreate;

	function requireArraySpeciesCreate () {
		if (hasRequiredArraySpeciesCreate) return arraySpeciesCreate;
		hasRequiredArraySpeciesCreate = 1;
		var arraySpeciesConstructor = requireArraySpeciesConstructor();

		// `ArraySpeciesCreate` abstract operation
		// https://tc39.es/ecma262/#sec-arrayspeciescreate
		arraySpeciesCreate = function (originalArray, length) {
		  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
		};
		return arraySpeciesCreate;
	}

	var arrayMethodHasSpeciesSupport;
	var hasRequiredArrayMethodHasSpeciesSupport;

	function requireArrayMethodHasSpeciesSupport () {
		if (hasRequiredArrayMethodHasSpeciesSupport) return arrayMethodHasSpeciesSupport;
		hasRequiredArrayMethodHasSpeciesSupport = 1;
		var fails = requireFails();
		var wellKnownSymbol = requireWellKnownSymbol();
		var V8_VERSION = requireEnvironmentV8Version();

		var SPECIES = wellKnownSymbol('species');

		arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
		  // We can't use this feature detection in V8 since it causes
		  // deoptimization and serious performance degradation
		  // https://github.com/zloirock/core-js/issues/677
		  return V8_VERSION >= 51 || !fails(function () {
		    var array = [];
		    var constructor = array.constructor = {};
		    constructor[SPECIES] = function () {
		      return { foo: 1 };
		    };
		    return array[METHOD_NAME](Boolean).foo !== 1;
		  });
		};
		return arrayMethodHasSpeciesSupport;
	}

	var hasRequiredEs_array_concat;

	function requireEs_array_concat () {
		if (hasRequiredEs_array_concat) return es_array_concat;
		hasRequiredEs_array_concat = 1;
		var $ = require_export();
		var fails = requireFails();
		var isArray = requireIsArray();
		var isObject = requireIsObject();
		var toObject = requireToObject();
		var lengthOfArrayLike = requireLengthOfArrayLike();
		var doesNotExceedSafeInteger = requireDoesNotExceedSafeInteger();
		var createProperty = requireCreateProperty();
		var arraySpeciesCreate = requireArraySpeciesCreate();
		var arrayMethodHasSpeciesSupport = requireArrayMethodHasSpeciesSupport();
		var wellKnownSymbol = requireWellKnownSymbol();
		var V8_VERSION = requireEnvironmentV8Version();

		var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');

		// We can't use this feature detection in V8 since it causes
		// deoptimization and serious performance degradation
		// https://github.com/zloirock/core-js/issues/679
		var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
		  var array = [];
		  array[IS_CONCAT_SPREADABLE] = false;
		  return array.concat()[0] !== array;
		});

		var isConcatSpreadable = function (O) {
		  if (!isObject(O)) return false;
		  var spreadable = O[IS_CONCAT_SPREADABLE];
		  return spreadable !== undefined ? !!spreadable : isArray(O);
		};

		var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport('concat');

		// `Array.prototype.concat` method
		// https://tc39.es/ecma262/#sec-array.prototype.concat
		// with adding support of @@isConcatSpreadable and @@species
		$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
		  // eslint-disable-next-line no-unused-vars -- required for `.length`
		  concat: function concat(arg) {
		    var O = toObject(this);
		    var A = arraySpeciesCreate(O, 0);
		    var n = 0;
		    var i, k, length, len, E;
		    for (i = -1, length = arguments.length; i < length; i++) {
		      E = i === -1 ? O : arguments[i];
		      if (isConcatSpreadable(E)) {
		        len = lengthOfArrayLike(E);
		        doesNotExceedSafeInteger(n + len);
		        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
		      } else {
		        doesNotExceedSafeInteger(n + 1);
		        createProperty(A, n++, E);
		      }
		    }
		    A.length = n;
		    return A;
		  }
		});
		return es_array_concat;
	}

	requireEs_array_concat();

	var es_array_includes = {};

	var objectDefineProperties = {};

	var objectKeys;
	var hasRequiredObjectKeys;

	function requireObjectKeys () {
		if (hasRequiredObjectKeys) return objectKeys;
		hasRequiredObjectKeys = 1;
		var internalObjectKeys = requireObjectKeysInternal();
		var enumBugKeys = requireEnumBugKeys();

		// `Object.keys` method
		// https://tc39.es/ecma262/#sec-object.keys
		// eslint-disable-next-line es/no-object-keys -- safe
		objectKeys = Object.keys || function keys(O) {
		  return internalObjectKeys(O, enumBugKeys);
		};
		return objectKeys;
	}

	var hasRequiredObjectDefineProperties;

	function requireObjectDefineProperties () {
		if (hasRequiredObjectDefineProperties) return objectDefineProperties;
		hasRequiredObjectDefineProperties = 1;
		var DESCRIPTORS = requireDescriptors();
		var V8_PROTOTYPE_DEFINE_BUG = requireV8PrototypeDefineBug();
		var definePropertyModule = requireObjectDefineProperty();
		var anObject = requireAnObject();
		var toIndexedObject = requireToIndexedObject();
		var objectKeys = requireObjectKeys();

		// `Object.defineProperties` method
		// https://tc39.es/ecma262/#sec-object.defineproperties
		// eslint-disable-next-line es/no-object-defineproperties -- safe
		objectDefineProperties.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
		  anObject(O);
		  var props = toIndexedObject(Properties);
		  var keys = objectKeys(Properties);
		  var length = keys.length;
		  var index = 0;
		  var key;
		  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
		  return O;
		};
		return objectDefineProperties;
	}

	var html$1;
	var hasRequiredHtml;

	function requireHtml () {
		if (hasRequiredHtml) return html$1;
		hasRequiredHtml = 1;
		var getBuiltIn = requireGetBuiltIn();

		html$1 = getBuiltIn('document', 'documentElement');
		return html$1;
	}

	var objectCreate;
	var hasRequiredObjectCreate;

	function requireObjectCreate () {
		if (hasRequiredObjectCreate) return objectCreate;
		hasRequiredObjectCreate = 1;
		/* global ActiveXObject -- old IE, WSH */
		var anObject = requireAnObject();
		var definePropertiesModule = requireObjectDefineProperties();
		var enumBugKeys = requireEnumBugKeys();
		var hiddenKeys = requireHiddenKeys();
		var html = requireHtml();
		var documentCreateElement = requireDocumentCreateElement();
		var sharedKey = requireSharedKey();

		var GT = '>';
		var LT = '<';
		var PROTOTYPE = 'prototype';
		var SCRIPT = 'script';
		var IE_PROTO = sharedKey('IE_PROTO');

		var EmptyConstructor = function () { /* empty */ };

		var scriptTag = function (content) {
		  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
		};

		// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
		var NullProtoObjectViaActiveX = function (activeXDocument) {
		  activeXDocument.write(scriptTag(''));
		  activeXDocument.close();
		  var temp = activeXDocument.parentWindow.Object;
		  // eslint-disable-next-line no-useless-assignment -- avoid memory leak
		  activeXDocument = null;
		  return temp;
		};

		// Create object with fake `null` prototype: use iframe Object with cleared prototype
		var NullProtoObjectViaIFrame = function () {
		  // Thrash, waste and sodomy: IE GC bug
		  var iframe = documentCreateElement('iframe');
		  var JS = 'java' + SCRIPT + ':';
		  var iframeDocument;
		  iframe.style.display = 'none';
		  html.appendChild(iframe);
		  // https://github.com/zloirock/core-js/issues/475
		  iframe.src = String(JS);
		  iframeDocument = iframe.contentWindow.document;
		  iframeDocument.open();
		  iframeDocument.write(scriptTag('document.F=Object'));
		  iframeDocument.close();
		  return iframeDocument.F;
		};

		// Check for document.domain and active x support
		// No need to use active x approach when document.domain is not set
		// see https://github.com/es-shims/es5-shim/issues/150
		// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
		// avoid IE GC bug
		var activeXDocument;
		var NullProtoObject = function () {
		  try {
		    activeXDocument = new ActiveXObject('htmlfile');
		  } catch (error) { /* ignore */ }
		  NullProtoObject = typeof document != 'undefined'
		    ? document.domain && activeXDocument
		      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
		      : NullProtoObjectViaIFrame()
		    : NullProtoObjectViaActiveX(activeXDocument); // WSH
		  var length = enumBugKeys.length;
		  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
		  return NullProtoObject();
		};

		hiddenKeys[IE_PROTO] = true;

		// `Object.create` method
		// https://tc39.es/ecma262/#sec-object.create
		// eslint-disable-next-line es/no-object-create -- safe
		objectCreate = Object.create || function create(O, Properties) {
		  var result;
		  if (O !== null) {
		    EmptyConstructor[PROTOTYPE] = anObject(O);
		    result = new EmptyConstructor();
		    EmptyConstructor[PROTOTYPE] = null;
		    // add "__proto__" for Object.getPrototypeOf polyfill
		    result[IE_PROTO] = O;
		  } else result = NullProtoObject();
		  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
		};
		return objectCreate;
	}

	var addToUnscopables;
	var hasRequiredAddToUnscopables;

	function requireAddToUnscopables () {
		if (hasRequiredAddToUnscopables) return addToUnscopables;
		hasRequiredAddToUnscopables = 1;
		var wellKnownSymbol = requireWellKnownSymbol();
		var create = requireObjectCreate();
		var defineProperty = requireObjectDefineProperty().f;

		var UNSCOPABLES = wellKnownSymbol('unscopables');
		var ArrayPrototype = Array.prototype;

		// Array.prototype[@@unscopables]
		// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
		if (ArrayPrototype[UNSCOPABLES] === undefined) {
		  defineProperty(ArrayPrototype, UNSCOPABLES, {
		    configurable: true,
		    value: create(null)
		  });
		}

		// add a key to Array.prototype[@@unscopables]
		addToUnscopables = function (key) {
		  ArrayPrototype[UNSCOPABLES][key] = true;
		};
		return addToUnscopables;
	}

	var hasRequiredEs_array_includes;

	function requireEs_array_includes () {
		if (hasRequiredEs_array_includes) return es_array_includes;
		hasRequiredEs_array_includes = 1;
		var $ = require_export();
		var $includes = requireArrayIncludes().includes;
		var fails = requireFails();
		var addToUnscopables = requireAddToUnscopables();

		// FF99+ bug
		var BROKEN_ON_SPARSE = fails(function () {
		  // eslint-disable-next-line es/no-array-prototype-includes -- detection
		  return !Array(1).includes();
		});

		// `Array.prototype.includes` method
		// https://tc39.es/ecma262/#sec-array.prototype.includes
		$({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {
		  includes: function includes(el /* , fromIndex = 0 */) {
		    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
		  }
		});

		// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
		addToUnscopables('includes');
		return es_array_includes;
	}

	requireEs_array_includes();

	var es_array_join = {};

	var arrayMethodIsStrict;
	var hasRequiredArrayMethodIsStrict;

	function requireArrayMethodIsStrict () {
		if (hasRequiredArrayMethodIsStrict) return arrayMethodIsStrict;
		hasRequiredArrayMethodIsStrict = 1;
		var fails = requireFails();

		arrayMethodIsStrict = function (METHOD_NAME, argument) {
		  var method = [][METHOD_NAME];
		  return !!method && fails(function () {
		    // eslint-disable-next-line no-useless-call -- required for testing
		    method.call(null, argument || function () { return 1; }, 1);
		  });
		};
		return arrayMethodIsStrict;
	}

	var hasRequiredEs_array_join;

	function requireEs_array_join () {
		if (hasRequiredEs_array_join) return es_array_join;
		hasRequiredEs_array_join = 1;
		var $ = require_export();
		var uncurryThis = requireFunctionUncurryThis();
		var IndexedObject = requireIndexedObject();
		var toIndexedObject = requireToIndexedObject();
		var arrayMethodIsStrict = requireArrayMethodIsStrict();

		var nativeJoin = uncurryThis([].join);

		var ES3_STRINGS = IndexedObject !== Object;
		var FORCED = ES3_STRINGS || !arrayMethodIsStrict('join', ',');

		// `Array.prototype.join` method
		// https://tc39.es/ecma262/#sec-array.prototype.join
		$({ target: 'Array', proto: true, forced: FORCED }, {
		  join: function join(separator) {
		    return nativeJoin(toIndexedObject(this), separator === undefined ? ',' : separator);
		  }
		});
		return es_array_join;
	}

	requireEs_array_join();

	var es_object_toString = {};

	var objectToString;
	var hasRequiredObjectToString;

	function requireObjectToString () {
		if (hasRequiredObjectToString) return objectToString;
		hasRequiredObjectToString = 1;
		var TO_STRING_TAG_SUPPORT = requireToStringTagSupport();
		var classof = requireClassof();

		// `Object.prototype.toString` method implementation
		// https://tc39.es/ecma262/#sec-object.prototype.tostring
		objectToString = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
		  return '[object ' + classof(this) + ']';
		};
		return objectToString;
	}

	var hasRequiredEs_object_toString;

	function requireEs_object_toString () {
		if (hasRequiredEs_object_toString) return es_object_toString;
		hasRequiredEs_object_toString = 1;
		var TO_STRING_TAG_SUPPORT = requireToStringTagSupport();
		var defineBuiltIn = requireDefineBuiltIn();
		var toString = requireObjectToString();

		// `Object.prototype.toString` method
		// https://tc39.es/ecma262/#sec-object.prototype.tostring
		if (!TO_STRING_TAG_SUPPORT) {
		  defineBuiltIn(Object.prototype, 'toString', toString, { unsafe: true });
		}
		return es_object_toString;
	}

	requireEs_object_toString();

	var es_promise = {};

	var es_promise_constructor = {};

	var environment;
	var hasRequiredEnvironment;

	function requireEnvironment () {
		if (hasRequiredEnvironment) return environment;
		hasRequiredEnvironment = 1;
		/* global Bun, Deno -- detection */
		var globalThis = requireGlobalThis();
		var userAgent = requireEnvironmentUserAgent();
		var classof = requireClassofRaw();

		var userAgentStartsWith = function (string) {
		  return userAgent.slice(0, string.length) === string;
		};

		environment = (function () {
		  if (userAgentStartsWith('Bun/')) return 'BUN';
		  if (userAgentStartsWith('Cloudflare-Workers')) return 'CLOUDFLARE';
		  if (userAgentStartsWith('Deno/')) return 'DENO';
		  if (userAgentStartsWith('Node.js/')) return 'NODE';
		  if (globalThis.Bun && typeof Bun.version == 'string') return 'BUN';
		  if (globalThis.Deno && typeof Deno.version == 'object') return 'DENO';
		  if (classof(globalThis.process) === 'process') return 'NODE';
		  if (globalThis.window && globalThis.document) return 'BROWSER';
		  return 'REST';
		})();
		return environment;
	}

	var environmentIsNode;
	var hasRequiredEnvironmentIsNode;

	function requireEnvironmentIsNode () {
		if (hasRequiredEnvironmentIsNode) return environmentIsNode;
		hasRequiredEnvironmentIsNode = 1;
		var ENVIRONMENT = requireEnvironment();

		environmentIsNode = ENVIRONMENT === 'NODE';
		return environmentIsNode;
	}

	var path;
	var hasRequiredPath;

	function requirePath () {
		if (hasRequiredPath) return path;
		hasRequiredPath = 1;
		var globalThis = requireGlobalThis();

		path = globalThis;
		return path;
	}

	var functionUncurryThisAccessor;
	var hasRequiredFunctionUncurryThisAccessor;

	function requireFunctionUncurryThisAccessor () {
		if (hasRequiredFunctionUncurryThisAccessor) return functionUncurryThisAccessor;
		hasRequiredFunctionUncurryThisAccessor = 1;
		var uncurryThis = requireFunctionUncurryThis();
		var aCallable = requireACallable();

		functionUncurryThisAccessor = function (object, key, method) {
		  try {
		    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
		    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
		  } catch (error) { /* empty */ }
		};
		return functionUncurryThisAccessor;
	}

	var isPossiblePrototype;
	var hasRequiredIsPossiblePrototype;

	function requireIsPossiblePrototype () {
		if (hasRequiredIsPossiblePrototype) return isPossiblePrototype;
		hasRequiredIsPossiblePrototype = 1;
		var isObject = requireIsObject();

		isPossiblePrototype = function (argument) {
		  return isObject(argument) || argument === null;
		};
		return isPossiblePrototype;
	}

	var aPossiblePrototype;
	var hasRequiredAPossiblePrototype;

	function requireAPossiblePrototype () {
		if (hasRequiredAPossiblePrototype) return aPossiblePrototype;
		hasRequiredAPossiblePrototype = 1;
		var isPossiblePrototype = requireIsPossiblePrototype();

		var $String = String;
		var $TypeError = TypeError;

		aPossiblePrototype = function (argument) {
		  if (isPossiblePrototype(argument)) return argument;
		  throw new $TypeError("Can't set " + $String(argument) + ' as a prototype');
		};
		return aPossiblePrototype;
	}

	var objectSetPrototypeOf;
	var hasRequiredObjectSetPrototypeOf;

	function requireObjectSetPrototypeOf () {
		if (hasRequiredObjectSetPrototypeOf) return objectSetPrototypeOf;
		hasRequiredObjectSetPrototypeOf = 1;
		/* eslint-disable no-proto -- safe */
		var uncurryThisAccessor = requireFunctionUncurryThisAccessor();
		var isObject = requireIsObject();
		var requireObjectCoercible = requireRequireObjectCoercible();
		var aPossiblePrototype = requireAPossiblePrototype();

		// `Object.setPrototypeOf` method
		// https://tc39.es/ecma262/#sec-object.setprototypeof
		// Works with __proto__ only. Old v8 can't work with null proto objects.
		// eslint-disable-next-line es/no-object-setprototypeof -- safe
		objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
		  var CORRECT_SETTER = false;
		  var test = {};
		  var setter;
		  try {
		    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
		    setter(test, []);
		    CORRECT_SETTER = test instanceof Array;
		  } catch (error) { /* empty */ }
		  return function setPrototypeOf(O, proto) {
		    requireObjectCoercible(O);
		    aPossiblePrototype(proto);
		    if (!isObject(O)) return O;
		    if (CORRECT_SETTER) setter(O, proto);
		    else O.__proto__ = proto;
		    return O;
		  };
		}() : undefined);
		return objectSetPrototypeOf;
	}

	var setToStringTag;
	var hasRequiredSetToStringTag;

	function requireSetToStringTag () {
		if (hasRequiredSetToStringTag) return setToStringTag;
		hasRequiredSetToStringTag = 1;
		var defineProperty = requireObjectDefineProperty().f;
		var hasOwn = requireHasOwnProperty();
		var wellKnownSymbol = requireWellKnownSymbol();

		var TO_STRING_TAG = wellKnownSymbol('toStringTag');

		setToStringTag = function (target, TAG, STATIC) {
		  if (target && !STATIC) target = target.prototype;
		  if (target && !hasOwn(target, TO_STRING_TAG)) {
		    defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
		  }
		};
		return setToStringTag;
	}

	var defineBuiltInAccessor;
	var hasRequiredDefineBuiltInAccessor;

	function requireDefineBuiltInAccessor () {
		if (hasRequiredDefineBuiltInAccessor) return defineBuiltInAccessor;
		hasRequiredDefineBuiltInAccessor = 1;
		var makeBuiltIn = requireMakeBuiltIn();
		var defineProperty = requireObjectDefineProperty();

		defineBuiltInAccessor = function (target, name, descriptor) {
		  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
		  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
		  return defineProperty.f(target, name, descriptor);
		};
		return defineBuiltInAccessor;
	}

	var setSpecies;
	var hasRequiredSetSpecies;

	function requireSetSpecies () {
		if (hasRequiredSetSpecies) return setSpecies;
		hasRequiredSetSpecies = 1;
		var getBuiltIn = requireGetBuiltIn();
		var defineBuiltInAccessor = requireDefineBuiltInAccessor();
		var wellKnownSymbol = requireWellKnownSymbol();
		var DESCRIPTORS = requireDescriptors();

		var SPECIES = wellKnownSymbol('species');

		setSpecies = function (CONSTRUCTOR_NAME) {
		  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);

		  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
		    defineBuiltInAccessor(Constructor, SPECIES, {
		      configurable: true,
		      get: function () { return this; }
		    });
		  }
		};
		return setSpecies;
	}

	var anInstance;
	var hasRequiredAnInstance;

	function requireAnInstance () {
		if (hasRequiredAnInstance) return anInstance;
		hasRequiredAnInstance = 1;
		var isPrototypeOf = requireObjectIsPrototypeOf();

		var $TypeError = TypeError;

		anInstance = function (it, Prototype) {
		  if (isPrototypeOf(Prototype, it)) return it;
		  throw new $TypeError('Incorrect invocation');
		};
		return anInstance;
	}

	var aConstructor;
	var hasRequiredAConstructor;

	function requireAConstructor () {
		if (hasRequiredAConstructor) return aConstructor;
		hasRequiredAConstructor = 1;
		var isConstructor = requireIsConstructor();
		var tryToString = requireTryToString();

		var $TypeError = TypeError;

		// `Assert: IsConstructor(argument) is true`
		aConstructor = function (argument) {
		  if (isConstructor(argument)) return argument;
		  throw new $TypeError(tryToString(argument) + ' is not a constructor');
		};
		return aConstructor;
	}

	var speciesConstructor;
	var hasRequiredSpeciesConstructor;

	function requireSpeciesConstructor () {
		if (hasRequiredSpeciesConstructor) return speciesConstructor;
		hasRequiredSpeciesConstructor = 1;
		var anObject = requireAnObject();
		var aConstructor = requireAConstructor();
		var isNullOrUndefined = requireIsNullOrUndefined();
		var wellKnownSymbol = requireWellKnownSymbol();

		var SPECIES = wellKnownSymbol('species');

		// `SpeciesConstructor` abstract operation
		// https://tc39.es/ecma262/#sec-speciesconstructor
		speciesConstructor = function (O, defaultConstructor) {
		  var C = anObject(O).constructor;
		  var S;
		  return C === undefined || isNullOrUndefined(S = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S);
		};
		return speciesConstructor;
	}

	var functionApply;
	var hasRequiredFunctionApply;

	function requireFunctionApply () {
		if (hasRequiredFunctionApply) return functionApply;
		hasRequiredFunctionApply = 1;
		var NATIVE_BIND = requireFunctionBindNative();

		var FunctionPrototype = Function.prototype;
		var apply = FunctionPrototype.apply;
		var call = FunctionPrototype.call;

		// eslint-disable-next-line es/no-function-prototype-bind, es/no-reflect -- safe
		functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
		  return call.apply(apply, arguments);
		});
		return functionApply;
	}

	var functionUncurryThisClause;
	var hasRequiredFunctionUncurryThisClause;

	function requireFunctionUncurryThisClause () {
		if (hasRequiredFunctionUncurryThisClause) return functionUncurryThisClause;
		hasRequiredFunctionUncurryThisClause = 1;
		var classofRaw = requireClassofRaw();
		var uncurryThis = requireFunctionUncurryThis();

		functionUncurryThisClause = function (fn) {
		  // Nashorn bug:
		  //   https://github.com/zloirock/core-js/issues/1128
		  //   https://github.com/zloirock/core-js/issues/1130
		  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
		};
		return functionUncurryThisClause;
	}

	var functionBindContext;
	var hasRequiredFunctionBindContext;

	function requireFunctionBindContext () {
		if (hasRequiredFunctionBindContext) return functionBindContext;
		hasRequiredFunctionBindContext = 1;
		var uncurryThis = requireFunctionUncurryThisClause();
		var aCallable = requireACallable();
		var NATIVE_BIND = requireFunctionBindNative();

		var bind = uncurryThis(uncurryThis.bind);

		// optional / simple context binding
		functionBindContext = function (fn, that) {
		  aCallable(fn);
		  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
		    return fn.apply(that, arguments);
		  };
		};
		return functionBindContext;
	}

	var arraySlice;
	var hasRequiredArraySlice;

	function requireArraySlice () {
		if (hasRequiredArraySlice) return arraySlice;
		hasRequiredArraySlice = 1;
		var uncurryThis = requireFunctionUncurryThis();

		arraySlice = uncurryThis([].slice);
		return arraySlice;
	}

	var validateArgumentsLength;
	var hasRequiredValidateArgumentsLength;

	function requireValidateArgumentsLength () {
		if (hasRequiredValidateArgumentsLength) return validateArgumentsLength;
		hasRequiredValidateArgumentsLength = 1;
		var $TypeError = TypeError;

		validateArgumentsLength = function (passed, required) {
		  if (passed < required) throw new $TypeError('Not enough arguments');
		  return passed;
		};
		return validateArgumentsLength;
	}

	var environmentIsIos;
	var hasRequiredEnvironmentIsIos;

	function requireEnvironmentIsIos () {
		if (hasRequiredEnvironmentIsIos) return environmentIsIos;
		hasRequiredEnvironmentIsIos = 1;
		var userAgent = requireEnvironmentUserAgent();

		// eslint-disable-next-line redos/no-vulnerable -- safe
		environmentIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
		return environmentIsIos;
	}

	var task;
	var hasRequiredTask;

	function requireTask () {
		if (hasRequiredTask) return task;
		hasRequiredTask = 1;
		var globalThis = requireGlobalThis();
		var apply = requireFunctionApply();
		var bind = requireFunctionBindContext();
		var isCallable = requireIsCallable();
		var hasOwn = requireHasOwnProperty();
		var fails = requireFails();
		var html = requireHtml();
		var arraySlice = requireArraySlice();
		var createElement = requireDocumentCreateElement();
		var validateArgumentsLength = requireValidateArgumentsLength();
		var IS_IOS = requireEnvironmentIsIos();
		var IS_NODE = requireEnvironmentIsNode();

		var set = globalThis.setImmediate;
		var clear = globalThis.clearImmediate;
		var process = globalThis.process;
		var Dispatch = globalThis.Dispatch;
		var Function = globalThis.Function;
		var MessageChannel = globalThis.MessageChannel;
		var String = globalThis.String;
		var counter = 0;
		var queue = {};
		var ONREADYSTATECHANGE = 'onreadystatechange';
		var $location, defer, channel, port;

		fails(function () {
		  // Deno throws a ReferenceError on `location` access without `--location` flag
		  $location = globalThis.location;
		});

		var run = function (id) {
		  if (hasOwn(queue, id)) {
		    var fn = queue[id];
		    delete queue[id];
		    fn();
		  }
		};

		var runner = function (id) {
		  return function () {
		    run(id);
		  };
		};

		var eventListener = function (event) {
		  run(event.data);
		};

		var globalPostMessageDefer = function (id) {
		  // old engines have not location.origin
		  globalThis.postMessage(String(id), $location.protocol + '//' + $location.host);
		};

		// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
		if (!set || !clear) {
		  set = function setImmediate(handler) {
		    validateArgumentsLength(arguments.length, 1);
		    var fn = isCallable(handler) ? handler : Function(handler);
		    var args = arraySlice(arguments, 1);
		    queue[++counter] = function () {
		      apply(fn, undefined, args);
		    };
		    defer(counter);
		    return counter;
		  };
		  clear = function clearImmediate(id) {
		    delete queue[id];
		  };
		  // Node.js 0.8-
		  if (IS_NODE) {
		    defer = function (id) {
		      process.nextTick(runner(id));
		    };
		  // Sphere (JS game engine) Dispatch API
		  } else if (Dispatch && Dispatch.now) {
		    defer = function (id) {
		      Dispatch.now(runner(id));
		    };
		  // Browsers with MessageChannel, includes WebWorkers
		  // except iOS - https://github.com/zloirock/core-js/issues/624
		  } else if (MessageChannel && !IS_IOS) {
		    channel = new MessageChannel();
		    port = channel.port2;
		    channel.port1.onmessage = eventListener;
		    defer = bind(port.postMessage, port);
		  // Browsers with postMessage, skip WebWorkers
		  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
		  } else if (
		    globalThis.addEventListener &&
		    isCallable(globalThis.postMessage) &&
		    !globalThis.importScripts &&
		    $location && $location.protocol !== 'file:' &&
		    !fails(globalPostMessageDefer)
		  ) {
		    defer = globalPostMessageDefer;
		    globalThis.addEventListener('message', eventListener, false);
		  // IE8-
		  } else if (ONREADYSTATECHANGE in createElement('script')) {
		    defer = function (id) {
		      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
		        html.removeChild(this);
		        run(id);
		      };
		    };
		  // Rest old browsers
		  } else {
		    defer = function (id) {
		      setTimeout(runner(id), 0);
		    };
		  }
		}

		task = {
		  set: set,
		  clear: clear
		};
		return task;
	}

	var safeGetBuiltIn;
	var hasRequiredSafeGetBuiltIn;

	function requireSafeGetBuiltIn () {
		if (hasRequiredSafeGetBuiltIn) return safeGetBuiltIn;
		hasRequiredSafeGetBuiltIn = 1;
		var globalThis = requireGlobalThis();
		var DESCRIPTORS = requireDescriptors();

		// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
		var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

		// Avoid NodeJS experimental warning
		safeGetBuiltIn = function (name) {
		  if (!DESCRIPTORS) return globalThis[name];
		  var descriptor = getOwnPropertyDescriptor(globalThis, name);
		  return descriptor && descriptor.value;
		};
		return safeGetBuiltIn;
	}

	var queue;
	var hasRequiredQueue;

	function requireQueue () {
		if (hasRequiredQueue) return queue;
		hasRequiredQueue = 1;
		var Queue = function () {
		  this.head = null;
		  this.tail = null;
		};

		Queue.prototype = {
		  add: function (item) {
		    var entry = { item: item, next: null };
		    var tail = this.tail;
		    if (tail) tail.next = entry;
		    else this.head = entry;
		    this.tail = entry;
		  },
		  get: function () {
		    var entry = this.head;
		    if (entry) {
		      var next = this.head = entry.next;
		      if (next === null) this.tail = null;
		      return entry.item;
		    }
		  }
		};

		queue = Queue;
		return queue;
	}

	var environmentIsIosPebble;
	var hasRequiredEnvironmentIsIosPebble;

	function requireEnvironmentIsIosPebble () {
		if (hasRequiredEnvironmentIsIosPebble) return environmentIsIosPebble;
		hasRequiredEnvironmentIsIosPebble = 1;
		var userAgent = requireEnvironmentUserAgent();

		environmentIsIosPebble = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != 'undefined';
		return environmentIsIosPebble;
	}

	var environmentIsWebosWebkit;
	var hasRequiredEnvironmentIsWebosWebkit;

	function requireEnvironmentIsWebosWebkit () {
		if (hasRequiredEnvironmentIsWebosWebkit) return environmentIsWebosWebkit;
		hasRequiredEnvironmentIsWebosWebkit = 1;
		var userAgent = requireEnvironmentUserAgent();

		environmentIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);
		return environmentIsWebosWebkit;
	}

	var microtask_1;
	var hasRequiredMicrotask;

	function requireMicrotask () {
		if (hasRequiredMicrotask) return microtask_1;
		hasRequiredMicrotask = 1;
		var globalThis = requireGlobalThis();
		var safeGetBuiltIn = requireSafeGetBuiltIn();
		var bind = requireFunctionBindContext();
		var macrotask = requireTask().set;
		var Queue = requireQueue();
		var IS_IOS = requireEnvironmentIsIos();
		var IS_IOS_PEBBLE = requireEnvironmentIsIosPebble();
		var IS_WEBOS_WEBKIT = requireEnvironmentIsWebosWebkit();
		var IS_NODE = requireEnvironmentIsNode();

		var MutationObserver = globalThis.MutationObserver || globalThis.WebKitMutationObserver;
		var document = globalThis.document;
		var process = globalThis.process;
		var Promise = globalThis.Promise;
		var microtask = safeGetBuiltIn('queueMicrotask');
		var notify, toggle, node, promise, then;

		// modern engines have queueMicrotask method
		if (!microtask) {
		  var queue = new Queue();

		  var flush = function () {
		    var parent, fn;
		    if (IS_NODE && (parent = process.domain)) parent.exit();
		    while (fn = queue.get()) try {
		      fn();
		    } catch (error) {
		      if (queue.head) notify();
		      throw error;
		    }
		    if (parent) parent.enter();
		  };

		  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
		  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
		  if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
		    toggle = true;
		    node = document.createTextNode('');
		    new MutationObserver(flush).observe(node, { characterData: true });
		    notify = function () {
		      node.data = toggle = !toggle;
		    };
		  // environments with maybe non-completely correct, but existent Promise
		  } else if (!IS_IOS_PEBBLE && Promise && Promise.resolve) {
		    // Promise.resolve without an argument throws an error in LG WebOS 2
		    promise = Promise.resolve(undefined);
		    // workaround of WebKit ~ iOS Safari 10.1 bug
		    promise.constructor = Promise;
		    then = bind(promise.then, promise);
		    notify = function () {
		      then(flush);
		    };
		  // Node.js without promises
		  } else if (IS_NODE) {
		    notify = function () {
		      process.nextTick(flush);
		    };
		  // for other environments - macrotask based on:
		  // - setImmediate
		  // - MessageChannel
		  // - window.postMessage
		  // - onreadystatechange
		  // - setTimeout
		  } else {
		    // `webpack` dev server bug on IE global methods - use bind(fn, global)
		    macrotask = bind(macrotask, globalThis);
		    notify = function () {
		      macrotask(flush);
		    };
		  }

		  microtask = function (fn) {
		    if (!queue.head) notify();
		    queue.add(fn);
		  };
		}

		microtask_1 = microtask;
		return microtask_1;
	}

	var hostReportErrors;
	var hasRequiredHostReportErrors;

	function requireHostReportErrors () {
		if (hasRequiredHostReportErrors) return hostReportErrors;
		hasRequiredHostReportErrors = 1;
		hostReportErrors = function (a, b) {
		  try {
		    // eslint-disable-next-line no-console -- safe
		    arguments.length === 1 ? console.error(a) : console.error(a, b);
		  } catch (error) { /* empty */ }
		};
		return hostReportErrors;
	}

	var perform;
	var hasRequiredPerform;

	function requirePerform () {
		if (hasRequiredPerform) return perform;
		hasRequiredPerform = 1;
		perform = function (exec) {
		  try {
		    return { error: false, value: exec() };
		  } catch (error) {
		    return { error: true, value: error };
		  }
		};
		return perform;
	}

	var promiseNativeConstructor;
	var hasRequiredPromiseNativeConstructor;

	function requirePromiseNativeConstructor () {
		if (hasRequiredPromiseNativeConstructor) return promiseNativeConstructor;
		hasRequiredPromiseNativeConstructor = 1;
		var globalThis = requireGlobalThis();

		promiseNativeConstructor = globalThis.Promise;
		return promiseNativeConstructor;
	}

	var promiseConstructorDetection;
	var hasRequiredPromiseConstructorDetection;

	function requirePromiseConstructorDetection () {
		if (hasRequiredPromiseConstructorDetection) return promiseConstructorDetection;
		hasRequiredPromiseConstructorDetection = 1;
		var globalThis = requireGlobalThis();
		var NativePromiseConstructor = requirePromiseNativeConstructor();
		var isCallable = requireIsCallable();
		var isForced = requireIsForced();
		var inspectSource = requireInspectSource();
		var wellKnownSymbol = requireWellKnownSymbol();
		var ENVIRONMENT = requireEnvironment();
		var IS_PURE = requireIsPure();
		var V8_VERSION = requireEnvironmentV8Version();

		var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
		var SPECIES = wellKnownSymbol('species');
		var SUBCLASSING = false;
		var NATIVE_PROMISE_REJECTION_EVENT = isCallable(globalThis.PromiseRejectionEvent);

		var FORCED_PROMISE_CONSTRUCTOR = isForced('Promise', function () {
		  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
		  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
		  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
		  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
		  // We can't detect it synchronously, so just check versions
		  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
		  // We need Promise#{ catch, finally } in the pure version for preventing prototype pollution
		  if (IS_PURE && !(NativePromisePrototype['catch'] && NativePromisePrototype['finally'])) return true;
		  // We can't use @@species feature detection in V8 since it causes
		  // deoptimization and performance degradation
		  // https://github.com/zloirock/core-js/issues/679
		  if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
		    // Detect correctness of subclassing with @@species support
		    var promise = new NativePromiseConstructor(function (resolve) { resolve(1); });
		    var FakePromise = function (exec) {
		      exec(function () { /* empty */ }, function () { /* empty */ });
		    };
		    var constructor = promise.constructor = {};
		    constructor[SPECIES] = FakePromise;
		    SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;
		    if (!SUBCLASSING) return true;
		  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
		  } return !GLOBAL_CORE_JS_PROMISE && (ENVIRONMENT === 'BROWSER' || ENVIRONMENT === 'DENO') && !NATIVE_PROMISE_REJECTION_EVENT;
		});

		promiseConstructorDetection = {
		  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
		  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
		  SUBCLASSING: SUBCLASSING
		};
		return promiseConstructorDetection;
	}

	var newPromiseCapability = {};

	var hasRequiredNewPromiseCapability;

	function requireNewPromiseCapability () {
		if (hasRequiredNewPromiseCapability) return newPromiseCapability;
		hasRequiredNewPromiseCapability = 1;
		var aCallable = requireACallable();

		var $TypeError = TypeError;

		var PromiseCapability = function (C) {
		  var resolve, reject;
		  this.promise = new C(function ($$resolve, $$reject) {
		    if (resolve !== undefined || reject !== undefined) throw new $TypeError('Bad Promise constructor');
		    resolve = $$resolve;
		    reject = $$reject;
		  });
		  this.resolve = aCallable(resolve);
		  this.reject = aCallable(reject);
		};

		// `NewPromiseCapability` abstract operation
		// https://tc39.es/ecma262/#sec-newpromisecapability
		newPromiseCapability.f = function (C) {
		  return new PromiseCapability(C);
		};
		return newPromiseCapability;
	}

	var hasRequiredEs_promise_constructor;

	function requireEs_promise_constructor () {
		if (hasRequiredEs_promise_constructor) return es_promise_constructor;
		hasRequiredEs_promise_constructor = 1;
		var $ = require_export();
		var IS_PURE = requireIsPure();
		var IS_NODE = requireEnvironmentIsNode();
		var globalThis = requireGlobalThis();
		var path = requirePath();
		var call = requireFunctionCall();
		var defineBuiltIn = requireDefineBuiltIn();
		var setPrototypeOf = requireObjectSetPrototypeOf();
		var setToStringTag = requireSetToStringTag();
		var setSpecies = requireSetSpecies();
		var aCallable = requireACallable();
		var isCallable = requireIsCallable();
		var isObject = requireIsObject();
		var anInstance = requireAnInstance();
		var speciesConstructor = requireSpeciesConstructor();
		var task = requireTask().set;
		var microtask = requireMicrotask();
		var hostReportErrors = requireHostReportErrors();
		var perform = requirePerform();
		var Queue = requireQueue();
		var InternalStateModule = requireInternalState();
		var NativePromiseConstructor = requirePromiseNativeConstructor();
		var PromiseConstructorDetection = requirePromiseConstructorDetection();
		var newPromiseCapabilityModule = requireNewPromiseCapability();

		var PROMISE = 'Promise';
		var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
		var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
		var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
		var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
		var setInternalState = InternalStateModule.set;
		var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
		var PromiseConstructor = NativePromiseConstructor;
		var PromisePrototype = NativePromisePrototype;
		var TypeError = globalThis.TypeError;
		var document = globalThis.document;
		var process = globalThis.process;
		var newPromiseCapability = newPromiseCapabilityModule.f;
		var newGenericPromiseCapability = newPromiseCapability;

		var DISPATCH_EVENT = !!(document && document.createEvent && globalThis.dispatchEvent);
		var UNHANDLED_REJECTION = 'unhandledrejection';
		var REJECTION_HANDLED = 'rejectionhandled';
		var PENDING = 0;
		var FULFILLED = 1;
		var REJECTED = 2;
		var HANDLED = 1;
		var UNHANDLED = 2;

		var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

		// helpers
		var isThenable = function (it) {
		  var then;
		  return isObject(it) && isCallable(then = it.then) ? then : false;
		};

		var callReaction = function (reaction, state) {
		  var value = state.value;
		  var ok = state.state === FULFILLED;
		  var handler = ok ? reaction.ok : reaction.fail;
		  var resolve = reaction.resolve;
		  var reject = reaction.reject;
		  var domain = reaction.domain;
		  var result, then, exited;
		  try {
		    if (handler) {
		      if (!ok) {
		        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
		        state.rejection = HANDLED;
		      }
		      if (handler === true) result = value;
		      else {
		        if (domain) domain.enter();
		        result = handler(value); // can throw
		        if (domain) {
		          domain.exit();
		          exited = true;
		        }
		      }
		      if (result === reaction.promise) {
		        reject(new TypeError('Promise-chain cycle'));
		      } else if (then = isThenable(result)) {
		        call(then, result, resolve, reject);
		      } else resolve(result);
		    } else reject(value);
		  } catch (error) {
		    if (domain && !exited) domain.exit();
		    reject(error);
		  }
		};

		var notify = function (state, isReject) {
		  if (state.notified) return;
		  state.notified = true;
		  microtask(function () {
		    var reactions = state.reactions;
		    var reaction;
		    while (reaction = reactions.get()) {
		      callReaction(reaction, state);
		    }
		    state.notified = false;
		    if (isReject && !state.rejection) onUnhandled(state);
		  });
		};

		var dispatchEvent = function (name, promise, reason) {
		  var event, handler;
		  if (DISPATCH_EVENT) {
		    event = document.createEvent('Event');
		    event.promise = promise;
		    event.reason = reason;
		    event.initEvent(name, false, true);
		    globalThis.dispatchEvent(event);
		  } else event = { promise: promise, reason: reason };
		  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = globalThis['on' + name])) handler(event);
		  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
		};

		var onUnhandled = function (state) {
		  call(task, globalThis, function () {
		    var promise = state.facade;
		    var value = state.value;
		    var IS_UNHANDLED = isUnhandled(state);
		    var result;
		    if (IS_UNHANDLED) {
		      result = perform(function () {
		        if (IS_NODE) {
		          process.emit('unhandledRejection', value, promise);
		        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
		      });
		      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
		      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
		      if (result.error) throw result.value;
		    }
		  });
		};

		var isUnhandled = function (state) {
		  return state.rejection !== HANDLED && !state.parent;
		};

		var onHandleUnhandled = function (state) {
		  call(task, globalThis, function () {
		    var promise = state.facade;
		    if (IS_NODE) {
		      process.emit('rejectionHandled', promise);
		    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
		  });
		};

		var bind = function (fn, state, unwrap) {
		  return function (value) {
		    fn(state, value, unwrap);
		  };
		};

		var internalReject = function (state, value, unwrap) {
		  if (state.done) return;
		  state.done = true;
		  if (unwrap) state = unwrap;
		  state.value = value;
		  state.state = REJECTED;
		  notify(state, true);
		};

		var internalResolve = function (state, value, unwrap) {
		  if (state.done) return;
		  state.done = true;
		  if (unwrap) state = unwrap;
		  try {
		    if (state.facade === value) throw new TypeError("Promise can't be resolved itself");
		    var then = isThenable(value);
		    if (then) {
		      microtask(function () {
		        var wrapper = { done: false };
		        try {
		          call(then, value,
		            bind(internalResolve, wrapper, state),
		            bind(internalReject, wrapper, state)
		          );
		        } catch (error) {
		          internalReject(wrapper, error, state);
		        }
		      });
		    } else {
		      state.value = value;
		      state.state = FULFILLED;
		      notify(state, false);
		    }
		  } catch (error) {
		    internalReject({ done: false }, error, state);
		  }
		};

		// constructor polyfill
		if (FORCED_PROMISE_CONSTRUCTOR) {
		  // 25.4.3.1 Promise(executor)
		  PromiseConstructor = function Promise(executor) {
		    anInstance(this, PromisePrototype);
		    aCallable(executor);
		    call(Internal, this);
		    var state = getInternalPromiseState(this);
		    try {
		      executor(bind(internalResolve, state), bind(internalReject, state));
		    } catch (error) {
		      internalReject(state, error);
		    }
		  };

		  PromisePrototype = PromiseConstructor.prototype;

		  // eslint-disable-next-line no-unused-vars -- required for `.length`
		  Internal = function Promise(executor) {
		    setInternalState(this, {
		      type: PROMISE,
		      done: false,
		      notified: false,
		      parent: false,
		      reactions: new Queue(),
		      rejection: false,
		      state: PENDING,
		      value: null
		    });
		  };

		  // `Promise.prototype.then` method
		  // https://tc39.es/ecma262/#sec-promise.prototype.then
		  Internal.prototype = defineBuiltIn(PromisePrototype, 'then', function then(onFulfilled, onRejected) {
		    var state = getInternalPromiseState(this);
		    var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
		    state.parent = true;
		    reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
		    reaction.fail = isCallable(onRejected) && onRejected;
		    reaction.domain = IS_NODE ? process.domain : undefined;
		    if (state.state === PENDING) state.reactions.add(reaction);
		    else microtask(function () {
		      callReaction(reaction, state);
		    });
		    return reaction.promise;
		  });

		  OwnPromiseCapability = function () {
		    var promise = new Internal();
		    var state = getInternalPromiseState(promise);
		    this.promise = promise;
		    this.resolve = bind(internalResolve, state);
		    this.reject = bind(internalReject, state);
		  };

		  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
		    return C === PromiseConstructor || C === PromiseWrapper
		      ? new OwnPromiseCapability(C)
		      : newGenericPromiseCapability(C);
		  };

		  if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
		    nativeThen = NativePromisePrototype.then;

		    if (!NATIVE_PROMISE_SUBCLASSING) {
		      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
		      defineBuiltIn(NativePromisePrototype, 'then', function then(onFulfilled, onRejected) {
		        var that = this;
		        return new PromiseConstructor(function (resolve, reject) {
		          call(nativeThen, that, resolve, reject);
		        }).then(onFulfilled, onRejected);
		      // https://github.com/zloirock/core-js/issues/640
		      }, { unsafe: true });
		    }

		    // make `.constructor === Promise` work for native promise-based APIs
		    try {
		      delete NativePromisePrototype.constructor;
		    } catch (error) { /* empty */ }

		    // make `instanceof Promise` work for native promise-based APIs
		    if (setPrototypeOf) {
		      setPrototypeOf(NativePromisePrototype, PromisePrototype);
		    }
		  }
		}

		// `Promise` constructor
		// https://tc39.es/ecma262/#sec-promise-executor
		$({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
		  Promise: PromiseConstructor
		});

		PromiseWrapper = path.Promise;

		setToStringTag(PromiseConstructor, PROMISE, false, true);
		setSpecies(PROMISE);
		return es_promise_constructor;
	}

	var es_promise_all = {};

	var iterators;
	var hasRequiredIterators;

	function requireIterators () {
		if (hasRequiredIterators) return iterators;
		hasRequiredIterators = 1;
		iterators = {};
		return iterators;
	}

	var isArrayIteratorMethod;
	var hasRequiredIsArrayIteratorMethod;

	function requireIsArrayIteratorMethod () {
		if (hasRequiredIsArrayIteratorMethod) return isArrayIteratorMethod;
		hasRequiredIsArrayIteratorMethod = 1;
		var wellKnownSymbol = requireWellKnownSymbol();
		var Iterators = requireIterators();

		var ITERATOR = wellKnownSymbol('iterator');
		var ArrayPrototype = Array.prototype;

		// check on default Array iterator
		isArrayIteratorMethod = function (it) {
		  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
		};
		return isArrayIteratorMethod;
	}

	var getIteratorMethod;
	var hasRequiredGetIteratorMethod;

	function requireGetIteratorMethod () {
		if (hasRequiredGetIteratorMethod) return getIteratorMethod;
		hasRequiredGetIteratorMethod = 1;
		var classof = requireClassof();
		var getMethod = requireGetMethod();
		var isNullOrUndefined = requireIsNullOrUndefined();
		var Iterators = requireIterators();
		var wellKnownSymbol = requireWellKnownSymbol();

		var ITERATOR = wellKnownSymbol('iterator');

		getIteratorMethod = function (it) {
		  if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR)
		    || getMethod(it, '@@iterator')
		    || Iterators[classof(it)];
		};
		return getIteratorMethod;
	}

	var getIterator;
	var hasRequiredGetIterator;

	function requireGetIterator () {
		if (hasRequiredGetIterator) return getIterator;
		hasRequiredGetIterator = 1;
		var call = requireFunctionCall();
		var aCallable = requireACallable();
		var anObject = requireAnObject();
		var tryToString = requireTryToString();
		var getIteratorMethod = requireGetIteratorMethod();

		var $TypeError = TypeError;

		getIterator = function (argument, usingIterator) {
		  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
		  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
		  throw new $TypeError(tryToString(argument) + ' is not iterable');
		};
		return getIterator;
	}

	var iteratorClose;
	var hasRequiredIteratorClose;

	function requireIteratorClose () {
		if (hasRequiredIteratorClose) return iteratorClose;
		hasRequiredIteratorClose = 1;
		var call = requireFunctionCall();
		var anObject = requireAnObject();
		var getMethod = requireGetMethod();

		iteratorClose = function (iterator, kind, value) {
		  var innerResult, innerError;
		  anObject(iterator);
		  try {
		    innerResult = getMethod(iterator, 'return');
		    if (!innerResult) {
		      if (kind === 'throw') throw value;
		      return value;
		    }
		    innerResult = call(innerResult, iterator);
		  } catch (error) {
		    innerError = true;
		    innerResult = error;
		  }
		  if (kind === 'throw') throw value;
		  if (innerError) throw innerResult;
		  anObject(innerResult);
		  return value;
		};
		return iteratorClose;
	}

	var iterate;
	var hasRequiredIterate;

	function requireIterate () {
		if (hasRequiredIterate) return iterate;
		hasRequiredIterate = 1;
		var bind = requireFunctionBindContext();
		var call = requireFunctionCall();
		var anObject = requireAnObject();
		var tryToString = requireTryToString();
		var isArrayIteratorMethod = requireIsArrayIteratorMethod();
		var lengthOfArrayLike = requireLengthOfArrayLike();
		var isPrototypeOf = requireObjectIsPrototypeOf();
		var getIterator = requireGetIterator();
		var getIteratorMethod = requireGetIteratorMethod();
		var iteratorClose = requireIteratorClose();

		var $TypeError = TypeError;

		var Result = function (stopped, result) {
		  this.stopped = stopped;
		  this.result = result;
		};

		var ResultPrototype = Result.prototype;

		iterate = function (iterable, unboundFunction, options) {
		  var that = options && options.that;
		  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
		  var IS_RECORD = !!(options && options.IS_RECORD);
		  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
		  var INTERRUPTED = !!(options && options.INTERRUPTED);
		  var fn = bind(unboundFunction, that);
		  var iterator, iterFn, index, length, result, next, step;

		  var stop = function (condition) {
		    if (iterator) iteratorClose(iterator, 'normal');
		    return new Result(true, condition);
		  };

		  var callFn = function (value) {
		    if (AS_ENTRIES) {
		      anObject(value);
		      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
		    } return INTERRUPTED ? fn(value, stop) : fn(value);
		  };

		  if (IS_RECORD) {
		    iterator = iterable.iterator;
		  } else if (IS_ITERATOR) {
		    iterator = iterable;
		  } else {
		    iterFn = getIteratorMethod(iterable);
		    if (!iterFn) throw new $TypeError(tryToString(iterable) + ' is not iterable');
		    // optimisation for array iterators
		    if (isArrayIteratorMethod(iterFn)) {
		      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
		        result = callFn(iterable[index]);
		        if (result && isPrototypeOf(ResultPrototype, result)) return result;
		      } return new Result(false);
		    }
		    iterator = getIterator(iterable, iterFn);
		  }

		  next = IS_RECORD ? iterable.next : iterator.next;
		  while (!(step = call(next, iterator)).done) {
		    try {
		      result = callFn(step.value);
		    } catch (error) {
		      iteratorClose(iterator, 'throw', error);
		    }
		    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
		  } return new Result(false);
		};
		return iterate;
	}

	var checkCorrectnessOfIteration;
	var hasRequiredCheckCorrectnessOfIteration;

	function requireCheckCorrectnessOfIteration () {
		if (hasRequiredCheckCorrectnessOfIteration) return checkCorrectnessOfIteration;
		hasRequiredCheckCorrectnessOfIteration = 1;
		var wellKnownSymbol = requireWellKnownSymbol();

		var ITERATOR = wellKnownSymbol('iterator');
		var SAFE_CLOSING = false;

		try {
		  var called = 0;
		  var iteratorWithReturn = {
		    next: function () {
		      return { done: !!called++ };
		    },
		    'return': function () {
		      SAFE_CLOSING = true;
		    }
		  };
		  iteratorWithReturn[ITERATOR] = function () {
		    return this;
		  };
		  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
		  Array.from(iteratorWithReturn, function () { throw 2; });
		} catch (error) { /* empty */ }

		checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
		  try {
		    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
		  } catch (error) { return false; } // workaround of old WebKit + `eval` bug
		  var ITERATION_SUPPORT = false;
		  try {
		    var object = {};
		    object[ITERATOR] = function () {
		      return {
		        next: function () {
		          return { done: ITERATION_SUPPORT = true };
		        }
		      };
		    };
		    exec(object);
		  } catch (error) { /* empty */ }
		  return ITERATION_SUPPORT;
		};
		return checkCorrectnessOfIteration;
	}

	var promiseStaticsIncorrectIteration;
	var hasRequiredPromiseStaticsIncorrectIteration;

	function requirePromiseStaticsIncorrectIteration () {
		if (hasRequiredPromiseStaticsIncorrectIteration) return promiseStaticsIncorrectIteration;
		hasRequiredPromiseStaticsIncorrectIteration = 1;
		var NativePromiseConstructor = requirePromiseNativeConstructor();
		var checkCorrectnessOfIteration = requireCheckCorrectnessOfIteration();
		var FORCED_PROMISE_CONSTRUCTOR = requirePromiseConstructorDetection().CONSTRUCTOR;

		promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function (iterable) {
		  NativePromiseConstructor.all(iterable).then(undefined, function () { /* empty */ });
		});
		return promiseStaticsIncorrectIteration;
	}

	var hasRequiredEs_promise_all;

	function requireEs_promise_all () {
		if (hasRequiredEs_promise_all) return es_promise_all;
		hasRequiredEs_promise_all = 1;
		var $ = require_export();
		var call = requireFunctionCall();
		var aCallable = requireACallable();
		var newPromiseCapabilityModule = requireNewPromiseCapability();
		var perform = requirePerform();
		var iterate = requireIterate();
		var PROMISE_STATICS_INCORRECT_ITERATION = requirePromiseStaticsIncorrectIteration();

		// `Promise.all` method
		// https://tc39.es/ecma262/#sec-promise.all
		$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
		  all: function all(iterable) {
		    var C = this;
		    var capability = newPromiseCapabilityModule.f(C);
		    var resolve = capability.resolve;
		    var reject = capability.reject;
		    var result = perform(function () {
		      var $promiseResolve = aCallable(C.resolve);
		      var values = [];
		      var counter = 0;
		      var remaining = 1;
		      iterate(iterable, function (promise) {
		        var index = counter++;
		        var alreadyCalled = false;
		        remaining++;
		        call($promiseResolve, C, promise).then(function (value) {
		          if (alreadyCalled) return;
		          alreadyCalled = true;
		          values[index] = value;
		          --remaining || resolve(values);
		        }, reject);
		      });
		      --remaining || resolve(values);
		    });
		    if (result.error) reject(result.value);
		    return capability.promise;
		  }
		});
		return es_promise_all;
	}

	var es_promise_catch = {};

	var hasRequiredEs_promise_catch;

	function requireEs_promise_catch () {
		if (hasRequiredEs_promise_catch) return es_promise_catch;
		hasRequiredEs_promise_catch = 1;
		var $ = require_export();
		var IS_PURE = requireIsPure();
		var FORCED_PROMISE_CONSTRUCTOR = requirePromiseConstructorDetection().CONSTRUCTOR;
		var NativePromiseConstructor = requirePromiseNativeConstructor();
		var getBuiltIn = requireGetBuiltIn();
		var isCallable = requireIsCallable();
		var defineBuiltIn = requireDefineBuiltIn();

		var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;

		// `Promise.prototype.catch` method
		// https://tc39.es/ecma262/#sec-promise.prototype.catch
		$({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
		  'catch': function (onRejected) {
		    return this.then(undefined, onRejected);
		  }
		});

		// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
		if (!IS_PURE && isCallable(NativePromiseConstructor)) {
		  var method = getBuiltIn('Promise').prototype['catch'];
		  if (NativePromisePrototype['catch'] !== method) {
		    defineBuiltIn(NativePromisePrototype, 'catch', method, { unsafe: true });
		  }
		}
		return es_promise_catch;
	}

	var es_promise_race = {};

	var hasRequiredEs_promise_race;

	function requireEs_promise_race () {
		if (hasRequiredEs_promise_race) return es_promise_race;
		hasRequiredEs_promise_race = 1;
		var $ = require_export();
		var call = requireFunctionCall();
		var aCallable = requireACallable();
		var newPromiseCapabilityModule = requireNewPromiseCapability();
		var perform = requirePerform();
		var iterate = requireIterate();
		var PROMISE_STATICS_INCORRECT_ITERATION = requirePromiseStaticsIncorrectIteration();

		// `Promise.race` method
		// https://tc39.es/ecma262/#sec-promise.race
		$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
		  race: function race(iterable) {
		    var C = this;
		    var capability = newPromiseCapabilityModule.f(C);
		    var reject = capability.reject;
		    var result = perform(function () {
		      var $promiseResolve = aCallable(C.resolve);
		      iterate(iterable, function (promise) {
		        call($promiseResolve, C, promise).then(capability.resolve, reject);
		      });
		    });
		    if (result.error) reject(result.value);
		    return capability.promise;
		  }
		});
		return es_promise_race;
	}

	var es_promise_reject = {};

	var hasRequiredEs_promise_reject;

	function requireEs_promise_reject () {
		if (hasRequiredEs_promise_reject) return es_promise_reject;
		hasRequiredEs_promise_reject = 1;
		var $ = require_export();
		var newPromiseCapabilityModule = requireNewPromiseCapability();
		var FORCED_PROMISE_CONSTRUCTOR = requirePromiseConstructorDetection().CONSTRUCTOR;

		// `Promise.reject` method
		// https://tc39.es/ecma262/#sec-promise.reject
		$({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
		  reject: function reject(r) {
		    var capability = newPromiseCapabilityModule.f(this);
		    var capabilityReject = capability.reject;
		    capabilityReject(r);
		    return capability.promise;
		  }
		});
		return es_promise_reject;
	}

	var es_promise_resolve = {};

	var promiseResolve;
	var hasRequiredPromiseResolve;

	function requirePromiseResolve () {
		if (hasRequiredPromiseResolve) return promiseResolve;
		hasRequiredPromiseResolve = 1;
		var anObject = requireAnObject();
		var isObject = requireIsObject();
		var newPromiseCapability = requireNewPromiseCapability();

		promiseResolve = function (C, x) {
		  anObject(C);
		  if (isObject(x) && x.constructor === C) return x;
		  var promiseCapability = newPromiseCapability.f(C);
		  var resolve = promiseCapability.resolve;
		  resolve(x);
		  return promiseCapability.promise;
		};
		return promiseResolve;
	}

	var hasRequiredEs_promise_resolve;

	function requireEs_promise_resolve () {
		if (hasRequiredEs_promise_resolve) return es_promise_resolve;
		hasRequiredEs_promise_resolve = 1;
		var $ = require_export();
		var getBuiltIn = requireGetBuiltIn();
		var IS_PURE = requireIsPure();
		var NativePromiseConstructor = requirePromiseNativeConstructor();
		var FORCED_PROMISE_CONSTRUCTOR = requirePromiseConstructorDetection().CONSTRUCTOR;
		var promiseResolve = requirePromiseResolve();

		var PromiseConstructorWrapper = getBuiltIn('Promise');
		var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;

		// `Promise.resolve` method
		// https://tc39.es/ecma262/#sec-promise.resolve
		$({ target: 'Promise', stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
		  resolve: function resolve(x) {
		    return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x);
		  }
		});
		return es_promise_resolve;
	}

	var hasRequiredEs_promise;

	function requireEs_promise () {
		if (hasRequiredEs_promise) return es_promise;
		hasRequiredEs_promise = 1;
		// TODO: Remove this module from `core-js@4` since it's split to modules listed below
		requireEs_promise_constructor();
		requireEs_promise_all();
		requireEs_promise_catch();
		requireEs_promise_race();
		requireEs_promise_reject();
		requireEs_promise_resolve();
		return es_promise;
	}

	requireEs_promise();

	var es_regexp_exec = {};

	var toString;
	var hasRequiredToString;

	function requireToString () {
		if (hasRequiredToString) return toString;
		hasRequiredToString = 1;
		var classof = requireClassof();

		var $String = String;

		toString = function (argument) {
		  if (classof(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');
		  return $String(argument);
		};
		return toString;
	}

	var regexpFlags;
	var hasRequiredRegexpFlags;

	function requireRegexpFlags () {
		if (hasRequiredRegexpFlags) return regexpFlags;
		hasRequiredRegexpFlags = 1;
		var anObject = requireAnObject();

		// `RegExp.prototype.flags` getter implementation
		// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
		regexpFlags = function () {
		  var that = anObject(this);
		  var result = '';
		  if (that.hasIndices) result += 'd';
		  if (that.global) result += 'g';
		  if (that.ignoreCase) result += 'i';
		  if (that.multiline) result += 'm';
		  if (that.dotAll) result += 's';
		  if (that.unicode) result += 'u';
		  if (that.unicodeSets) result += 'v';
		  if (that.sticky) result += 'y';
		  return result;
		};
		return regexpFlags;
	}

	var regexpStickyHelpers;
	var hasRequiredRegexpStickyHelpers;

	function requireRegexpStickyHelpers () {
		if (hasRequiredRegexpStickyHelpers) return regexpStickyHelpers;
		hasRequiredRegexpStickyHelpers = 1;
		var fails = requireFails();
		var globalThis = requireGlobalThis();

		// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
		var $RegExp = globalThis.RegExp;

		var UNSUPPORTED_Y = fails(function () {
		  var re = $RegExp('a', 'y');
		  re.lastIndex = 2;
		  return re.exec('abcd') !== null;
		});

		// UC Browser bug
		// https://github.com/zloirock/core-js/issues/1008
		var MISSED_STICKY = UNSUPPORTED_Y || fails(function () {
		  return !$RegExp('a', 'y').sticky;
		});

		var BROKEN_CARET = UNSUPPORTED_Y || fails(function () {
		  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
		  var re = $RegExp('^r', 'gy');
		  re.lastIndex = 2;
		  return re.exec('str') !== null;
		});

		regexpStickyHelpers = {
		  BROKEN_CARET: BROKEN_CARET,
		  MISSED_STICKY: MISSED_STICKY,
		  UNSUPPORTED_Y: UNSUPPORTED_Y
		};
		return regexpStickyHelpers;
	}

	var regexpUnsupportedDotAll;
	var hasRequiredRegexpUnsupportedDotAll;

	function requireRegexpUnsupportedDotAll () {
		if (hasRequiredRegexpUnsupportedDotAll) return regexpUnsupportedDotAll;
		hasRequiredRegexpUnsupportedDotAll = 1;
		var fails = requireFails();
		var globalThis = requireGlobalThis();

		// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
		var $RegExp = globalThis.RegExp;

		regexpUnsupportedDotAll = fails(function () {
		  var re = $RegExp('.', 's');
		  return !(re.dotAll && re.test('\n') && re.flags === 's');
		});
		return regexpUnsupportedDotAll;
	}

	var regexpUnsupportedNcg;
	var hasRequiredRegexpUnsupportedNcg;

	function requireRegexpUnsupportedNcg () {
		if (hasRequiredRegexpUnsupportedNcg) return regexpUnsupportedNcg;
		hasRequiredRegexpUnsupportedNcg = 1;
		var fails = requireFails();
		var globalThis = requireGlobalThis();

		// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
		var $RegExp = globalThis.RegExp;

		regexpUnsupportedNcg = fails(function () {
		  var re = $RegExp('(?<a>b)', 'g');
		  return re.exec('b').groups.a !== 'b' ||
		    'b'.replace(re, '$<a>c') !== 'bc';
		});
		return regexpUnsupportedNcg;
	}

	var regexpExec;
	var hasRequiredRegexpExec;

	function requireRegexpExec () {
		if (hasRequiredRegexpExec) return regexpExec;
		hasRequiredRegexpExec = 1;
		/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
		/* eslint-disable regexp/no-useless-quantifier -- testing */
		var call = requireFunctionCall();
		var uncurryThis = requireFunctionUncurryThis();
		var toString = requireToString();
		var regexpFlags = requireRegexpFlags();
		var stickyHelpers = requireRegexpStickyHelpers();
		var shared = requireShared();
		var create = requireObjectCreate();
		var getInternalState = requireInternalState().get;
		var UNSUPPORTED_DOT_ALL = requireRegexpUnsupportedDotAll();
		var UNSUPPORTED_NCG = requireRegexpUnsupportedNcg();

		var nativeReplace = shared('native-string-replace', String.prototype.replace);
		var nativeExec = RegExp.prototype.exec;
		var patchedExec = nativeExec;
		var charAt = uncurryThis(''.charAt);
		var indexOf = uncurryThis(''.indexOf);
		var replace = uncurryThis(''.replace);
		var stringSlice = uncurryThis(''.slice);

		var UPDATES_LAST_INDEX_WRONG = (function () {
		  var re1 = /a/;
		  var re2 = /b*/g;
		  call(nativeExec, re1, 'a');
		  call(nativeExec, re2, 'a');
		  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
		})();

		var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;

		// nonparticipating capturing group, copied from es5-shim's String#split patch.
		var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

		var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;

		if (PATCH) {
		  patchedExec = function exec(string) {
		    var re = this;
		    var state = getInternalState(re);
		    var str = toString(string);
		    var raw = state.raw;
		    var result, reCopy, lastIndex, match, i, object, group;

		    if (raw) {
		      raw.lastIndex = re.lastIndex;
		      result = call(patchedExec, raw, str);
		      re.lastIndex = raw.lastIndex;
		      return result;
		    }

		    var groups = state.groups;
		    var sticky = UNSUPPORTED_Y && re.sticky;
		    var flags = call(regexpFlags, re);
		    var source = re.source;
		    var charsAdded = 0;
		    var strCopy = str;

		    if (sticky) {
		      flags = replace(flags, 'y', '');
		      if (indexOf(flags, 'g') === -1) {
		        flags += 'g';
		      }

		      strCopy = stringSlice(str, re.lastIndex);
		      // Support anchored sticky behavior.
		      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== '\n')) {
		        source = '(?: ' + source + ')';
		        strCopy = ' ' + strCopy;
		        charsAdded++;
		      }
		      // ^(? + rx + ) is needed, in combination with some str slicing, to
		      // simulate the 'y' flag.
		      reCopy = new RegExp('^(?:' + source + ')', flags);
		    }

		    if (NPCG_INCLUDED) {
		      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
		    }
		    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

		    match = call(nativeExec, sticky ? reCopy : re, strCopy);

		    if (sticky) {
		      if (match) {
		        match.input = stringSlice(match.input, charsAdded);
		        match[0] = stringSlice(match[0], charsAdded);
		        match.index = re.lastIndex;
		        re.lastIndex += match[0].length;
		      } else re.lastIndex = 0;
		    } else if (UPDATES_LAST_INDEX_WRONG && match) {
		      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
		    }
		    if (NPCG_INCLUDED && match && match.length > 1) {
		      // Fix browsers whose `exec` methods don't consistently return `undefined`
		      // for NPCG, like IE8. NOTE: This doesn't work for /(.?)?/
		      call(nativeReplace, match[0], reCopy, function () {
		        for (i = 1; i < arguments.length - 2; i++) {
		          if (arguments[i] === undefined) match[i] = undefined;
		        }
		      });
		    }

		    if (match && groups) {
		      match.groups = object = create(null);
		      for (i = 0; i < groups.length; i++) {
		        group = groups[i];
		        object[group[0]] = match[group[1]];
		      }
		    }

		    return match;
		  };
		}

		regexpExec = patchedExec;
		return regexpExec;
	}

	var hasRequiredEs_regexp_exec;

	function requireEs_regexp_exec () {
		if (hasRequiredEs_regexp_exec) return es_regexp_exec;
		hasRequiredEs_regexp_exec = 1;
		var $ = require_export();
		var exec = requireRegexpExec();

		// `RegExp.prototype.exec` method
		// https://tc39.es/ecma262/#sec-regexp.prototype.exec
		$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
		  exec: exec
		});
		return es_regexp_exec;
	}

	requireEs_regexp_exec();

	var es_regexp_toString = {};

	var regexpFlagsDetection;
	var hasRequiredRegexpFlagsDetection;

	function requireRegexpFlagsDetection () {
		if (hasRequiredRegexpFlagsDetection) return regexpFlagsDetection;
		hasRequiredRegexpFlagsDetection = 1;
		var globalThis = requireGlobalThis();
		var fails = requireFails();

		// babel-minify and Closure Compiler transpiles RegExp('.', 'd') -> /./d and it causes SyntaxError
		var RegExp = globalThis.RegExp;

		var FLAGS_GETTER_IS_CORRECT = !fails(function () {
		  var INDICES_SUPPORT = true;
		  try {
		    RegExp('.', 'd');
		  } catch (error) {
		    INDICES_SUPPORT = false;
		  }

		  var O = {};
		  // modern V8 bug
		  var calls = '';
		  var expected = INDICES_SUPPORT ? 'dgimsy' : 'gimsy';

		  var addGetter = function (key, chr) {
		    // eslint-disable-next-line es/no-object-defineproperty -- safe
		    Object.defineProperty(O, key, { get: function () {
		      calls += chr;
		      return true;
		    } });
		  };

		  var pairs = {
		    dotAll: 's',
		    global: 'g',
		    ignoreCase: 'i',
		    multiline: 'm',
		    sticky: 'y'
		  };

		  if (INDICES_SUPPORT) pairs.hasIndices = 'd';

		  for (var key in pairs) addGetter(key, pairs[key]);

		  // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
		  var result = Object.getOwnPropertyDescriptor(RegExp.prototype, 'flags').get.call(O);

		  return result !== expected || calls !== expected;
		});

		regexpFlagsDetection = { correct: FLAGS_GETTER_IS_CORRECT };
		return regexpFlagsDetection;
	}

	var regexpGetFlags;
	var hasRequiredRegexpGetFlags;

	function requireRegexpGetFlags () {
		if (hasRequiredRegexpGetFlags) return regexpGetFlags;
		hasRequiredRegexpGetFlags = 1;
		var call = requireFunctionCall();
		var hasOwn = requireHasOwnProperty();
		var isPrototypeOf = requireObjectIsPrototypeOf();
		var regExpFlagsDetection = requireRegexpFlagsDetection();
		var regExpFlagsGetterImplementation = requireRegexpFlags();

		var RegExpPrototype = RegExp.prototype;

		regexpGetFlags = regExpFlagsDetection.correct ? function (it) {
		  return it.flags;
		} : function (it) {
		  return (!regExpFlagsDetection.correct && isPrototypeOf(RegExpPrototype, it) && !hasOwn(it, 'flags'))
		    ? call(regExpFlagsGetterImplementation, it)
		    : it.flags;
		};
		return regexpGetFlags;
	}

	var hasRequiredEs_regexp_toString;

	function requireEs_regexp_toString () {
		if (hasRequiredEs_regexp_toString) return es_regexp_toString;
		hasRequiredEs_regexp_toString = 1;
		var PROPER_FUNCTION_NAME = requireFunctionName().PROPER;
		var defineBuiltIn = requireDefineBuiltIn();
		var anObject = requireAnObject();
		var $toString = requireToString();
		var fails = requireFails();
		var getRegExpFlags = requireRegexpGetFlags();

		var TO_STRING = 'toString';
		var RegExpPrototype = RegExp.prototype;
		var nativeToString = RegExpPrototype[TO_STRING];

		var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) !== '/a/b'; });
		// FF44- RegExp#toString has a wrong name
		var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name !== TO_STRING;

		// `RegExp.prototype.toString` method
		// https://tc39.es/ecma262/#sec-regexp.prototype.tostring
		if (NOT_GENERIC || INCORRECT_NAME) {
		  defineBuiltIn(RegExpPrototype, TO_STRING, function toString() {
		    var R = anObject(this);
		    var pattern = $toString(R.source);
		    var flags = $toString(getRegExpFlags(R));
		    return '/' + pattern + '/' + flags;
		  }, { unsafe: true });
		}
		return es_regexp_toString;
	}

	requireEs_regexp_toString();

	var es_string_endsWith = {};

	var isRegexp;
	var hasRequiredIsRegexp;

	function requireIsRegexp () {
		if (hasRequiredIsRegexp) return isRegexp;
		hasRequiredIsRegexp = 1;
		var isObject = requireIsObject();
		var classof = requireClassofRaw();
		var wellKnownSymbol = requireWellKnownSymbol();

		var MATCH = wellKnownSymbol('match');

		// `IsRegExp` abstract operation
		// https://tc39.es/ecma262/#sec-isregexp
		isRegexp = function (it) {
		  var isRegExp;
		  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) === 'RegExp');
		};
		return isRegexp;
	}

	var notARegexp;
	var hasRequiredNotARegexp;

	function requireNotARegexp () {
		if (hasRequiredNotARegexp) return notARegexp;
		hasRequiredNotARegexp = 1;
		var isRegExp = requireIsRegexp();

		var $TypeError = TypeError;

		notARegexp = function (it) {
		  if (isRegExp(it)) {
		    throw new $TypeError("The method doesn't accept regular expressions");
		  } return it;
		};
		return notARegexp;
	}

	var correctIsRegexpLogic;
	var hasRequiredCorrectIsRegexpLogic;

	function requireCorrectIsRegexpLogic () {
		if (hasRequiredCorrectIsRegexpLogic) return correctIsRegexpLogic;
		hasRequiredCorrectIsRegexpLogic = 1;
		var wellKnownSymbol = requireWellKnownSymbol();

		var MATCH = wellKnownSymbol('match');

		correctIsRegexpLogic = function (METHOD_NAME) {
		  var regexp = /./;
		  try {
		    '/./'[METHOD_NAME](regexp);
		  } catch (error1) {
		    try {
		      regexp[MATCH] = false;
		      return '/./'[METHOD_NAME](regexp);
		    } catch (error2) { /* empty */ }
		  } return false;
		};
		return correctIsRegexpLogic;
	}

	var hasRequiredEs_string_endsWith;

	function requireEs_string_endsWith () {
		if (hasRequiredEs_string_endsWith) return es_string_endsWith;
		hasRequiredEs_string_endsWith = 1;
		var $ = require_export();
		var uncurryThis = requireFunctionUncurryThisClause();
		var getOwnPropertyDescriptor = requireObjectGetOwnPropertyDescriptor().f;
		var toLength = requireToLength();
		var toString = requireToString();
		var notARegExp = requireNotARegexp();
		var requireObjectCoercible = requireRequireObjectCoercible();
		var correctIsRegExpLogic = requireCorrectIsRegexpLogic();
		var IS_PURE = requireIsPure();

		var slice = uncurryThis(''.slice);
		var min = Math.min;

		var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('endsWith');
		// https://github.com/zloirock/core-js/pull/702
		var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {
		  var descriptor = getOwnPropertyDescriptor(String.prototype, 'endsWith');
		  return descriptor && !descriptor.writable;
		}();

		// `String.prototype.endsWith` method
		// https://tc39.es/ecma262/#sec-string.prototype.endswith
		$({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
		  endsWith: function endsWith(searchString /* , endPosition = @length */) {
		    var that = toString(requireObjectCoercible(this));
		    notARegExp(searchString);
		    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
		    var len = that.length;
		    var end = endPosition === undefined ? len : min(toLength(endPosition), len);
		    var search = toString(searchString);
		    return slice(that, end - search.length, end) === search;
		  }
		});
		return es_string_endsWith;
	}

	requireEs_string_endsWith();

	var es_string_includes = {};

	var hasRequiredEs_string_includes;

	function requireEs_string_includes () {
		if (hasRequiredEs_string_includes) return es_string_includes;
		hasRequiredEs_string_includes = 1;
		var $ = require_export();
		var uncurryThis = requireFunctionUncurryThis();
		var notARegExp = requireNotARegexp();
		var requireObjectCoercible = requireRequireObjectCoercible();
		var toString = requireToString();
		var correctIsRegExpLogic = requireCorrectIsRegexpLogic();

		var stringIndexOf = uncurryThis(''.indexOf);

		// `String.prototype.includes` method
		// https://tc39.es/ecma262/#sec-string.prototype.includes
		$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
		  includes: function includes(searchString /* , position = 0 */) {
		    return !!~stringIndexOf(
		      toString(requireObjectCoercible(this)),
		      toString(notARegExp(searchString)),
		      arguments.length > 1 ? arguments[1] : undefined
		    );
		  }
		});
		return es_string_includes;
	}

	requireEs_string_includes();

	var es_string_replace = {};

	var fixRegexpWellKnownSymbolLogic;
	var hasRequiredFixRegexpWellKnownSymbolLogic;

	function requireFixRegexpWellKnownSymbolLogic () {
		if (hasRequiredFixRegexpWellKnownSymbolLogic) return fixRegexpWellKnownSymbolLogic;
		hasRequiredFixRegexpWellKnownSymbolLogic = 1;
		// TODO: Remove from `core-js@4` since it's moved to entry points
		requireEs_regexp_exec();
		var call = requireFunctionCall();
		var defineBuiltIn = requireDefineBuiltIn();
		var regexpExec = requireRegexpExec();
		var fails = requireFails();
		var wellKnownSymbol = requireWellKnownSymbol();
		var createNonEnumerableProperty = requireCreateNonEnumerableProperty();

		var SPECIES = wellKnownSymbol('species');
		var RegExpPrototype = RegExp.prototype;

		fixRegexpWellKnownSymbolLogic = function (KEY, exec, FORCED, SHAM) {
		  var SYMBOL = wellKnownSymbol(KEY);

		  var DELEGATES_TO_SYMBOL = !fails(function () {
		    // String methods call symbol-named RegExp methods
		    var O = {};
		    O[SYMBOL] = function () { return 7; };
		    return ''[KEY](O) !== 7;
		  });

		  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
		    // Symbol-named RegExp methods call .exec
		    var execCalled = false;
		    var re = /a/;

		    if (KEY === 'split') {
		      // We can't use real regex here since it causes deoptimization
		      // and serious performance degradation in V8
		      // https://github.com/zloirock/core-js/issues/306
		      re = {};
		      // RegExp[@@split] doesn't call the regex's exec method, but first creates
		      // a new one. We need to return the patched regex when creating the new one.
		      re.constructor = {};
		      re.constructor[SPECIES] = function () { return re; };
		      re.flags = '';
		      re[SYMBOL] = /./[SYMBOL];
		    }

		    re.exec = function () {
		      execCalled = true;
		      return null;
		    };

		    re[SYMBOL]('');
		    return !execCalled;
		  });

		  if (
		    !DELEGATES_TO_SYMBOL ||
		    !DELEGATES_TO_EXEC ||
		    FORCED
		  ) {
		    var nativeRegExpMethod = /./[SYMBOL];
		    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
		      var $exec = regexp.exec;
		      if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
		        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
		          // The native String method already delegates to @@method (this
		          // polyfilled function), leasing to infinite recursion.
		          // We avoid it by directly calling the native @@method method.
		          return { done: true, value: call(nativeRegExpMethod, regexp, str, arg2) };
		        }
		        return { done: true, value: call(nativeMethod, str, regexp, arg2) };
		      }
		      return { done: false };
		    });

		    defineBuiltIn(String.prototype, KEY, methods[0]);
		    defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
		  }

		  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);
		};
		return fixRegexpWellKnownSymbolLogic;
	}

	var stringMultibyte;
	var hasRequiredStringMultibyte;

	function requireStringMultibyte () {
		if (hasRequiredStringMultibyte) return stringMultibyte;
		hasRequiredStringMultibyte = 1;
		var uncurryThis = requireFunctionUncurryThis();
		var toIntegerOrInfinity = requireToIntegerOrInfinity();
		var toString = requireToString();
		var requireObjectCoercible = requireRequireObjectCoercible();

		var charAt = uncurryThis(''.charAt);
		var charCodeAt = uncurryThis(''.charCodeAt);
		var stringSlice = uncurryThis(''.slice);

		var createMethod = function (CONVERT_TO_STRING) {
		  return function ($this, pos) {
		    var S = toString(requireObjectCoercible($this));
		    var position = toIntegerOrInfinity(pos);
		    var size = S.length;
		    var first, second;
		    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
		    first = charCodeAt(S, position);
		    return first < 0xD800 || first > 0xDBFF || position + 1 === size
		      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
		        ? CONVERT_TO_STRING
		          ? charAt(S, position)
		          : first
		        : CONVERT_TO_STRING
		          ? stringSlice(S, position, position + 2)
		          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
		  };
		};

		stringMultibyte = {
		  // `String.prototype.codePointAt` method
		  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
		  codeAt: createMethod(false),
		  // `String.prototype.at` method
		  // https://github.com/mathiasbynens/String.prototype.at
		  charAt: createMethod(true)
		};
		return stringMultibyte;
	}

	var advanceStringIndex;
	var hasRequiredAdvanceStringIndex;

	function requireAdvanceStringIndex () {
		if (hasRequiredAdvanceStringIndex) return advanceStringIndex;
		hasRequiredAdvanceStringIndex = 1;
		var charAt = requireStringMultibyte().charAt;

		// `AdvanceStringIndex` abstract operation
		// https://tc39.es/ecma262/#sec-advancestringindex
		advanceStringIndex = function (S, index, unicode) {
		  return index + (unicode ? charAt(S, index).length : 1);
		};
		return advanceStringIndex;
	}

	var getSubstitution;
	var hasRequiredGetSubstitution;

	function requireGetSubstitution () {
		if (hasRequiredGetSubstitution) return getSubstitution;
		hasRequiredGetSubstitution = 1;
		var uncurryThis = requireFunctionUncurryThis();
		var toObject = requireToObject();

		var floor = Math.floor;
		var charAt = uncurryThis(''.charAt);
		var replace = uncurryThis(''.replace);
		var stringSlice = uncurryThis(''.slice);
		// eslint-disable-next-line redos/no-vulnerable -- safe
		var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
		var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

		// `GetSubstitution` abstract operation
		// https://tc39.es/ecma262/#sec-getsubstitution
		getSubstitution = function (matched, str, position, captures, namedCaptures, replacement) {
		  var tailPos = position + matched.length;
		  var m = captures.length;
		  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
		  if (namedCaptures !== undefined) {
		    namedCaptures = toObject(namedCaptures);
		    symbols = SUBSTITUTION_SYMBOLS;
		  }
		  return replace(replacement, symbols, function (match, ch) {
		    var capture;
		    switch (charAt(ch, 0)) {
		      case '$': return '$';
		      case '&': return matched;
		      case '`': return stringSlice(str, 0, position);
		      case "'": return stringSlice(str, tailPos);
		      case '<':
		        capture = namedCaptures[stringSlice(ch, 1, -1)];
		        break;
		      default: // \d\d?
		        var n = +ch;
		        if (n === 0) return match;
		        if (n > m) {
		          var f = floor(n / 10);
		          if (f === 0) return match;
		          if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
		          return match;
		        }
		        capture = captures[n - 1];
		    }
		    return capture === undefined ? '' : capture;
		  });
		};
		return getSubstitution;
	}

	var regexpExecAbstract;
	var hasRequiredRegexpExecAbstract;

	function requireRegexpExecAbstract () {
		if (hasRequiredRegexpExecAbstract) return regexpExecAbstract;
		hasRequiredRegexpExecAbstract = 1;
		var call = requireFunctionCall();
		var anObject = requireAnObject();
		var isCallable = requireIsCallable();
		var classof = requireClassofRaw();
		var regexpExec = requireRegexpExec();

		var $TypeError = TypeError;

		// `RegExpExec` abstract operation
		// https://tc39.es/ecma262/#sec-regexpexec
		regexpExecAbstract = function (R, S) {
		  var exec = R.exec;
		  if (isCallable(exec)) {
		    var result = call(exec, R, S);
		    if (result !== null) anObject(result);
		    return result;
		  }
		  if (classof(R) === 'RegExp') return call(regexpExec, R, S);
		  throw new $TypeError('RegExp#exec called on incompatible receiver');
		};
		return regexpExecAbstract;
	}

	var hasRequiredEs_string_replace;

	function requireEs_string_replace () {
		if (hasRequiredEs_string_replace) return es_string_replace;
		hasRequiredEs_string_replace = 1;
		var apply = requireFunctionApply();
		var call = requireFunctionCall();
		var uncurryThis = requireFunctionUncurryThis();
		var fixRegExpWellKnownSymbolLogic = requireFixRegexpWellKnownSymbolLogic();
		var fails = requireFails();
		var anObject = requireAnObject();
		var isCallable = requireIsCallable();
		var isObject = requireIsObject();
		var toIntegerOrInfinity = requireToIntegerOrInfinity();
		var toLength = requireToLength();
		var toString = requireToString();
		var requireObjectCoercible = requireRequireObjectCoercible();
		var advanceStringIndex = requireAdvanceStringIndex();
		var getMethod = requireGetMethod();
		var getSubstitution = requireGetSubstitution();
		var getRegExpFlags = requireRegexpGetFlags();
		var regExpExec = requireRegexpExecAbstract();
		var wellKnownSymbol = requireWellKnownSymbol();

		var REPLACE = wellKnownSymbol('replace');
		var max = Math.max;
		var min = Math.min;
		var concat = uncurryThis([].concat);
		var push = uncurryThis([].push);
		var stringIndexOf = uncurryThis(''.indexOf);
		var stringSlice = uncurryThis(''.slice);

		var maybeToString = function (it) {
		  return it === undefined ? it : String(it);
		};

		// IE <= 11 replaces $0 with the whole match, as if it was $&
		// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
		var REPLACE_KEEPS_$0 = (function () {
		  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
		  return 'a'.replace(/./, '$0') === '$0';
		})();

		// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
		var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
		  if (/./[REPLACE]) {
		    return /./[REPLACE]('a', '$0') === '';
		  }
		  return false;
		})();

		var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
		  var re = /./;
		  re.exec = function () {
		    var result = [];
		    result.groups = { a: '7' };
		    return result;
		  };
		  // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive
		  return ''.replace(re, '$<a>') !== '7';
		});

		// @@replace logic
		fixRegExpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {
		  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

		  return [
		    // `String.prototype.replace` method
		    // https://tc39.es/ecma262/#sec-string.prototype.replace
		    function replace(searchValue, replaceValue) {
		      var O = requireObjectCoercible(this);
		      var replacer = isObject(searchValue) ? getMethod(searchValue, REPLACE) : undefined;
		      return replacer
		        ? call(replacer, searchValue, O, replaceValue)
		        : call(nativeReplace, toString(O), searchValue, replaceValue);
		    },
		    // `RegExp.prototype[@@replace]` method
		    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
		    function (string, replaceValue) {
		      var rx = anObject(this);
		      var S = toString(string);

		      if (
		        typeof replaceValue == 'string' &&
		        stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&
		        stringIndexOf(replaceValue, '$<') === -1
		      ) {
		        var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
		        if (res.done) return res.value;
		      }

		      var functionalReplace = isCallable(replaceValue);
		      if (!functionalReplace) replaceValue = toString(replaceValue);

		      var flags = toString(getRegExpFlags(rx));
		      var global = stringIndexOf(flags, 'g') !== -1;
		      var fullUnicode;
		      if (global) {
		        fullUnicode = stringIndexOf(flags, 'u') !== -1;
		        rx.lastIndex = 0;
		      }

		      var results = [];
		      var result;
		      while (true) {
		        result = regExpExec(rx, S);
		        if (result === null) break;

		        push(results, result);
		        if (!global) break;

		        var matchStr = toString(result[0]);
		        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
		      }

		      var accumulatedResult = '';
		      var nextSourcePosition = 0;
		      for (var i = 0; i < results.length; i++) {
		        result = results[i];

		        var matched = toString(result[0]);
		        var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);
		        var captures = [];
		        var replacement;
		        // NOTE: This is equivalent to
		        //   captures = result.slice(1).map(maybeToString)
		        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
		        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
		        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
		        for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));
		        var namedCaptures = result.groups;
		        if (functionalReplace) {
		          var replacerArgs = concat([matched], captures, position, S);
		          if (namedCaptures !== undefined) push(replacerArgs, namedCaptures);
		          replacement = toString(apply(replaceValue, undefined, replacerArgs));
		        } else {
		          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
		        }
		        if (position >= nextSourcePosition) {
		          accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
		          nextSourcePosition = position + matched.length;
		        }
		      }

		      return accumulatedResult + stringSlice(S, nextSourcePosition);
		    }
		  ];
		}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
		return es_string_replace;
	}

	requireEs_string_replace();

	var es_string_split = {};

	var hasRequiredEs_string_split;

	function requireEs_string_split () {
		if (hasRequiredEs_string_split) return es_string_split;
		hasRequiredEs_string_split = 1;
		var call = requireFunctionCall();
		var uncurryThis = requireFunctionUncurryThis();
		var fixRegExpWellKnownSymbolLogic = requireFixRegexpWellKnownSymbolLogic();
		var anObject = requireAnObject();
		var isObject = requireIsObject();
		var requireObjectCoercible = requireRequireObjectCoercible();
		var speciesConstructor = requireSpeciesConstructor();
		var advanceStringIndex = requireAdvanceStringIndex();
		var toLength = requireToLength();
		var toString = requireToString();
		var getMethod = requireGetMethod();
		var regExpExec = requireRegexpExecAbstract();
		var stickyHelpers = requireRegexpStickyHelpers();
		var fails = requireFails();

		var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
		var MAX_UINT32 = 0xFFFFFFFF;
		var min = Math.min;
		var push = uncurryThis([].push);
		var stringSlice = uncurryThis(''.slice);

		// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
		// Weex JS has frozen built-in prototypes, so use try / catch wrapper
		var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
		  // eslint-disable-next-line regexp/no-empty-group -- required for testing
		  var re = /(?:)/;
		  var originalExec = re.exec;
		  re.exec = function () { return originalExec.apply(this, arguments); };
		  var result = 'ab'.split(re);
		  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
		});

		var BUGGY = 'abbc'.split(/(b)*/)[1] === 'c' ||
		  // eslint-disable-next-line regexp/no-empty-group -- required for testing
		  'test'.split(/(?:)/, -1).length !== 4 ||
		  'ab'.split(/(?:ab)*/).length !== 2 ||
		  '.'.split(/(.?)(.?)/).length !== 4 ||
		  // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
		  '.'.split(/()()/).length > 1 ||
		  ''.split(/.?/).length;

		// @@split logic
		fixRegExpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {
		  var internalSplit = '0'.split(undefined, 0).length ? function (separator, limit) {
		    return separator === undefined && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
		  } : nativeSplit;

		  return [
		    // `String.prototype.split` method
		    // https://tc39.es/ecma262/#sec-string.prototype.split
		    function split(separator, limit) {
		      var O = requireObjectCoercible(this);
		      var splitter = isObject(separator) ? getMethod(separator, SPLIT) : undefined;
		      return splitter
		        ? call(splitter, separator, O, limit)
		        : call(internalSplit, toString(O), separator, limit);
		    },
		    // `RegExp.prototype[@@split]` method
		    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
		    //
		    // NOTE: This cannot be properly polyfilled in engines that don't support
		    // the 'y' flag.
		    function (string, limit) {
		      var rx = anObject(this);
		      var S = toString(string);

		      if (!BUGGY) {
		        var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);
		        if (res.done) return res.value;
		      }

		      var C = speciesConstructor(rx, RegExp);
		      var unicodeMatching = rx.unicode;
		      var flags = (rx.ignoreCase ? 'i' : '') +
		                  (rx.multiline ? 'm' : '') +
		                  (rx.unicode ? 'u' : '') +
		                  (UNSUPPORTED_Y ? 'g' : 'y');
		      // ^(? + rx + ) is needed, in combination with some S slicing, to
		      // simulate the 'y' flag.
		      var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);
		      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
		      if (lim === 0) return [];
		      if (S.length === 0) return regExpExec(splitter, S) === null ? [S] : [];
		      var p = 0;
		      var q = 0;
		      var A = [];
		      while (q < S.length) {
		        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
		        var z = regExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
		        var e;
		        if (
		          z === null ||
		          (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p
		        ) {
		          q = advanceStringIndex(S, q, unicodeMatching);
		        } else {
		          push(A, stringSlice(S, p, q));
		          if (A.length === lim) return A;
		          for (var i = 1; i <= z.length - 1; i++) {
		            push(A, z[i]);
		            if (A.length === lim) return A;
		          }
		          q = p = e;
		        }
		      }
		      push(A, stringSlice(S, p));
		      return A;
		    }
		  ];
		}, BUGGY || !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
		return es_string_split;
	}

	requireEs_string_split();

	var es_string_startsWith = {};

	var hasRequiredEs_string_startsWith;

	function requireEs_string_startsWith () {
		if (hasRequiredEs_string_startsWith) return es_string_startsWith;
		hasRequiredEs_string_startsWith = 1;
		var $ = require_export();
		var uncurryThis = requireFunctionUncurryThisClause();
		var getOwnPropertyDescriptor = requireObjectGetOwnPropertyDescriptor().f;
		var toLength = requireToLength();
		var toString = requireToString();
		var notARegExp = requireNotARegexp();
		var requireObjectCoercible = requireRequireObjectCoercible();
		var correctIsRegExpLogic = requireCorrectIsRegexpLogic();
		var IS_PURE = requireIsPure();

		var stringSlice = uncurryThis(''.slice);
		var min = Math.min;

		var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('startsWith');
		// https://github.com/zloirock/core-js/pull/702
		var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {
		  var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');
		  return descriptor && !descriptor.writable;
		}();

		// `String.prototype.startsWith` method
		// https://tc39.es/ecma262/#sec-string.prototype.startswith
		$({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
		  startsWith: function startsWith(searchString /* , position = 0 */) {
		    var that = toString(requireObjectCoercible(this));
		    notARegExp(searchString);
		    var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
		    var search = toString(searchString);
		    return stringSlice(that, index, index + search.length) === search;
		  }
		});
		return es_string_startsWith;
	}

	requireEs_string_startsWith();

	var es_string_trim = {};

	var whitespaces;
	var hasRequiredWhitespaces;

	function requireWhitespaces () {
		if (hasRequiredWhitespaces) return whitespaces;
		hasRequiredWhitespaces = 1;
		// a string of all valid unicode whitespaces
		whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
		  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
		return whitespaces;
	}

	var stringTrim;
	var hasRequiredStringTrim;

	function requireStringTrim () {
		if (hasRequiredStringTrim) return stringTrim;
		hasRequiredStringTrim = 1;
		var uncurryThis = requireFunctionUncurryThis();
		var requireObjectCoercible = requireRequireObjectCoercible();
		var toString = requireToString();
		var whitespaces = requireWhitespaces();

		var replace = uncurryThis(''.replace);
		var ltrim = RegExp('^[' + whitespaces + ']+');
		var rtrim = RegExp('(^|[^' + whitespaces + '])[' + whitespaces + ']+$');

		// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
		var createMethod = function (TYPE) {
		  return function ($this) {
		    var string = toString(requireObjectCoercible($this));
		    if (TYPE & 1) string = replace(string, ltrim, '');
		    if (TYPE & 2) string = replace(string, rtrim, '$1');
		    return string;
		  };
		};

		stringTrim = {
		  // `String.prototype.{ trimLeft, trimStart }` methods
		  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
		  start: createMethod(1),
		  // `String.prototype.{ trimRight, trimEnd }` methods
		  // https://tc39.es/ecma262/#sec-string.prototype.trimend
		  end: createMethod(2),
		  // `String.prototype.trim` method
		  // https://tc39.es/ecma262/#sec-string.prototype.trim
		  trim: createMethod(3)
		};
		return stringTrim;
	}

	var stringTrimForced;
	var hasRequiredStringTrimForced;

	function requireStringTrimForced () {
		if (hasRequiredStringTrimForced) return stringTrimForced;
		hasRequiredStringTrimForced = 1;
		var PROPER_FUNCTION_NAME = requireFunctionName().PROPER;
		var fails = requireFails();
		var whitespaces = requireWhitespaces();

		var non = '\u200B\u0085\u180E';

		// check that a method works with the correct list
		// of whitespaces and has a correct name
		stringTrimForced = function (METHOD_NAME) {
		  return fails(function () {
		    return !!whitespaces[METHOD_NAME]()
		      || non[METHOD_NAME]() !== non
		      || (PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME);
		  });
		};
		return stringTrimForced;
	}

	var hasRequiredEs_string_trim;

	function requireEs_string_trim () {
		if (hasRequiredEs_string_trim) return es_string_trim;
		hasRequiredEs_string_trim = 1;
		var $ = require_export();
		var $trim = requireStringTrim().trim;
		var forcedStringTrimMethod = requireStringTrimForced();

		// `String.prototype.trim` method
		// https://tc39.es/ecma262/#sec-string.prototype.trim
		$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
		  trim: function trim() {
		    return $trim(this);
		  }
		});
		return es_string_trim;
	}

	requireEs_string_trim();

	var web_domCollections_forEach = {};

	var domIterables;
	var hasRequiredDomIterables;

	function requireDomIterables () {
		if (hasRequiredDomIterables) return domIterables;
		hasRequiredDomIterables = 1;
		// iterable DOM collections
		// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
		domIterables = {
		  CSSRuleList: 0,
		  CSSStyleDeclaration: 0,
		  CSSValueList: 0,
		  ClientRectList: 0,
		  DOMRectList: 0,
		  DOMStringList: 0,
		  DOMTokenList: 1,
		  DataTransferItemList: 0,
		  FileList: 0,
		  HTMLAllCollection: 0,
		  HTMLCollection: 0,
		  HTMLFormElement: 0,
		  HTMLSelectElement: 0,
		  MediaList: 0,
		  MimeTypeArray: 0,
		  NamedNodeMap: 0,
		  NodeList: 1,
		  PaintRequestList: 0,
		  Plugin: 0,
		  PluginArray: 0,
		  SVGLengthList: 0,
		  SVGNumberList: 0,
		  SVGPathSegList: 0,
		  SVGPointList: 0,
		  SVGStringList: 0,
		  SVGTransformList: 0,
		  SourceBufferList: 0,
		  StyleSheetList: 0,
		  TextTrackCueList: 0,
		  TextTrackList: 0,
		  TouchList: 0
		};
		return domIterables;
	}

	var domTokenListPrototype;
	var hasRequiredDomTokenListPrototype;

	function requireDomTokenListPrototype () {
		if (hasRequiredDomTokenListPrototype) return domTokenListPrototype;
		hasRequiredDomTokenListPrototype = 1;
		// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`
		var documentCreateElement = requireDocumentCreateElement();

		var classList = documentCreateElement('span').classList;
		var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;

		domTokenListPrototype = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;
		return domTokenListPrototype;
	}

	var arrayIteration;
	var hasRequiredArrayIteration;

	function requireArrayIteration () {
		if (hasRequiredArrayIteration) return arrayIteration;
		hasRequiredArrayIteration = 1;
		var bind = requireFunctionBindContext();
		var uncurryThis = requireFunctionUncurryThis();
		var IndexedObject = requireIndexedObject();
		var toObject = requireToObject();
		var lengthOfArrayLike = requireLengthOfArrayLike();
		var arraySpeciesCreate = requireArraySpeciesCreate();

		var push = uncurryThis([].push);

		// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
		var createMethod = function (TYPE) {
		  var IS_MAP = TYPE === 1;
		  var IS_FILTER = TYPE === 2;
		  var IS_SOME = TYPE === 3;
		  var IS_EVERY = TYPE === 4;
		  var IS_FIND_INDEX = TYPE === 6;
		  var IS_FILTER_REJECT = TYPE === 7;
		  var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
		  return function ($this, callbackfn, that, specificCreate) {
		    var O = toObject($this);
		    var self = IndexedObject(O);
		    var length = lengthOfArrayLike(self);
		    var boundFunction = bind(callbackfn, that);
		    var index = 0;
		    var create = specificCreate || arraySpeciesCreate;
		    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
		    var value, result;
		    for (;length > index; index++) if (NO_HOLES || index in self) {
		      value = self[index];
		      result = boundFunction(value, index, O);
		      if (TYPE) {
		        if (IS_MAP) target[index] = result; // map
		        else if (result) switch (TYPE) {
		          case 3: return true;              // some
		          case 5: return value;             // find
		          case 6: return index;             // findIndex
		          case 2: push(target, value);      // filter
		        } else switch (TYPE) {
		          case 4: return false;             // every
		          case 7: push(target, value);      // filterReject
		        }
		      }
		    }
		    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
		  };
		};

		arrayIteration = {
		  // `Array.prototype.forEach` method
		  // https://tc39.es/ecma262/#sec-array.prototype.foreach
		  forEach: createMethod(0),
		  // `Array.prototype.map` method
		  // https://tc39.es/ecma262/#sec-array.prototype.map
		  map: createMethod(1),
		  // `Array.prototype.filter` method
		  // https://tc39.es/ecma262/#sec-array.prototype.filter
		  filter: createMethod(2),
		  // `Array.prototype.some` method
		  // https://tc39.es/ecma262/#sec-array.prototype.some
		  some: createMethod(3),
		  // `Array.prototype.every` method
		  // https://tc39.es/ecma262/#sec-array.prototype.every
		  every: createMethod(4),
		  // `Array.prototype.find` method
		  // https://tc39.es/ecma262/#sec-array.prototype.find
		  find: createMethod(5),
		  // `Array.prototype.findIndex` method
		  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
		  findIndex: createMethod(6),
		  // `Array.prototype.filterReject` method
		  // https://github.com/tc39/proposal-array-filtering
		  filterReject: createMethod(7)
		};
		return arrayIteration;
	}

	var arrayForEach;
	var hasRequiredArrayForEach;

	function requireArrayForEach () {
		if (hasRequiredArrayForEach) return arrayForEach;
		hasRequiredArrayForEach = 1;
		var $forEach = requireArrayIteration().forEach;
		var arrayMethodIsStrict = requireArrayMethodIsStrict();

		var STRICT_METHOD = arrayMethodIsStrict('forEach');

		// `Array.prototype.forEach` method implementation
		// https://tc39.es/ecma262/#sec-array.prototype.foreach
		arrayForEach = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {
		  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
		// eslint-disable-next-line es/no-array-prototype-foreach -- safe
		} : [].forEach;
		return arrayForEach;
	}

	var hasRequiredWeb_domCollections_forEach;

	function requireWeb_domCollections_forEach () {
		if (hasRequiredWeb_domCollections_forEach) return web_domCollections_forEach;
		hasRequiredWeb_domCollections_forEach = 1;
		var globalThis = requireGlobalThis();
		var DOMIterables = requireDomIterables();
		var DOMTokenListPrototype = requireDomTokenListPrototype();
		var forEach = requireArrayForEach();
		var createNonEnumerableProperty = requireCreateNonEnumerableProperty();

		var handlePrototype = function (CollectionPrototype) {
		  // some Chrome versions have non-configurable methods on DOMTokenList
		  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
		    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
		  } catch (error) {
		    CollectionPrototype.forEach = forEach;
		  }
		};

		for (var COLLECTION_NAME in DOMIterables) {
		  if (DOMIterables[COLLECTION_NAME]) {
		    handlePrototype(globalThis[COLLECTION_NAME] && globalThis[COLLECTION_NAME].prototype);
		  }
		}

		handlePrototype(DOMTokenListPrototype);
		return web_domCollections_forEach;
	}

	requireWeb_domCollections_forEach();

	/*! utd-webcomponents v3.5.0 */
	//TODO ajouter possibilitÃ© que utd reÃ§oive les textes de langue requis. De quelle faÃ§on?
	//A- En paramÃ¨tre des mÃ©thodes qui en ont besoin
	//B- Globalement via une initialisation de texte UTD qui serait faite une fois.

	//IMPORTANT! Laisser ce commentaire, une fois le build terminÃ©, il sera remplacÃ© par une condition permettant de ne pas rÃ©exÃ©cuter le script (afin d'Ã©viter les erreurs de custom elements dejÃ  dÃ©finis qui se produisent parfois. On suppose rechargement d'un onglet ou autre.)
	if (customElements.get('utd-infobulle')) { return true; }

	/*======================================================================================================================*/
	/* -10- FENÃTRES DE MESSAGE
	/*======================================================================================================================*/
	var message = function () {
	  var elementsPublics = {};

	  /**
	   * Affiche une fenÃªtre de message (dialog).
	   * @param {Object} parametres ParamÃ¨tres.
	   * @param {Object} parametres.type Type de message ("erreur", "information", "avertissement", "succes"  pour l'instant, autres types Ã  venir). DÃ©faut "avertissement".
	   * @param {Object} parametres.titre Titre du message. Texte brut ou HTML (ex. Annuler les modifications) DÃ©faut "". 
	   * @param {Object} parametres.corps Corps du message. Texte brut ou HTML (ex. DÃ©sirez-vous annuler les modifications ou poursuivre?.) DÃ©faut "".
	   * @param {Object} parametres.texteBoutonPrimaire Texte du bouton primaire. (Celui le plus Ã  droite). Si vide n'est pas affichÃ©.
	   * @param {Object} parametres.texteBoutonSecondaire Texte du bouton secondaire. (SituÃ© Ã  la gauche du bouton primaire). Si vide n'est pas affichÃ©.
	   * @param {Object} parametres.texteBoutonFermer Texte du bouton de fermeture du message. DÃ©faut "Fermer" ou "Close en anglais".
	   * @param {Object} parametres.afficherBoutonFermer Afficher le bouton pour fermer la fenÃªtre de message. DÃ©faut true.
	   * @param {Object} parametres.idControleFocusFermeture Id du contrÃ´le auquel on redonne le focus Ã  la fermeture de la fenÃªtre de message. Si non spÃ©cifiÃ©, focus redonnÃ© Ã  l'Ã©lÃ©ment actif avant l'affichage du message.
	   * @returns {Object} Une promesse jQuery qui contiendra Ã©ventuellement un objet contenant la raison de fermeture. (ex. objet.primaire ou objet.secondaire)
	   * @example afficherMessage(parametres)
	              .done(function (resultat) {
	                  if (resultat.primaire) {
	                      alert("TrÃ¨s bon choix! Poursuivre aurait pu causer une rupture du continuum espace temps!");
	                  } else if (resultat.secondaire) {
	                      alert("Mauvais choix! Vous auriez-du poursuivre. Ã cause de vous le continuum espace temps risque de se briser!");
	                  } else {
	                      alert("Vous vous Ãªtes contentÃ© de fermer la fenÃªtre sans faire de choix... La prochaine fois assumez-vous! L'avenir du monde est entre vos mains!");
	                  }
	              });
	  * @references https://www.w3.org/TR/wai-aria-practices/examples/dialog-modal/alertdialog.html
	  * @notes Le titre et les boutons sont lus 2 fois dans NVDA... Ã§a semble faire partie du pattern (voir lien ci-dessus). 
	  */
	  var evenementFermetureMessage = null;
	  elementsPublics.afficher = function (parametres) {
	    var valeursDefaut = {
	      type: "",
	      titre: "",
	      corps: "",
	      texteBoutonPrimaire: "",
	      texteBoutonSecondaire: "",
	      texteBoutonFermer: estPageLangueFrancais() ? "Fermer" : "Close",
	      afficherBoutonFermer: false,
	      estBoutonsTexteLong: false,
	      idControleFocusFermeture: null
	    };
	    parametres = extend(valeursDefaut, parametres);
	    var conteneurFenetreMessage = ajouterControle(parametres);
	    var fenetreMessage = conteneurFenetreMessage.querySelector('utd-dialog');
	    var boutons = conteneurFenetreMessage.querySelectorAll('[slot="pied"] > button');
	    boutons.forEach(function (btn) {
	      btn.addEventListener("click", function () {
	        var raison = this.getAttribute('raison-fermeture');
	        fenetreMessage.setAttribute('raison-fermeture', raison);
	        fenetreMessage.setAttribute('afficher', 'false');
	      });
	    });

	    //DÃ©finir une promesse qui sera rÃ©solue Ã  la fermeture de la fenÃªtre.
	    return new Promise(function (resolve) {
	      definirEvenementFermeture(fenetreMessage);
	      definirEvenementApresFermeture(fenetreMessage, resolve);
	      setTimeout(function () {
	        fenetreMessage.setAttribute('afficher', 'true');
	      });
	    });
	  };
	  /**
	   * (PrivÃ©e)
	   * Ajoute le contrÃ´le de fenÃªtre de message au DOM.
	   * @param {Object} parametres ParamÃ¨tres de la function afficherMessage.
	   * @returns Object correspondant au conteneur de la fenÃªtre de message.
	   */
	  function ajouterControle(parametres) {
	    //    var classeIcone = obtenirClasseIcone(parametres.type);
	    var type = parametres.type ? " type=\"".concat(parametres.type, "\" ") : '';
	    var htmlIdControleFermeture = parametres.idControleFocusFermeture ? " id-focus-fermeture=\"".concat(parametres.idControleFocusFermeture, "\"") : '';
	    var html = "\n        <utd-dialog titre=\"".concat(parametres.titre, "\" estfenetremessage=\"true\" boutons-texte-long=\"").concat(parametres.estBoutonsTexteLong, "\"").concat(type).concat(htmlIdControleFermeture, ">\n            <div slot=\"contenu\">\n                ").concat(parametres.corps, "\n            </div>\n            <div slot=\"pied\">");
	    var htmlBoutonPrimaire = "<button type=\"button\" class=\"utd-btn primaire compact\" raison-fermeture=\"primaire\" data-ga-action=\"".concat(parametres.titre, "\">").concat(parametres.texteBoutonPrimaire, "</button>");
	    var htmlBoutonSecondaire = parametres.texteBoutonSecondaire ? "<button type=\"button\" class=\"utd-btn secondaire compact\" raison-fermeture=\"secondaire\" data-ga-action=\"".concat(parametres.titre, "\">").concat(parametres.texteBoutonSecondaire, "</button>") : '';
	    html += "\n                ".concat(htmlBoutonSecondaire).concat(htmlBoutonPrimaire, "                        \n            </div>\n        </utd-dialog>");
	    var id = genererId();
	    var conteneurFenetreMessage = document.createElement('div');
	    conteneurFenetreMessage.id = id;
	    conteneurFenetreMessage.innerHTML = html;
	    document.body.appendChild(conteneurFenetreMessage);
	    return conteneurFenetreMessage;
	  }

	  /**
	   * (PrivÃ©ee)
	   * ComplÃ©ter la promesse indiquant de quelle faÃ§on la fenÃªtre s'est fermÃ©e et supprimer l'Ã©lÃ©ment du DOM une fois qu'il n'est plus affichÃ©.
	   * @param {Object} fenetreMessage Objet correspondant Ã  la fenÃªtre de message.     
	   */
	  function definirEvenementFermeture(fenetreMessage) {
	    fenetreMessage.addEventListener("fermeture", function (e) {
	      evenementFermetureMessage = e;
	    });
	  }

	  /**
	   * (PrivÃ©ee)
	   * ComplÃ©ter la promesse indiquant de quelle faÃ§on la fenÃªtre s'est fermÃ©e et supprimer l'Ã©lÃ©ment du DOM une fois qu'il n'est plus affichÃ©.
	   * @param {Object} fenetreMessage Objet correspondant Ã  la fenÃªtre de message.
	   * @param {Promise} resolve RÃ©solution de promesse.* 
	   */
	  function definirEvenementApresFermeture(fenetreMessage, resolve) {
	    fenetreMessage.addEventListener("apresFermeture", function (e) {
	      fenetreMessage.parentElement.remove();
	      resolve(evenementFermetureMessage.detail.raisonFermeture);
	    });
	  }
	  return elementsPublics;
	}();

	/*======================================================================================================================*/
	/* -11- DIALOGUE
	/*======================================================================================================================*/
	var dialogue = function () {
	  var elementsPublics = {};

	  /**
	  * Affiche une fenÃªtre de dialogue modal.
	  * @param {Object} parametres ParamÃ¨tres.
	  * @param {Object} parametres.idDialogue Id du contrÃ´le utd-dialog Ã  afficher.
	  * @param {Object} parametres.idControleFocusFermeture Id du contrÃ´le auquel on redonne le focus Ã  la fermeture du dialogue. Si non spÃ©cifiÃ©, focus redonnÃ© Ã  l'Ã©lÃ©ment actif avant l'affichage du message.
	  */

	  elementsPublics.afficher = function (idDialogue, idControleFocusFermeture) {
	    if (!idDialogue) {
	      console.error('utd.dialogue.afficher -> Aucun id de dialogue spÃ©cifiÃ©.');
	      return;
	    }
	    var dialogue = document.getElementById(idDialogue);
	    if (dialogue) {
	      dialogue.setAttribute('afficher', 'true');
	      if (idControleFocusFermeture) {
	        dialogue.setAttribute('id-focus-fermeture', idControleFocusFermeture);
	      }
	    } else {
	      console.error("utd.dialogue.afficher -> Contr\xF4le utd-dialog \"".concat(dialogue, "\" non trouv\xE9."));
	    }
	  };
	  elementsPublics.masquer = function (idDialogue) {
	    if (!idDialogue) {
	      console.error('utd.dialogue.masquer -> Aucun id de dialogue spÃ©cifiÃ©.');
	      return;
	    }
	    var dialogue = document.getElementById(idDialogue);
	    if (dialogue) {
	      dialogue.setAttribute('afficher', 'false');
	    } else {
	      console.error("utd.dialogue.masquer -> Contr\xF4le utd-dialog \"".concat(dialogue, "\" non trouv\xE9."));
	    }
	  };
	  return elementsPublics;
	}();

	/*======================================================================================================================*/
	/* -20- TRAITEMENT EN COURS
	/*======================================================================================================================*/
	var traitementEnCours = function () {
	  var elementsPublics = {};
	  var controleActifDebutTraitement;
	  elementsPublics.debuter = function (element, avecOverlay, textePrincipal, texteSecondaire) {
	    avecOverlay = avecOverlay !== undefined ? avecOverlay : true;
	    element = element || document.body;
	    var overlay = null;
	    if (!element.getAttribute('overlay')) {
	      //Ajouter un overlay global pendant le traitement en cours s'il y a lieu (dÃ©faut oui)  
	      if (avecOverlay) {
	        overlay = document.createElement("div");

	        //Si un overlay est dÃ©jÃ  prÃ©sent, on ajoute le nouveau mais on le masque (il sera peut-Ãªtre Ã©ventuellement rÃ©affichÃ© dans le traitement terminer du traitement en cours)
	        if (document.getElementsByClassName('utd-overlay').length > 0) {
	          overlay.classList.add('utd-d-none');
	        }
	        controleActifDebutTraitement = document.activeElement;
	        overlay.classList.add('utd-overlay');
	        desactiverInteractionsInterface(true);
	        document.body.appendChild(overlay);
	      }
	      element.setAttribute('overlay', avecOverlay ? 'true' : 'false');

	      //GÃ©nÃ©rer un id Ã  l'Ã©lÃ©ment qui va contenir le spinner de traitement en cours s'il n'en a pas.
	      if (!element.id) {
	        element.id = genererId();
	      }
	      if (estBouton(element)) {
	        element.classList.add("utd-traitement-en-cours");
	        var htmlTraitementEnCours = '<div class="utd-spinner"></div>';
	        if (element.getElementsByClassName('utd-spinner').length === 0) {
	          element.innerHTML += htmlTraitementEnCours;
	        }
	        element.disabled = true;
	        var texteTraitement = textePrincipal ? textePrincipal : estPageLangueFrancais() ? "Traitement en cours." : "Processing...";
	        notifierTraitementEnCoursLecteurEcran(element, false, texteTraitement);
	      } else {
	        if (element.tagName.toLowerCase() === 'body') {
	          //L'Ã©lÃ©ment est le body... c'est un traitement en cours global.
	          var htmlTextePrincipal = textePrincipal ? textePrincipal : obtenirTexteDefautDebutGlobal();

	          //Si un traitement en cours global existe dÃ©jÃ  on ne fait rien
	          if (estTraitementEnCoursGlobalExistant()) {
	            console.warn('UTD - Un traitement en cours global existe dÃ©jÃ . RequÃªte annulÃ©e.');
	          } else {
	            ajouterHtmlTraitementEnCoursGlobal(overlay, htmlTextePrincipal, texteSecondaire);
	          }
	          var _texteTraitement = "".concat(htmlTextePrincipal).concat(texteSecondaire ? '<br/>' + texteSecondaire : '');
	          notifierTraitementEnCoursLecteurEcran(element, false, _texteTraitement);
	        }

	        //TODO Ã©ventuellement implanter traitement pour autres Ã©lÃ©ments que des boutons et body?
	      }
	    }
	  };
	  elementsPublics.debuterGlobal = function (textePrincipal, texteSecondaire) {
	    elementsPublics.debuter(null, true, textePrincipal, texteSecondaire);
	  };
	  elementsPublics.terminer = function (element, texteFinTraitement) {
	    var elementOverlay = element || document.body;
	    if (estBouton(elementOverlay)) {
	      var spinner = elementOverlay.querySelector('.utd-spinner');
	      if (spinner) {
	        spinner.remove();
	      }
	      elementOverlay.classList.remove("utd-traitement-en-cours");
	      elementOverlay.disabled = false;
	    } else {
	      //Il s'agit d'un traitement en cours global
	      var traitementEnCoursGlobal = document.querySelector('.utd-conteneur-spinner-global');
	      if (traitementEnCoursGlobal) {
	        traitementEnCoursGlobal.remove();
	      }

	      //TODO ici il serait possible qu'il s'agissait au dÃ©part d'un traitement en cours sur bouton, mais que le bouton n'est plus dans le DOM... Il faudrait prÃ©voir Ã§a... et supprimer les zones de notif existantes?
	      //TODO mÃ©nage zones notif avec Ã©lÃ©ments qui n'existent plus...
	    }
	    var estElementAvecOverlay = !!(!element || elementOverlay.getAttribute('overlay') === 'true');
	    supprimerOverlay(element, elementOverlay);
	    elementOverlay.removeAttribute('overlay');
	    var texte = texteFinTraitement ? texteFinTraitement : estPageLangueFrancais() ? "Traitement terminÃ©." : "Processing complete.";
	    notifierTraitementEnCoursLecteurEcran(elementOverlay, true, texte);

	    //On s'assure que l'Ã©lÃ©ment avait un overlay, si ce n'est pas le cas c'Ã©tait un traitement en cours sans overlay.
	    if (estElementAvecOverlay && controleActifDebutTraitement) {
	      //Si aucun Ã©lÃ©ment actif ou l'Ã©lÃ©ment actif est le body (donc aucun contrÃ´le a le focus), on redonne le focus au contrÃ´le qui Ã©tait actif lorsque le traitement en cours a Ã©tÃ© initiÃ©.
	      //Le setTimeout permet de donner la chance au traitement appelant de lui mÃªme donner le focus Ã  un autre contrÃ´le avant nous. Le 300ms assure aussi que le message de fin de traitement a Ã©tÃ© lu au lecteur Ã©cran AVANT qu'on donne le focus.
	      setTimeout(function () {
	        if (!document.activeElement || document.activeElement && document.activeElement.tagName.toLowerCase() === 'body') {
	          //Ici on revÃ©rifie si le contrÃ´le existe encore car il pourrait ne plus Ãªtre lÃ  300ms plus tard.
	          if (controleActifDebutTraitement) {
	            controleActifDebutTraitement.focus();
	          }
	        }
	      }, 300);
	    }
	  };
	  elementsPublics.majGlobal = function (textePrincipal, texteSecondaire) {
	    var texte = textePrincipal ? textePrincipal : obtenirTexteDefautDebutGlobal();
	    definirTextes(texte, texteSecondaire);
	    var texteLecteurEcran = "".concat(textePrincipal).concat(texteSecondaire ? '<br/>' + texteSecondaire : '');
	    notifierTraitementEnCoursLecteurEcran(null, true, texteLecteurEcran);
	  };
	  elementsPublics.terminerGlobal = function (texteFinTraitement) {
	    var texte = texteFinTraitement ? texteFinTraitement : estPageLangueFrancais() ? "Chargement terminÃ©." : "Loading complete.";
	    elementsPublics.terminer(null, texte);
	  };
	  function obtenirTexteDefautDebutGlobal() {
	    return estPageLangueFrancais() ? "Chargement en cours..." : "Loading in progress...";
	  }
	  function estBouton(element) {
	    //TODO ajouter un lien qui look bouton utd (a role="button")
	    return element.tagName.toLowerCase() === 'button' || element.tagName.toLowerCase() === 'input' && element.type.toLowerCase() === 'submit';
	  }
	  function ajouterHtmlTraitementEnCoursGlobal(overlay, textePrincipal, texteSecondaire) {
	    var conteneurSpinner = document.createElement("div");
	    conteneurSpinner.classList.add('utd-conteneur-spinner-global');
	    var spinner = document.createElement("div");
	    spinner.classList.add('utd-spinner');
	    conteneurSpinner.appendChild(spinner);
	    overlay.appendChild(conteneurSpinner);
	    definirTextes(textePrincipal, texteSecondaire);
	  }
	  function definirTextes(textePrincipal, texteSecondaire) {
	    var conteneurSpinner = document.querySelector('.utd-conteneur-spinner-global');
	    if (!conteneurSpinner) {
	      console.warn('UTD - Aucun conteneur pour traitement en cours global trouvÃ© (.utd-conteneur-spinner-global');
	      return;
	    }
	    var ctrlTextePrincipal = conteneurSpinner.querySelector('.texte-principal');
	    if (!ctrlTextePrincipal) {
	      ctrlTextePrincipal = document.createElement("span");
	      ctrlTextePrincipal.classList.add('texte-principal');
	      conteneurSpinner.appendChild(ctrlTextePrincipal);
	    }
	    ctrlTextePrincipal.innerHTML = textePrincipal;
	    if (texteSecondaire) {
	      var ctrlTexteSecondaire = conteneurSpinner.querySelector('.texte-secondaire');
	      if (!ctrlTexteSecondaire) {
	        ctrlTexteSecondaire = document.createElement("span");
	        ctrlTexteSecondaire.classList.add('texte-secondaire');
	        conteneurSpinner.appendChild(ctrlTexteSecondaire);
	      }
	      ctrlTexteSecondaire.innerHTML = texteSecondaire;
	    }
	  }
	  function estTraitementEnCoursGlobalExistant() {
	    return !!document.querySelector('.utd-conteneur-spinner-global');
	  }
	  function supprimerOverlay(element, elementOverlay) {
	    //Si le traitement en cours sur l'Ã©lÃ©ment avait un overlay on le retire.
	    var avecOverlay = elementOverlay.getAttribute('overlay');

	    // On suppose que si l'Ã©lement n'est plus dans le DOM (!element), il avait un overlay, donc on le retire. Histoire d'Ã©viter des overlay qui restent collÃ©s et bloquent l'interface.
	    if (avecOverlay === 'true' || !element) {
	      //Retrait du overlay 
	      var overlayTraitementEnCours = document.getElementsByClassName('utd-overlay');
	      if (overlayTraitementEnCours.length > 1) {
	        //On enlÃ¨ve 1 overlay, si un masquÃ© existe c'est lui qu'on enlÃ¨ve. S'il y en a d'autres ils seront fermÃ©s Ã©ventuellement.
	        var overlayInvisibles = document.getElementsByClassName('utd-overlay utd-d-none');
	        if (overlayInvisibles.length > 0) {
	          overlayInvisibles[0].remove();
	        } else {
	          //Si aucun overlay invisible, on enlÃ¨ve le 1er trouvÃ©.
	          overlayTraitementEnCours[0].remove();
	        }
	      } else if (overlayTraitementEnCours.length === 1) {
	        desactiverInteractionsInterface(false);
	        overlayTraitementEnCours[0].remove();
	      }
	    }
	  }

	  //DÃ©sactive l'interaction avec la page (ex. les tabs qui ne sont pas gÃ©rÃ©s par l'overlay)
	  function desactiverInteractionsInterface(desactiver) {
	    var enfantsBody = document.body.children;
	    for (var i = 0; i < enfantsBody.length; i++) {
	      var enfant = enfantsBody[i];

	      // VÃ©rifie si l'Ã©lÃ©ment a l'attribut 'role' et si sa valeur est 'status'
	      var estElementStatus = enfant.hasAttribute('role') && enfant.getAttribute('role') === 'status';
	      if (desactiver) {
	        if (!estElementStatus) {
	          enfant.setAttribute('inert', '');
	        }
	      } else {
	        if (enfant.hasAttribute('inert')) {
	          enfant.removeAttribute('inert');
	        }
	      }
	    }
	  }
	  function notifierTraitementEnCoursLecteurEcran(element, estTraitementTermine, texteTraitement) {
	    element = element || document.body;
	    var idZoneNotification = "zoneNotification_".concat(element.id);

	    //Ajouter la zone de notification hors Ã©cran si elle n'existe pas dÃ©jÃ .
	    var zoneNotificationsLecteurEcran = document.getElementById(idZoneNotification);
	    if (!zoneNotificationsLecteurEcran) {
	      zoneNotificationsLecteurEcran = document.createElement("div");
	      zoneNotificationsLecteurEcran.id = idZoneNotification;
	      zoneNotificationsLecteurEcran.setAttribute('role', 'status');
	      zoneNotificationsLecteurEcran.classList.add('utd-sr-only');
	      document.body.appendChild(zoneNotificationsLecteurEcran);
	    }
	    //setTimeout nÃ©cessaire pour le lecteur Ã©cran
	    var timeout = estTraitementTermine ? 250 : 200;
	    setTimeout(function () {
	      zoneNotificationsLecteurEcran.innerHTML = texteTraitement;
	      setTimeout(function () {
	        if (estTraitementTermine) {
	          zoneNotificationsLecteurEcran.remove();
	        }
	      }, 250);
	    }, timeout);
	  }
	  return elementsPublics;
	}();

	/*======================================================================================================================*/
	/* -30- NOTIFICATIONS
	/*======================================================================================================================*/
	var notification = function () {
	  var elementsPublics = {};

	  /**
	   * Affiche une notification (toast).
	   * @param {Object} parametres ParamÃ¨tres.
	   * @param {Object} parametres.type Type de notification (positif, negatif ou neutre). DÃ©faut "positif".
	   * @param {Object} parametres.titre Titre de la notification (ex. SuccÃ¨s) DÃ©faut "SuccÃ¨s" ou "Ãchec".
	   * @param {Object} parametres.message Message de la notification (ex. Enregistrement effectuÃ© avec succÃ¨s.) DÃ©faut "".
	   * @param {Object} parametres.texteBoutonFermer Texte du bouton de fermeture de la notification. DÃ©faut "Fermer".
	   * @param {Object} parametres.delaiFermeture DÃ©lai (en ms) de fermeture automatique de la notification. DÃ©faut 5000.
	   */

	  elementsPublics.emettre = function (parametres) {
	    var valeursDefaut = {
	      type: "positif",
	      titre: "",
	      //parametres.type == "echec" ? "Ãchec" : "SuccÃ¨s",
	      message: "",
	      texteBoutonFermer: estPageLangueFrancais() ? "Fermer" : "Close",
	      delaiFermeture: 5000
	    };
	    parametres = extend(valeursDefaut, parametres);
	    var zoneNotifications = obtenirZoneNotifications();
	    var notification = ajouterNotification(zoneNotifications, parametres);
	    retirerNotificationApresDelai(notification, parametres);
	  };
	  /**
	   * Obtient la node correspondant Ã  la zone de notifications utd.
	   * @returns {object} La zone de notifications utd.
	   */
	  function obtenirZoneNotifications() {
	    var zoneNotifications = document.getElementById('utdZoneNotifications');
	    if (!zoneNotifications) {
	      zoneNotifications = document.createElement('div');
	      zoneNotifications.id = 'utdZoneNotifications';
	      zoneNotifications.classList.add('utd-notifications');
	      document.body.appendChild(zoneNotifications);
	    }
	    return zoneNotifications;
	  }
	  /**
	   * (PrivÃ©e)
	   * Ajoute une notification dans la zone des notifications.
	   * @param {Object} zoneNotifications Node correspondant Ã  la zone de notifications.
	   * @param {Object} parametres ParamÃ¨tres de la mÃ©thode emettre (qui permet d'Ã©mettre une notification).
	   * @returns {Object} Node correspondant Ã  la notification ajoutÃ©e.
	   */
	  function ajouterNotification(zoneNotifications, parametres) {
	    var notification = document.createElement('div');
	    notification.classList.add("notification", parametres.type);
	    var possedeTitre = !!parametres.titre;
	    if (!possedeTitre) {
	      notification.classList.add("sans-titre");
	    }
	    notification.innerHTML = obtenirHtmlNotification(parametres, possedeTitre);
	    definirEvenementClick(notification);
	    zoneNotifications.appendChild(notification);
	    afficherNotification(notification);
	    return notification;
	  }
	  /**
	   * 
	   * @param {Object} parametres ParamÃ¨tres de la mÃ©thode emettre (qui permet d'Ã©mettre une notification).
	   * @param {Boolean} possedeTitre Indique si la notification possÃ¨de un titre ou non.
	   * @returns 
	   */
	  function obtenirHtmlNotification(parametres, possedeTitre) {
	    var html = "\n            <button type=\"button\">\n                <span class=\"utd-sr-only\">".concat(parametres.texteBoutonFermer, "</span>\n                <span class=\"utd-icone-svg x-fermer-blanc\" aria-hidden=\"true\"></span>\n            </button>\n            <div class=\"zone-alerte\" role=\"alert\">");
	    if (possedeTitre) {
	      var classeIcone = obtenirClasseIcone(parametres.type);
	      html += "\n                <div class=\"titre\">\n                    <span class=\"utd-icone-svg ".concat(classeIcone, " md\" aria-hidden=\"true\"></span>\n                    <span class=\"texte\">").concat(parametres.titre, "&nbsp;</span>\n                </div>            \n            ");
	    }
	    html += "\n            <div class=\"texte-message\">\n                ".concat(parametres.message, "\n            </div></div>");
	    return html;
	  }
	  /**
	   * Obtient la classe de l'icÃ´ne de titre.
	   * @param {string} type Type de notification
	   * @returns {string} Classe de l'icÃ´ne de titre pour le type spÃ©cifiÃ©.
	   */
	  function obtenirClasseIcone(type) {
	    switch (type) {
	      case "negatif":
	        return "erreur-blanc";
	      case "neutre":
	        return "information-blanc";
	      default:
	        return "succes-blanc";
	    }
	  }
	  /**
	   * Affiche la notification en effectuant un fade in.
	   * @param {Object} notification Node notification Ã  afficher.
	   */
	  function afficherNotification(notification) {
	    setTimeout(function () {
	      notification.classList.add('visible');
	    }, 100);
	  }
	  /**
	   * Retire la notification aprÃ¨s le dÃ©lai prÃ©vu.
	   * @param {Object} notification Node correspondant Ã  la notification Ã  retirer.
	   * @param {Object} parametres ParamÃ¨tres de la mÃ©thode emettre (qui permet d'Ã©mettre une notification).
	   */
	  function retirerNotificationApresDelai(notification, parametres) {
	    setTimeout(function () {
	      retirerNotification(notification);
	    }, parametres.delaiFermeture);
	  }

	  /**
	   * Retire la notification du dom et en effectuant un fade out.
	   * @param {Object} notification Node correspondant Ã  la notification Ã  retirer.
	   */
	  function retirerNotification(notification) {
	    var dureeAnimationMs = 500;
	    notification.classList.remove('visible');
	    setTimeout(function () {
	      notification.remove();
	    }, dureeAnimationMs);
	  }

	  /**
	   * (PrivÃ©ee)
	   * DÃ©finit le traitement Ã  effectuer sur le click d'une notification.
	   * @param {Object} notification Node de notification sur laquelle on doit appliquer l'Ã©vÃ©nement.
	   */
	  function definirEvenementClick(notification) {
	    notification.addEventListener("click", function (e) {
	      retirerNotification(notification);
	    });
	  }
	  return elementsPublics;
	}();

	/*======================================================================================================================*/
	/* -35- Fil d'ariane
	/*======================================================================================================================*/
	var filAriane = function () {
	  var elementsPublics = {};
	  /**
	   * DÃ©finit le contrÃ´le fil d'ariane.
	   * @param {Array} elementsFilAriane Array d'objets contenant les informations Ã  afficher dans le fil d'ariane.
	   */
	  elementsPublics.definir = function (elementsFilAriane) {
	    var filAriane = document.querySelector('nav.utd-fil-ariane');
	    if (!filAriane) {
	      var header = document.querySelector('header');

	      // S'il n'y a pas de fil d'ariane et qu'il n'y a pas de header, on ne fait rien, car on ne sait pas oÃ¹ ajouter le fil d'ariane.
	      if (!header) {
	        console.error("Aucune balise <header> pr\xE9sente pour ajouter le fil d'ariane.");
	        return;
	      }
	      var conteneur = document.createElement('div');
	      conteneur.classList.add("utd-container");
	      filAriane = document.createElement('nav');
	      filAriane.classList.add("utd-fil-ariane");
	      conteneur.append(filAriane);
	      header.append(conteneur);
	    }
	    filAriane.setAttribute('aria-label', estPageLangueFrancais() ? "Fil d'Ariane" : "Breadcrumb");
	    var doitAfficherEllipse = elementsFilAriane.length > 5;
	    var htmlFilAriane = obtenirCodeHtmlFilAriane(elementsFilAriane, doitAfficherEllipse);
	    filAriane.innerHTML = htmlFilAriane;
	    if (doitAfficherEllipse) {
	      definirEvenementsFilAriane(filAriane);
	    }
	  };

	  /**
	   * (PrivÃ©e)
	   * Obtient le code HTML du fil d'ariane.
	   * @param {Array} elementsFilAriane Array d'objets contenant les informations Ã  afficher dans le fil d'ariane.
	   * @param {Boolean} doitAfficherEllipse Indique si une ellipse doit Ãªtre affichÃ©e pour des niveaux supplÃ©mentaires.
	   * @returns {string} Code html constituant le fil d'ariane.
	   */
	  function obtenirCodeHtmlFilAriane(elementsFilAriane, doitAfficherEllipse) {
	    var html = "<ul>";
	    var nbElementsFilAriane = elementsFilAriane.length;
	    var estSousMenuAjoute = false;
	    elementsFilAriane.forEach(function (e, i) {
	      if (nbElementsFilAriane === i + 1) {
	        //Dernier Ã©lÃ©ment
	        html += "<li>".concat(e.libelle, "</li>");
	      } else if (!doitAfficherEllipse) {
	        //Pas plus de 5 niveaux
	        html += "<li><a href=\"".concat(e.href, "\">").concat(e.libelle, "</a></li>");
	      } else {
	        if (i > 1 && i < nbElementsFilAriane - 2) {
	          if (!estSousMenuAjoute) {
	            html += "<li data-expanded=\"false\">\n                                    <button type=\"button\" aria-expanded=\"false\" aria-controls=\"sousMenufilArianeUtd\" aria-label=\"".concat(obtenirAriaLabelBouton(false), "\">\n                                        <span class=\"utd-icone-svg ellipse\" aria-hidden=\"true\"></span>\n                                    </button>                                                                \n                                    <ul id=\"sousMenufilArianeUtd\">");
	          }
	          html += "<li><a href=\"".concat(e.href, "\">").concat(e.libelle, "</a></li>");
	          estSousMenuAjoute = true;
	        } else if (i === nbElementsFilAriane - 2) {
	          html += "</ul></li><li><a href=\"".concat(e.href, "\">").concat(e.libelle, "</a></li>");
	        } else {
	          html += "<li><a href=\"".concat(e.href, "\" aria-current=\"page\">").concat(e.libelle, "</a></li>");
	        }
	      }
	    });
	    html += "</ul>";
	    return html;
	  }

	  /**
	   * (PrivÃ©e)
	   * DÃ©fini les diffÃ©rents Ã©vÃ©nements du fil d'ariane.
	   */
	  function definirEvenementsFilAriane(controleFilAriane) {
	    var boutonEllipse = controleFilAriane.querySelector('button');
	    if (boutonEllipse) {
	      boutonEllipse.removeEventListener('click', clickBoutonEllipse);
	      boutonEllipse.addEventListener('click', clickBoutonEllipse);
	      var sousMenu = boutonEllipse.parentElement;
	      sousMenu.removeEventListener('focusout', focusOutSousMenu);
	      sousMenu.addEventListener('focusout', focusOutSousMenu);
	      sousMenu.removeEventListener('keydown', keydownSousMenu);
	      sousMenu.addEventListener('keydown', keydownSousMenu);
	    }
	  }
	  function clickBoutonEllipse() {
	    var afficher = this.getAttribute('aria-expanded') !== 'true';
	    afficherMasquerSousMenu(this.parentElement, afficher);
	  }
	  function focusOutSousMenu() {
	    var sousMenu = this;
	    setTimeout(function () {
	      if (sousMenu && !sousMenu.contains(document.activeElement)) {
	        afficherMasquerSousMenu(sousMenu, false);
	      }
	    });
	  }
	  function keydownSousMenu(event) {
	    var sousMenu = event.currentTarget;
	    if (sousMenu && event.key === 'Escape' || event.key === 'Esc') {
	      if (sousMenu.getAttribute('data-expanded') === 'true') {
	        var _sousMenu$querySelect;
	        afficherMasquerSousMenu(sousMenu, false);
	        (_sousMenu$querySelect = sousMenu.querySelector('button')) === null || _sousMenu$querySelect === void 0 || _sousMenu$querySelect.focus();
	      }
	    }
	  }
	  function afficherMasquerSousMenu(sousMenu, afficher) {
	    sousMenu.setAttribute('data-expanded', String(afficher));
	    var bouton = sousMenu.querySelector('button');
	    if (bouton) {
	      bouton.setAttribute('aria-expanded', String(afficher));
	      bouton.setAttribute('aria-label', obtenirAriaLabelBouton(afficher));
	    }
	  }
	  function obtenirAriaLabelBouton(estSousMenuAffiche) {
	    if (estPageLangueFrancais()) {
	      var action = estSousMenuAffiche ? 'Masquer' : 'Afficher';
	      return "".concat(action, " les niveaux interm\xE9diaires du fil d'Ariane.");
	    } else {
	      var _action = estSousMenuAffiche ? 'Hide' : 'Show';
	      return "".concat(_action, " intermediate breadcrumb levels.");
	    }
	  }
	  return elementsPublics;
	}();

	/* ============================================================= */
	/* ======================== UTILITAIRES ======================== */
	/* ============================================================= */
	/**
	 * Obtient l'id du contrÃ´le actif. Si le contrÃ´le actif n'a pas d'id, on lui en assigne un.
	 * @returns L'id du contrÃ´le actif.
	 */
	function obtenirIdControleActif() {
	  if (document.activeElement) {
	    var id = document.activeElement.id;
	    if (!id) {
	      id = genererId();
	      document.activeElement.id = id;
	    }
	    return id;
	  }
	  return null;
	}

	/**
	 * 
	 * @param {Object} cible Objet dans lequel on doit copier les donnÃ©es. 
	 * @param {Object} source Objet contenant les infos Ã  copier dans l'objet cible. 
	 * @returns 
	 */
	function extend(cible, source) {
	  for (var sourceProp in source) {
	    var sourceVal = source[sourceProp];
	    // Is this value an object?  If so, iterate over its properties, copying them over
	    if (sourceVal && Object.prototype.toString.call(sourceVal) === "[object Object]") {
	      cible[sourceProp] = cible[sourceProp] || {};
	      extend(cible[sourceProp], sourceVal);
	    } else {
	      cible[sourceProp] = sourceVal;
	    }
	  }
	  return cible;
	}

	/**
	 * GÃ©nÃ¨re un id unique.
	 * @returns Un id unique.
	 */
	function genererId() {
	  return Date.now().toString(36) + '-' + Math.random().toString(36).substr(2, 9);
	}

	/**
	 * Normalise une chaÃ®ne de caractÃ¨res pour utilisation insensible Ã  la case et aux accents.
	 * @param {string} chaineCaracteres ChaÃ®ne de caractÃ¨res.
	 * */
	function normaliserChaineCaracteres(chaineCaracteres) {
	  return normaliserApostrophes(remplacerAccents(chaineCaracteres).toLowerCase());
	}

	/**
	* Normaliser les apostrophes d'une chaÃ®ne de caractÃ¨res.
	* @param {string} chaineCaracteres ChaÃ®ne de caractÃ¨res.
	**/
	function normaliserApostrophes(chaineCaracteres) {
	  return chaineCaracteres.replace(/[\u2018-\u2019]/g, "'");
	}

	/**
	 * Remplace les accents d'une chaÃ®ne de caractÃ¨res.
	 * @param {string} chaineCaracteres ChaÃ®ne de caractÃ¨res.
	 * */
	function remplacerAccents(chaineCaracteres) {
	  return chaineCaracteres.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
	}

	/**
	 * GÃ©nÃ¨re un id Ã  partir du texte spÃ©cifiÃ©. Le texte est normalisÃ©, puis tous les caractÃ¨res non textuels sont remplacÃ©s par des underscore "_".
	 * @param {string} texte Texte Ã  partir duquel il faut crÃ©er un id.
	 * @returns Un id gÃ©nÃ©rÃ© Ã  partir du texte.
	 */
	function obtenirIdSelonTexte(texte) {
	  var texteNormalise = normaliserChaineCaracteres(texte);
	  return texteNormalise.replace(/\W/g, '_');
	}

	/**
	 * Obtient la langue de la page courante.
	 * @returns {string} Code de langue de la page courante (fr/en).
	 */
	function obtenirLanguePage() {
	  return document.getElementsByTagName("html")[0].getAttribute("lang") || "fr";
	}

	/**
	 * Indique si la page courante est en franÃ§ais.
	 * @returns {boolean} Indicateur de page courante en franÃ§ais.
	 */
	function estPageLangueFrancais() {
	  var langue = obtenirLanguePage();
	  return langue.startsWith('fr');
	}
	function ajusterAccessibiliteLiens(texteAccessibilite) {
	  texteAccessibilite = texteAccessibilite || estPageLangueFrancais() ? "Cet hyperlien s'ouvrira dans une nouvelle fenÃªtre." : "This link will open in a new window.";
	  document.querySelectorAll('main a[target="_blank"], utd-alerte-generale a[target="_blank"]').forEach(function (lien) {
	    //Ne pas traiter les liens sans href
	    if (!lien.getAttribute('href')) {
	      return;
	    }
	    //Ne pas traiter les liens vers des fichiers pdf ou les liens ayant explicitement une classe indiquant de ne pas les considÃ©rer comme lien externe(sans-lien-externe).  TODO Ã©ventuellement rafiner la condition afin de traiter uniquement les liens vers des pages web...
	    if (lien.getAttribute('href').endsWith(".pdf") || lien.classList.contains("utd-sans-lien-externe")) {
	      return;
	    }
	    ajusterAttributRelLiens(lien, ['noopener', 'noreferrer']);

	    // Lien externe fait avec l'ancienne mÃ©thode... on skip. 
	    if (lien.classList.contains("utd-lien-externe")) {
	      //Ajouter le texte pour accessibilitÃ© nouvelle fenÃªtre si on dÃ©tecte qu'il n'est pas lÃ . 
	      if (!lien.querySelector(".utd-sr-only")) {
	        lien.innerHTML = lien.innerHTML + "<span class=\"utd-sr-only\">".concat(texteAccessibilite, "</span>");
	      }
	      return;
	    }

	    //Ajouter la classe lien-externe-auto afin d'afficher l'icÃ´ne d'ouverture dans une nouvelle fenÃªtre.
	    if (!lien.classList.contains("utd-lien-externe-auto") && !lien.querySelector('.utd-lien-externe-auto')) {
	      lien.classList.add("utd-lien-externe-auto");
	    }

	    //Ajouter l'image de lien externe et la wrapper avec le dernier mot du lien
	    if (!lien.querySelector(".utd-no-wrap")) {
	      var texte = lien.textContent.trim();
	      var mots = texte.split(/\s+/); // Split sur les espaces

	      if (mots.length > 1) {
	        var dernierMot = mots.pop();
	        var texteSansDernierMot = mots.join(' ');
	        lien.innerHTML = "".concat(texteSansDernierMot, " <span class=\"utd-no-wrap\">").concat(dernierMot, "<span role=\"img\" aria-label=\"").concat(texteAccessibilite, "\"></span>");
	      } else if (mots.length === 1) {
	        lien.innerHTML = "<span class=\"utd-no-wrap\">".concat(texte, "<span role=\"img\" aria-label=\"").concat(texteAccessibilite, "\"></span>");
	      }
	    }
	  });
	}
	function notifierLecteurEcran(texte) {
	  //GÃ©nÃ©rer un id Ã  l'Ã©lÃ©ment qui va contenir le spinner de traitement en cours
	  var id = genererId();
	  var idZoneNotification = "zoneNotification_".concat(id);

	  //Ajouter la zone de notification hors Ã©cran si elle n'existe pas dÃ©jÃ . (Elle ne devrait pas exister)
	  var zoneNotificationsLecteurEcran = document.getElementById(idZoneNotification);
	  if (!zoneNotificationsLecteurEcran) {
	    zoneNotificationsLecteurEcran = document.createElement("div");
	    zoneNotificationsLecteurEcran.id = idZoneNotification;
	    zoneNotificationsLecteurEcran.setAttribute('role', 'status');
	    zoneNotificationsLecteurEcran.classList.add('utd-sr-only');
	    document.body.appendChild(zoneNotificationsLecteurEcran);
	  }

	  //setTimeouts nÃ©cessaires pour le lecteur Ã©cran
	  setTimeout(function () {
	    zoneNotificationsLecteurEcran.innerHTML = texte;
	    setTimeout(function () {
	      zoneNotificationsLecteurEcran.remove();
	    }, 250);
	  }, 100);
	}
	function scrollIntoViewSiRequis(el) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
	    behavior: 'smooth',
	    block: 'center'
	  };
	  var rect = el.getBoundingClientRect();
	  var estVisible = rect.top >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight);
	  if (!estVisible) {
	    el.scrollIntoView(options);
	  }
	}

	/**
	 * Ajoute les valeurs "noopener" et "noreferrer" Ã  l'attribut "rel" d'un hyperlien,
	 * en conservant les valeurs existantes.
	 *
	 * @param {HTMLElement} lien L'Ã©lÃ©ment <a> (hyperlien) Ã  modifier.
	 */
	function ajusterAttributRelLiens(lien, nouveauxRels) {
	  if (!lien || lien.tagName !== 'A') {
	    return;
	  }
	  var relCourant = lien.getAttribute('rel');
	  if (!relCourant) {
	    lien.setAttribute('rel', nouveauxRels.join(' '));
	    return;
	  }
	  var relArray = relCourant.split(' ');
	  nouveauxRels.forEach(function (rel) {
	    if (!relArray.includes(rel)) {
	      relArray.push(rel);
	    }
	  });
	  lien.setAttribute('rel', relArray.join(' '));
	}

	var es_object_assign = {};

	var objectAssign;
	var hasRequiredObjectAssign;

	function requireObjectAssign () {
		if (hasRequiredObjectAssign) return objectAssign;
		hasRequiredObjectAssign = 1;
		var DESCRIPTORS = requireDescriptors();
		var uncurryThis = requireFunctionUncurryThis();
		var call = requireFunctionCall();
		var fails = requireFails();
		var objectKeys = requireObjectKeys();
		var getOwnPropertySymbolsModule = requireObjectGetOwnPropertySymbols();
		var propertyIsEnumerableModule = requireObjectPropertyIsEnumerable();
		var toObject = requireToObject();
		var IndexedObject = requireIndexedObject();

		// eslint-disable-next-line es/no-object-assign -- safe
		var $assign = Object.assign;
		// eslint-disable-next-line es/no-object-defineproperty -- required for testing
		var defineProperty = Object.defineProperty;
		var concat = uncurryThis([].concat);

		// `Object.assign` method
		// https://tc39.es/ecma262/#sec-object.assign
		objectAssign = !$assign || fails(function () {
		  // should have correct order of operations (Edge bug)
		  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, 'a', {
		    enumerable: true,
		    get: function () {
		      defineProperty(this, 'b', {
		        value: 3,
		        enumerable: false
		      });
		    }
		  }), { b: 2 })).b !== 1) return true;
		  // should work with symbols and should have deterministic property order (V8 bug)
		  var A = {};
		  var B = {};
		  // eslint-disable-next-line es/no-symbol -- safe
		  var symbol = Symbol('assign detection');
		  var alphabet = 'abcdefghijklmnopqrst';
		  A[symbol] = 7;
		  // eslint-disable-next-line es/no-array-prototype-foreach -- safe
		  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
		  return $assign({}, A)[symbol] !== 7 || objectKeys($assign({}, B)).join('') !== alphabet;
		}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`
		  var T = toObject(target);
		  var argumentsLength = arguments.length;
		  var index = 1;
		  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
		  var propertyIsEnumerable = propertyIsEnumerableModule.f;
		  while (argumentsLength > index) {
		    var S = IndexedObject(arguments[index++]);
		    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
		    var length = keys.length;
		    var j = 0;
		    var key;
		    while (length > j) {
		      key = keys[j++];
		      if (!DESCRIPTORS || call(propertyIsEnumerable, S, key)) T[key] = S[key];
		    }
		  } return T;
		} : $assign;
		return objectAssign;
	}

	var hasRequiredEs_object_assign;

	function requireEs_object_assign () {
		if (hasRequiredEs_object_assign) return es_object_assign;
		hasRequiredEs_object_assign = 1;
		var $ = require_export();
		var assign = requireObjectAssign();

		// `Object.assign` method
		// https://tc39.es/ecma262/#sec-object.assign
		// eslint-disable-next-line es/no-object-assign -- required for testing
		$({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign }, {
		  assign: assign
		});
		return es_object_assign;
	}

	requireEs_object_assign();

	var datatables = function () {
	  var elementsPublics = {};
	  elementsPublics.obtenirParametresDefaut = function () {
	    var lang = document.getElementsByTagName('html')[0].getAttribute('lang');
	    return {
	      language: lang.startsWith('en') ? obtenirTextesAnglais() : obtenirTextesFrancais(),
	      layout: {
	        top2: obtenirLayoutTop2Info(),
	        topStart: 'search',
	        topEnd: 'pageLength',
	        bottom: 'paging',
	        bottomStart: null,
	        bottomEnd: null
	      },
	      //            autoWidth: false,
	      //            select: {style: 'single', info: false},
	      //            select: false,
	      //            lengthMenu: [1, 2, 5, 10, 25, 50],
	      //            pageLength: 25,
	      //            lengthChange: false,
	      //            info: false,
	      //            paging: false,
	      //            pagingTag: 'button',
	      pagingType: "simple_numbers",
	      //            searching: false,
	      //            ordering: true,
	      //            order: [[0, 'asc']],
	      /*            responsive: {
	                  details: false
	              },*/
	      classes: {
	        info: {
	          container: 'utd-datatable-info'
	        },
	        length: {
	          container: 'utd-datatable-length',
	          select: 'utd-form-control'
	        },
	        paging: {
	          active: 'current',
	          button: 'dt-paging-button',
	          container: 'utd-datatable-paging paging_',
	          disabled: 'disabled'
	        },
	        search: {
	          container: 'utd-datatable-search',
	          input: 'utd-form-control lg'
	        }
	      }
	    };
	  };
	  elementsPublics.definirParametresDefaut = function () {
	    /* Datatables - Options par dÃ©faut */
	    if (DataTable === undefined) {
	      return;
	    }
	    Object.assign(DataTable.defaults, this.obtenirParametresDefaut());
	  };

	  /**
	   * (PrivÃ©e)
	   * Obtient le html requis pour l'affichage de la zone 'info' selon la langue du site.
	   * @returns Object contenant le html.
	   */
	  function obtenirLayoutTop2Info() {
	    var lang = document.getElementsByTagName('html')[0].getAttribute('lang');
	    if (lang.startsWith('en')) {
	      return 'info';
	    } else {
	      return obtenirLayoutTop2InfoFrancais();
	    }
	  }

	  /**
	   * (PrivÃ©e)
	   * Obtient le html requis pour l'affichage de la zone 'info' selon la langue du site.
	   * @returns Object contenant le html.
	   */
	  function obtenirLayoutTop2InfoFrancais() {
	    return {
	      info: {
	        callback: function callback(settings, start, end, max, total, pre) {
	          var texteInfo = '';
	          if (max === 0) {
	            texteInfo = "<span class=\"info-empty\">0 \xE9l\xE9ment</span>";
	          } else {
	            texteInfo = "<span class=\"info-total\">".concat(total, " \xE9l\xE9ment").concat(total > 1 ? 's' : '', "&nbsp;</span>");

	            //Pagination active et plus d'une page
	            if (total !== end || start !== 1) {
	              texteInfo += "<span class=\"info-position\">\xC9l\xE9ment".concat(start !== end ? 's' : '', " ").concat(start, " \xE0 ").concat(end, "</span>");
	            }
	          }

	          //Le tableau est filtrÃ©
	          if (total !== max) {
	            texteInfo += "<span class=\"info-filtered\">&nbsp;(filtr\xE9 de ".concat(max, " \xE9l\xE9ment").concat(max > 1 ? 's' : '', " au total)</span>");
	          }
	          return texteInfo;
	        }
	      }
	    };
	  }

	  /**
	   * (PrivÃ©e)
	   * Obtient les textes franÃ§ais pour datatables. Tous les textes, car franÃ§ais n'est pas inclus dans datatables par dÃ©faut.
	   * @returns Object contenant les textes franÃ§ais.
	   */
	  function obtenirTextesFrancais() {
	    return {
	      "emptyTable": "Aucune donnÃ©e disponible dans le tableau",
	      "loadingRecords": "<span class=\"utd-sr-only\" role=\"alert\">Chargement en cours...</span>",
	      "processing": "<span class=\"utd-sr-only\" role=\"alert\">Traitement en cours...</span>",
	      "select": {
	        "rows": {
	          "_": "%d lignes sÃ©lectionnÃ©es",
	          "0": "Aucune ligne sÃ©lÃ©ctionnÃ©e",
	          "1": "1 ligne sÃ©lectionnÃ©e"
	        },
	        "cells": {
	          "1": "1 cellule sÃ©lectionnÃ©e",
	          "_": "%d cellules sÃ©lectionnÃ©es"
	        },
	        "columns": {
	          "1": "1 colonne sÃ©lectionnÃ©e",
	          "_": "%d colonnes sÃ©lectionnÃ©es"
	        },
	        "aria": {
	          "headerCheckbox": "SÃ©lectionner toutes les lignes",
	          "rowCheckbox": "SÃ©lectionner la ligne"
	        }
	      },
	      "autoFill": {
	        "cancel": "Annuler",
	        "fill": "Remplir toutes les cellules avec <i>%d<\/i>",
	        "fillHorizontal": "Remplir les cellules horizontalement",
	        "fillVertical": "Remplir les cellules verticalement"
	      },
	      "searchBuilder": {
	        "conditions": {
	          "date": {
	            "after": "AprÃ¨s le",
	            "before": "Avant le",
	            "between": "Entre",
	            "empty": "Vide",
	            "not": "DiffÃ©rent de",
	            "notBetween": "Pas entre",
	            "notEmpty": "Non vide",
	            "equals": "Ãgal Ã "
	          },
	          "number": {
	            "between": "Entre",
	            "empty": "Vide",
	            "gt": "SupÃ©rieur Ã ",
	            "gte": "SupÃ©rieur ou Ã©gal Ã ",
	            "lt": "InfÃ©rieur Ã ",
	            "lte": "InfÃ©rieur ou Ã©gal Ã ",
	            "not": "DiffÃ©rent de",
	            "notBetween": "Pas entre",
	            "notEmpty": "Non vide",
	            "equals": "Ãgal Ã "
	          },
	          "string": {
	            "contains": "Contient",
	            "empty": "Vide",
	            "endsWith": "Se termine par",
	            "not": "DiffÃ©rent de",
	            "notEmpty": "Non vide",
	            "startsWith": "Commence par",
	            "equals": "Ãgal Ã ",
	            "notContains": "Ne contient pas",
	            "notEndsWith": "Ne termine pas par",
	            "notStartsWith": "Ne commence pas par"
	          },
	          "array": {
	            "empty": "Vide",
	            "contains": "Contient",
	            "not": "DiffÃ©rent de",
	            "notEmpty": "Non vide",
	            "without": "Sans",
	            "equals": "Ãgal Ã "
	          }
	        },
	        "add": "Ajouter une condition",
	        "button": {
	          "0": "Recherche avancÃ©e",
	          "_": "Recherche avancÃ©e (%d)"
	        },
	        "clearAll": "Effacer tout",
	        "condition": "Condition",
	        "data": "DonnÃ©e",
	        "deleteTitle": "Supprimer la rÃ¨gle de filtrage",
	        "logicAnd": "Et",
	        "logicOr": "Ou",
	        "title": {
	          "0": "Recherche avancÃ©e",
	          "_": "Recherche avancÃ©e (%d)"
	        },
	        "value": "Valeur",
	        "leftTitle": "DÃ©sindenter le critÃ¨re",
	        "rightTitle": "Indenter le critÃ¨re"
	      },
	      "searchPanes": {
	        "clearMessage": "Effacer tout",
	        "count": "{total}",
	        "title": "Filtres actifs - %d",
	        "collapse": {
	          "0": "Volet de recherche",
	          "_": "Volet de recherche (%d)"
	        },
	        "countFiltered": "{shown} ({total})",
	        "emptyPanes": "Pas de volet de recherche",
	        "loadMessage": "Chargement du volet de recherche...",
	        "collapseMessage": "RÃ©duire tout",
	        "showMessage": "Montrer tout"
	      },
	      "buttons": {
	        "collection": "Collection",
	        "colvis": "VisibilitÃ© colonnes",
	        "colvisRestore": "RÃ©tablir visibilitÃ©",
	        "copy": "Copier",
	        "copySuccess": {
	          "1": "1 ligne copiÃ©e dans le presse-papier",
	          "_": "%d lignes copiÃ©es dans le presse-papier"
	        },
	        "copyTitle": "Copier dans le presse-papier",
	        "csv": "CSV",
	        "excel": "Excel",
	        "pageLength": {
	          "-1": "Afficher toutes les lignes",
	          "_": "Afficher %d lignes",
	          "1": "Afficher 1 ligne"
	        },
	        "pdf": "PDF",
	        "print": "Imprimer",
	        "copyKeys": "Appuyez sur ctrl ou u2318 + C pour copier les donnÃ©es du tableau dans votre presse-papier.",
	        "createState": "CrÃ©er un Ã©tat",
	        "removeAllStates": "Supprimer tous les Ã©tats",
	        "removeState": "Supprimer",
	        "renameState": "Renommer",
	        "savedStates": "Ãtats sauvegardÃ©s",
	        "stateRestore": "Ãtat %d",
	        "updateState": "Mettre Ã  jour"
	      },
	      "decimal": ",",
	      "datetime": {
	        "previous": "PrÃ©cÃ©dent",
	        "next": "Suivant",
	        "hours": "Heures",
	        "minutes": "Minutes",
	        "seconds": "Secondes",
	        "unknown": "-",
	        "amPm": ["am", "pm"],
	        "months": {
	          "0": "Janvier",
	          "2": "Mars",
	          "3": "Avril",
	          "4": "Mai",
	          "5": "Juin",
	          "6": "Juillet",
	          "8": "Septembre",
	          "9": "Octobre",
	          "10": "Novembre",
	          "1": "FÃ©vrier",
	          "11": "DÃ©cembre",
	          "7": "AoÃ»t"
	        },
	        "weekdays": ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"]
	      },
	      "editor": {
	        "close": "Fermer",
	        "create": {
	          "title": "CrÃ©er une nouvelle entrÃ©e",
	          "button": "Nouveau",
	          "submit": "CrÃ©er"
	        },
	        "edit": {
	          "button": "Editer",
	          "title": "Editer EntrÃ©e",
	          "submit": "Mettre Ã  jour"
	        },
	        "remove": {
	          "button": "Supprimer",
	          "title": "Supprimer",
	          "submit": "Supprimer",
	          "confirm": {
	            "_": "Ãtes-vous sÃ»r de vouloir supprimer %d lignes ?",
	            "1": "Ãtes-vous sÃ»r de vouloir supprimer 1 ligne ?"
	          }
	        },
	        "multi": {
	          "title": "Valeurs multiples",
	          "info": "Les Ã©lÃ©ments sÃ©lectionnÃ©s contiennent diffÃ©rentes valeurs pour cette entrÃ©e. Pour modifier et dÃ©finir tous les Ã©lÃ©ments de cette entrÃ©e Ã  la mÃªme valeur, cliquez ou tapez ici, sinon ils conserveront leurs valeurs individuelles.",
	          "restore": "Annuler les modifications",
	          "noMulti": "Ce champ peut Ãªtre modifiÃ© individuellement, mais ne fait pas partie d'un groupe. "
	        },
	        "error": {
	          "system": "Une erreur systÃ¨me s'est produite (<a target=\"\\\" rel=\"nofollow\" href=\"\\\">Plus d'information<\/a>)."
	        }
	      },
	      "stateRestore": {
	        "removeSubmit": "Supprimer",
	        "creationModal": {
	          "button": "CrÃ©er",
	          "order": "Tri",
	          "paging": "Pagination",
	          "scroller": "Position du dÃ©filement",
	          "search": "Recherche",
	          "select": "SÃ©lection",
	          "columns": {
	            "search": "Recherche par colonne",
	            "visible": "VisibilitÃ© des colonnes"
	          },
	          "name": "Nom :",
	          "searchBuilder": "Recherche avancÃ©e",
	          "title": "CrÃ©er un nouvel Ã©tat",
	          "toggleLabel": "Inclus :"
	        },
	        "renameButton": "Renommer",
	        "duplicateError": "Il existe dÃ©jÃ  un Ã©tat avec ce nom.",
	        "emptyError": "Le nom ne peut pas Ãªtre vide.",
	        "emptyStates": "Aucun Ã©tat sauvegardÃ©",
	        "removeConfirm": "Voulez vous vraiment supprimer %s ?",
	        "removeError": "Ãchec de la suppression de l'Ã©tat.",
	        "removeJoiner": "et",
	        "removeTitle": "Supprimer l'Ã©tat",
	        "renameLabel": "Nouveau nom pour %s :",
	        "renameTitle": "Renommer l'Ã©tat"
	      },
	      "info": "<span class=\"info-total\">_TOTAL_ \xE9l\xE9ments&nbsp;</span><span class=\"info-position\">\xE9l\xE9ments _START_ \xE0 _END_</span>",
	      "infoEmpty": "<span class=\"info-empty\">0 \xE9l\xE9ment</span>",
	      "infoFiltered": "<span class=\"info-filtered\">&nbsp;(filtr\xE9 de _MAX_ \xE9l\xE9ments au total)</span>",
	      "lengthMenu": "Nombre par page&nbsp;_MENU_",
	      "paginate": {
	        "first": "PremiÃ¨re",
	        "last": "DerniÃ¨re",
	        "previous": '<span class="utd-icone-svg chevron-pagination" aria-hidden="true"></span><span class="utd-sr-only">Page prÃ©cÃ©dente</span>',
	        "next": '<span class="utd-icone-svg chevron-pagination" aria-hidden="true"></span><span class="utd-sr-only">Page suivante</span>'
	      },
	      "zeroRecords": "Aucun Ã©lÃ©ment Ã  afficher.",
	      "aria": {
	        "orderable": ": activer pour trier la colonne par ordre croissant",
	        "orderableRemove": ": activer pour retirer le tri de la colonne",
	        "orderableReverse": ": activer pour trier la colonne par ordre dÃ©croissant",
	        "paginate": {
	          "first": "PremiÃ¨re page",
	          "last": "DerniÃ¨re page",
	          "previous": 'Page prÃ©cÃ©dente',
	          "next": 'Page suivante'
	        }
	      },
	      "infoThousands": " ",
	      "search": "Rechercher",
	      "searchPlaceholder": "Rechercher...",
	      "thousands": " "
	    };
	  }

	  /**
	   * (PrivÃ©e)
	   * Obtient les textes anglais pour datatables. On ne retourne que les textes diffÃ©rents de ceux par dÃ©faut.
	   * @returns Object contenant les textes anglais.
	   */
	  function obtenirTextesAnglais() {
	    return {
	      "processing": "Processing...",
	      "search": "Search",
	      "searchPlaceholder": "Search...",
	      "info": "<span class=\"info-total\">_TOTAL_ entries</span><span class=\"info-position\">entries _START_ to _END_</span>",
	      "infoEmpty": "<span class=\"info-empty\">0 entrie</span>",
	      "infoFiltered": "<span class=\"info-filtered\"> (filtered from _MAX_ items)</span>",
	      "lengthMenu": "Entries per page&nbsp;_MENU_",
	      "paginate": {
	        "previous": '<span class="utd-icone-svg chevron-bleu-piv" aria-hidden="true"></span>',
	        "next": '<span class="utd-icone-svg chevron-bleu-piv" aria-hidden="true"></span>'
	      },
	      "aria": {
	        "paginate": {
	          "first": "First page",
	          "last": "Last page",
	          "previous": 'Previous page',
	          "next": 'Next page'
	        }
	      },
	      "select": {
	        "rows": {
	          "_": "%d rows selected",
	          "0": "No row selected",
	          "1": "1 row selected"
	        }
	      }
	    };
	  }
	  return elementsPublics;
	}();

	var es_symbol = {};

	var es_symbol_constructor = {};

	var objectGetOwnPropertyNamesExternal = {};

	var hasRequiredObjectGetOwnPropertyNamesExternal;

	function requireObjectGetOwnPropertyNamesExternal () {
		if (hasRequiredObjectGetOwnPropertyNamesExternal) return objectGetOwnPropertyNamesExternal;
		hasRequiredObjectGetOwnPropertyNamesExternal = 1;
		/* eslint-disable es/no-object-getownpropertynames -- safe */
		var classof = requireClassofRaw();
		var toIndexedObject = requireToIndexedObject();
		var $getOwnPropertyNames = requireObjectGetOwnPropertyNames().f;
		var arraySlice = requireArraySlice();

		var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
		  ? Object.getOwnPropertyNames(window) : [];

		var getWindowNames = function (it) {
		  try {
		    return $getOwnPropertyNames(it);
		  } catch (error) {
		    return arraySlice(windowNames);
		  }
		};

		// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
		objectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames(it) {
		  return windowNames && classof(it) === 'Window'
		    ? getWindowNames(it)
		    : $getOwnPropertyNames(toIndexedObject(it));
		};
		return objectGetOwnPropertyNamesExternal;
	}

	var wellKnownSymbolWrapped = {};

	var hasRequiredWellKnownSymbolWrapped;

	function requireWellKnownSymbolWrapped () {
		if (hasRequiredWellKnownSymbolWrapped) return wellKnownSymbolWrapped;
		hasRequiredWellKnownSymbolWrapped = 1;
		var wellKnownSymbol = requireWellKnownSymbol();

		wellKnownSymbolWrapped.f = wellKnownSymbol;
		return wellKnownSymbolWrapped;
	}

	var wellKnownSymbolDefine;
	var hasRequiredWellKnownSymbolDefine;

	function requireWellKnownSymbolDefine () {
		if (hasRequiredWellKnownSymbolDefine) return wellKnownSymbolDefine;
		hasRequiredWellKnownSymbolDefine = 1;
		var path = requirePath();
		var hasOwn = requireHasOwnProperty();
		var wrappedWellKnownSymbolModule = requireWellKnownSymbolWrapped();
		var defineProperty = requireObjectDefineProperty().f;

		wellKnownSymbolDefine = function (NAME) {
		  var Symbol = path.Symbol || (path.Symbol = {});
		  if (!hasOwn(Symbol, NAME)) defineProperty(Symbol, NAME, {
		    value: wrappedWellKnownSymbolModule.f(NAME)
		  });
		};
		return wellKnownSymbolDefine;
	}

	var symbolDefineToPrimitive;
	var hasRequiredSymbolDefineToPrimitive;

	function requireSymbolDefineToPrimitive () {
		if (hasRequiredSymbolDefineToPrimitive) return symbolDefineToPrimitive;
		hasRequiredSymbolDefineToPrimitive = 1;
		var call = requireFunctionCall();
		var getBuiltIn = requireGetBuiltIn();
		var wellKnownSymbol = requireWellKnownSymbol();
		var defineBuiltIn = requireDefineBuiltIn();

		symbolDefineToPrimitive = function () {
		  var Symbol = getBuiltIn('Symbol');
		  var SymbolPrototype = Symbol && Symbol.prototype;
		  var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
		  var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

		  if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
		    // `Symbol.prototype[@@toPrimitive]` method
		    // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
		    // eslint-disable-next-line no-unused-vars -- required for .length
		    defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function (hint) {
		      return call(valueOf, this);
		    }, { arity: 1 });
		  }
		};
		return symbolDefineToPrimitive;
	}

	var hasRequiredEs_symbol_constructor;

	function requireEs_symbol_constructor () {
		if (hasRequiredEs_symbol_constructor) return es_symbol_constructor;
		hasRequiredEs_symbol_constructor = 1;
		var $ = require_export();
		var globalThis = requireGlobalThis();
		var call = requireFunctionCall();
		var uncurryThis = requireFunctionUncurryThis();
		var IS_PURE = requireIsPure();
		var DESCRIPTORS = requireDescriptors();
		var NATIVE_SYMBOL = requireSymbolConstructorDetection();
		var fails = requireFails();
		var hasOwn = requireHasOwnProperty();
		var isPrototypeOf = requireObjectIsPrototypeOf();
		var anObject = requireAnObject();
		var toIndexedObject = requireToIndexedObject();
		var toPropertyKey = requireToPropertyKey();
		var $toString = requireToString();
		var createPropertyDescriptor = requireCreatePropertyDescriptor();
		var nativeObjectCreate = requireObjectCreate();
		var objectKeys = requireObjectKeys();
		var getOwnPropertyNamesModule = requireObjectGetOwnPropertyNames();
		var getOwnPropertyNamesExternal = requireObjectGetOwnPropertyNamesExternal();
		var getOwnPropertySymbolsModule = requireObjectGetOwnPropertySymbols();
		var getOwnPropertyDescriptorModule = requireObjectGetOwnPropertyDescriptor();
		var definePropertyModule = requireObjectDefineProperty();
		var definePropertiesModule = requireObjectDefineProperties();
		var propertyIsEnumerableModule = requireObjectPropertyIsEnumerable();
		var defineBuiltIn = requireDefineBuiltIn();
		var defineBuiltInAccessor = requireDefineBuiltInAccessor();
		var shared = requireShared();
		var sharedKey = requireSharedKey();
		var hiddenKeys = requireHiddenKeys();
		var uid = requireUid();
		var wellKnownSymbol = requireWellKnownSymbol();
		var wrappedWellKnownSymbolModule = requireWellKnownSymbolWrapped();
		var defineWellKnownSymbol = requireWellKnownSymbolDefine();
		var defineSymbolToPrimitive = requireSymbolDefineToPrimitive();
		var setToStringTag = requireSetToStringTag();
		var InternalStateModule = requireInternalState();
		var $forEach = requireArrayIteration().forEach;

		var HIDDEN = sharedKey('hidden');
		var SYMBOL = 'Symbol';
		var PROTOTYPE = 'prototype';

		var setInternalState = InternalStateModule.set;
		var getInternalState = InternalStateModule.getterFor(SYMBOL);

		var ObjectPrototype = Object[PROTOTYPE];
		var $Symbol = globalThis.Symbol;
		var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
		var RangeError = globalThis.RangeError;
		var TypeError = globalThis.TypeError;
		var QObject = globalThis.QObject;
		var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
		var nativeDefineProperty = definePropertyModule.f;
		var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
		var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
		var push = uncurryThis([].push);

		var AllSymbols = shared('symbols');
		var ObjectPrototypeSymbols = shared('op-symbols');
		var WellKnownSymbolsStore = shared('wks');

		// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
		var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

		// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
		var fallbackDefineProperty = function (O, P, Attributes) {
		  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
		  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
		  nativeDefineProperty(O, P, Attributes);
		  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
		    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
		  }
		};

		var setSymbolDescriptor = DESCRIPTORS && fails(function () {
		  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
		    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
		  })).a !== 7;
		}) ? fallbackDefineProperty : nativeDefineProperty;

		var wrap = function (tag, description) {
		  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
		  setInternalState(symbol, {
		    type: SYMBOL,
		    tag: tag,
		    description: description
		  });
		  if (!DESCRIPTORS) symbol.description = description;
		  return symbol;
		};

		var $defineProperty = function defineProperty(O, P, Attributes) {
		  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
		  anObject(O);
		  var key = toPropertyKey(P);
		  anObject(Attributes);
		  if (hasOwn(AllSymbols, key)) {
		    if (!Attributes.enumerable) {
		      if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, nativeObjectCreate(null)));
		      O[HIDDEN][key] = true;
		    } else {
		      if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
		      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
		    } return setSymbolDescriptor(O, key, Attributes);
		  } return nativeDefineProperty(O, key, Attributes);
		};

		var $defineProperties = function defineProperties(O, Properties) {
		  anObject(O);
		  var properties = toIndexedObject(Properties);
		  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
		  $forEach(keys, function (key) {
		    if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
		  });
		  return O;
		};

		var $create = function create(O, Properties) {
		  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
		};

		var $propertyIsEnumerable = function propertyIsEnumerable(V) {
		  var P = toPropertyKey(V);
		  var enumerable = call(nativePropertyIsEnumerable, this, P);
		  if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
		  return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P]
		    ? enumerable : true;
		};

		var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
		  var it = toIndexedObject(O);
		  var key = toPropertyKey(P);
		  if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
		  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
		  if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
		    descriptor.enumerable = true;
		  }
		  return descriptor;
		};

		var $getOwnPropertyNames = function getOwnPropertyNames(O) {
		  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
		  var result = [];
		  $forEach(names, function (key) {
		    if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
		  });
		  return result;
		};

		var $getOwnPropertySymbols = function (O) {
		  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
		  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
		  var result = [];
		  $forEach(names, function (key) {
		    if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
		      push(result, AllSymbols[key]);
		    }
		  });
		  return result;
		};

		// `Symbol` constructor
		// https://tc39.es/ecma262/#sec-symbol-constructor
		if (!NATIVE_SYMBOL) {
		  $Symbol = function Symbol() {
		    if (isPrototypeOf(SymbolPrototype, this)) throw new TypeError('Symbol is not a constructor');
		    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
		    var tag = uid(description);
		    var setter = function (value) {
		      var $this = this === undefined ? globalThis : this;
		      if ($this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
		      if (hasOwn($this, HIDDEN) && hasOwn($this[HIDDEN], tag)) $this[HIDDEN][tag] = false;
		      var descriptor = createPropertyDescriptor(1, value);
		      try {
		        setSymbolDescriptor($this, tag, descriptor);
		      } catch (error) {
		        if (!(error instanceof RangeError)) throw error;
		        fallbackDefineProperty($this, tag, descriptor);
		      }
		    };
		    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
		    return wrap(tag, description);
		  };

		  SymbolPrototype = $Symbol[PROTOTYPE];

		  defineBuiltIn(SymbolPrototype, 'toString', function toString() {
		    return getInternalState(this).tag;
		  });

		  defineBuiltIn($Symbol, 'withoutSetter', function (description) {
		    return wrap(uid(description), description);
		  });

		  propertyIsEnumerableModule.f = $propertyIsEnumerable;
		  definePropertyModule.f = $defineProperty;
		  definePropertiesModule.f = $defineProperties;
		  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
		  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
		  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

		  wrappedWellKnownSymbolModule.f = function (name) {
		    return wrap(wellKnownSymbol(name), name);
		  };

		  if (DESCRIPTORS) {
		    // https://tc39.es/ecma262/#sec-symbol.prototype.description
		    defineBuiltInAccessor(SymbolPrototype, 'description', {
		      configurable: true,
		      get: function description() {
		        return getInternalState(this).description;
		      }
		    });
		    if (!IS_PURE) {
		      defineBuiltIn(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
		    }
		  }
		}

		$({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
		  Symbol: $Symbol
		});

		$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
		  defineWellKnownSymbol(name);
		});

		$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
		  useSetter: function () { USE_SETTER = true; },
		  useSimple: function () { USE_SETTER = false; }
		});

		$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
		  // `Object.create` method
		  // https://tc39.es/ecma262/#sec-object.create
		  create: $create,
		  // `Object.defineProperty` method
		  // https://tc39.es/ecma262/#sec-object.defineproperty
		  defineProperty: $defineProperty,
		  // `Object.defineProperties` method
		  // https://tc39.es/ecma262/#sec-object.defineproperties
		  defineProperties: $defineProperties,
		  // `Object.getOwnPropertyDescriptor` method
		  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
		  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
		});

		$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
		  // `Object.getOwnPropertyNames` method
		  // https://tc39.es/ecma262/#sec-object.getownpropertynames
		  getOwnPropertyNames: $getOwnPropertyNames
		});

		// `Symbol.prototype[@@toPrimitive]` method
		// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
		defineSymbolToPrimitive();

		// `Symbol.prototype[@@toStringTag]` property
		// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
		setToStringTag($Symbol, SYMBOL);

		hiddenKeys[HIDDEN] = true;
		return es_symbol_constructor;
	}

	var es_symbol_for = {};

	var symbolRegistryDetection;
	var hasRequiredSymbolRegistryDetection;

	function requireSymbolRegistryDetection () {
		if (hasRequiredSymbolRegistryDetection) return symbolRegistryDetection;
		hasRequiredSymbolRegistryDetection = 1;
		var NATIVE_SYMBOL = requireSymbolConstructorDetection();

		/* eslint-disable es/no-symbol -- safe */
		symbolRegistryDetection = NATIVE_SYMBOL && !!Symbol['for'] && !!Symbol.keyFor;
		return symbolRegistryDetection;
	}

	var hasRequiredEs_symbol_for;

	function requireEs_symbol_for () {
		if (hasRequiredEs_symbol_for) return es_symbol_for;
		hasRequiredEs_symbol_for = 1;
		var $ = require_export();
		var getBuiltIn = requireGetBuiltIn();
		var hasOwn = requireHasOwnProperty();
		var toString = requireToString();
		var shared = requireShared();
		var NATIVE_SYMBOL_REGISTRY = requireSymbolRegistryDetection();

		var StringToSymbolRegistry = shared('string-to-symbol-registry');
		var SymbolToStringRegistry = shared('symbol-to-string-registry');

		// `Symbol.for` method
		// https://tc39.es/ecma262/#sec-symbol.for
		$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
		  'for': function (key) {
		    var string = toString(key);
		    if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
		    var symbol = getBuiltIn('Symbol')(string);
		    StringToSymbolRegistry[string] = symbol;
		    SymbolToStringRegistry[symbol] = string;
		    return symbol;
		  }
		});
		return es_symbol_for;
	}

	var es_symbol_keyFor = {};

	var hasRequiredEs_symbol_keyFor;

	function requireEs_symbol_keyFor () {
		if (hasRequiredEs_symbol_keyFor) return es_symbol_keyFor;
		hasRequiredEs_symbol_keyFor = 1;
		var $ = require_export();
		var hasOwn = requireHasOwnProperty();
		var isSymbol = requireIsSymbol();
		var tryToString = requireTryToString();
		var shared = requireShared();
		var NATIVE_SYMBOL_REGISTRY = requireSymbolRegistryDetection();

		var SymbolToStringRegistry = shared('symbol-to-string-registry');

		// `Symbol.keyFor` method
		// https://tc39.es/ecma262/#sec-symbol.keyfor
		$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
		  keyFor: function keyFor(sym) {
		    if (!isSymbol(sym)) throw new TypeError(tryToString(sym) + ' is not a symbol');
		    if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
		  }
		});
		return es_symbol_keyFor;
	}

	var es_json_stringify = {};

	var getJsonReplacerFunction;
	var hasRequiredGetJsonReplacerFunction;

	function requireGetJsonReplacerFunction () {
		if (hasRequiredGetJsonReplacerFunction) return getJsonReplacerFunction;
		hasRequiredGetJsonReplacerFunction = 1;
		var uncurryThis = requireFunctionUncurryThis();
		var isArray = requireIsArray();
		var isCallable = requireIsCallable();
		var classof = requireClassofRaw();
		var toString = requireToString();

		var push = uncurryThis([].push);

		getJsonReplacerFunction = function (replacer) {
		  if (isCallable(replacer)) return replacer;
		  if (!isArray(replacer)) return;
		  var rawLength = replacer.length;
		  var keys = [];
		  for (var i = 0; i < rawLength; i++) {
		    var element = replacer[i];
		    if (typeof element == 'string') push(keys, element);
		    else if (typeof element == 'number' || classof(element) === 'Number' || classof(element) === 'String') push(keys, toString(element));
		  }
		  var keysLength = keys.length;
		  var root = true;
		  return function (key, value) {
		    if (root) {
		      root = false;
		      return value;
		    }
		    if (isArray(this)) return value;
		    for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;
		  };
		};
		return getJsonReplacerFunction;
	}

	var hasRequiredEs_json_stringify;

	function requireEs_json_stringify () {
		if (hasRequiredEs_json_stringify) return es_json_stringify;
		hasRequiredEs_json_stringify = 1;
		var $ = require_export();
		var getBuiltIn = requireGetBuiltIn();
		var apply = requireFunctionApply();
		var call = requireFunctionCall();
		var uncurryThis = requireFunctionUncurryThis();
		var fails = requireFails();
		var isCallable = requireIsCallable();
		var isSymbol = requireIsSymbol();
		var arraySlice = requireArraySlice();
		var getReplacerFunction = requireGetJsonReplacerFunction();
		var NATIVE_SYMBOL = requireSymbolConstructorDetection();

		var $String = String;
		var $stringify = getBuiltIn('JSON', 'stringify');
		var exec = uncurryThis(/./.exec);
		var charAt = uncurryThis(''.charAt);
		var charCodeAt = uncurryThis(''.charCodeAt);
		var replace = uncurryThis(''.replace);
		var numberToString = uncurryThis(1.1.toString);

		var tester = /[\uD800-\uDFFF]/g;
		var low = /^[\uD800-\uDBFF]$/;
		var hi = /^[\uDC00-\uDFFF]$/;

		var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function () {
		  var symbol = getBuiltIn('Symbol')('stringify detection');
		  // MS Edge converts symbol values to JSON as {}
		  return $stringify([symbol]) !== '[null]'
		    // WebKit converts symbol values to JSON as null
		    || $stringify({ a: symbol }) !== '{}'
		    // V8 throws on boxed symbols
		    || $stringify(Object(symbol)) !== '{}';
		});

		// https://github.com/tc39/proposal-well-formed-stringify
		var ILL_FORMED_UNICODE = fails(function () {
		  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
		    || $stringify('\uDEAD') !== '"\\udead"';
		});

		var stringifyWithSymbolsFix = function (it, replacer) {
		  var args = arraySlice(arguments);
		  var $replacer = getReplacerFunction(replacer);
		  if (!isCallable($replacer) && (it === undefined || isSymbol(it))) return; // IE8 returns string on undefined
		  args[1] = function (key, value) {
		    // some old implementations (like WebKit) could pass numbers as keys
		    if (isCallable($replacer)) value = call($replacer, this, $String(key), value);
		    if (!isSymbol(value)) return value;
		  };
		  return apply($stringify, null, args);
		};

		var fixIllFormed = function (match, offset, string) {
		  var prev = charAt(string, offset - 1);
		  var next = charAt(string, offset + 1);
		  if ((exec(low, match) && !exec(hi, next)) || (exec(hi, match) && !exec(low, prev))) {
		    return '\\u' + numberToString(charCodeAt(match, 0), 16);
		  } return match;
		};

		if ($stringify) {
		  // `JSON.stringify` method
		  // https://tc39.es/ecma262/#sec-json.stringify
		  $({ target: 'JSON', stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
		    // eslint-disable-next-line no-unused-vars -- required for `.length`
		    stringify: function stringify(it, replacer, space) {
		      var args = arraySlice(arguments);
		      var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
		      return ILL_FORMED_UNICODE && typeof result == 'string' ? replace(result, tester, fixIllFormed) : result;
		    }
		  });
		}
		return es_json_stringify;
	}

	var es_object_getOwnPropertySymbols = {};

	var hasRequiredEs_object_getOwnPropertySymbols;

	function requireEs_object_getOwnPropertySymbols () {
		if (hasRequiredEs_object_getOwnPropertySymbols) return es_object_getOwnPropertySymbols;
		hasRequiredEs_object_getOwnPropertySymbols = 1;
		var $ = require_export();
		var NATIVE_SYMBOL = requireSymbolConstructorDetection();
		var fails = requireFails();
		var getOwnPropertySymbolsModule = requireObjectGetOwnPropertySymbols();
		var toObject = requireToObject();

		// V8 ~ Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
		// https://bugs.chromium.org/p/v8/issues/detail?id=3443
		var FORCED = !NATIVE_SYMBOL || fails(function () { getOwnPropertySymbolsModule.f(1); });

		// `Object.getOwnPropertySymbols` method
		// https://tc39.es/ecma262/#sec-object.getownpropertysymbols
		$({ target: 'Object', stat: true, forced: FORCED }, {
		  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
		    var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
		    return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
		  }
		});
		return es_object_getOwnPropertySymbols;
	}

	var hasRequiredEs_symbol;

	function requireEs_symbol () {
		if (hasRequiredEs_symbol) return es_symbol;
		hasRequiredEs_symbol = 1;
		// TODO: Remove this module from `core-js@4` since it's split to modules listed below
		requireEs_symbol_constructor();
		requireEs_symbol_for();
		requireEs_symbol_keyFor();
		requireEs_json_stringify();
		requireEs_object_getOwnPropertySymbols();
		return es_symbol;
	}

	requireEs_symbol();

	var es_array_filter = {};

	var hasRequiredEs_array_filter;

	function requireEs_array_filter () {
		if (hasRequiredEs_array_filter) return es_array_filter;
		hasRequiredEs_array_filter = 1;
		var $ = require_export();
		var $filter = requireArrayIteration().filter;
		var arrayMethodHasSpeciesSupport = requireArrayMethodHasSpeciesSupport();

		var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');

		// `Array.prototype.filter` method
		// https://tc39.es/ecma262/#sec-array.prototype.filter
		// with adding support of @@species
		$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
		  filter: function filter(callbackfn /* , thisArg */) {
		    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
		  }
		});
		return es_array_filter;
	}

	requireEs_array_filter();

	var es_object_getOwnPropertyDescriptor = {};

	var hasRequiredEs_object_getOwnPropertyDescriptor;

	function requireEs_object_getOwnPropertyDescriptor () {
		if (hasRequiredEs_object_getOwnPropertyDescriptor) return es_object_getOwnPropertyDescriptor;
		hasRequiredEs_object_getOwnPropertyDescriptor = 1;
		var $ = require_export();
		var fails = requireFails();
		var toIndexedObject = requireToIndexedObject();
		var nativeGetOwnPropertyDescriptor = requireObjectGetOwnPropertyDescriptor().f;
		var DESCRIPTORS = requireDescriptors();

		var FORCED = !DESCRIPTORS || fails(function () { nativeGetOwnPropertyDescriptor(1); });

		// `Object.getOwnPropertyDescriptor` method
		// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
		$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
		  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
		    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
		  }
		});
		return es_object_getOwnPropertyDescriptor;
	}

	requireEs_object_getOwnPropertyDescriptor();

	var es_object_getOwnPropertyDescriptors = {};

	var hasRequiredEs_object_getOwnPropertyDescriptors;

	function requireEs_object_getOwnPropertyDescriptors () {
		if (hasRequiredEs_object_getOwnPropertyDescriptors) return es_object_getOwnPropertyDescriptors;
		hasRequiredEs_object_getOwnPropertyDescriptors = 1;
		var $ = require_export();
		var DESCRIPTORS = requireDescriptors();
		var ownKeys = requireOwnKeys();
		var toIndexedObject = requireToIndexedObject();
		var getOwnPropertyDescriptorModule = requireObjectGetOwnPropertyDescriptor();
		var createProperty = requireCreateProperty();

		// `Object.getOwnPropertyDescriptors` method
		// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
		$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
		  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
		    var O = toIndexedObject(object);
		    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
		    var keys = ownKeys(O);
		    var result = {};
		    var index = 0;
		    var key, descriptor;
		    while (keys.length > index) {
		      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
		      if (descriptor !== undefined) createProperty(result, key, descriptor);
		    }
		    return result;
		  }
		});
		return es_object_getOwnPropertyDescriptors;
	}

	requireEs_object_getOwnPropertyDescriptors();

	var es_object_keys = {};

	var hasRequiredEs_object_keys;

	function requireEs_object_keys () {
		if (hasRequiredEs_object_keys) return es_object_keys;
		hasRequiredEs_object_keys = 1;
		var $ = require_export();
		var toObject = requireToObject();
		var nativeKeys = requireObjectKeys();
		var fails = requireFails();

		var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

		// `Object.keys` method
		// https://tc39.es/ecma262/#sec-object.keys
		$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
		  keys: function keys(it) {
		    return nativeKeys(toObject(it));
		  }
		});
		return es_object_keys;
	}

	requireEs_object_keys();

	var es_reflect_construct = {};

	var functionBind;
	var hasRequiredFunctionBind;

	function requireFunctionBind () {
		if (hasRequiredFunctionBind) return functionBind;
		hasRequiredFunctionBind = 1;
		var uncurryThis = requireFunctionUncurryThis();
		var aCallable = requireACallable();
		var isObject = requireIsObject();
		var hasOwn = requireHasOwnProperty();
		var arraySlice = requireArraySlice();
		var NATIVE_BIND = requireFunctionBindNative();

		var $Function = Function;
		var concat = uncurryThis([].concat);
		var join = uncurryThis([].join);
		var factories = {};

		var construct = function (C, argsLength, args) {
		  if (!hasOwn(factories, argsLength)) {
		    var list = [];
		    var i = 0;
		    for (; i < argsLength; i++) list[i] = 'a[' + i + ']';
		    factories[argsLength] = $Function('C,a', 'return new C(' + join(list, ',') + ')');
		  } return factories[argsLength](C, args);
		};

		// `Function.prototype.bind` method implementation
		// https://tc39.es/ecma262/#sec-function.prototype.bind
		// eslint-disable-next-line es/no-function-prototype-bind -- detection
		functionBind = NATIVE_BIND ? $Function.bind : function bind(that /* , ...args */) {
		  var F = aCallable(this);
		  var Prototype = F.prototype;
		  var partArgs = arraySlice(arguments, 1);
		  var boundFunction = function bound(/* args... */) {
		    var args = concat(partArgs, arraySlice(arguments));
		    return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
		  };
		  if (isObject(Prototype)) boundFunction.prototype = Prototype;
		  return boundFunction;
		};
		return functionBind;
	}

	var hasRequiredEs_reflect_construct;

	function requireEs_reflect_construct () {
		if (hasRequiredEs_reflect_construct) return es_reflect_construct;
		hasRequiredEs_reflect_construct = 1;
		var $ = require_export();
		var getBuiltIn = requireGetBuiltIn();
		var apply = requireFunctionApply();
		var bind = requireFunctionBind();
		var aConstructor = requireAConstructor();
		var anObject = requireAnObject();
		var isObject = requireIsObject();
		var create = requireObjectCreate();
		var fails = requireFails();

		var nativeConstruct = getBuiltIn('Reflect', 'construct');
		var ObjectPrototype = Object.prototype;
		var push = [].push;

		// `Reflect.construct` method
		// https://tc39.es/ecma262/#sec-reflect.construct
		// MS Edge supports only 2 arguments and argumentsList argument is optional
		// FF Nightly sets third argument as `new.target`, but does not create `this` from it
		var NEW_TARGET_BUG = fails(function () {
		  function F() { /* empty */ }
		  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
		});

		var ARGS_BUG = !fails(function () {
		  nativeConstruct(function () { /* empty */ });
		});

		var FORCED = NEW_TARGET_BUG || ARGS_BUG;

		$({ target: 'Reflect', stat: true, forced: FORCED, sham: FORCED }, {
		  construct: function construct(Target, args /* , newTarget */) {
		    aConstructor(Target);
		    anObject(args);
		    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
		    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
		    if (Target === newTarget) {
		      // w/o altered newTarget, optimization for 0-4 arguments
		      switch (args.length) {
		        case 0: return new Target();
		        case 1: return new Target(args[0]);
		        case 2: return new Target(args[0], args[1]);
		        case 3: return new Target(args[0], args[1], args[2]);
		        case 4: return new Target(args[0], args[1], args[2], args[3]);
		      }
		      // w/o altered newTarget, lot of arguments case
		      var $args = [null];
		      apply(push, $args, args);
		      return new (apply(bind, Target, $args))();
		    }
		    // with altered newTarget, not support built-in constructors
		    var proto = newTarget.prototype;
		    var instance = create(isObject(proto) ? proto : ObjectPrototype);
		    var result = apply(Target, instance, args);
		    return isObject(result) ? result : instance;
		  }
		});
		return es_reflect_construct;
	}

	requireEs_reflect_construct();

	function _typeof(o) {
	  "@babel/helpers - typeof";

	  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
	    return typeof o;
	  } : function (o) {
	    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
	  }, _typeof(o);
	}

	function toPrimitive(t, r) {
	  if ("object" != _typeof(t) || !t) return t;
	  var e = t[Symbol.toPrimitive];
	  if (void 0 !== e) {
	    var i = e.call(t, r);
	    if ("object" != _typeof(i)) return i;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return ("string" === r ? String : Number)(t);
	}

	function toPropertyKey(t) {
	  var i = toPrimitive(t, "string");
	  return "symbol" == _typeof(i) ? i : i + "";
	}

	function _defineProperties(e, r) {
	  for (var t = 0; t < r.length; t++) {
	    var o = r[t];
	    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
	  }
	}
	function _createClass(e, r, t) {
	  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
	    writable: false
	  }), e;
	}

	function _classCallCheck(a, n) {
	  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
	}

	function _assertThisInitialized(e) {
	  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  return e;
	}

	function _possibleConstructorReturn(t, e) {
	  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
	  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
	  return _assertThisInitialized(t);
	}

	function _getPrototypeOf(t) {
	  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
	    return t.__proto__ || Object.getPrototypeOf(t);
	  }, _getPrototypeOf(t);
	}

	function _setPrototypeOf(t, e) {
	  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
	    return t.__proto__ = e, t;
	  }, _setPrototypeOf(t, e);
	}

	function _inherits(t, e) {
	  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
	  t.prototype = Object.create(e && e.prototype, {
	    constructor: {
	      value: t,
	      writable: true,
	      configurable: true
	    }
	  }), Object.defineProperty(t, "prototype", {
	    writable: false
	  }), e && _setPrototypeOf(t, e);
	}

	function _defineProperty(e, r, t) {
	  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
	    value: t,
	    enumerable: true,
	    configurable: true,
	    writable: true
	  }) : e[r] = t, e;
	}

	// generated during release, do not modify

	const PUBLIC_VERSION = '5';

	if (typeof window !== 'undefined') {
		// @ts-expect-error
		((window.__svelte ??= {}).v ??= new Set()).add(PUBLIC_VERSION);
	}

	let legacy_mode_flag = false;
	let tracing_mode_flag = false;

	function enable_legacy_mode_flag() {
		legacy_mode_flag = true;
	}

	enable_legacy_mode_flag();

	const EACH_ITEM_REACTIVE = 1;
	const EACH_INDEX_REACTIVE = 1 << 1;
	/** See EachBlock interface metadata.is_controlled for an explanation what this is */
	const EACH_IS_CONTROLLED = 1 << 2;
	const EACH_IS_ANIMATED = 1 << 3;
	const EACH_ITEM_IMMUTABLE = 1 << 4;

	const PROPS_IS_IMMUTABLE = 1;
	const PROPS_IS_RUNES = 1 << 1;
	const PROPS_IS_UPDATED = 1 << 2;
	const PROPS_IS_BINDABLE = 1 << 3;
	const PROPS_IS_LAZY_INITIAL = 1 << 4;

	const TRANSITION_IN = 1;
	const TRANSITION_OUT = 1 << 1;
	const TRANSITION_GLOBAL = 1 << 2;

	const TEMPLATE_FRAGMENT = 1;
	const TEMPLATE_USE_IMPORT_NODE = 1 << 1;

	const HYDRATION_START = '[';
	/** used to indicate that an `{:else}...` block was rendered */
	const HYDRATION_START_ELSE = '[!';
	const HYDRATION_END = ']';
	const HYDRATION_ERROR = {};

	const UNINITIALIZED = Symbol();

	// Dev-time component properties
	const FILENAME = Symbol('filename');

	const NAMESPACE_HTML = 'http://www.w3.org/1999/xhtml';
	const NAMESPACE_SVG = 'http://www.w3.org/2000/svg';

	const ATTACHMENT_KEY = '@attach';

	var DEV = false;

	// Store the references to globals in case someone tries to monkey patch these, causing the below
	// to de-opt (this occurs often when using popular extensions).
	var is_array = Array.isArray;
	var index_of = Array.prototype.indexOf;
	var array_from = Array.from;
	var object_keys = Object.keys;
	var define_property = Object.defineProperty;
	var get_descriptor = Object.getOwnPropertyDescriptor;
	var get_descriptors = Object.getOwnPropertyDescriptors;
	var object_prototype = Object.prototype;
	var array_prototype = Array.prototype;
	var get_prototype_of = Object.getPrototypeOf;
	var is_extensible = Object.isExtensible;

	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */
	function is_function(thing) {
		return typeof thing === 'function';
	}

	const noop = () => {};

	/** @param {Function} fn */
	function run(fn) {
		return fn();
	}

	/** @param {Array<() => void>} arr */
	function run_all(arr) {
		for (var i = 0; i < arr.length; i++) {
			arr[i]();
		}
	}

	/**
	 * TODO replace with Promise.withResolvers once supported widely enough
	 * @template T
	 */
	function deferred() {
		/** @type {(value: T) => void} */
		var resolve;

		/** @type {(reason: any) => void} */
		var reject;

		/** @type {Promise<T>} */
		var promise = new Promise((res, rej) => {
			resolve = res;
			reject = rej;
		});

		// @ts-expect-error
		return { promise, resolve, reject };
	}

	const DERIVED = 1 << 1;
	const EFFECT = 1 << 2;
	const RENDER_EFFECT = 1 << 3;
	const BLOCK_EFFECT = 1 << 4;
	const BRANCH_EFFECT = 1 << 5;
	const ROOT_EFFECT = 1 << 6;
	const BOUNDARY_EFFECT = 1 << 7;
	const UNOWNED = 1 << 8;
	const DISCONNECTED = 1 << 9;
	const CLEAN = 1 << 10;
	const DIRTY = 1 << 11;
	const MAYBE_DIRTY = 1 << 12;
	const INERT = 1 << 13;
	const DESTROYED = 1 << 14;
	const EFFECT_RAN = 1 << 15;
	/** 'Transparent' effects do not create a transition boundary */
	const EFFECT_TRANSPARENT = 1 << 16;
	const INSPECT_EFFECT = 1 << 17;
	const HEAD_EFFECT = 1 << 18;
	const EFFECT_PRESERVED = 1 << 19;
	const USER_EFFECT = 1 << 20;

	// Flags used for async
	const REACTION_IS_UPDATING = 1 << 21;
	const ASYNC = 1 << 22;

	const ERROR_VALUE = 1 << 23;

	const STATE_SYMBOL = Symbol('$state');
	const LEGACY_PROPS = Symbol('legacy props');
	const LOADING_ATTR_SYMBOL = Symbol('');
	const PROXY_PATH_SYMBOL = Symbol('proxy path');

	/** allow users to ignore aborted signal errors if `reason.name === 'StaleReactionError` */
	const STALE_REACTION = new (class StaleReactionError extends Error {
		name = 'StaleReactionError';
		message = 'The reaction that called `getAbortSignal()` was re-run or destroyed';
	})();

	const ELEMENT_NODE = 1;
	const TEXT_NODE = 3;
	const COMMENT_NODE = 8;
	const DOCUMENT_FRAGMENT_NODE = 11;

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * `%name%(...)` can only be used during component initialisation
	 * @param {string} name
	 * @returns {never}
	 */
	function lifecycle_outside_component(name) {
		{
			throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
		}
	}

	/**
	 * The `this` prop on `<svelte:element>` must be a string, if defined
	 * @returns {never}
	 */
	function svelte_element_invalid_this_value() {
		{
			throw new Error(`https://svelte.dev/e/svelte_element_invalid_this_value`);
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * Cannot create a `$derived(...)` with an `await` expression outside of an effect tree
	 * @returns {never}
	 */
	function async_derived_orphan() {
		{
			throw new Error(`https://svelte.dev/e/async_derived_orphan`);
		}
	}

	/**
	 * Calling `%method%` on a component instance (of %component%) is no longer valid in Svelte 5
	 * @param {string} method
	 * @param {string} component
	 * @returns {never}
	 */
	function component_api_changed(method, component) {
		{
			throw new Error(`https://svelte.dev/e/component_api_changed`);
		}
	}

	/**
	 * Attempted to instantiate %component% with `new %name%`, which is no longer valid in Svelte 5. If this component is not under your control, set the `compatibility.componentApi` compiler option to `4` to keep it working.
	 * @param {string} component
	 * @param {string} name
	 * @returns {never}
	 */
	function component_api_invalid_new(component, name) {
		{
			throw new Error(`https://svelte.dev/e/component_api_invalid_new`);
		}
	}

	/**
	 * `%rune%` cannot be used inside an effect cleanup function
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_in_teardown(rune) {
		{
			throw new Error(`https://svelte.dev/e/effect_in_teardown`);
		}
	}

	/**
	 * Effect cannot be created inside a `$derived` value that was not itself created inside an effect
	 * @returns {never}
	 */
	function effect_in_unowned_derived() {
		{
			throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
		}
	}

	/**
	 * `%rune%` can only be used inside an effect (e.g. during component initialisation)
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_orphan(rune) {
		{
			throw new Error(`https://svelte.dev/e/effect_orphan`);
		}
	}

	/**
	 * Maximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state
	 * @returns {never}
	 */
	function effect_update_depth_exceeded() {
		{
			throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
		}
	}

	/**
	 * Failed to hydrate the application
	 * @returns {never}
	 */
	function hydration_failed() {
		{
			throw new Error(`https://svelte.dev/e/hydration_failed`);
		}
	}

	/**
	 * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value
	 * @param {string} key
	 * @returns {never}
	 */
	function props_invalid_value(key) {
		{
			throw new Error(`https://svelte.dev/e/props_invalid_value`);
		}
	}

	/**
	 * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.
	 * @returns {never}
	 */
	function state_descriptors_fixed() {
		{
			throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
		}
	}

	/**
	 * Cannot set prototype of `$state` object
	 * @returns {never}
	 */
	function state_prototype_fixed() {
		{
			throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
		}
	}

	/**
	 * Updating state inside `$derived(...)`, `$inspect(...)` or a template expression is forbidden. If the value should not be reactive, declare it without `$state`
	 * @returns {never}
	 */
	function state_unsafe_mutation() {
		{
			throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
		}
	}

	/**
	 * A `<svelte:boundary>` `reset` function cannot be called while an error is still being handled
	 * @returns {never}
	 */
	function svelte_boundary_reset_onerror() {
		{
			throw new Error(`https://svelte.dev/e/svelte_boundary_reset_onerror`);
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * Your `console.%method%` contained `$state` proxies. Consider using `$inspect(...)` or `$state.snapshot(...)` instead
	 * @param {string} method
	 */
	function console_log_state(method) {
		{
			console.warn(`https://svelte.dev/e/console_log_state`);
		}
	}

	/**
	 * Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near %location%
	 * @param {string | undefined | null} [location]
	 */
	function hydration_mismatch(location) {
		{
			console.warn(`https://svelte.dev/e/hydration_mismatch`);
		}
	}

	/**
	 * %parent% passed property `%prop%` to %child% with `bind:`, but its parent component %owner% did not declare `%prop%` as a binding. Consider creating a binding between %owner% and %parent% (e.g. `bind:%prop%={...}` instead of `%prop%={...}`)
	 * @param {string} parent
	 * @param {string} prop
	 * @param {string} child
	 * @param {string} owner
	 */
	function ownership_invalid_binding(parent, prop, child, owner) {
		{
			console.warn(`https://svelte.dev/e/ownership_invalid_binding`);
		}
	}

	/**
	 * Mutating unbound props (`%name%`, at %location%) is strongly discouraged. Consider using `bind:%prop%={...}` in %parent% (or using a callback) instead
	 * @param {string} name
	 * @param {string} location
	 * @param {string} prop
	 * @param {string} parent
	 */
	function ownership_invalid_mutation(name, location, prop, parent) {
		{
			console.warn(`https://svelte.dev/e/ownership_invalid_mutation`);
		}
	}

	/**
	 * The `value` property of a `<select multiple>` element should be an array, but it received a non-array value. The selection will be kept as is.
	 */
	function select_multiple_invalid_value() {
		{
			console.warn(`https://svelte.dev/e/select_multiple_invalid_value`);
		}
	}

	/**
	 * Reactive `$state(...)` proxies and the values they proxy have different identities. Because of this, comparisons with `%operator%` will produce unexpected results
	 * @param {string} operator
	 */
	function state_proxy_equality_mismatch(operator) {
		{
			console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
		}
	}

	/**
	 * A `<svelte:boundary>` `reset` function only resets the boundary the first time it is called
	 */
	function svelte_boundary_reset_noop() {
		{
			console.warn(`https://svelte.dev/e/svelte_boundary_reset_noop`);
		}
	}

	/** @import { TemplateNode } from '#client' */


	/**
	 * Use this variable to guard everything related to hydration code so it can be treeshaken out
	 * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.
	 */
	let hydrating = false;

	/** @param {boolean} value */
	function set_hydrating(value) {
		hydrating = value;
	}

	/**
	 * The node that is currently being hydrated. This starts out as the first node inside the opening
	 * <!--[--> comment, and updates each time a component calls `$.child(...)` or `$.sibling(...)`.
	 * When entering a block (e.g. `{#if ...}`), `hydrate_node` is the block opening comment; by the
	 * time we leave the block it is the closing comment, which serves as the block's anchor.
	 * @type {TemplateNode}
	 */
	let hydrate_node;

	/** @param {TemplateNode} node */
	function set_hydrate_node(node) {
		if (node === null) {
			hydration_mismatch();
			throw HYDRATION_ERROR;
		}

		return (hydrate_node = node);
	}

	function hydrate_next() {
		return set_hydrate_node(/** @type {TemplateNode} */ (get_next_sibling(hydrate_node)));
	}

	/** @param {TemplateNode} node */
	function reset(node) {
		if (!hydrating) return;

		// If the node has remaining siblings, something has gone wrong
		if (get_next_sibling(hydrate_node) !== null) {
			hydration_mismatch();
			throw HYDRATION_ERROR;
		}

		hydrate_node = node;
	}

	function next(count = 1) {
		if (hydrating) {
			var i = count;
			var node = hydrate_node;

			while (i--) {
				node = /** @type {TemplateNode} */ (get_next_sibling(node));
			}

			hydrate_node = node;
		}
	}

	/**
	 * Skips or removes (depending on {@link remove}) all nodes starting at `hydrate_node` up until the next hydration end comment
	 * @param {boolean} remove
	 */
	function skip_nodes(remove = true) {
		var depth = 0;
		var node = hydrate_node;

		while (true) {
			if (node.nodeType === COMMENT_NODE) {
				var data = /** @type {Comment} */ (node).data;

				if (data === HYDRATION_END) {
					if (depth === 0) return node;
					depth -= 1;
				} else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {
					depth += 1;
				}
			}

			var next = /** @type {TemplateNode} */ (get_next_sibling(node));
			if (remove) node.remove();
			node = next;
		}
	}

	/**
	 *
	 * @param {TemplateNode} node
	 */
	function read_hydration_instruction(node) {
		if (!node || node.nodeType !== COMMENT_NODE) {
			hydration_mismatch();
			throw HYDRATION_ERROR;
		}

		return /** @type {Comment} */ (node).data;
	}

	/** @import { Equals } from '#client' */

	/** @type {Equals} */
	function equals$1(value) {
		return value === this.v;
	}

	/**
	 * @param {unknown} a
	 * @param {unknown} b
	 * @returns {boolean}
	 */
	function safe_not_equal(a, b) {
		return a != a
			? b == b
			: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';
	}

	/** @type {Equals} */
	function safe_equals(value) {
		return !safe_not_equal(value, this.v);
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * `<svelte:element this="%tag%">` is a void element â it cannot have content
	 * @param {string} tag
	 */
	function dynamic_void_element_content(tag) {
		{
			console.warn(`https://svelte.dev/e/dynamic_void_element_content`);
		}
	}

	/** @import { Snapshot } from './types' */

	/**
	 * In dev, we keep track of which properties could not be cloned. In prod
	 * we don't bother, but we keep a dummy array around so that the
	 * signature stays the same
	 * @type {string[]}
	 */
	const empty = [];

	/**
	 * @template T
	 * @param {T} value
	 * @param {boolean} [skip_warning]
	 * @param {boolean} [no_tojson]
	 * @returns {Snapshot<T>}
	 */
	function snapshot(value, skip_warning = false, no_tojson = false) {

		return clone(value, new Map(), '', empty, null, no_tojson);
	}

	/**
	 * @template T
	 * @param {T} value
	 * @param {Map<T, Snapshot<T>>} cloned
	 * @param {string} path
	 * @param {string[]} paths
	 * @param {null | T} [original] The original value, if `value` was produced from a `toJSON` call
	 * @param {boolean} [no_tojson]
	 * @returns {Snapshot<T>}
	 */
	function clone(value, cloned, path, paths, original = null, no_tojson = false) {
		if (typeof value === 'object' && value !== null) {
			var unwrapped = cloned.get(value);
			if (unwrapped !== undefined) return unwrapped;

			if (value instanceof Map) return /** @type {Snapshot<T>} */ (new Map(value));
			if (value instanceof Set) return /** @type {Snapshot<T>} */ (new Set(value));

			if (is_array(value)) {
				var copy = /** @type {Snapshot<any>} */ (Array(value.length));
				cloned.set(value, copy);

				if (original !== null) {
					cloned.set(original, copy);
				}

				for (var i = 0; i < value.length; i += 1) {
					var element = value[i];
					if (i in value) {
						copy[i] = clone(element, cloned, path, paths, null, no_tojson);
					}
				}

				return copy;
			}

			if (get_prototype_of(value) === object_prototype) {
				/** @type {Snapshot<any>} */
				copy = {};
				cloned.set(value, copy);

				if (original !== null) {
					cloned.set(original, copy);
				}

				for (var key in value) {
					copy[key] = clone(
						// @ts-expect-error
						value[key],
						cloned,
						path,
						paths,
						null,
						no_tojson
					);
				}

				return copy;
			}

			if (value instanceof Date) {
				return /** @type {Snapshot<T>} */ (structuredClone(value));
			}

			if (typeof (/** @type {T & { toJSON?: any } } */ (value).toJSON) === 'function' && !no_tojson) {
				return clone(
					/** @type {T & { toJSON(): any } } */ (value).toJSON(),
					cloned,
					path,
					paths,
					// Associate the instance with the toJSON clone
					value
				);
			}
		}

		if (value instanceof EventTarget) {
			// can't be cloned
			return /** @type {Snapshot<T>} */ (value);
		}

		try {
			return /** @type {Snapshot<T>} */ (structuredClone(value));
		} catch (e) {

			return /** @type {Snapshot<T>} */ (value);
		}
	}

	/** @import { Derived, Reaction, Value } from '#client' */

	/**
	 * @param {Value} source
	 * @param {string} label
	 */
	function tag(source, label) {
		source.label = label;
		tag_proxy(source.v, label);

		return source;
	}

	/**
	 * @param {unknown} value
	 * @param {string} label
	 */
	function tag_proxy(value, label) {
		// @ts-expect-error
		value?.[PROXY_PATH_SYMBOL]?.(label);
		return value;
	}

	/** @import { ComponentContext, DevStackEntry, Effect } from '#client' */

	/** @type {ComponentContext | null} */
	let component_context = null;

	/** @param {ComponentContext | null} context */
	function set_component_context(context) {
		component_context = context;
	}

	/** @type {DevStackEntry | null} */
	let dev_stack = null;

	/**
	 * Execute a callback with a new dev stack entry
	 * @param {() => any} callback - Function to execute
	 * @param {DevStackEntry['type']} type - Type of block/component
	 * @param {any} component - Component function
	 * @param {number} line - Line number
	 * @param {number} column - Column number
	 * @param {Record<string, any>} [additional] - Any additional properties to add to the dev stack entry
	 * @returns {any}
	 */
	function add_svelte_meta(callback, type, component, line, column, additional) {
		const parent = dev_stack;

		dev_stack = {
			type,
			file: component[FILENAME],
			line,
			column,
			parent,
			...additional
		};

		try {
			return callback();
		} finally {
			dev_stack = parent;
		}
	}

	/**
	 * @param {Record<string, unknown>} props
	 * @param {any} runes
	 * @param {Function} [fn]
	 * @returns {void}
	 */
	function push(props, runes = false, fn) {
		component_context = {
			p: component_context,
			c: null,
			e: null,
			s: props,
			x: null,
			l: legacy_mode_flag && !runes ? { s: null, u: null, $: [] } : null
		};
	}

	/**
	 * @template {Record<string, any>} T
	 * @param {T} [component]
	 * @returns {T}
	 */
	function pop(component) {
		var context = /** @type {ComponentContext} */ (component_context);
		var effects = context.e;

		if (effects !== null) {
			context.e = null;

			for (var fn of effects) {
				create_user_effect(fn);
			}
		}

		if (component !== undefined) {
			context.x = component;
		}

		component_context = context.p;

		return component ?? /** @type {T} */ ({});
	}

	/** @returns {boolean} */
	function is_runes() {
		return !legacy_mode_flag || (component_context !== null && component_context.l === null);
	}

	/** @type {Array<() => void>} */
	let micro_tasks = [];

	function run_micro_tasks() {
		var tasks = micro_tasks;
		micro_tasks = [];
		run_all(tasks);
	}

	/**
	 * @param {() => void} fn
	 */
	function queue_micro_task(fn) {
		if (micro_tasks.length === 0 && !is_flushing_sync) {
			var tasks = micro_tasks;
			queueMicrotask(() => {
				// If this is false, a flushSync happened in the meantime. Do _not_ run new scheduled microtasks in that case
				// as the ordering of microtasks would be broken at that point - consider this case:
				// - queue_micro_task schedules microtask A to flush task X
				// - synchronously after, flushSync runs, processing task X
				// - synchronously after, some other microtask B is scheduled, but not through queue_micro_task but for example a Promise.resolve() in user code
				// - synchronously after, queue_micro_task schedules microtask C to flush task Y
				// - one tick later, microtask A now resolves, flushing task Y before microtask B, which is incorrect
				// This if check prevents that race condition (that realistically will only happen in tests)
				if (tasks === micro_tasks) run_micro_tasks();
			});
		}

		micro_tasks.push(fn);
	}

	/**
	 * Synchronously run any queued tasks.
	 */
	function flush_tasks() {
		while (micro_tasks.length > 0) {
			run_micro_tasks();
		}
	}

	/** @import { Derived, Effect } from '#client' */
	/** @import { Boundary } from './dom/blocks/boundary.js' */

	const adjustments = new WeakMap();

	/**
	 * @param {unknown} error
	 */
	function handle_error(error) {
		var effect = active_effect;

		// for unowned deriveds, don't throw until we read the value
		if (effect === null) {
			/** @type {Derived} */ (active_reaction).f |= ERROR_VALUE;
			return error;
		}

		if ((effect.f & EFFECT_RAN) === 0) {
			// if the error occurred while creating this subtree, we let it
			// bubble up until it hits a boundary that can handle it
			if ((effect.f & BOUNDARY_EFFECT) === 0) {
				if (!effect.parent && error instanceof Error) {
					apply_adjustments(error);
				}

				throw error;
			}

			/** @type {Boundary} */ (effect.b).error(error);
		} else {
			// otherwise we bubble up the effect tree ourselves
			invoke_error_boundary(error, effect);
		}
	}

	/**
	 * @param {unknown} error
	 * @param {Effect | null} effect
	 */
	function invoke_error_boundary(error, effect) {
		while (effect !== null) {
			if ((effect.f & BOUNDARY_EFFECT) !== 0) {
				try {
					/** @type {Boundary} */ (effect.b).error(error);
					return;
				} catch (e) {
					error = e;
				}
			}

			effect = effect.parent;
		}

		if (error instanceof Error) {
			apply_adjustments(error);
		}

		throw error;
	}

	/**
	 * @param {Error} error
	 */
	function apply_adjustments(error) {
		const adjusted = adjustments.get(error);

		if (adjusted) {
			define_property(error, 'message', {
				value: adjusted.message
			});

			define_property(error, 'stack', {
				value: adjusted.stack
			});
		}
	}

	/** @import { Derived, Effect, Source, Value } from '#client' */

	/** @type {Set<Batch>} */
	const batches = new Set();

	/** @type {Batch | null} */
	let current_batch = null;

	/**
	 * This is needed to avoid overwriting inputs in non-async mode
	 * TODO 6.0 remove this, as non-async mode will go away
	 * @type {Batch | null}
	 */
	let previous_batch = null;

	/** @type {Set<() => void>} */
	let effect_pending_updates = new Set();

	/** @type {Effect[]} */
	let queued_root_effects = [];

	/** @type {Effect | null} */
	let last_scheduled_effect = null;

	let is_flushing = false;
	let is_flushing_sync = false;

	class Batch {
		/**
		 * The current values of any sources that are updated in this batch
		 * They keys of this map are identical to `this.#previous`
		 * @type {Map<Source, any>}
		 */
		current = new Map();

		/**
		 * The values of any sources that are updated in this batch _before_ those updates took place.
		 * They keys of this map are identical to `this.#current`
		 * @type {Map<Source, any>}
		 */
		#previous = new Map();

		/**
		 * When the batch is committed (and the DOM is updated), we need to remove old branches
		 * and append new ones by calling the functions added inside (if/each/key/etc) blocks
		 * @type {Set<() => void>}
		 */
		#callbacks = new Set();

		/**
		 * The number of async effects that are currently in flight
		 */
		#pending = 0;

		/**
		 * A deferred that resolves when the batch is committed, used with `settled()`
		 * TODO replace with Promise.withResolvers once supported widely enough
		 * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
		 */
		#deferred = null;

		/**
		 * Async effects inside a newly-created `<svelte:boundary>`
		 * â these do not prevent the batch from committing
		 * @type {Effect[]}
		 */
		#boundary_async_effects = [];

		/**
		 * Template effects and `$effect.pre` effects, which run when
		 * a batch is committed
		 * @type {Effect[]}
		 */
		#render_effects = [];

		/**
		 * The same as `#render_effects`, but for `$effect` (which runs after)
		 * @type {Effect[]}
		 */
		#effects = [];

		/**
		 * Block effects, which may need to re-run on subsequent flushes
		 * in order to update internal sources (e.g. each block items)
		 * @type {Effect[]}
		 */
		#block_effects = [];

		/**
		 * Deferred effects (which run after async work has completed) that are DIRTY
		 * @type {Effect[]}
		 */
		#dirty_effects = [];

		/**
		 * Deferred effects that are MAYBE_DIRTY
		 * @type {Effect[]}
		 */
		#maybe_dirty_effects = [];

		/**
		 * A set of branches that still exist, but will be destroyed when this batch
		 * is committed â we skip over these during `process`
		 * @type {Set<Effect>}
		 */
		skipped_effects = new Set();

		/**
		 *
		 * @param {Effect[]} root_effects
		 */
		process(root_effects) {
			queued_root_effects = [];

			previous_batch = null;

			var revert = Batch.apply(this);

			for (const root of root_effects) {
				this.#traverse_effect_tree(root);
			}

			// if we didn't start any new async work, and no async work
			// is outstanding from a previous flush, commit
			if (this.#pending === 0) {
				this.#commit();

				var render_effects = this.#render_effects;
				var effects = this.#effects;

				this.#render_effects = [];
				this.#effects = [];
				this.#block_effects = [];

				// If sources are written to, then work needs to happen in a separate batch, else prior sources would be mixed with
				// newly updated sources, which could lead to infinite loops when effects run over and over again.
				previous_batch = this;
				current_batch = null;

				flush_queued_effects(render_effects);
				flush_queued_effects(effects);

				this.#deferred?.resolve();
			} else {
				this.#defer_effects(this.#render_effects);
				this.#defer_effects(this.#effects);
				this.#defer_effects(this.#block_effects);
			}

			revert();

			for (const effect of this.#boundary_async_effects) {
				update_effect(effect);
			}

			this.#boundary_async_effects = [];
		}

		/**
		 * Traverse the effect tree, executing effects or stashing
		 * them for later execution as appropriate
		 * @param {Effect} root
		 */
		#traverse_effect_tree(root) {
			root.f ^= CLEAN;

			var effect = root.first;

			while (effect !== null) {
				var flags = effect.f;
				var is_branch = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
				var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;

				var skip = is_skippable_branch || (flags & INERT) !== 0 || this.skipped_effects.has(effect);

				if (!skip && effect.fn !== null) {
					if (is_branch) {
						effect.f ^= CLEAN;
					} else if ((flags & EFFECT) !== 0) {
						this.#effects.push(effect);
					} else if ((flags & CLEAN) === 0) {
						if ((flags & ASYNC) !== 0 && effect.b?.is_pending()) {
							this.#boundary_async_effects.push(effect);
						} else if (is_dirty(effect)) {
							if ((effect.f & BLOCK_EFFECT) !== 0) this.#block_effects.push(effect);
							update_effect(effect);
						}
					}

					var child = effect.first;

					if (child !== null) {
						effect = child;
						continue;
					}
				}

				var parent = effect.parent;
				effect = effect.next;

				while (effect === null && parent !== null) {
					effect = parent.next;
					parent = parent.parent;
				}
			}
		}

		/**
		 * @param {Effect[]} effects
		 */
		#defer_effects(effects) {
			for (const e of effects) {
				const target = (e.f & DIRTY) !== 0 ? this.#dirty_effects : this.#maybe_dirty_effects;
				target.push(e);

				// mark as clean so they get scheduled if they depend on pending async state
				set_signal_status(e, CLEAN);
			}

			effects.length = 0;
		}

		/**
		 * Associate a change to a given source with the current
		 * batch, noting its previous and current values
		 * @param {Source} source
		 * @param {any} value
		 */
		capture(source, value) {
			if (!this.#previous.has(source)) {
				this.#previous.set(source, value);
			}

			this.current.set(source, source.v);
		}

		activate() {
			current_batch = this;
		}

		deactivate() {
			current_batch = null;
			previous_batch = null;

			for (const update of effect_pending_updates) {
				effect_pending_updates.delete(update);
				update();

				if (current_batch !== null) {
					// only do one at a time
					break;
				}
			}
		}

		flush() {
			if (queued_root_effects.length > 0) {
				this.activate();
				flush_effects();

				if (current_batch !== null && current_batch !== this) {
					// this can happen if a new batch was created during `flush_effects()`
					return;
				}
			} else if (this.#pending === 0) {
				this.#commit();
			}

			this.deactivate();
		}

		/**
		 * Append and remove branches to/from the DOM
		 */
		#commit() {
			for (const fn of this.#callbacks) {
				fn();
			}

			this.#callbacks.clear();

			// If there are other pending batches, they now need to be 'rebased' â
			// in other words, we re-run block/async effects with the newly
			// committed state, unless the batch in question has a more
			// recent value for a given source
			if (batches.size > 1) {
				this.#previous.clear();

				let is_earlier = true;

				for (const batch of batches) {
					if (batch === this) {
						is_earlier = false;
						continue;
					}

					for (const [source, value] of this.current) {
						if (batch.current.has(source)) {
							if (is_earlier) {
								// bring the value up to date
								batch.current.set(source, value);
							} else {
								// later batch has more recent value,
								// no need to re-run these effects
								continue;
							}
						}

						mark_effects(source);
					}

					if (queued_root_effects.length > 0) {
						current_batch = batch;
						const revert = Batch.apply(batch);

						for (const root of queued_root_effects) {
							batch.#traverse_effect_tree(root);
						}

						queued_root_effects = [];
						revert();
					}
				}

				current_batch = null;
			}

			batches.delete(this);
		}

		increment() {
			this.#pending += 1;
		}

		decrement() {
			this.#pending -= 1;

			if (this.#pending === 0) {
				for (const e of this.#dirty_effects) {
					set_signal_status(e, DIRTY);
					schedule_effect(e);
				}

				for (const e of this.#maybe_dirty_effects) {
					set_signal_status(e, MAYBE_DIRTY);
					schedule_effect(e);
				}

				this.flush();
			} else {
				this.deactivate();
			}
		}

		/** @param {() => void} fn */
		add_callback(fn) {
			this.#callbacks.add(fn);
		}

		settled() {
			return (this.#deferred ??= deferred()).promise;
		}

		static ensure() {
			if (current_batch === null) {
				const batch = (current_batch = new Batch());
				batches.add(current_batch);

				if (!is_flushing_sync) {
					Batch.enqueue(() => {
						if (current_batch !== batch) {
							// a flushSync happened in the meantime
							return;
						}

						batch.flush();
					});
				}
			}

			return current_batch;
		}

		/** @param {() => void} task */
		static enqueue(task) {
			queue_micro_task(task);
		}

		/**
		 * @param {Batch} current_batch
		 */
		static apply(current_batch) {
			{
				return noop;
			}
		}
	}

	/**
	 * Synchronously flush any pending updates.
	 * Returns void if no callback is provided, otherwise returns the result of calling the callback.
	 * @template [T=void]
	 * @param {(() => T) | undefined} [fn]
	 * @returns {T}
	 */
	function flushSync(fn) {

		var was_flushing_sync = is_flushing_sync;
		is_flushing_sync = true;

		try {
			var result;

			if (fn) ;

			while (true) {
				flush_tasks();

				if (queued_root_effects.length === 0) {
					current_batch?.flush();

					// we need to check again, in case we just updated an `$effect.pending()`
					if (queued_root_effects.length === 0) {
						// this would be reset in `flush_effects()` but since we are early returning here,
						// we need to reset it here as well in case the first time there's 0 queued root effects
						last_scheduled_effect = null;

						return /** @type {T} */ (result);
					}
				}

				flush_effects();
			}
		} finally {
			is_flushing_sync = was_flushing_sync;
		}
	}

	function flush_effects() {
		var was_updating_effect = is_updating_effect;
		is_flushing = true;

		try {
			var flush_count = 0;
			set_is_updating_effect(true);

			while (queued_root_effects.length > 0) {
				var batch = Batch.ensure();

				if (flush_count++ > 1000) {
					var updates, entry; if (DEV) ;

					infinite_loop_guard();
				}

				batch.process(queued_root_effects);
				old_values.clear();
			}
		} finally {
			is_flushing = false;
			set_is_updating_effect(was_updating_effect);

			last_scheduled_effect = null;
		}
	}

	function infinite_loop_guard() {
		try {
			effect_update_depth_exceeded();
		} catch (error) {

			// Best effort: invoke the boundary nearest the most recent
			// effect and hope that it's relevant to the infinite loop
			invoke_error_boundary(error, last_scheduled_effect);
		}
	}

	/** @type {Effect[] | null} */
	let eager_block_effects = null;

	/**
	 * @param {Array<Effect>} effects
	 * @returns {void}
	 */
	function flush_queued_effects(effects) {
		var length = effects.length;
		if (length === 0) return;

		var i = 0;

		while (i < length) {
			var effect = effects[i++];

			if ((effect.f & (DESTROYED | INERT)) === 0 && is_dirty(effect)) {
				eager_block_effects = [];

				update_effect(effect);

				// Effects with no dependencies or teardown do not get added to the effect tree.
				// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we
				// don't know if we need to keep them until they are executed. Doing the check
				// here (rather than in `update_effect`) allows us to skip the work for
				// immediate effects.
				if (effect.deps === null && effect.first === null && effect.nodes_start === null) {
					// if there's no teardown or abort controller we completely unlink
					// the effect from the graph
					if (effect.teardown === null && effect.ac === null) {
						// remove this effect from the graph
						unlink_effect(effect);
					} else {
						// keep the effect in the graph, but free up some memory
						effect.fn = null;
					}
				}

				// If update_effect() has a flushSync() in it, we may have flushed another flush_queued_effects(),
				// which already handled this logic and did set eager_block_effects to null.
				if (eager_block_effects?.length > 0) {
					// TODO this feels incorrect! it gets the tests passing
					old_values.clear();

					for (const e of eager_block_effects) {
						update_effect(e);
					}

					eager_block_effects = [];
				}
			}
		}

		eager_block_effects = null;
	}

	/**
	 * This is similar to `mark_reactions`, but it only marks async/block effects
	 * so that these can re-run after another batch has been committed
	 * @param {Value} value
	 */
	function mark_effects(value) {
		if (value.reactions !== null) {
			for (const reaction of value.reactions) {
				const flags = reaction.f;

				if ((flags & DERIVED) !== 0) {
					mark_effects(/** @type {Derived} */ (reaction));
				} else if ((flags & (ASYNC | BLOCK_EFFECT)) !== 0) {
					set_signal_status(reaction, DIRTY);
					schedule_effect(/** @type {Effect} */ (reaction));
				}
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function schedule_effect(signal) {
		var effect = (last_scheduled_effect = signal);

		while (effect.parent !== null) {
			effect = effect.parent;
			var flags = effect.f;

			// if the effect is being scheduled because a parent (each/await/etc) block
			// updated an internal source, bail out or we'll cause a second flush
			if (is_flushing && effect === active_effect && (flags & BLOCK_EFFECT) !== 0) {
				return;
			}

			if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
				if ((flags & CLEAN) === 0) return;
				effect.f ^= CLEAN;
			}
		}

		queued_root_effects.push(effect);
	}

	/**
	 * Returns a `subscribe` function that integrates external event-based systems with Svelte's reactivity.
	 * It's particularly useful for integrating with web APIs like `MediaQuery`, `IntersectionObserver`, or `WebSocket`.
	 *
	 * If `subscribe` is called inside an effect (including indirectly, for example inside a getter),
	 * the `start` callback will be called with an `update` function. Whenever `update` is called, the effect re-runs.
	 *
	 * If `start` returns a cleanup function, it will be called when the effect is destroyed.
	 *
	 * If `subscribe` is called in multiple effects, `start` will only be called once as long as the effects
	 * are active, and the returned teardown function will only be called when all effects are destroyed.
	 *
	 * It's best understood with an example. Here's an implementation of [`MediaQuery`](https://svelte.dev/docs/svelte/svelte-reactivity#MediaQuery):
	 *
	 * ```js
	 * import { createSubscriber } from 'svelte/reactivity';
	 * import { on } from 'svelte/events';
	 *
	 * export class MediaQuery {
	 * 	#query;
	 * 	#subscribe;
	 *
	 * 	constructor(query) {
	 * 		this.#query = window.matchMedia(`(${query})`);
	 *
	 * 		this.#subscribe = createSubscriber((update) => {
	 * 			// when the `change` event occurs, re-run any effects that read `this.current`
	 * 			const off = on(this.#query, 'change', update);
	 *
	 * 			// stop listening when all the effects are destroyed
	 * 			return () => off();
	 * 		});
	 * 	}
	 *
	 * 	get current() {
	 * 		// This makes the getter reactive, if read in an effect
	 * 		this.#subscribe();
	 *
	 * 		// Return the current state of the query, whether or not we're in an effect
	 * 		return this.#query.matches;
	 * 	}
	 * }
	 * ```
	 * @param {(update: () => void) => (() => void) | void} start
	 * @since 5.7.0
	 */
	function createSubscriber(start) {
		let subscribers = 0;
		let version = source(0);
		/** @type {(() => void) | void} */
		let stop;

		return () => {
			if (effect_tracking()) {
				get(version);

				render_effect(() => {
					if (subscribers === 0) {
						stop = untrack(() => start(() => increment(version)));
					}

					subscribers += 1;

					return () => {
						queue_micro_task(() => {
							// Only count down after a microtask, else we would reach 0 before our own render effect reruns,
							// but reach 1 again when the tick callback of the prior teardown runs. That would mean we
							// re-subcribe unnecessarily and create a memory leak because the old subscription is never cleaned up.
							subscribers -= 1;

							if (subscribers === 0) {
								stop?.();
								stop = undefined;
								// Increment the version to ensure any dependent deriveds are marked dirty when the subscription is picked up again later.
								// If we didn't do this then the comparison of write versions would determine that the derived has a later version than
								// the subscriber, and it would not be re-run.
								increment(version);
							}
						});
					};
				});
			}
		};
	}

	/** @import { Effect, Source, TemplateNode, } from '#client' */

	/**
	 * @typedef {{
	 * 	 onerror?: (error: unknown, reset: () => void) => void;
	 *   failed?: (anchor: Node, error: () => unknown, reset: () => () => void) => void;
	 *   pending?: (anchor: Node) => void;
	 * }} BoundaryProps
	 */

	var flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED | BOUNDARY_EFFECT;

	/**
	 * @param {TemplateNode} node
	 * @param {BoundaryProps} props
	 * @param {((anchor: Node) => void)} children
	 * @returns {void}
	 */
	function boundary(node, props, children) {
		new Boundary(node, props, children);
	}

	class Boundary {
		/** @type {Boundary | null} */
		parent;

		#pending = false;

		/** @type {TemplateNode} */
		#anchor;

		/** @type {TemplateNode | null} */
		#hydrate_open = hydrating ? hydrate_node : null;

		/** @type {BoundaryProps} */
		#props;

		/** @type {((anchor: Node) => void)} */
		#children;

		/** @type {Effect} */
		#effect;

		/** @type {Effect | null} */
		#main_effect = null;

		/** @type {Effect | null} */
		#pending_effect = null;

		/** @type {Effect | null} */
		#failed_effect = null;

		/** @type {DocumentFragment | null} */
		#offscreen_fragment = null;

		#local_pending_count = 0;
		#pending_count = 0;

		#is_creating_fallback = false;

		/**
		 * A source containing the number of pending async deriveds/expressions.
		 * Only created if `$effect.pending()` is used inside the boundary,
		 * otherwise updating the source results in needless `Batch.ensure()`
		 * calls followed by no-op flushes
		 * @type {Source<number> | null}
		 */
		#effect_pending = null;

		#effect_pending_update = () => {
			if (this.#effect_pending) {
				internal_set(this.#effect_pending, this.#local_pending_count);
			}
		};

		#effect_pending_subscriber = createSubscriber(() => {
			this.#effect_pending = source(this.#local_pending_count);

			return () => {
				this.#effect_pending = null;
			};
		});

		/**
		 * @param {TemplateNode} node
		 * @param {BoundaryProps} props
		 * @param {((anchor: Node) => void)} children
		 */
		constructor(node, props, children) {
			this.#anchor = node;
			this.#props = props;
			this.#children = children;

			this.parent = /** @type {Effect} */ (active_effect).b;

			this.#pending = !!this.#props.pending;

			this.#effect = block(() => {
				/** @type {Effect} */ (active_effect).b = this;

				if (hydrating) {
					const comment = this.#hydrate_open;
					hydrate_next();

					const server_rendered_pending =
						/** @type {Comment} */ (comment).nodeType === COMMENT_NODE &&
						/** @type {Comment} */ (comment).data === HYDRATION_START_ELSE;

					if (server_rendered_pending) {
						this.#hydrate_pending_content();
					} else {
						this.#hydrate_resolved_content();
					}
				} else {
					try {
						this.#main_effect = branch(() => children(this.#anchor));
					} catch (error) {
						this.error(error);
					}

					if (this.#pending_count > 0) {
						this.#show_pending_snippet();
					} else {
						this.#pending = false;
					}
				}
			}, flags);

			if (hydrating) {
				this.#anchor = hydrate_node;
			}
		}

		#hydrate_resolved_content() {
			try {
				this.#main_effect = branch(() => this.#children(this.#anchor));
			} catch (error) {
				this.error(error);
			}

			// Since server rendered resolved content, we never show pending state
			// Even if client-side async operations are still running, the content is already displayed
			this.#pending = false;
		}

		#hydrate_pending_content() {
			const pending = this.#props.pending;
			if (!pending) {
				return;
			}
			this.#pending_effect = branch(() => pending(this.#anchor));

			Batch.enqueue(() => {
				this.#main_effect = this.#run(() => {
					Batch.ensure();
					return branch(() => this.#children(this.#anchor));
				});

				if (this.#pending_count > 0) {
					this.#show_pending_snippet();
				} else {
					pause_effect(/** @type {Effect} */ (this.#pending_effect), () => {
						this.#pending_effect = null;
					});

					this.#pending = false;
				}
			});
		}

		/**
		 * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
		 * @returns {boolean}
		 */
		is_pending() {
			return this.#pending || (!!this.parent && this.parent.is_pending());
		}

		has_pending_snippet() {
			return !!this.#props.pending;
		}

		/**
		 * @param {() => Effect | null} fn
		 */
		#run(fn) {
			var previous_effect = active_effect;
			var previous_reaction = active_reaction;
			var previous_ctx = component_context;

			set_active_effect(this.#effect);
			set_active_reaction(this.#effect);
			set_component_context(this.#effect.ctx);

			try {
				return fn();
			} catch (e) {
				handle_error(e);
				return null;
			} finally {
				set_active_effect(previous_effect);
				set_active_reaction(previous_reaction);
				set_component_context(previous_ctx);
			}
		}

		#show_pending_snippet() {
			const pending = /** @type {(anchor: Node) => void} */ (this.#props.pending);

			if (this.#main_effect !== null) {
				this.#offscreen_fragment = document.createDocumentFragment();
				move_effect(this.#main_effect, this.#offscreen_fragment);
			}

			if (this.#pending_effect === null) {
				this.#pending_effect = branch(() => pending(this.#anchor));
			}
		}

		/**
		 * Updates the pending count associated with the currently visible pending snippet,
		 * if any, such that we can replace the snippet with content once work is done
		 * @param {1 | -1} d
		 */
		#update_pending_count(d) {
			if (!this.has_pending_snippet()) {
				if (this.parent) {
					this.parent.#update_pending_count(d);
				}

				// if there's no parent, we're in a scope with no pending snippet
				return;
			}

			this.#pending_count += d;

			if (this.#pending_count === 0) {
				this.#pending = false;

				if (this.#pending_effect) {
					pause_effect(this.#pending_effect, () => {
						this.#pending_effect = null;
					});
				}

				if (this.#offscreen_fragment) {
					this.#anchor.before(this.#offscreen_fragment);
					this.#offscreen_fragment = null;
				}
			}
		}

		/**
		 * Update the source that powers `$effect.pending()` inside this boundary,
		 * and controls when the current `pending` snippet (if any) is removed.
		 * Do not call from inside the class
		 * @param {1 | -1} d
		 */
		update_pending_count(d) {
			this.#update_pending_count(d);

			this.#local_pending_count += d;
			effect_pending_updates.add(this.#effect_pending_update);
		}

		get_effect_pending() {
			this.#effect_pending_subscriber();
			return get(/** @type {Source<number>} */ (this.#effect_pending));
		}

		/** @param {unknown} error */
		error(error) {
			var onerror = this.#props.onerror;
			let failed = this.#props.failed;

			// If we have nothing to capture the error, or if we hit an error while
			// rendering the fallback, re-throw for another boundary to handle
			if (this.#is_creating_fallback || (!onerror && !failed)) {
				throw error;
			}

			if (this.#main_effect) {
				destroy_effect(this.#main_effect);
				this.#main_effect = null;
			}

			if (this.#pending_effect) {
				destroy_effect(this.#pending_effect);
				this.#pending_effect = null;
			}

			if (this.#failed_effect) {
				destroy_effect(this.#failed_effect);
				this.#failed_effect = null;
			}

			if (hydrating) {
				set_hydrate_node(/** @type {TemplateNode} */ (this.#hydrate_open));
				next();
				set_hydrate_node(skip_nodes());
			}

			var did_reset = false;
			var calling_on_error = false;

			const reset = () => {
				if (did_reset) {
					svelte_boundary_reset_noop();
					return;
				}

				did_reset = true;

				if (calling_on_error) {
					svelte_boundary_reset_onerror();
				}

				// If the failure happened while flushing effects, current_batch can be null
				Batch.ensure();

				this.#local_pending_count = 0;

				if (this.#failed_effect !== null) {
					pause_effect(this.#failed_effect, () => {
						this.#failed_effect = null;
					});
				}

				// we intentionally do not try to find the nearest pending boundary. If this boundary has one, we'll render it on reset
				// but it would be really weird to show the parent's boundary on a child reset.
				this.#pending = this.has_pending_snippet();

				this.#main_effect = this.#run(() => {
					this.#is_creating_fallback = false;
					return branch(() => this.#children(this.#anchor));
				});

				if (this.#pending_count > 0) {
					this.#show_pending_snippet();
				} else {
					this.#pending = false;
				}
			};

			var previous_reaction = active_reaction;

			try {
				set_active_reaction(null);
				calling_on_error = true;
				onerror?.(error, reset);
				calling_on_error = false;
			} catch (error) {
				invoke_error_boundary(error, this.#effect && this.#effect.parent);
			} finally {
				set_active_reaction(previous_reaction);
			}

			if (failed) {
				queue_micro_task(() => {
					this.#failed_effect = this.#run(() => {
						this.#is_creating_fallback = true;

						try {
							return branch(() => {
								failed(
									this.#anchor,
									() => error,
									() => reset
								);
							});
						} catch (error) {
							invoke_error_boundary(error, /** @type {Effect} */ (this.#effect.parent));
							return null;
						} finally {
							this.#is_creating_fallback = false;
						}
					});
				});
			}
		}
	}

	/**
	 *
	 * @param {Effect} effect
	 * @param {DocumentFragment} fragment
	 */
	function move_effect(effect, fragment) {
		var node = effect.nodes_start;
		var end = effect.nodes_end;

		while (node !== null) {
			/** @type {TemplateNode | null} */
			var next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));

			fragment.append(node);
			node = next;
		}
	}

	/** @import { Effect, Value } from '#client' */


	/**
	 *
	 * @param {Array<() => any>} sync
	 * @param {Array<() => Promise<any>>} async
	 * @param {(values: Value[]) => any} fn
	 */
	function flatten(sync, async, fn) {
		const d = is_runes() ? derived : derived_safe_equal;

		if (async.length === 0) {
			fn(sync.map(d));
			return;
		}

		var batch = current_batch;
		var parent = /** @type {Effect} */ (active_effect);

		var restore = capture();

		var was_hydrating = hydrating;

		Promise.all(async.map((expression) => async_derived(expression)))
			.then((result) => {
				batch?.activate();

				restore();

				try {
					fn([...sync.map(d), ...result]);
				} catch (error) {
					// ignore errors in blocks that have already been destroyed
					if ((parent.f & DESTROYED) === 0) {
						invoke_error_boundary(error, parent);
					}
				}

				if (was_hydrating) {
					set_hydrating(false);
				}

				batch?.deactivate();
				unset_context();
			})
			.catch((error) => {
				invoke_error_boundary(error, parent);
			});
	}

	/**
	 * Captures the current effect context so that we can restore it after
	 * some asynchronous work has happened (so that e.g. `await a + b`
	 * causes `b` to be registered as a dependency).
	 */
	function capture() {
		var previous_effect = active_effect;
		var previous_reaction = active_reaction;
		var previous_component_context = component_context;
		var previous_batch = current_batch;

		var was_hydrating = hydrating;

		if (was_hydrating) {
			var previous_hydrate_node = hydrate_node;
		}

		return function restore() {
			set_active_effect(previous_effect);
			set_active_reaction(previous_reaction);
			set_component_context(previous_component_context);
			previous_batch?.activate();

			if (was_hydrating) {
				set_hydrating(true);
				set_hydrate_node(previous_hydrate_node);
			}
		};
	}

	function unset_context() {
		set_active_effect(null);
		set_active_reaction(null);
		set_component_context(null);
	}

	/** @import { Derived, Effect, Source } from '#client' */
	/** @import { Batch } from './batch.js'; */

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived(fn) {
		var flags = DERIVED | DIRTY;
		var parent_derived =
			active_reaction !== null && (active_reaction.f & DERIVED) !== 0
				? /** @type {Derived} */ (active_reaction)
				: null;

		if (active_effect === null || (parent_derived !== null && (parent_derived.f & UNOWNED) !== 0)) {
			flags |= UNOWNED;
		} else {
			// Since deriveds are evaluated lazily, any effects created inside them are
			// created too late to ensure that the parent effect is added to the tree
			active_effect.f |= EFFECT_PRESERVED;
		}

		/** @type {Derived<V>} */
		const signal = {
			ctx: component_context,
			deps: null,
			effects: null,
			equals: equals$1,
			f: flags,
			fn,
			reactions: null,
			rv: 0,
			v: /** @type {V} */ (UNINITIALIZED),
			wv: 0,
			parent: parent_derived ?? active_effect,
			ac: null
		};

		return signal;
	}

	/**
	 * @template V
	 * @param {() => V | Promise<V>} fn
	 * @param {string} [location] If provided, print a warning if the value is not read immediately after update
	 * @returns {Promise<Source<V>>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function async_derived(fn, location) {
		let parent = /** @type {Effect | null} */ (active_effect);

		if (parent === null) {
			async_derived_orphan();
		}

		var boundary = /** @type {Boundary} */ (parent.b);

		var promise = /** @type {Promise<V>} */ (/** @type {unknown} */ (undefined));
		var signal = source(/** @type {V} */ (UNINITIALIZED));

		// only suspend in async deriveds created on initialisation
		var should_suspend = !active_reaction;

		/** @type {Map<Batch, ReturnType<typeof deferred<V>>>} */
		var deferreds = new Map();

		async_effect(() => {

			/** @type {ReturnType<typeof deferred<V>>} */
			var d = deferred();
			promise = d.promise;

			try {
				// If this code is changed at some point, make sure to still access the then property
				// of fn() to read any signals it might access, so that we track them as dependencies.
				Promise.resolve(fn()).then(d.resolve, d.reject);
			} catch (error) {
				d.reject(error);
			}

			var batch = /** @type {Batch} */ (current_batch);
			var pending = boundary.is_pending();

			if (should_suspend) {
				boundary.update_pending_count(1);
				if (!pending) {
					batch.increment();

					deferreds.get(batch)?.reject(STALE_REACTION);
					deferreds.set(batch, d);
				}
			}

			/**
			 * @param {any} value
			 * @param {unknown} error
			 */
			const handler = (value, error = undefined) => {

				if (!pending) batch.activate();

				if (error) {
					if (error !== STALE_REACTION) {
						signal.f |= ERROR_VALUE;

						// @ts-expect-error the error is the wrong type, but we don't care
						internal_set(signal, error);
					}
				} else {
					if ((signal.f & ERROR_VALUE) !== 0) {
						signal.f ^= ERROR_VALUE;
					}

					internal_set(signal, value);
				}

				if (should_suspend) {
					boundary.update_pending_count(-1);
					if (!pending) batch.decrement();
				}

				unset_context();
			};

			d.promise.then(handler, (e) => handler(null, e || 'unknown'));
		});

		teardown(() => {
			for (const d of deferreds.values()) {
				d.reject(STALE_REACTION);
			}
		});

		return new Promise((fulfil) => {
			/** @param {Promise<V>} p */
			function next(p) {
				function go() {
					if (p === promise) {
						fulfil(signal);
					} else {
						// if the effect re-runs before the initial promise
						// resolves, delay resolution until we have a value
						next(promise);
					}
				}

				p.then(go, go);
			}

			next(promise);
		});
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function user_derived(fn) {
		const d = derived(fn);

		push_reaction_value(d);

		return d;
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived_safe_equal(fn) {
		const signal = derived(fn);
		signal.equals = safe_equals;
		return signal;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function destroy_derived_effects(derived) {
		var effects = derived.effects;

		if (effects !== null) {
			derived.effects = null;

			for (var i = 0; i < effects.length; i += 1) {
				destroy_effect(/** @type {Effect} */ (effects[i]));
			}
		}
	}

	/**
	 * @param {Derived} derived
	 * @returns {Effect | null}
	 */
	function get_derived_parent_effect(derived) {
		var parent = derived.parent;
		while (parent !== null) {
			if ((parent.f & DERIVED) === 0) {
				return /** @type {Effect} */ (parent);
			}
			parent = parent.parent;
		}
		return null;
	}

	/**
	 * @template T
	 * @param {Derived} derived
	 * @returns {T}
	 */
	function execute_derived(derived) {
		var value;
		var prev_active_effect = active_effect;

		set_active_effect(get_derived_parent_effect(derived));

		{
			try {
				destroy_derived_effects(derived);
				value = update_reaction(derived);
			} finally {
				set_active_effect(prev_active_effect);
			}
		}

		return value;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function update_derived(derived) {
		var value = execute_derived(derived);

		if (!derived.equals(value)) {
			derived.v = value;
			derived.wv = increment_write_version();
		}

		// don't mark derived clean if we're reading it inside a
		// cleanup function, or it will cache a stale value
		if (is_destroying_effect) {
			return;
		}

		{
			var status =
				(skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;

			set_signal_status(derived, status);
		}
	}

	/** @import { Derived, Effect, Source, Value } from '#client' */

	/** @type {Map<Source, any>} */
	const old_values = new Map();

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 * @returns {Source<V>}
	 */
	// TODO rename this to `state` throughout the codebase
	function source(v, stack) {
		/** @type {Value} */
		var signal = {
			f: 0, // TODO ideally we could skip this altogether, but it causes type errors
			v,
			reactions: null,
			equals: equals$1,
			rv: 0,
			wv: 0
		};

		return signal;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function state(v, stack) {
		const s = source(v);

		push_reaction_value(s);

		return s;
	}

	/**
	 * @template V
	 * @param {V} initial_value
	 * @param {boolean} [immutable]
	 * @returns {Source<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function mutable_source(initial_value, immutable = false, trackable = true) {
		const s = source(initial_value);
		if (!immutable) {
			s.equals = safe_equals;
		}

		// bind the signal to the component context, in case we need to
		// track updates to trigger beforeUpdate/afterUpdate callbacks
		if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) {
			(component_context.l.s ??= []).push(s);
		}

		return s;
	}

	/**
	 * @template V
	 * @param {Value<V>} source
	 * @param {V} value
	 */
	function mutate(source, value) {
		set(
			source,
			untrack(() => get(source))
		);
		return value;
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @param {boolean} [should_proxy]
	 * @returns {V}
	 */
	function set(source, value, should_proxy = false) {
		if (
			active_reaction !== null &&
			// since we are untracking the function inside `$inspect.with` we need to add this check
			// to ensure we error if state is set inside an inspect effect
			(!untracking || (active_reaction.f & INSPECT_EFFECT) !== 0) &&
			is_runes() &&
			(active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | INSPECT_EFFECT)) !== 0 &&
			!current_sources?.includes(source)
		) {
			state_unsafe_mutation();
		}

		let new_value = should_proxy ? proxy(value) : value;

		return internal_set(source, new_value);
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @returns {V}
	 */
	function internal_set(source, value) {
		if (!source.equals(value)) {
			var old_value = source.v;

			if (is_destroying_effect) {
				old_values.set(source, value);
			} else {
				old_values.set(source, old_value);
			}

			source.v = value;

			var batch = Batch.ensure();
			batch.capture(source, old_value);

			if ((source.f & DERIVED) !== 0) {
				// if we are assigning to a dirty derived we set it to clean/maybe dirty but we also eagerly execute it to track the dependencies
				if ((source.f & DIRTY) !== 0) {
					execute_derived(/** @type {Derived} */ (source));
				}
				set_signal_status(source, (source.f & UNOWNED) === 0 ? CLEAN : MAYBE_DIRTY);
			}

			source.wv = increment_write_version();

			mark_reactions(source, DIRTY);

			// It's possible that the current reaction might not have up-to-date dependencies
			// whilst it's actively running. So in the case of ensuring it registers the reaction
			// properly for itself, we need to ensure the current effect actually gets
			// scheduled. i.e: `$effect(() => x++)`
			if (
				is_runes() &&
				active_effect !== null &&
				(active_effect.f & CLEAN) !== 0 &&
				(active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0
			) {
				if (untracked_writes === null) {
					set_untracked_writes([source]);
				} else {
					untracked_writes.push(source);
				}
			}
		}

		return value;
	}

	/**
	 * Silently (without using `get`) increment a source
	 * @param {Source<number>} source
	 */
	function increment(source) {
		set(source, source.v + 1);
	}

	/**
	 * @param {Value} signal
	 * @param {number} status should be DIRTY or MAYBE_DIRTY
	 * @returns {void}
	 */
	function mark_reactions(signal, status) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		var runes = is_runes();
		var length = reactions.length;

		for (var i = 0; i < length; i++) {
			var reaction = reactions[i];
			var flags = reaction.f;

			// In legacy mode, skip the current effect to prevent infinite loops
			if (!runes && reaction === active_effect) continue;

			var not_dirty = (flags & DIRTY) === 0;

			// don't set a DIRTY reaction to MAYBE_DIRTY
			if (not_dirty) {
				set_signal_status(reaction, status);
			}

			if ((flags & DERIVED) !== 0) {
				mark_reactions(/** @type {Derived} */ (reaction), MAYBE_DIRTY);
			} else if (not_dirty) {
				if ((flags & BLOCK_EFFECT) !== 0) {
					if (eager_block_effects !== null) {
						eager_block_effects.push(/** @type {Effect} */ (reaction));
					}
				}

				schedule_effect(/** @type {Effect} */ (reaction));
			}
		}
	}

	/** @import { Source } from '#client' */

	/**
	 * @template T
	 * @param {T} value
	 * @returns {T}
	 */
	function proxy(value) {
		// if non-proxyable, or is already a proxy, return `value`
		if (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {
			return value;
		}

		const prototype = get_prototype_of(value);

		if (prototype !== object_prototype && prototype !== array_prototype) {
			return value;
		}

		/** @type {Map<any, Source<any>>} */
		var sources = new Map();
		var is_proxied_array = is_array(value);
		var version = state(0);
		var parent_version = update_version;

		/**
		 * Executes the proxy in the context of the reaction it was originally created in, if any
		 * @template T
		 * @param {() => T} fn
		 */
		var with_parent = (fn) => {
			if (update_version === parent_version) {
				return fn();
			}

			// child source is being created after the initial proxy â
			// prevent it from being associated with the current reaction
			var reaction = active_reaction;
			var version = update_version;

			set_active_reaction(null);
			set_update_version(parent_version);

			var result = fn();

			set_active_reaction(reaction);
			set_update_version(version);

			return result;
		};

		if (is_proxied_array) {
			// We need to create the length source eagerly to ensure that
			// mutations to the array are properly synced with our proxy
			sources.set('length', state(/** @type {any[]} */ (value).length));
		}

		return new Proxy(/** @type {any} */ (value), {
			defineProperty(_, prop, descriptor) {
				if (
					!('value' in descriptor) ||
					descriptor.configurable === false ||
					descriptor.enumerable === false ||
					descriptor.writable === false
				) {
					// we disallow non-basic descriptors, because unless they are applied to the
					// target object â which we avoid, so that state can be forked â we will run
					// afoul of the various invariants
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants
					state_descriptors_fixed();
				}
				var s = sources.get(prop);
				if (s === undefined) {
					s = with_parent(() => {
						var s = state(descriptor.value);
						sources.set(prop, s);
						return s;
					});
				} else {
					set(s, descriptor.value, true);
				}

				return true;
			},

			deleteProperty(target, prop) {
				var s = sources.get(prop);

				if (s === undefined) {
					if (prop in target) {
						const s = with_parent(() => state(UNINITIALIZED));
						sources.set(prop, s);
						increment(version);
					}
				} else {
					set(s, UNINITIALIZED);
					increment(version);
				}

				return true;
			},

			get(target, prop, receiver) {
				if (prop === STATE_SYMBOL) {
					return value;
				}

				var s = sources.get(prop);
				var exists = prop in target;

				// create a source, but only if it's an own property and not a prototype property
				if (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {
					s = with_parent(() => {
						var p = proxy(exists ? target[prop] : UNINITIALIZED);
						var s = state(p);

						return s;
					});

					sources.set(prop, s);
				}

				if (s !== undefined) {
					var v = get(s);
					return v === UNINITIALIZED ? undefined : v;
				}

				return Reflect.get(target, prop, receiver);
			},

			getOwnPropertyDescriptor(target, prop) {
				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				if (descriptor && 'value' in descriptor) {
					var s = sources.get(prop);
					if (s) descriptor.value = get(s);
				} else if (descriptor === undefined) {
					var source = sources.get(prop);
					var value = source?.v;

					if (source !== undefined && value !== UNINITIALIZED) {
						return {
							enumerable: true,
							configurable: true,
							value,
							writable: true
						};
					}
				}

				return descriptor;
			},

			has(target, prop) {
				if (prop === STATE_SYMBOL) {
					return true;
				}

				var s = sources.get(prop);
				var has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);

				if (
					s !== undefined ||
					(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))
				) {
					if (s === undefined) {
						s = with_parent(() => {
							var p = has ? proxy(target[prop]) : UNINITIALIZED;
							var s = state(p);

							return s;
						});

						sources.set(prop, s);
					}

					var value = get(s);
					if (value === UNINITIALIZED) {
						return false;
					}
				}

				return has;
			},

			set(target, prop, value, receiver) {
				var s = sources.get(prop);
				var has = prop in target;

				// variable.length = value -> clear all signals with index >= value
				if (is_proxied_array && prop === 'length') {
					for (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {
						var other_s = sources.get(i + '');
						if (other_s !== undefined) {
							set(other_s, UNINITIALIZED);
						} else if (i in target) {
							// If the item exists in the original, we need to create a uninitialized source,
							// else a later read of the property would result in a source being created with
							// the value of the original item at that index.
							other_s = with_parent(() => state(UNINITIALIZED));
							sources.set(i + '', other_s);
						}
					}
				}

				// If we haven't yet created a source for this property, we need to ensure
				// we do so otherwise if we read it later, then the write won't be tracked and
				// the heuristics of effects will be different vs if we had read the proxied
				// object property before writing to that property.
				if (s === undefined) {
					if (!has || get_descriptor(target, prop)?.writable) {
						s = with_parent(() => state(undefined));
						set(s, proxy(value));

						sources.set(prop, s);
					}
				} else {
					has = s.v !== UNINITIALIZED;

					var p = with_parent(() => proxy(value));
					set(s, p);
				}

				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				// Set the new value before updating any signals so that any listeners get the new value
				if (descriptor?.set) {
					descriptor.set.call(receiver, value);
				}

				if (!has) {
					// If we have mutated an array directly, we might need to
					// signal that length has also changed. Do it before updating metadata
					// to ensure that iterating over the array as a result of a metadata update
					// will not cause the length to be out of sync.
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n >= ls.v) {
							set(ls, n + 1);
						}
					}

					increment(version);
				}

				return true;
			},

			ownKeys(target) {
				get(version);

				var own_keys = Reflect.ownKeys(target).filter((key) => {
					var source = sources.get(key);
					return source === undefined || source.v !== UNINITIALIZED;
				});

				for (var [key, source] of sources) {
					if (source.v !== UNINITIALIZED && !(key in target)) {
						own_keys.push(key);
					}
				}

				return own_keys;
			},

			setPrototypeOf() {
				state_prototype_fixed();
			}
		});
	}

	/**
	 * @param {any} value
	 */
	function get_proxied_value(value) {
		try {
			if (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {
				return value[STATE_SYMBOL];
			}
		} catch {
			// the above if check can throw an error if the value in question
			// is the contentWindow of an iframe on another domain, in which
			// case we want to just return the value (because it's definitely
			// not a proxied value) so we don't break any JavaScript interacting
			// with that iframe (such as various payment companies client side
			// JavaScript libraries interacting with their iframes on the same
			// domain)
		}

		return value;
	}

	/**
	 * @param {any} a
	 * @param {any} b
	 */
	function is(a, b) {
		return Object.is(get_proxied_value(a), get_proxied_value(b));
	}

	/**
	 * @param {any} a
	 * @param {any} b
	 * @param {boolean} equal
	 * @returns {boolean}
	 */
	function strict_equals(a, b, equal = true) {
		// try-catch needed because this tries to read properties of `a` and `b`,
		// which could be disallowed for example in a secure context
		try {
			if ((a === b) !== (get_proxied_value(a) === get_proxied_value(b))) {
				state_proxy_equality_mismatch(equal ? '===' : '!==');
			}
		} catch {}

		return (a === b) === equal;
	}

	/**
	 * @param {any} a
	 * @param {any} b
	 * @param {boolean} equal
	 * @returns {boolean}
	 */
	function equals(a, b, equal = true) {
		if ((a == b) !== (get_proxied_value(a) == get_proxied_value(b))) {
			state_proxy_equality_mismatch();
		}

		return (a == b) === equal;
	}

	/** @import { Effect, TemplateNode } from '#client' */

	// export these for reference in the compiled code, making global name deduplication unnecessary
	/** @type {Window} */
	var $window;

	/** @type {boolean} */
	var is_firefox;

	/** @type {() => Node | null} */
	var first_child_getter;
	/** @type {() => Node | null} */
	var next_sibling_getter;

	/**
	 * Initialize these lazily to avoid issues when using the runtime in a server context
	 * where these globals are not available while avoiding a separate server entry point
	 */
	function init_operations() {
		if ($window !== undefined) {
			return;
		}

		$window = window;
		is_firefox = /Firefox/.test(navigator.userAgent);

		var element_prototype = Element.prototype;
		var node_prototype = Node.prototype;
		var text_prototype = Text.prototype;

		// @ts-ignore
		first_child_getter = get_descriptor(node_prototype, 'firstChild').get;
		// @ts-ignore
		next_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;

		if (is_extensible(element_prototype)) {
			// the following assignments improve perf of lookups on DOM nodes
			// @ts-expect-error
			element_prototype.__click = undefined;
			// @ts-expect-error
			element_prototype.__className = undefined;
			// @ts-expect-error
			element_prototype.__attributes = null;
			// @ts-expect-error
			element_prototype.__style = undefined;
			// @ts-expect-error
			element_prototype.__e = undefined;
		}

		if (is_extensible(text_prototype)) {
			// @ts-expect-error
			text_prototype.__t = undefined;
		}
	}

	/**
	 * @param {string} value
	 * @returns {Text}
	 */
	function create_text(value = '') {
		return document.createTextNode(value);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_first_child(node) {
		return first_child_getter.call(node);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_next_sibling(node) {
		return next_sibling_getter.call(node);
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @template {Node} N
	 * @param {N} node
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function child(node, is_text) {
		if (!hydrating) {
			return get_first_child(node);
		}

		var child = /** @type {TemplateNode} */ (get_first_child(hydrate_node));

		// Child can be null if we have an element with a single child, like `<p>{text}</p>`, where `text` is empty
		if (child === null) {
			child = hydrate_node.appendChild(create_text());
		} else if (is_text && child.nodeType !== TEXT_NODE) {
			var text = create_text();
			child?.before(text);
			set_hydrate_node(text);
			return text;
		}

		set_hydrate_node(child);
		return child;
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {DocumentFragment | TemplateNode | TemplateNode[]} fragment
	 * @param {boolean} [is_text]
	 * @returns {Node | null}
	 */
	function first_child(fragment, is_text = false) {
		if (!hydrating) {
			// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)
			var first = /** @type {DocumentFragment} */ (get_first_child(/** @type {Node} */ (fragment)));

			// TODO prevent user comments with the empty string when preserveComments is true
			if (first instanceof Comment && first.data === '') return get_next_sibling(first);

			return first;
		}

		// if an {expression} is empty during SSR, there might be no
		// text node to hydrate â we must therefore create one
		if (is_text && hydrate_node?.nodeType !== TEXT_NODE) {
			var text = create_text();

			hydrate_node?.before(text);
			set_hydrate_node(text);
			return text;
		}

		return hydrate_node;
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {TemplateNode} node
	 * @param {number} count
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function sibling(node, count = 1, is_text = false) {
		let next_sibling = hydrating ? hydrate_node : node;
		var last_sibling;

		while (count--) {
			last_sibling = next_sibling;
			next_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));
		}

		if (!hydrating) {
			return next_sibling;
		}

		// if a sibling {expression} is empty during SSR, there might be no
		// text node to hydrate â we must therefore create one
		if (is_text && next_sibling?.nodeType !== TEXT_NODE) {
			var text = create_text();
			// If the next sibling is `null` and we're handling text then it's because
			// the SSR content was empty for the text, so we need to generate a new text
			// node and insert it after the last sibling
			if (next_sibling === null) {
				last_sibling?.after(text);
			} else {
				next_sibling.before(text);
			}
			set_hydrate_node(text);
			return text;
		}

		set_hydrate_node(next_sibling);
		return /** @type {TemplateNode} */ (next_sibling);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {void}
	 */
	function clear_text_content(node) {
		node.textContent = '';
	}

	/**
	 * Returns `true` if we're updating the current block, for example `condition` in
	 * an `{#if condition}` block just changed. In this case, the branch should be
	 * appended (or removed) at the same time as other updates within the
	 * current `<svelte:boundary>`
	 */
	function should_defer_append() {
		return false;
	}

	/**
	 * @param {HTMLElement} dom
	 * @param {boolean} value
	 * @returns {void}
	 */
	function autofocus(dom, value) {
		if (value) {
			const body = document.body;
			dom.autofocus = true;

			queue_micro_task(() => {
				if (document.activeElement === body) {
					dom.focus();
				}
			});
		}
	}

	let listening_to_form_reset = false;

	function add_form_reset_listener() {
		if (!listening_to_form_reset) {
			listening_to_form_reset = true;
			document.addEventListener(
				'reset',
				(evt) => {
					// Needs to happen one tick later or else the dom properties of the form
					// elements have not updated to their reset values yet
					Promise.resolve().then(() => {
						if (!evt.defaultPrevented) {
							for (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {
								// @ts-expect-error
								e.__on_r?.();
							}
						}
					});
				},
				// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
				{ capture: true }
			);
		}
	}

	/**
	 * @template T
	 * @param {() => T} fn
	 */
	function without_reactive_context(fn) {
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);
		try {
			return fn();
		} finally {
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/**
	 * Listen to the given event, and then instantiate a global form reset listener if not already done,
	 * to notify all bindings when the form is reset
	 * @param {HTMLElement} element
	 * @param {string} event
	 * @param {(is_reset?: true) => void} handler
	 * @param {(is_reset?: true) => void} [on_reset]
	 */
	function listen_to_event_and_reset_event(element, event, handler, on_reset = handler) {
		element.addEventListener(event, () => without_reactive_context(handler));
		// @ts-expect-error
		const prev = element.__on_r;
		if (prev) {
			// special case for checkbox that can have multiple binds (group & checked)
			// @ts-expect-error
			element.__on_r = () => {
				prev();
				on_reset(true);
			};
		} else {
			// @ts-expect-error
			element.__on_r = () => on_reset(true);
		}

		add_form_reset_listener();
	}

	/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, TemplateNode, TransitionManager } from '#client' */

	/**
	 * @param {'$effect' | '$effect.pre' | '$inspect'} rune
	 */
	function validate_effect(rune) {
		if (active_effect === null && active_reaction === null) {
			effect_orphan();
		}

		if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0 && active_effect === null) {
			effect_in_unowned_derived();
		}

		if (is_destroying_effect) {
			effect_in_teardown();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {Effect} parent_effect
	 */
	function push_effect(effect, parent_effect) {
		var parent_last = parent_effect.last;
		if (parent_last === null) {
			parent_effect.last = parent_effect.first = effect;
		} else {
			parent_last.next = effect;
			effect.prev = parent_last;
			parent_effect.last = effect;
		}
	}

	/**
	 * @param {number} type
	 * @param {null | (() => void | (() => void))} fn
	 * @param {boolean} sync
	 * @param {boolean} push
	 * @returns {Effect}
	 */
	function create_effect(type, fn, sync, push = true) {
		var parent = active_effect;

		if (parent !== null && (parent.f & INERT) !== 0) {
			type |= INERT;
		}

		/** @type {Effect} */
		var effect = {
			ctx: component_context,
			deps: null,
			nodes_start: null,
			nodes_end: null,
			f: type | DIRTY,
			first: null,
			fn,
			last: null,
			next: null,
			parent,
			b: parent && parent.b,
			prev: null,
			teardown: null,
			transitions: null,
			wv: 0,
			ac: null
		};

		if (sync) {
			try {
				update_effect(effect);
				effect.f |= EFFECT_RAN;
			} catch (e) {
				destroy_effect(effect);
				throw e;
			}
		} else if (fn !== null) {
			schedule_effect(effect);
		}

		if (push) {
			/** @type {Effect | null} */
			var e = effect;

			// if an effect has already ran and doesn't need to be kept in the tree
			// (because it won't re-run, has no DOM, and has no teardown etc)
			// then we skip it and go to its child (if any)
			if (
				sync &&
				e.deps === null &&
				e.teardown === null &&
				e.nodes_start === null &&
				e.first === e.last && // either `null`, or a singular child
				(e.f & EFFECT_PRESERVED) === 0
			) {
				e = e.first;
			}

			if (e !== null) {
				e.parent = parent;

				if (parent !== null) {
					push_effect(e, parent);
				}

				// if we're in a derived, add the effect there too
				if (
					active_reaction !== null &&
					(active_reaction.f & DERIVED) !== 0 &&
					(type & ROOT_EFFECT) === 0
				) {
					var derived = /** @type {Derived} */ (active_reaction);
					(derived.effects ??= []).push(e);
				}
			}
		}

		return effect;
	}

	/**
	 * Internal representation of `$effect.tracking()`
	 * @returns {boolean}
	 */
	function effect_tracking() {
		return active_reaction !== null && !untracking;
	}

	/**
	 * @param {() => void} fn
	 */
	function teardown(fn) {
		const effect = create_effect(RENDER_EFFECT, null, false);
		set_signal_status(effect, CLEAN);
		effect.teardown = fn;
		return effect;
	}

	/**
	 * Internal representation of `$effect(...)`
	 * @param {() => void | (() => void)} fn
	 */
	function user_effect(fn) {
		validate_effect();

		// Non-nested `$effect(...)` in a component should be deferred
		// until the component is mounted
		var flags = /** @type {Effect} */ (active_effect).f;
		var defer = !active_reaction && (flags & BRANCH_EFFECT) !== 0 && (flags & EFFECT_RAN) === 0;

		if (defer) {
			// Top-level `$effect(...)` in an unmounted component â defer until mount
			var context = /** @type {ComponentContext} */ (component_context);
			(context.e ??= []).push(fn);
		} else {
			// Everything else â create immediately
			return create_user_effect(fn);
		}
	}

	/**
	 * @param {() => void | (() => void)} fn
	 */
	function create_user_effect(fn) {
		return create_effect(EFFECT | USER_EFFECT, fn, false);
	}

	/**
	 * Internal representation of `$effect.pre(...)`
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function user_pre_effect(fn) {
		validate_effect();
		return create_effect(RENDER_EFFECT | USER_EFFECT, fn, true);
	}

	/**
	 * Internal representation of `$effect.root(...)`
	 * @param {() => void | (() => void)} fn
	 * @returns {() => void}
	 */
	function effect_root(fn) {
		Batch.ensure();
		const effect = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);

		return () => {
			destroy_effect(effect);
		};
	}

	/**
	 * An effect root whose children can transition out
	 * @param {() => void} fn
	 * @returns {(options?: { outro?: boolean }) => Promise<void>}
	 */
	function component_root(fn) {
		Batch.ensure();
		const effect = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);

		return (options = {}) => {
			return new Promise((fulfil) => {
				if (options.outro) {
					pause_effect(effect, () => {
						destroy_effect(effect);
						fulfil(undefined);
					});
				} else {
					destroy_effect(effect);
					fulfil(undefined);
				}
			});
		};
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function effect(fn) {
		return create_effect(EFFECT, fn, false);
	}

	/**
	 * Internal representation of `$: ..`
	 * @param {() => any} deps
	 * @param {() => void | (() => void)} fn
	 */
	function legacy_pre_effect(deps, fn) {
		var context = /** @type {ComponentContextLegacy} */ (component_context);

		/** @type {{ effect: null | Effect, ran: boolean, deps: () => any }} */
		var token = { effect: null, ran: false, deps };

		context.l.$.push(token);

		token.effect = render_effect(() => {
			deps();

			// If this legacy pre effect has already run before the end of the reset, then
			// bail out to emulate the same behavior.
			if (token.ran) return;

			token.ran = true;
			untrack(fn);
		});
	}

	function legacy_pre_effect_reset() {
		var context = /** @type {ComponentContextLegacy} */ (component_context);

		render_effect(() => {
			// Run dirty `$:` statements
			for (var token of context.l.$) {
				token.deps();

				var effect = token.effect;

				// If the effect is CLEAN, then make it MAYBE_DIRTY. This ensures we traverse through
				// the effects dependencies and correctly ensure each dependency is up-to-date.
				if ((effect.f & CLEAN) !== 0) {
					set_signal_status(effect, MAYBE_DIRTY);
				}

				if (is_dirty(effect)) {
					update_effect(effect);
				}

				token.ran = false;
			}
		});
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function async_effect(fn) {
		return create_effect(ASYNC | EFFECT_PRESERVED, fn, true);
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function render_effect(fn, flags = 0) {
		return create_effect(RENDER_EFFECT | flags, fn, true);
	}

	/**
	 * @param {(...expressions: any) => void | (() => void)} fn
	 * @param {Array<() => any>} sync
	 * @param {Array<() => Promise<any>>} async
	 */
	function template_effect(fn, sync = [], async = []) {
		flatten(sync, async, (values) => {
			create_effect(RENDER_EFFECT, () => fn(...values.map(get)), true);
		});
	}

	/**
	 * @param {(() => void)} fn
	 * @param {number} flags
	 */
	function block(fn, flags = 0) {
		var effect = create_effect(BLOCK_EFFECT | flags, fn, true);
		return effect;
	}

	/**
	 * @param {(() => void)} fn
	 * @param {boolean} [push]
	 */
	function branch(fn, push = true) {
		return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true, push);
	}

	/**
	 * @param {Effect} effect
	 */
	function execute_effect_teardown(effect) {
		var teardown = effect.teardown;
		if (teardown !== null) {
			const previously_destroying_effect = is_destroying_effect;
			const previous_reaction = active_reaction;
			set_is_destroying_effect(true);
			set_active_reaction(null);
			try {
				teardown.call(null);
			} finally {
				set_is_destroying_effect(previously_destroying_effect);
				set_active_reaction(previous_reaction);
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @param {boolean} remove_dom
	 * @returns {void}
	 */
	function destroy_effect_children(signal, remove_dom = false) {
		var effect = signal.first;
		signal.first = signal.last = null;

		while (effect !== null) {
			const controller = effect.ac;

			if (controller !== null) {
				without_reactive_context(() => {
					controller.abort(STALE_REACTION);
				});
			}

			var next = effect.next;

			if ((effect.f & ROOT_EFFECT) !== 0) {
				// this is now an independent root
				effect.parent = null;
			} else {
				destroy_effect(effect, remove_dom);
			}

			effect = next;
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function destroy_block_effect_children(signal) {
		var effect = signal.first;

		while (effect !== null) {
			var next = effect.next;
			if ((effect.f & BRANCH_EFFECT) === 0) {
				destroy_effect(effect);
			}
			effect = next;
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} [remove_dom]
	 * @returns {void}
	 */
	function destroy_effect(effect, remove_dom = true) {
		var removed = false;

		if (
			(remove_dom || (effect.f & HEAD_EFFECT) !== 0) &&
			effect.nodes_start !== null &&
			effect.nodes_end !== null
		) {
			remove_effect_dom(effect.nodes_start, /** @type {TemplateNode} */ (effect.nodes_end));
			removed = true;
		}

		destroy_effect_children(effect, remove_dom && !removed);
		remove_reactions(effect, 0);
		set_signal_status(effect, DESTROYED);

		var transitions = effect.transitions;

		if (transitions !== null) {
			for (const transition of transitions) {
				transition.stop();
			}
		}

		execute_effect_teardown(effect);

		var parent = effect.parent;

		// If the parent doesn't have any children, then skip this work altogether
		if (parent !== null && parent.first !== null) {
			unlink_effect(effect);
		}

		// `first` and `child` are nulled out in destroy_effect_children
		// we don't null out `parent` so that error propagation can work correctly
		effect.next =
			effect.prev =
			effect.teardown =
			effect.ctx =
			effect.deps =
			effect.fn =
			effect.nodes_start =
			effect.nodes_end =
			effect.ac =
				null;
	}

	/**
	 *
	 * @param {TemplateNode | null} node
	 * @param {TemplateNode} end
	 */
	function remove_effect_dom(node, end) {
		while (node !== null) {
			/** @type {TemplateNode | null} */
			var next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));

			node.remove();
			node = next;
		}
	}

	/**
	 * Detach an effect from the effect tree, freeing up memory and
	 * reducing the amount of work that happens on subsequent traversals
	 * @param {Effect} effect
	 */
	function unlink_effect(effect) {
		var parent = effect.parent;
		var prev = effect.prev;
		var next = effect.next;

		if (prev !== null) prev.next = next;
		if (next !== null) next.prev = prev;

		if (parent !== null) {
			if (parent.first === effect) parent.first = next;
			if (parent.last === effect) parent.last = prev;
		}
	}

	/**
	 * When a block effect is removed, we don't immediately destroy it or yank it
	 * out of the DOM, because it might have transitions. Instead, we 'pause' it.
	 * It stays around (in memory, and in the DOM) until outro transitions have
	 * completed, and if the state change is reversed then we _resume_ it.
	 * A paused effect does not update, and the DOM subtree becomes inert.
	 * @param {Effect} effect
	 * @param {() => void} [callback]
	 */
	function pause_effect(effect, callback) {
		/** @type {TransitionManager[]} */
		var transitions = [];

		pause_children(effect, transitions, true);

		run_out_transitions(transitions, () => {
			destroy_effect(effect);
			if (callback) callback();
		});
	}

	/**
	 * @param {TransitionManager[]} transitions
	 * @param {() => void} fn
	 */
	function run_out_transitions(transitions, fn) {
		var remaining = transitions.length;
		if (remaining > 0) {
			var check = () => --remaining || fn();
			for (var transition of transitions) {
				transition.out(check);
			}
		} else {
			fn();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {TransitionManager[]} transitions
	 * @param {boolean} local
	 */
	function pause_children(effect, transitions, local) {
		if ((effect.f & INERT) !== 0) return;
		effect.f ^= INERT;

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transitions.push(transition);
				}
			}
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call pause_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			pause_children(child, transitions, transparent ? local : false);
			child = sibling;
		}
	}

	/**
	 * The opposite of `pause_effect`. We call this if (for example)
	 * `x` becomes falsy then truthy: `{#if x}...{/if}`
	 * @param {Effect} effect
	 */
	function resume_effect(effect) {
		resume_children(effect, true);
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} local
	 */
	function resume_children(effect, local) {
		if ((effect.f & INERT) === 0) return;
		effect.f ^= INERT;

		// If a dependency of this effect changed while it was paused,
		// schedule the effect to update. we don't use `is_dirty`
		// here because we don't want to eagerly recompute a derived like
		// `{#if foo}{foo.bar()}{/if}` if `foo` is now `undefined
		if ((effect.f & CLEAN) === 0) {
			set_signal_status(effect, DIRTY);
			schedule_effect(effect);
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call resume_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			resume_children(child, transparent ? local : false);
			child = sibling;
		}

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transition.in();
				}
			}
		}
	}

	/** @import { Derived, Effect, Reaction, Signal, Source, Value } from '#client' */

	let is_updating_effect = false;

	/** @param {boolean} value */
	function set_is_updating_effect(value) {
		is_updating_effect = value;
	}

	let is_destroying_effect = false;

	/** @param {boolean} value */
	function set_is_destroying_effect(value) {
		is_destroying_effect = value;
	}

	/** @type {null | Reaction} */
	let active_reaction = null;

	let untracking = false;

	/** @param {null | Reaction} reaction */
	function set_active_reaction(reaction) {
		active_reaction = reaction;
	}

	/** @type {null | Effect} */
	let active_effect = null;

	/** @param {null | Effect} effect */
	function set_active_effect(effect) {
		active_effect = effect;
	}

	/**
	 * When sources are created within a reaction, reading and writing
	 * them within that reaction should not cause a re-run
	 * @type {null | Source[]}
	 */
	let current_sources = null;

	/** @param {Value} value */
	function push_reaction_value(value) {
		if (active_reaction !== null && (true)) {
			if (current_sources === null) {
				current_sources = [value];
			} else {
				current_sources.push(value);
			}
		}
	}

	/**
	 * The dependencies of the reaction that is currently being executed. In many cases,
	 * the dependencies are unchanged between runs, and so this will be `null` unless
	 * and until a new dependency is accessed â we track this via `skipped_deps`
	 * @type {null | Value[]}
	 */
	let new_deps = null;

	let skipped_deps = 0;

	/**
	 * Tracks writes that the effect it's executed in doesn't listen to yet,
	 * so that the dependency can be added to the effect later on if it then reads it
	 * @type {null | Source[]}
	 */
	let untracked_writes = null;

	/** @param {null | Source[]} value */
	function set_untracked_writes(value) {
		untracked_writes = value;
	}

	/**
	 * @type {number} Used by sources and deriveds for handling updates.
	 * Version starts from 1 so that unowned deriveds differentiate between a created effect and a run one for tracing
	 **/
	let write_version = 1;

	/** @type {number} Used to version each read of a source of derived to avoid duplicating depedencies inside a reaction */
	let read_version = 0;

	let update_version = read_version;

	/** @param {number} value */
	function set_update_version(value) {
		update_version = value;
	}

	// If we are working with a get() chain that has no active container,
	// to prevent memory leaks, we skip adding the reaction.
	let skip_reaction = false;

	function increment_write_version() {
		return ++write_version;
	}

	/**
	 * Determines whether a derived or effect is dirty.
	 * If it is MAYBE_DIRTY, will set the status to CLEAN
	 * @param {Reaction} reaction
	 * @returns {boolean}
	 */
	function is_dirty(reaction) {
		var flags = reaction.f;

		if ((flags & DIRTY) !== 0) {
			return true;
		}

		if ((flags & MAYBE_DIRTY) !== 0) {
			var dependencies = reaction.deps;
			var is_unowned = (flags & UNOWNED) !== 0;

			if (dependencies !== null) {
				var i;
				var dependency;
				var is_disconnected = (flags & DISCONNECTED) !== 0;
				var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
				var length = dependencies.length;

				// If we are working with a disconnected or an unowned signal that is now connected (due to an active effect)
				// then we need to re-connect the reaction to the dependency, unless the effect has already been destroyed
				// (which can happen if the derived is read by an async derived)
				if (
					(is_disconnected || is_unowned_connected) &&
					(active_effect === null || (active_effect.f & DESTROYED) === 0)
				) {
					var derived = /** @type {Derived} */ (reaction);
					var parent = derived.parent;

					for (i = 0; i < length; i++) {
						dependency = dependencies[i];

						// We always re-add all reactions (even duplicates) if the derived was
						// previously disconnected, however we don't if it was unowned as we
						// de-duplicate dependencies in that case
						if (is_disconnected || !dependency?.reactions?.includes(derived)) {
							(dependency.reactions ??= []).push(derived);
						}
					}

					if (is_disconnected) {
						derived.f ^= DISCONNECTED;
					}
					// If the unowned derived is now fully connected to the graph again (it's unowned and reconnected, has a parent
					// and the parent is not unowned), then we can mark it as connected again, removing the need for the unowned
					// flag
					if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {
						derived.f ^= UNOWNED;
					}
				}

				for (i = 0; i < length; i++) {
					dependency = dependencies[i];

					if (is_dirty(/** @type {Derived} */ (dependency))) {
						update_derived(/** @type {Derived} */ (dependency));
					}

					if (dependency.wv > reaction.wv) {
						return true;
					}
				}
			}

			// Unowned signals should never be marked as clean unless they
			// are used within an active_effect without skip_reaction
			if (!is_unowned || (active_effect !== null && !skip_reaction)) {
				set_signal_status(reaction, CLEAN);
			}
		}

		return false;
	}

	/**
	 * @param {Value} signal
	 * @param {Effect} effect
	 * @param {boolean} [root]
	 */
	function schedule_possible_effect_self_invalidation(signal, effect, root = true) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		if (current_sources?.includes(signal)) {
			return;
		}

		for (var i = 0; i < reactions.length; i++) {
			var reaction = reactions[i];

			if ((reaction.f & DERIVED) !== 0) {
				schedule_possible_effect_self_invalidation(/** @type {Derived} */ (reaction), effect, false);
			} else if (effect === reaction) {
				if (root) {
					set_signal_status(reaction, DIRTY);
				} else if ((reaction.f & CLEAN) !== 0) {
					set_signal_status(reaction, MAYBE_DIRTY);
				}
				schedule_effect(/** @type {Effect} */ (reaction));
			}
		}
	}

	/** @param {Reaction} reaction */
	function update_reaction(reaction) {
		var previous_deps = new_deps;
		var previous_skipped_deps = skipped_deps;
		var previous_untracked_writes = untracked_writes;
		var previous_reaction = active_reaction;
		var previous_skip_reaction = skip_reaction;
		var previous_sources = current_sources;
		var previous_component_context = component_context;
		var previous_untracking = untracking;
		var previous_update_version = update_version;

		var flags = reaction.f;

		new_deps = /** @type {null | Value[]} */ (null);
		skipped_deps = 0;
		untracked_writes = null;
		skip_reaction =
			(flags & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);
		active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;

		current_sources = null;
		set_component_context(reaction.ctx);
		untracking = false;
		update_version = ++read_version;

		if (reaction.ac !== null) {
			without_reactive_context(() => {
				/** @type {AbortController} */ (reaction.ac).abort(STALE_REACTION);
			});

			reaction.ac = null;
		}

		try {
			reaction.f |= REACTION_IS_UPDATING;
			var fn = /** @type {Function} */ (reaction.fn);
			var result = fn();
			var deps = reaction.deps;

			if (new_deps !== null) {
				var i;

				remove_reactions(reaction, skipped_deps);

				if (deps !== null && skipped_deps > 0) {
					deps.length = skipped_deps + new_deps.length;
					for (i = 0; i < new_deps.length; i++) {
						deps[skipped_deps + i] = new_deps[i];
					}
				} else {
					reaction.deps = deps = new_deps;
				}

				if (
					!skip_reaction ||
					// Deriveds that already have reactions can cleanup, so we still add them as reactions
					((flags & DERIVED) !== 0 &&
						/** @type {import('#client').Derived} */ (reaction).reactions !== null)
				) {
					for (i = skipped_deps; i < deps.length; i++) {
						(deps[i].reactions ??= []).push(reaction);
					}
				}
			} else if (deps !== null && skipped_deps < deps.length) {
				remove_reactions(reaction, skipped_deps);
				deps.length = skipped_deps;
			}

			// If we're inside an effect and we have untracked writes, then we need to
			// ensure that if any of those untracked writes result in re-invalidation
			// of the current effect, then that happens accordingly
			if (
				is_runes() &&
				untracked_writes !== null &&
				!untracking &&
				deps !== null &&
				(reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0
			) {
				for (i = 0; i < /** @type {Source[]} */ (untracked_writes).length; i++) {
					schedule_possible_effect_self_invalidation(
						untracked_writes[i],
						/** @type {Effect} */ (reaction)
					);
				}
			}

			// If we are returning to an previous reaction then
			// we need to increment the read version to ensure that
			// any dependencies in this reaction aren't marked with
			// the same version
			if (previous_reaction !== null && previous_reaction !== reaction) {
				read_version++;

				if (untracked_writes !== null) {
					if (previous_untracked_writes === null) {
						previous_untracked_writes = untracked_writes;
					} else {
						previous_untracked_writes.push(.../** @type {Source[]} */ (untracked_writes));
					}
				}
			}

			if ((reaction.f & ERROR_VALUE) !== 0) {
				reaction.f ^= ERROR_VALUE;
			}

			return result;
		} catch (error) {
			return handle_error(error);
		} finally {
			reaction.f ^= REACTION_IS_UPDATING;
			new_deps = previous_deps;
			skipped_deps = previous_skipped_deps;
			untracked_writes = previous_untracked_writes;
			active_reaction = previous_reaction;
			skip_reaction = previous_skip_reaction;
			current_sources = previous_sources;
			set_component_context(previous_component_context);
			untracking = previous_untracking;
			update_version = previous_update_version;
		}
	}

	/**
	 * @template V
	 * @param {Reaction} signal
	 * @param {Value<V>} dependency
	 * @returns {void}
	 */
	function remove_reaction(signal, dependency) {
		let reactions = dependency.reactions;
		if (reactions !== null) {
			var index = index_of.call(reactions, signal);
			if (index !== -1) {
				var new_length = reactions.length - 1;
				if (new_length === 0) {
					reactions = dependency.reactions = null;
				} else {
					// Swap with last element and then remove.
					reactions[index] = reactions[new_length];
					reactions.pop();
				}
			}
		}

		// If the derived has no reactions, then we can disconnect it from the graph,
		// allowing it to either reconnect in the future, or be GC'd by the VM.
		if (
			reactions === null &&
			(dependency.f & DERIVED) !== 0 &&
			// Destroying a child effect while updating a parent effect can cause a dependency to appear
			// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
			// allows us to skip the expensive work of disconnecting and immediately reconnecting it
			(new_deps === null || !new_deps.includes(dependency))
		) {
			set_signal_status(dependency, MAYBE_DIRTY);
			// If we are working with a derived that is owned by an effect, then mark it as being
			// disconnected.
			if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
				dependency.f ^= DISCONNECTED;
			}
			// Disconnect any reactions owned by this reaction
			destroy_derived_effects(/** @type {Derived} **/ (dependency));
			remove_reactions(/** @type {Derived} **/ (dependency), 0);
		}
	}

	/**
	 * @param {Reaction} signal
	 * @param {number} start_index
	 * @returns {void}
	 */
	function remove_reactions(signal, start_index) {
		var dependencies = signal.deps;
		if (dependencies === null) return;

		for (var i = start_index; i < dependencies.length; i++) {
			remove_reaction(signal, dependencies[i]);
		}
	}

	/**
	 * @param {Effect} effect
	 * @returns {void}
	 */
	function update_effect(effect) {
		var flags = effect.f;

		if ((flags & DESTROYED) !== 0) {
			return;
		}

		set_signal_status(effect, CLEAN);

		var previous_effect = active_effect;
		var was_updating_effect = is_updating_effect;

		active_effect = effect;
		is_updating_effect = true;

		try {
			if ((flags & BLOCK_EFFECT) !== 0) {
				destroy_block_effect_children(effect);
			} else {
				destroy_effect_children(effect);
			}

			execute_effect_teardown(effect);
			var teardown = update_reaction(effect);
			effect.teardown = typeof teardown === 'function' ? teardown : null;
			effect.wv = write_version;

			// In DEV, increment versions of any sources that were written to during the effect,
			// so that they are correctly marked as dirty when the effect re-runs
			var dep; if (DEV && tracing_mode_flag && (effect.f & DIRTY) !== 0 && effect.deps !== null) ;
		} finally {
			is_updating_effect = was_updating_effect;
			active_effect = previous_effect;
		}
	}

	/**
	 * Returns a promise that resolves once any pending state changes have been applied.
	 * @returns {Promise<void>}
	 */
	async function tick() {

		await Promise.resolve();

		// By calling flushSync we guarantee that any pending state changes are applied after one tick.
		// TODO look into whether we can make flushing subsequent updates synchronously in the future.
		flushSync();
	}

	/**
	 * @template V
	 * @param {Value<V>} signal
	 * @returns {V}
	 */
	function get(signal) {
		var flags = signal.f;
		var is_derived = (flags & DERIVED) !== 0;

		// Register the dependency on the current reaction signal.
		if (active_reaction !== null && !untracking) {
			// if we're in a derived that is being read inside an _async_ derived,
			// it's possible that the effect was already destroyed. In this case,
			// we don't add the dependency, because that would create a memory leak
			var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;

			if (!destroyed && !current_sources?.includes(signal)) {
				var deps = active_reaction.deps;

				if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
					// we're in the effect init/update cycle
					if (signal.rv < read_version) {
						signal.rv = read_version;

						// If the signal is accessing the same dependencies in the same
						// order as it did last time, increment `skipped_deps`
						// rather than updating `new_deps`, which creates GC cost
						if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
							skipped_deps++;
						} else if (new_deps === null) {
							new_deps = [signal];
						} else if (!skip_reaction || !new_deps.includes(signal)) {
							// Normally we can push duplicated dependencies to `new_deps`, but if we're inside
							// an unowned derived because skip_reaction is true, then we need to ensure that
							// we don't have duplicates
							new_deps.push(signal);
						}
					}
				} else {
					// we're adding a dependency outside the init/update cycle
					// (i.e. after an `await`)
					(active_reaction.deps ??= []).push(signal);

					var reactions = signal.reactions;

					if (reactions === null) {
						signal.reactions = [active_reaction];
					} else if (!reactions.includes(active_reaction)) {
						reactions.push(active_reaction);
					}
				}
			}
		} else if (
			is_derived &&
			/** @type {Derived} */ (signal).deps === null &&
			/** @type {Derived} */ (signal).effects === null
		) {
			var derived = /** @type {Derived} */ (signal);
			var parent = derived.parent;

			if (parent !== null && (parent.f & UNOWNED) === 0) {
				// If the derived is owned by another derived then mark it as unowned
				// as the derived value might have been referenced in a different context
				// since and thus its parent might not be its true owner anymore
				derived.f ^= UNOWNED;
			}
		}

		if (is_destroying_effect) {
			if (old_values.has(signal)) {
				return old_values.get(signal);
			}

			if (is_derived) {
				derived = /** @type {Derived} */ (signal);

				var value = derived.v;

				// if the derived is dirty and has reactions, or depends on the values that just changed, re-execute
				// (a derived can be maybe_dirty due to the effect destroy removing its last reaction)
				if (
					((derived.f & CLEAN) === 0 && derived.reactions !== null) ||
					depends_on_old_values(derived)
				) {
					value = execute_derived(derived);
				}

				old_values.set(derived, value);

				return value;
			}
		} else if (is_derived) {
			derived = /** @type {Derived} */ (signal);

			if (is_dirty(derived)) {
				update_derived(derived);
			}
		}

		if ((signal.f & ERROR_VALUE) !== 0) {
			throw signal.v;
		}

		return signal.v;
	}

	/** @param {Derived} derived */
	function depends_on_old_values(derived) {
		if (derived.v === UNINITIALIZED) return true; // we don't know, so assume the worst
		if (derived.deps === null) return false;

		for (const dep of derived.deps) {
			if (old_values.has(dep)) {
				return true;
			}

			if ((dep.f & DERIVED) !== 0 && depends_on_old_values(/** @type {Derived} */ (dep))) {
				return true;
			}
		}

		return false;
	}

	/**
	 * When used inside a [`$derived`](https://svelte.dev/docs/svelte/$derived) or [`$effect`](https://svelte.dev/docs/svelte/$effect),
	 * any state read inside `fn` will not be treated as a dependency.
	 *
	 * ```ts
	 * $effect(() => {
	 *   // this will run when `data` changes, but not when `time` changes
	 *   save(data, {
	 *     timestamp: untrack(() => time)
	 *   });
	 * });
	 * ```
	 * @template T
	 * @param {() => T} fn
	 * @returns {T}
	 */
	function untrack(fn) {
		var previous_untracking = untracking;
		try {
			untracking = true;
			return fn();
		} finally {
			untracking = previous_untracking;
		}
	}

	const STATUS_MASK = -7169;

	/**
	 * @param {Signal} signal
	 * @param {number} status
	 * @returns {void}
	 */
	function set_signal_status(signal, status) {
		signal.f = (signal.f & STATUS_MASK) | status;
	}

	/**
	 * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.
	 * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).
	 * @param {any} value
	 * @returns {void}
	 */
	function deep_read_state(value) {
		if (typeof value !== 'object' || !value || value instanceof EventTarget) {
			return;
		}

		if (STATE_SYMBOL in value) {
			deep_read(value);
		} else if (!Array.isArray(value)) {
			for (let key in value) {
				const prop = value[key];
				if (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {
					deep_read(prop);
				}
			}
		}
	}

	/**
	 * Deeply traverse an object and read all its properties
	 * so that they're all reactive in case this is `$state`
	 * @param {any} value
	 * @param {Set<any>} visited
	 * @returns {void}
	 */
	function deep_read(value, visited = new Set()) {
		if (
			typeof value === 'object' &&
			value !== null &&
			// We don't want to traverse DOM elements
			!(value instanceof EventTarget) &&
			!visited.has(value)
		) {
			visited.add(value);
			// When working with a possible SvelteDate, this
			// will ensure we capture changes to it.
			if (value instanceof Date) {
				value.getTime();
			}
			for (let key in value) {
				try {
					deep_read(value[key], visited);
				} catch (e) {
					// continue
				}
			}
			const proto = get_prototype_of(value);
			if (
				proto !== Object.prototype &&
				proto !== Array.prototype &&
				proto !== Map.prototype &&
				proto !== Set.prototype &&
				proto !== Date.prototype
			) {
				const descriptors = get_descriptors(proto);
				for (let key in descriptors) {
					const get = descriptors[key].get;
					if (get) {
						try {
							get.call(value);
						} catch (e) {
							// continue
						}
					}
				}
			}
		}
	}

	/** @type {Set<string>} */
	const all_registered_events = new Set();

	/** @type {Set<(events: Array<string>) => void>} */
	const root_event_handles = new Set();

	/**
	 * SSR adds onload and onerror attributes to catch those events before the hydration.
	 * This function detects those cases, removes the attributes and replays the events.
	 * @param {HTMLElement} dom
	 */
	function replay_events(dom) {
		if (!hydrating) return;

		dom.removeAttribute('onload');
		dom.removeAttribute('onerror');
		// @ts-expect-error
		const event = dom.__e;
		if (event !== undefined) {
			// @ts-expect-error
			dom.__e = undefined;
			queueMicrotask(() => {
				if (dom.isConnected) {
					dom.dispatchEvent(event);
				}
			});
		}
	}

	/**
	 * @param {string} event_name
	 * @param {EventTarget} dom
	 * @param {EventListener} [handler]
	 * @param {AddEventListenerOptions} [options]
	 */
	function create_event(event_name, dom, handler, options = {}) {
		/**
		 * @this {EventTarget}
		 */
		function target_handler(/** @type {Event} */ event) {
			if (!options.capture) {
				// Only call in the bubble phase, else delegated events would be called before the capturing events
				handle_event_propagation.call(dom, event);
			}
			if (!event.cancelBubble) {
				return without_reactive_context(() => {
					return handler?.call(this, event);
				});
			}
		}

		// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned
		// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we
		// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes
		// this bug. The same applies to wheel events and touch events.
		if (
			event_name.startsWith('pointer') ||
			event_name.startsWith('touch') ||
			event_name === 'wheel'
		) {
			queue_micro_task(() => {
				dom.addEventListener(event_name, target_handler, options);
			});
		} else {
			dom.addEventListener(event_name, target_handler, options);
		}

		return target_handler;
	}

	/**
	 * @param {string} event_name
	 * @param {Element} dom
	 * @param {EventListener} [handler]
	 * @param {boolean} [capture]
	 * @param {boolean} [passive]
	 * @returns {void}
	 */
	function event(event_name, dom, handler, capture, passive) {
		var options = { capture, passive };
		var target_handler = create_event(event_name, dom, handler, options);

		if (
			dom === document.body ||
			// @ts-ignore
			dom === window ||
			// @ts-ignore
			dom === document ||
			// Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
			dom instanceof HTMLMediaElement
		) {
			teardown(() => {
				dom.removeEventListener(event_name, target_handler, options);
			});
		}
	}

	/**
	 * @param {Array<string>} events
	 * @returns {void}
	 */
	function delegate(events) {
		for (var i = 0; i < events.length; i++) {
			all_registered_events.add(events[i]);
		}

		for (var fn of root_event_handles) {
			fn(events);
		}
	}

	// used to store the reference to the currently propagated event
	// to prevent garbage collection between microtasks in Firefox
	// If the event object is GCed too early, the expando __root property
	// set on the event object is lost, causing the event delegation
	// to process the event twice
	let last_propagated_event = null;

	/**
	 * @this {EventTarget}
	 * @param {Event} event
	 * @returns {void}
	 */
	function handle_event_propagation(event) {
		var handler_element = this;
		var owner_document = /** @type {Node} */ (handler_element).ownerDocument;
		var event_name = event.type;
		var path = event.composedPath?.() || [];
		var current_target = /** @type {null | Element} */ (path[0] || event.target);

		last_propagated_event = event;

		// composedPath contains list of nodes the event has propagated through.
		// We check __root to skip all nodes below it in case this is a
		// parent of the __root node, which indicates that there's nested
		// mounted apps. In this case we don't want to trigger events multiple times.
		var path_idx = 0;

		// the `last_propagated_event === event` check is redundant, but
		// without it the variable will be DCE'd and things will
		// fail mysteriously in Firefox
		// @ts-expect-error is added below
		var handled_at = last_propagated_event === event && event.__root;

		if (handled_at) {
			var at_idx = path.indexOf(handled_at);
			if (
				at_idx !== -1 &&
				(handler_element === document || handler_element === /** @type {any} */ (window))
			) {
				// This is the fallback document listener or a window listener, but the event was already handled
				// -> ignore, but set handle_at to document/window so that we're resetting the event
				// chain in case someone manually dispatches the same event object again.
				// @ts-expect-error
				event.__root = handler_element;
				return;
			}

			// We're deliberately not skipping if the index is higher, because
			// someone could create an event programmatically and emit it multiple times,
			// in which case we want to handle the whole propagation chain properly each time.
			// (this will only be a false negative if the event is dispatched multiple times and
			// the fallback document listener isn't reached in between, but that's super rare)
			var handler_idx = path.indexOf(handler_element);
			if (handler_idx === -1) {
				// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)
				// so guard against that, too, and assume that everything was handled at this point.
				return;
			}

			if (at_idx <= handler_idx) {
				path_idx = at_idx;
			}
		}

		current_target = /** @type {Element} */ (path[path_idx] || event.target);
		// there can only be one delegated event per element, and we either already handled the current target,
		// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe
		// to handle a possible delegated event on it later (through the root delegation listener for example).
		if (current_target === handler_element) return;

		// Proxy currentTarget to correct target
		define_property(event, 'currentTarget', {
			configurable: true,
			get() {
				return current_target || owner_document;
			}
		});

		// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,
		// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic
		// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,
		// it's probably best that all event handled by Svelte have this behaviour, as we don't really want
		// an event handler to run in the context of another reaction or effect.
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);

		try {
			/**
			 * @type {unknown}
			 */
			var throw_error;
			/**
			 * @type {unknown[]}
			 */
			var other_errors = [];

			while (current_target !== null) {
				/** @type {null | Element} */
				var parent_element =
					current_target.assignedSlot ||
					current_target.parentNode ||
					/** @type {any} */ (current_target).host ||
					null;

				try {
					// @ts-expect-error
					var delegated = current_target['__' + event_name];

					if (
						delegated != null &&
						(!(/** @type {any} */ (current_target).disabled) ||
							// DOM could've been updated already by the time this is reached, so we check this as well
							// -> the target could not have been disabled because it emits the event in the first place
							event.target === current_target)
					) {
						if (is_array(delegated)) {
							var [fn, ...data] = delegated;
							fn.apply(current_target, [event, ...data]);
						} else {
							delegated.call(current_target, event);
						}
					}
				} catch (error) {
					if (throw_error) {
						other_errors.push(error);
					} else {
						throw_error = error;
					}
				}
				if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
					break;
				}
				current_target = parent_element;
			}

			if (throw_error) {
				for (let error of other_errors) {
					// Throw the rest of the errors, one-by-one on a microtask
					queueMicrotask(() => {
						throw error;
					});
				}
				throw throw_error;
			}
		} finally {
			// @ts-expect-error is used above
			event.__root = handler_element;
			// @ts-ignore remove proxy on currentTarget
			delete event.currentTarget;
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/** @param {string} html */
	function create_fragment_from_html(html) {
		var elem = document.createElement('template');
		elem.innerHTML = html.replaceAll('<!>', '<!---->'); // XHTML compliance
		return elem.content;
	}

	/** @import { Effect, TemplateNode } from '#client' */
	/** @import { TemplateStructure } from './types' */

	/**
	 * @param {TemplateNode} start
	 * @param {TemplateNode | null} end
	 */
	function assign_nodes(start, end) {
		var effect = /** @type {Effect} */ (active_effect);
		if (effect.nodes_start === null) {
			effect.nodes_start = start;
			effect.nodes_end = end;
		}
	}

	/**
	 * @param {string} content
	 * @param {number} flags
	 * @returns {() => Node | Node[]}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function from_html(content, flags) {
		var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
		var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;

		/** @type {Node} */
		var node;

		/**
		 * Whether or not the first item is a text/element node. If not, we need to
		 * create an additional comment node to act as `effect.nodes.start`
		 */
		var has_start = !content.startsWith('<!>');

		return () => {
			if (hydrating) {
				assign_nodes(hydrate_node, null);
				return hydrate_node;
			}

			if (node === undefined) {
				node = create_fragment_from_html(has_start ? content : '<!>' + content);
				if (!is_fragment) node = /** @type {Node} */ (get_first_child(node));
			}

			var clone = /** @type {TemplateNode} */ (
				use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
			);

			if (is_fragment) {
				var start = /** @type {TemplateNode} */ (get_first_child(clone));
				var end = /** @type {TemplateNode} */ (clone.lastChild);

				assign_nodes(start, end);
			} else {
				assign_nodes(clone, clone);
			}

			return clone;
		};
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {any} value
	 */
	function text(value = '') {
		if (!hydrating) {
			var t = create_text(value + '');
			assign_nodes(t, t);
			return t;
		}

		var node = hydrate_node;

		if (node.nodeType !== TEXT_NODE) {
			// if an {expression} is empty during SSR, we need to insert an empty text node
			node.before((node = create_text()));
			set_hydrate_node(node);
		}

		assign_nodes(node, node);
		return node;
	}

	/**
	 * @returns {TemplateNode | DocumentFragment}
	 */
	function comment() {
		// we're not delegating to `template` here for performance reasons
		if (hydrating) {
			assign_nodes(hydrate_node, null);
			return hydrate_node;
		}

		var frag = document.createDocumentFragment();
		var start = document.createComment('');
		var anchor = create_text();
		frag.append(start, anchor);

		assign_nodes(start, anchor);

		return frag;
	}

	/**
	 * Assign the created (or in hydration mode, traversed) dom elements to the current block
	 * and insert the elements into the dom (in client mode).
	 * @param {Text | Comment | Element} anchor
	 * @param {DocumentFragment | Element} dom
	 */
	function append(anchor, dom) {
		if (hydrating) {
			/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;
			hydrate_next();
			return;
		}

		if (anchor === null) {
			// edge case â void `<svelte:element>` with content
			return;
		}

		anchor.before(/** @type {Node} */ (dom));
	}

	const VOID_ELEMENT_NAMES = [
		'area',
		'base',
		'br',
		'col',
		'command',
		'embed',
		'hr',
		'img',
		'input',
		'keygen',
		'link',
		'meta',
		'param',
		'source',
		'track',
		'wbr'
	];

	/**
	 * Returns `true` if `name` is of a void element
	 * @param {string} name
	 */
	function is_void(name) {
		return VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === '!doctype';
	}

	/**
	 * @param {string} name
	 */
	function is_capture_event(name) {
		return name.endsWith('capture') && name !== 'gotpointercapture' && name !== 'lostpointercapture';
	}

	/** List of Element events that will be delegated */
	const DELEGATED_EVENTS = [
		'beforeinput',
		'click',
		'change',
		'dblclick',
		'contextmenu',
		'focusin',
		'focusout',
		'input',
		'keydown',
		'keyup',
		'mousedown',
		'mousemove',
		'mouseout',
		'mouseover',
		'mouseup',
		'pointerdown',
		'pointermove',
		'pointerout',
		'pointerover',
		'pointerup',
		'touchend',
		'touchmove',
		'touchstart'
	];

	/**
	 * Returns `true` if `event_name` is a delegated event
	 * @param {string} event_name
	 */
	function is_delegated(event_name) {
		return DELEGATED_EVENTS.includes(event_name);
	}

	/**
	 * @type {Record<string, string>}
	 * List of attribute names that should be aliased to their property names
	 * because they behave differently between setting them as an attribute and
	 * setting them as a property.
	 */
	const ATTRIBUTE_ALIASES = {
		// no `class: 'className'` because we handle that separately
		formnovalidate: 'formNoValidate',
		ismap: 'isMap',
		nomodule: 'noModule',
		playsinline: 'playsInline',
		readonly: 'readOnly',
		defaultvalue: 'defaultValue',
		defaultchecked: 'defaultChecked',
		srcobject: 'srcObject',
		novalidate: 'noValidate',
		allowfullscreen: 'allowFullscreen',
		disablepictureinpicture: 'disablePictureInPicture',
		disableremoteplayback: 'disableRemotePlayback'
	};

	/**
	 * @param {string} name
	 */
	function normalize_attribute(name) {
		name = name.toLowerCase();
		return ATTRIBUTE_ALIASES[name] ?? name;
	}

	/**
	 * Subset of delegated events which should be passive by default.
	 * These two are already passive via browser defaults on window, document and body.
	 * But since
	 * - we're delegating them
	 * - they happen often
	 * - they apply to mobile which is generally less performant
	 * we're marking them as passive by default for other elements, too.
	 */
	const PASSIVE_EVENTS = ['touchstart', 'touchmove'];

	/**
	 * Returns `true` if `name` is a passive event
	 * @param {string} name
	 */
	function is_passive_event(name) {
		return PASSIVE_EVENTS.includes(name);
	}

	/** List of elements that require raw contents and should not have SSR comments put in them */
	const RAW_TEXT_ELEMENTS = /** @type {const} */ (['textarea', 'script', 'style', 'title']);

	/** @param {string} name */
	function is_raw_text_element(name) {
		return RAW_TEXT_ELEMENTS.includes(/** @type {typeof RAW_TEXT_ELEMENTS[number]} */ (name));
	}

	/**
	 * Prevent devtools trying to make `location` a clickable link by inserting a zero-width space
	 * @template {string | undefined} T
	 * @param {T} location
	 * @returns {T};
	 */
	function sanitize_location(location) {
		return /** @type {T} */ (location?.replace(/\//g, '/\u200b'));
	}

	/** @import { ComponentContext, Effect, TemplateNode } from '#client' */
	/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */

	/**
	 * This is normally true â block effects should run their intro transitions â
	 * but is false during hydration (unless `options.intro` is `true`) and
	 * when creating the children of a `<svelte:element>` that just changed tag
	 */
	let should_intro = true;

	/** @param {boolean} value */
	function set_should_intro(value) {
		should_intro = value;
	}

	/**
	 * @param {Element} text
	 * @param {string} value
	 * @returns {void}
	 */
	function set_text(text, value) {
		// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing
		var str = value == null ? '' : typeof value === 'object' ? value + '' : value;
		// @ts-expect-error
		if (str !== (text.__t ??= text.nodeValue)) {
			// @ts-expect-error
			text.__t = str;
			text.nodeValue = str + '';
		}
	}

	/**
	 * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.
	 * Transitions will play during the initial render unless the `intro` option is set to `false`.
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
	 * @param {MountOptions<Props>} options
	 * @returns {Exports}
	 */
	function mount(component, options) {
		return _mount(component, options);
	}

	/**
	 * Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
	 * @param {{} extends Props ? {
	 * 		target: Document | Element | ShadowRoot;
	 * 		props?: Props;
	 * 		events?: Record<string, (e: any) => any>;
	 *  	context?: Map<any, any>;
	 * 		intro?: boolean;
	 * 		recover?: boolean;
	 * 	} : {
	 * 		target: Document | Element | ShadowRoot;
	 * 		props: Props;
	 * 		events?: Record<string, (e: any) => any>;
	 *  	context?: Map<any, any>;
	 * 		intro?: boolean;
	 * 		recover?: boolean;
	 * 	}} options
	 * @returns {Exports}
	 */
	function hydrate(component, options) {
		init_operations();
		options.intro = options.intro ?? false;
		const target = options.target;
		const was_hydrating = hydrating;
		const previous_hydrate_node = hydrate_node;

		try {
			var anchor = /** @type {TemplateNode} */ (get_first_child(target));
			while (
				anchor &&
				(anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */ (anchor).data !== HYDRATION_START)
			) {
				anchor = /** @type {TemplateNode} */ (get_next_sibling(anchor));
			}

			if (!anchor) {
				throw HYDRATION_ERROR;
			}

			set_hydrating(true);
			set_hydrate_node(/** @type {Comment} */ (anchor));

			const instance = _mount(component, { ...options, anchor });

			set_hydrating(false);

			return /**  @type {Exports} */ (instance);
		} catch (error) {
			// re-throw Svelte errors - they are certainly not related to hydration
			if (
				error instanceof Error &&
				error.message.split('\n').some((line) => line.startsWith('https://svelte.dev/e/'))
			) {
				throw error;
			}
			if (error !== HYDRATION_ERROR) {
				// eslint-disable-next-line no-console
				console.warn('Failed to hydrate: ', error);
			}

			if (options.recover === false) {
				hydration_failed();
			}

			// If an error occurred above, the operations might not yet have been initialised.
			init_operations();
			clear_text_content(target);

			set_hydrating(false);
			return mount(component, options);
		} finally {
			set_hydrating(was_hydrating);
			set_hydrate_node(previous_hydrate_node);
		}
	}

	/** @type {Map<string, number>} */
	const document_listeners = new Map();

	/**
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component
	 * @param {MountOptions} options
	 * @returns {Exports}
	 */
	function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
		init_operations();

		/** @type {Set<string>} */
		var registered_events = new Set();

		/** @param {Array<string>} events */
		var event_handle = (events) => {
			for (var i = 0; i < events.length; i++) {
				var event_name = events[i];

				if (registered_events.has(event_name)) continue;
				registered_events.add(event_name);

				var passive = is_passive_event(event_name);

				// Add the event listener to both the container and the document.
				// The container listener ensures we catch events from within in case
				// the outer content stops propagation of the event.
				target.addEventListener(event_name, handle_event_propagation, { passive });

				var n = document_listeners.get(event_name);

				if (n === undefined) {
					// The document listener ensures we catch events that originate from elements that were
					// manually moved outside of the container (e.g. via manual portals).
					document.addEventListener(event_name, handle_event_propagation, { passive });
					document_listeners.set(event_name, 1);
				} else {
					document_listeners.set(event_name, n + 1);
				}
			}
		};

		event_handle(array_from(all_registered_events));
		root_event_handles.add(event_handle);

		/** @type {Exports} */
		// @ts-expect-error will be defined because the render effect runs synchronously
		var component = undefined;

		var unmount = component_root(() => {
			var anchor_node = anchor ?? target.appendChild(create_text());

			boundary(
				/** @type {TemplateNode} */ (anchor_node),
				{
					pending: () => {}
				},
				(anchor_node) => {
					if (context) {
						push({});
						var ctx = /** @type {ComponentContext} */ (component_context);
						ctx.c = context;
					}

					if (events) {
						// We can't spread the object or else we'd lose the state proxy stuff, if it is one
						/** @type {any} */ (props).$$events = events;
					}

					if (hydrating) {
						assign_nodes(/** @type {TemplateNode} */ (anchor_node), null);
					}

					should_intro = intro;
					// @ts-expect-error the public typings are not what the actual function looks like
					component = Component(anchor_node, props) || {};
					should_intro = true;

					if (hydrating) {
						/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;

						if (
							hydrate_node === null ||
							hydrate_node.nodeType !== COMMENT_NODE ||
							/** @type {Comment} */ (hydrate_node).data !== HYDRATION_END
						) {
							hydration_mismatch();
							throw HYDRATION_ERROR;
						}
					}

					if (context) {
						pop();
					}
				}
			);

			return () => {
				for (var event_name of registered_events) {
					target.removeEventListener(event_name, handle_event_propagation);

					var n = /** @type {number} */ (document_listeners.get(event_name));

					if (--n === 0) {
						document.removeEventListener(event_name, handle_event_propagation);
						document_listeners.delete(event_name);
					} else {
						document_listeners.set(event_name, n);
					}
				}

				root_event_handles.delete(event_handle);

				if (anchor_node !== anchor) {
					anchor_node.parentNode?.removeChild(anchor_node);
				}
			};
		});

		mounted_components.set(component, unmount);
		return component;
	}

	/**
	 * References of the components that were mounted or hydrated.
	 * Uses a `WeakMap` to avoid memory leaks.
	 */
	let mounted_components = new WeakMap();

	/**
	 * Unmounts a component that was previously mounted using `mount` or `hydrate`.
	 *
	 * Since 5.13.0, if `options.outro` is `true`, [transitions](https://svelte.dev/docs/svelte/transition) will play before the component is removed from the DOM.
	 *
	 * Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).
	 *
	 * ```js
	 * import { mount, unmount } from 'svelte';
	 * import App from './App.svelte';
	 *
	 * const app = mount(App, { target: document.body });
	 *
	 * // later...
	 * unmount(app, { outro: true });
	 * ```
	 * @param {Record<string, any>} component
	 * @param {{ outro?: boolean }} [options]
	 * @returns {Promise<void>}
	 */
	function unmount(component, options) {
		const fn = mounted_components.get(component);

		if (fn) {
			mounted_components.delete(component);
			return fn(options);
		}

		return Promise.resolve();
	}

	/**
	 * @param {() => string} tag_fn
	 * @returns {void}
	 */
	function validate_void_dynamic_element(tag_fn) {
		const tag = tag_fn();
		if (tag && is_void(tag)) {
			dynamic_void_element_content();
		}
	}

	/** @param {() => unknown} tag_fn */
	function validate_dynamic_element_tag(tag_fn) {
		const tag = tag_fn();
		const is_string = typeof tag === 'string';
		if (tag && !is_string) {
			svelte_element_invalid_this_value();
		}
	}

	/** @import { ComponentContext, ComponentContextLegacy } from '#client' */
	/** @import { EventDispatcher } from './index.js' */
	/** @import { NotFunction } from './internal/types.js' */

	/**
	 * `onMount`, like [`$effect`](https://svelte.dev/docs/svelte/$effect), schedules a function to run as soon as the component has been mounted to the DOM.
	 * Unlike `$effect`, the provided function only runs once.
	 *
	 * It must be called during the component's initialisation (but doesn't need to live _inside_ the component;
	 * it can be called from an external module). If a function is returned _synchronously_ from `onMount`,
	 * it will be called when the component is unmounted.
	 *
	 * `onMount` functions do not run during [server-side rendering](https://svelte.dev/docs/svelte/svelte-server#render).
	 *
	 * @template T
	 * @param {() => NotFunction<T> | Promise<NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
		if (component_context === null) {
			lifecycle_outside_component();
		}

		if (legacy_mode_flag && component_context.l !== null) {
			init_update_callbacks(component_context).m.push(fn);
		} else {
			user_effect(() => {
				const cleanup = untrack(fn);
				if (typeof cleanup === 'function') return /** @type {() => void} */ (cleanup);
			});
		}
	}

	/**
	 * Legacy-mode: Init callbacks object for onMount/beforeUpdate/afterUpdate
	 * @param {ComponentContext} context
	 */
	function init_update_callbacks(context) {
		var l = /** @type {ComponentContextLegacy} */ (context).l;
		return (l.u ??= { a: [], b: [], m: [] });
	}

	/** @import { SourceLocation } from '#client' */

	/**
	 * @param {any} fn
	 * @param {string} filename
	 * @param {SourceLocation[]} locations
	 * @returns {any}
	 */
	function add_locations(fn, filename, locations) {
		return (/** @type {any[]} */ ...args) => {
			const dom = fn(...args);

			var node = hydrating ? dom : dom.nodeType === DOCUMENT_FRAGMENT_NODE ? dom.firstChild : dom;
			assign_locations(node, filename, locations);

			return dom;
		};
	}

	/**
	 * @param {Element} element
	 * @param {string} filename
	 * @param {SourceLocation} location
	 */
	function assign_location(element, filename, location) {
		// @ts-expect-error
		element.__svelte_meta = {
			parent: dev_stack,
			loc: { file: filename, line: location[0], column: location[1] }
		};

		if (location[2]) {
			assign_locations(element.firstChild, filename, location[2]);
		}
	}

	/**
	 * @param {Node | null} node
	 * @param {string} filename
	 * @param {SourceLocation[]} locations
	 */
	function assign_locations(node, filename, locations) {
		var i = 0;
		var depth = 0;

		while (node && i < locations.length) {
			if (hydrating && node.nodeType === COMMENT_NODE) {
				var comment = /** @type {Comment} */ (node);
				if (comment.data === HYDRATION_START || comment.data === HYDRATION_START_ELSE) depth += 1;
				else if (comment.data[0] === HYDRATION_END) depth -= 1;
			}

			if (depth === 0 && node.nodeType === ELEMENT_NODE) {
				assign_location(/** @type {Element} */ (node), filename, locations[i++]);
			}

			node = node.nextSibling;
		}
	}

	/** @typedef {{ file: string, line: number, column: number }} Location */


	/**
	 * Sets up a validator that
	 * - traverses the path of a prop to find out if it is allowed to be mutated
	 * - checks that the binding chain is not interrupted
	 * @param {Record<string, any>} props
	 */
	function create_ownership_validator(props) {
		const component = component_context?.function;
		const parent = component_context?.p?.function;

		return {
			/**
			 * @param {string} prop
			 * @param {any[]} path
			 * @param {any} result
			 * @param {number} line
			 * @param {number} column
			 */
			mutation: (prop, path, result, line, column) => {
				const name = path[0];
				if (is_bound_or_unset(props, name) || !parent) {
					return result;
				}

				/** @type {any} */
				let value = props;

				for (let i = 0; i < path.length - 1; i++) {
					value = value[path[i]];
					if (!value?.[STATE_SYMBOL]) {
						return result;
					}
				}

				const location = sanitize_location(`${component[FILENAME]}:${line}:${column}`);

				ownership_invalid_mutation(name, location, prop, parent[FILENAME]);

				return result;
			},
			/**
			 * @param {any} key
			 * @param {any} child_component
			 * @param {() => any} value
			 */
			binding: (key, child_component, value) => {
				if (!is_bound_or_unset(props, key) && parent && value()?.[STATE_SYMBOL]) {
					ownership_invalid_binding(
						component[FILENAME],
						key,
						child_component[FILENAME],
						parent[FILENAME]
					);
				}
			}
		};
	}

	/**
	 * @param {Record<string, any>} props
	 * @param {string} prop_name
	 */
	function is_bound_or_unset(props, prop_name) {
		// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`
		// or `createClassComponent(Component, props)`
		const is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
		return (
			!!get_descriptor(props, prop_name)?.set ||
			(is_entry_props && prop_name in props) ||
			!(prop_name in props)
		);
	}

	/** @param {Function & { [FILENAME]: string }} target */
	function check_target(target) {
		if (target) {
			component_api_invalid_new(target[FILENAME] ?? 'a component', target.name);
		}
	}

	function legacy_api() {
		const component = component_context?.function;

		/** @param {string} method */
		function error(method) {
			component_api_changed(method, component[FILENAME]);
		}

		return {
			$destroy: () => error('$destroy()'),
			$on: () => error('$on(...)'),
			$set: () => error('$set(...)')
		};
	}

	/** @import { Effect, TemplateNode } from '#client' */
	/** @import { Batch } from '../../reactivity/batch.js'; */

	// TODO reinstate https://github.com/sveltejs/svelte/pull/15250

	/**
	 * @param {TemplateNode} node
	 * @param {(branch: (fn: (anchor: Node) => void, flag?: boolean) => void) => void} fn
	 * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'
	 * @returns {void}
	 */
	function if_block(node, fn, elseif = false) {
		if (hydrating) {
			hydrate_next();
		}

		var anchor = node;

		/** @type {Effect | null} */
		var consequent_effect = null;

		/** @type {Effect | null} */
		var alternate_effect = null;

		/** @type {typeof UNINITIALIZED | boolean | null} */
		var condition = UNINITIALIZED;

		var flags = elseif ? EFFECT_TRANSPARENT : 0;

		var has_branch = false;

		const set_branch = (/** @type {(anchor: Node) => void} */ fn, flag = true) => {
			has_branch = true;
			update_branch(flag, fn);
		};

		/** @type {DocumentFragment | null} */
		var offscreen_fragment = null;

		function commit() {
			if (offscreen_fragment !== null) {
				// remove the anchor
				/** @type {Text} */ (offscreen_fragment.lastChild).remove();

				anchor.before(offscreen_fragment);
				offscreen_fragment = null;
			}

			var active = condition ? consequent_effect : alternate_effect;
			var inactive = condition ? alternate_effect : consequent_effect;

			if (active) {
				resume_effect(active);
			}

			if (inactive) {
				pause_effect(inactive, () => {
					if (condition) {
						alternate_effect = null;
					} else {
						consequent_effect = null;
					}
				});
			}
		}

		const update_branch = (
			/** @type {boolean | null} */ new_condition,
			/** @type {null | ((anchor: Node) => void)} */ fn
		) => {
			if (condition === (condition = new_condition)) return;

			/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */
			let mismatch = false;

			if (hydrating) {
				const is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;

				if (!!condition === is_else) {
					// Hydration mismatch: remove everything inside the anchor and start fresh.
					// This could happen with `{#if browser}...{/if}`, for example
					anchor = skip_nodes();

					set_hydrate_node(anchor);
					set_hydrating(false);
					mismatch = true;
				}
			}

			var defer = should_defer_append();
			var target = anchor;

			if (defer) {
				offscreen_fragment = document.createDocumentFragment();
				offscreen_fragment.append((target = create_text()));
			}

			if (condition) {
				consequent_effect ??= fn && branch(() => fn(target));
			} else {
				alternate_effect ??= fn && branch(() => fn(target));
			}

			if (defer) {
				var batch = /** @type {Batch} */ (current_batch);

				var active = condition ? consequent_effect : alternate_effect;
				var inactive = condition ? alternate_effect : consequent_effect;

				if (active) batch.skipped_effects.delete(active);
				if (inactive) batch.skipped_effects.add(inactive);

				batch.add_callback(commit);
			} else {
				commit();
			}

			if (mismatch) {
				// continue in hydration mode
				set_hydrating(true);
			}
		};

		block(() => {
			has_branch = false;
			fn(set_branch);
			if (!has_branch) {
				update_branch(null, null);
			}
		}, flags);

		if (hydrating) {
			anchor = hydrate_node;
		}
	}

	/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */
	/** @import { Batch } from '../../reactivity/batch.js'; */

	/**
	 * @param {any} _
	 * @param {number} i
	 */
	function index(_, i) {
		return i;
	}

	/**
	 * Pause multiple effects simultaneously, and coordinate their
	 * subsequent destruction. Used in each blocks
	 * @param {EachState} state
	 * @param {EachItem[]} items
	 * @param {null | Node} controlled_anchor
	 */
	function pause_effects(state, items, controlled_anchor) {
		var items_map = state.items;

		/** @type {TransitionManager[]} */
		var transitions = [];
		var length = items.length;

		for (var i = 0; i < length; i++) {
			pause_children(items[i].e, transitions, true);
		}

		var is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;
		// If we have a controlled anchor, it means that the each block is inside a single
		// DOM element, so we can apply a fast-path for clearing the contents of the element.
		if (is_controlled) {
			var parent_node = /** @type {Element} */ (
				/** @type {Element} */ (controlled_anchor).parentNode
			);
			clear_text_content(parent_node);
			parent_node.append(/** @type {Element} */ (controlled_anchor));
			items_map.clear();
			link(state, items[0].prev, items[length - 1].next);
		}

		run_out_transitions(transitions, () => {
			for (var i = 0; i < length; i++) {
				var item = items[i];
				if (!is_controlled) {
					items_map.delete(item.k);
					link(state, item.prev, item.next);
				}
				destroy_effect(item.e, !is_controlled);
			}
		});
	}

	/**
	 * @template V
	 * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @param {(value: V, index: number) => any} get_key
	 * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn
	 * @param {null | ((anchor: Node) => void)} fallback_fn
	 * @returns {void}
	 */
	function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {
		var anchor = node;

		/** @type {EachState} */
		var state = { flags, items: new Map(), first: null };

		var is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;

		if (is_controlled) {
			var parent_node = /** @type {Element} */ (node);

			anchor = hydrating
				? set_hydrate_node(/** @type {Comment | Text} */ (get_first_child(parent_node)))
				: parent_node.appendChild(create_text());
		}

		if (hydrating) {
			hydrate_next();
		}

		/** @type {Effect | null} */
		var fallback = null;

		var was_empty = false;

		/** @type {Map<any, EachItem>} */
		var offscreen_items = new Map();

		// TODO: ideally we could use derived for runes mode but because of the ability
		// to use a store which can be mutated, we can't do that here as mutating a store
		// will still result in the collection array being the same from the store
		var each_array = derived_safe_equal(() => {
			var collection = get_collection();

			return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
		});

		/** @type {V[]} */
		var array;

		/** @type {Effect} */
		var each_effect;

		function commit() {
			reconcile(
				each_effect,
				array,
				state,
				offscreen_items,
				anchor,
				render_fn,
				flags,
				get_key,
				get_collection
			);

			if (fallback_fn !== null) {
				if (array.length === 0) {
					if (fallback) {
						resume_effect(fallback);
					} else {
						fallback = branch(() => fallback_fn(anchor));
					}
				} else if (fallback !== null) {
					pause_effect(fallback, () => {
						fallback = null;
					});
				}
			}
		}

		block(() => {
			// store a reference to the effect so that we can update the start/end nodes in reconciliation
			each_effect ??= /** @type {Effect} */ (active_effect);

			array = /** @type {V[]} */ (get(each_array));
			var length = array.length;

			if (was_empty && length === 0) {
				// ignore updates if the array is empty,
				// and it already was empty on previous run
				return;
			}
			was_empty = length === 0;

			/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */
			let mismatch = false;

			if (hydrating) {
				var is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;

				if (is_else !== (length === 0)) {
					// hydration mismatch â remove the server-rendered DOM and start over
					anchor = skip_nodes();

					set_hydrate_node(anchor);
					set_hydrating(false);
					mismatch = true;
				}
			}

			// this is separate to the previous block because `hydrating` might change
			if (hydrating) {
				/** @type {EachItem | null} */
				var prev = null;

				/** @type {EachItem} */
				var item;

				for (var i = 0; i < length; i++) {
					if (
						hydrate_node.nodeType === COMMENT_NODE &&
						/** @type {Comment} */ (hydrate_node).data === HYDRATION_END
					) {
						// The server rendered fewer items than expected,
						// so break out and continue appending non-hydrated items
						anchor = /** @type {Comment} */ (hydrate_node);
						mismatch = true;
						set_hydrating(false);
						break;
					}

					var value = array[i];
					var key = get_key(value, i);
					item = create_item(
						hydrate_node,
						state,
						prev,
						null,
						value,
						key,
						i,
						render_fn,
						flags,
						get_collection
					);
					state.items.set(key, item);

					prev = item;
				}

				// remove excess nodes
				if (length > 0) {
					set_hydrate_node(skip_nodes());
				}
			}

			if (hydrating) {
				if (length === 0 && fallback_fn) {
					fallback = branch(() => fallback_fn(anchor));
				}
			} else {
				if (should_defer_append()) {
					var keys = new Set();
					var batch = /** @type {Batch} */ (current_batch);

					for (i = 0; i < length; i += 1) {
						value = array[i];
						key = get_key(value, i);

						var existing = state.items.get(key) ?? offscreen_items.get(key);

						if (existing) {
							// update before reconciliation, to trigger any async updates
							if ((flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0) {
								update_item(existing, value, i, flags);
							}
						} else {
							item = create_item(
								null,
								state,
								null,
								null,
								value,
								key,
								i,
								render_fn,
								flags,
								get_collection,
								true
							);

							offscreen_items.set(key, item);
						}

						keys.add(key);
					}

					for (const [key, item] of state.items) {
						if (!keys.has(key)) {
							batch.skipped_effects.add(item.e);
						}
					}

					batch.add_callback(commit);
				} else {
					commit();
				}
			}

			if (mismatch) {
				// continue in hydration mode
				set_hydrating(true);
			}

			// When we mount the each block for the first time, the collection won't be
			// connected to this effect as the effect hasn't finished running yet and its deps
			// won't be assigned. However, it's possible that when reconciling the each block
			// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the
			// collection again can provide consistency to the reactive graph again as the deriveds
			// will now be `CLEAN`.
			get(each_array);
		});

		if (hydrating) {
			anchor = hydrate_node;
		}
	}

	/**
	 * Add, remove, or reorder items output by an each block as its input changes
	 * @template V
	 * @param {Effect} each_effect
	 * @param {Array<V>} array
	 * @param {EachState} state
	 * @param {Map<any, EachItem>} offscreen_items
	 * @param {Element | Comment | Text} anchor
	 * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>, collection: () => V[]) => void} render_fn
	 * @param {number} flags
	 * @param {(value: V, index: number) => any} get_key
	 * @param {() => V[]} get_collection
	 * @returns {void}
	 */
	function reconcile(
		each_effect,
		array,
		state,
		offscreen_items,
		anchor,
		render_fn,
		flags,
		get_key,
		get_collection
	) {
		var is_animated = (flags & EACH_IS_ANIMATED) !== 0;
		var should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;

		var length = array.length;
		var items = state.items;
		var first = state.first;
		var current = first;

		/** @type {undefined | Set<EachItem>} */
		var seen;

		/** @type {EachItem | null} */
		var prev = null;

		/** @type {undefined | Set<EachItem>} */
		var to_animate;

		/** @type {EachItem[]} */
		var matched = [];

		/** @type {EachItem[]} */
		var stashed = [];

		/** @type {V} */
		var value;

		/** @type {any} */
		var key;

		/** @type {EachItem | undefined} */
		var item;

		/** @type {number} */
		var i;

		if (is_animated) {
			for (i = 0; i < length; i += 1) {
				value = array[i];
				key = get_key(value, i);
				item = items.get(key);

				if (item !== undefined) {
					item.a?.measure();
					(to_animate ??= new Set()).add(item);
				}
			}
		}

		for (i = 0; i < length; i += 1) {
			value = array[i];
			key = get_key(value, i);

			item = items.get(key);

			if (item === undefined) {
				var pending = offscreen_items.get(key);

				if (pending !== undefined) {
					offscreen_items.delete(key);
					items.set(key, pending);

					var next = prev ? prev.next : current;

					link(state, prev, pending);
					link(state, pending, next);

					move(pending, next, anchor);
					prev = pending;
				} else {
					var child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;

					prev = create_item(
						child_anchor,
						state,
						prev,
						prev === null ? state.first : prev.next,
						value,
						key,
						i,
						render_fn,
						flags,
						get_collection
					);
				}

				items.set(key, prev);

				matched = [];
				stashed = [];

				current = prev.next;
				continue;
			}

			if (should_update) {
				update_item(item, value, i, flags);
			}

			if ((item.e.f & INERT) !== 0) {
				resume_effect(item.e);
				if (is_animated) {
					item.a?.unfix();
					(to_animate ??= new Set()).delete(item);
				}
			}

			if (item !== current) {
				if (seen !== undefined && seen.has(item)) {
					if (matched.length < stashed.length) {
						// more efficient to move later items to the front
						var start = stashed[0];
						var j;

						prev = start.prev;

						var a = matched[0];
						var b = matched[matched.length - 1];

						for (j = 0; j < matched.length; j += 1) {
							move(matched[j], start, anchor);
						}

						for (j = 0; j < stashed.length; j += 1) {
							seen.delete(stashed[j]);
						}

						link(state, a.prev, b.next);
						link(state, prev, a);
						link(state, b, start);

						current = start;
						prev = b;
						i -= 1;

						matched = [];
						stashed = [];
					} else {
						// more efficient to move earlier items to the back
						seen.delete(item);
						move(item, current, anchor);

						link(state, item.prev, item.next);
						link(state, item, prev === null ? state.first : prev.next);
						link(state, prev, item);

						prev = item;
					}

					continue;
				}

				matched = [];
				stashed = [];

				while (current !== null && current.k !== key) {
					// If the each block isn't inert and an item has an effect that is already inert,
					// skip over adding it to our seen Set as the item is already being handled
					if ((current.e.f & INERT) === 0) {
						(seen ??= new Set()).add(current);
					}
					stashed.push(current);
					current = current.next;
				}

				if (current === null) {
					continue;
				}

				item = current;
			}

			matched.push(item);
			prev = item;
			current = item.next;
		}

		if (current !== null || seen !== undefined) {
			var to_destroy = seen === undefined ? [] : array_from(seen);

			while (current !== null) {
				// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished
				if ((current.e.f & INERT) === 0) {
					to_destroy.push(current);
				}
				current = current.next;
			}

			var destroy_length = to_destroy.length;

			if (destroy_length > 0) {
				var controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;

				if (is_animated) {
					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.measure();
					}

					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.fix();
					}
				}

				pause_effects(state, to_destroy, controlled_anchor);
			}
		}

		if (is_animated) {
			queue_micro_task(() => {
				if (to_animate === undefined) return;
				for (item of to_animate) {
					item.a?.apply();
				}
			});
		}

		each_effect.first = state.first && state.first.e;
		each_effect.last = prev && prev.e;

		for (var unused of offscreen_items.values()) {
			destroy_effect(unused.e);
		}

		offscreen_items.clear();
	}

	/**
	 * @param {EachItem} item
	 * @param {any} value
	 * @param {number} index
	 * @param {number} type
	 * @returns {void}
	 */
	function update_item(item, value, index, type) {
		if ((type & EACH_ITEM_REACTIVE) !== 0) {
			internal_set(item.v, value);
		}

		if ((type & EACH_INDEX_REACTIVE) !== 0) {
			internal_set(/** @type {Value<number>} */ (item.i), index);
		} else {
			item.i = index;
		}
	}

	/**
	 * @template V
	 * @param {Node | null} anchor
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 * @param {V} value
	 * @param {unknown} key
	 * @param {number} index
	 * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>, collection: () => V[]) => void} render_fn
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @param {boolean} [deferred]
	 * @returns {EachItem}
	 */
	function create_item(
		anchor,
		state,
		prev,
		next,
		value,
		key,
		index,
		render_fn,
		flags,
		get_collection,
		deferred
	) {
		var reactive = (flags & EACH_ITEM_REACTIVE) !== 0;
		var mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;

		var v = reactive ? (mutable ? mutable_source(value, false, false) : source(value)) : value;
		var i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);

		/** @type {EachItem} */
		var item = {
			i,
			v,
			k: key,
			a: null,
			// @ts-expect-error
			e: null,
			prev,
			next
		};

		try {
			if (anchor === null) {
				var fragment = document.createDocumentFragment();
				fragment.append((anchor = create_text()));
			}

			item.e = branch(() => render_fn(/** @type {Node} */ (anchor), v, i, get_collection), hydrating);

			item.e.prev = prev && prev.e;
			item.e.next = next && next.e;

			if (prev === null) {
				if (!deferred) {
					state.first = item;
				}
			} else {
				prev.next = item;
				prev.e.next = item.e;
			}

			if (next !== null) {
				next.prev = item;
				next.e.prev = item.e;
			}

			return item;
		} finally {
		}
	}

	/**
	 * @param {EachItem} item
	 * @param {EachItem | null} next
	 * @param {Text | Element | Comment} anchor
	 */
	function move(item, next, anchor) {
		var end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;

		var dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;
		var node = /** @type {TemplateNode} */ (item.e.nodes_start);

		while (node !== null && node !== end) {
			var next_node = /** @type {TemplateNode} */ (get_next_sibling(node));
			dest.before(node);
			node = next_node;
		}
	}

	/**
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 */
	function link(state, prev, next) {
		if (prev === null) {
			state.first = next;
		} else {
			prev.next = next;
			prev.e.next = next && next.e;
		}

		if (next !== null) {
			next.prev = prev;
			next.e.prev = prev && prev.e;
		}
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {Element | Text | Comment} node
	 * @param {() => string} get_value
	 * @param {boolean} [svg]
	 * @param {boolean} [mathml]
	 * @param {boolean} [skip_warning]
	 * @returns {void}
	 */
	function html(node, get_value, svg = false, mathml = false, skip_warning = false) {
		var anchor = node;

		var value = '';

		template_effect(() => {
			var effect = /** @type {Effect} */ (active_effect);

			if (value === (value = get_value() ?? '')) {
				if (hydrating) hydrate_next();
				return;
			}

			if (effect.nodes_start !== null) {
				remove_effect_dom(effect.nodes_start, /** @type {TemplateNode} */ (effect.nodes_end));
				effect.nodes_start = effect.nodes_end = null;
			}

			if (value === '') return;

			if (hydrating) {
				// We're deliberately not trying to repair mismatches between server and client,
				// as it's costly and error-prone (and it's an edge case to have a mismatch anyway)
				/** @type {Comment} */ (hydrate_node).data;
				var next = hydrate_next();
				var last = next;

				while (
					next !== null &&
					(next.nodeType !== COMMENT_NODE || /** @type {Comment} */ (next).data !== '')
				) {
					last = next;
					next = /** @type {TemplateNode} */ (get_next_sibling(next));
				}

				if (next === null) {
					hydration_mismatch();
					throw HYDRATION_ERROR;
				}

				assign_nodes(hydrate_node, last);
				anchor = set_hydrate_node(next);
				return;
			}

			var html = value + '';
			if (svg) html = `<svg>${html}</svg>`;
			else if (mathml) html = `<math>${html}</math>`;

			// Don't use create_fragment_with_script_from_html here because that would mean script tags are executed.
			// @html is basically `.innerHTML = ...` and that doesn't execute scripts either due to security reasons.
			/** @type {DocumentFragment | Element} */
			var node = create_fragment_from_html(html);

			if (svg || mathml) {
				node = /** @type {Element} */ (get_first_child(node));
			}

			assign_nodes(
				/** @type {TemplateNode} */ (get_first_child(node)),
				/** @type {TemplateNode} */ (node.lastChild)
			);

			if (svg || mathml) {
				while (get_first_child(node)) {
					anchor.before(/** @type {Node} */ (get_first_child(node)));
				}
			} else {
				anchor.before(node);
			}
		});
	}

	/**
	 * @param {Comment} anchor
	 * @param {Record<string, any>} $$props
	 * @param {string} name
	 * @param {Record<string, unknown>} slot_props
	 * @param {null | ((anchor: Comment) => void)} fallback_fn
	 */
	function slot(anchor, $$props, name, slot_props, fallback_fn) {
		if (hydrating) {
			hydrate_next();
		}

		var slot_fn = $$props.$$slots?.[name];
		// Interop: Can use snippets to fill slots
		var is_interop = false;
		if (slot_fn === true) {
			slot_fn = $$props[name === 'default' ? 'children' : name];
			is_interop = true;
		}

		if (slot_fn === undefined) ; else {
			slot_fn(anchor, is_interop ? () => slot_props : slot_props);
		}
	}

	/**
	 * @param {Record<string, any>} props
	 * @returns {Record<string, boolean>}
	 */
	function sanitize_slots(props) {
		/** @type {Record<string, boolean>} */
		const sanitized = {};
		if (props.children) sanitized.default = true;
		for (const key in props.$$slots) {
			sanitized[key] = true;
		}
		return sanitized;
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {Comment | Element} node
	 * @param {() => string} get_tag
	 * @param {boolean} is_svg
	 * @param {undefined | ((element: Element, anchor: Node | null) => void)} render_fn,
	 * @param {undefined | (() => string)} get_namespace
	 * @param {undefined | [number, number]} location
	 * @returns {void}
	 */
	function element(node, get_tag, is_svg, render_fn, get_namespace, location) {
		let was_hydrating = hydrating;

		if (hydrating) {
			hydrate_next();
		}

		/** @type {string | null} */
		var tag;

		/** @type {string | null} */
		var current_tag;

		/** @type {null | Element} */
		var element = null;

		if (hydrating && hydrate_node.nodeType === ELEMENT_NODE) {
			element = /** @type {Element} */ (hydrate_node);
			hydrate_next();
		}

		var anchor = /** @type {TemplateNode} */ (hydrating ? hydrate_node : node);

		/** @type {Effect | null} */
		var effect;

		block(() => {
			const next_tag = get_tag() || null;
			var ns = next_tag === 'svg' ? NAMESPACE_SVG : null;

			// Assumption: Noone changes the namespace but not the tag (what would that even mean?)
			if (next_tag === tag) return;

			if (effect) {
				if (next_tag === null) {
					// start outro
					pause_effect(effect, () => {
						effect = null;
						current_tag = null;
					});
				} else if (next_tag === current_tag) {
					// same tag as is currently rendered â abort outro
					resume_effect(effect);
				} else {
					// tag is changing â destroy immediately, render contents without intro transitions
					destroy_effect(effect);
					set_should_intro(false);
				}
			}

			if (next_tag && next_tag !== current_tag) {
				effect = branch(() => {
					element = hydrating
						? /** @type {Element} */ (element)
						: ns
							? document.createElementNS(ns, next_tag)
							: document.createElement(next_tag);

					assign_nodes(element, element);

					if (render_fn) {
						if (hydrating && is_raw_text_element(next_tag)) {
							// prevent hydration glitches
							element.append(document.createComment(''));
						}

						// If hydrating, use the existing ssr comment as the anchor so that the
						// inner open and close methods can pick up the existing nodes correctly
						var child_anchor = /** @type {TemplateNode} */ (
							hydrating ? get_first_child(element) : element.appendChild(create_text())
						);

						if (hydrating) {
							if (child_anchor === null) {
								set_hydrating(false);
							} else {
								set_hydrate_node(child_anchor);
							}
						}

						// `child_anchor` is undefined if this is a void element, but we still
						// need to call `render_fn` in order to run actions etc. If the element
						// contains children, it's a user error (which is warned on elsewhere)
						// and the DOM will be silently discarded
						render_fn(element, child_anchor);
					}

					// we do this after calling `render_fn` so that child effects don't override `nodes.end`
					/** @type {Effect} */ (active_effect).nodes_end = element;

					anchor.before(element);
				});
			}

			tag = next_tag;
			if (tag) current_tag = tag;
			set_should_intro(true);
		}, EFFECT_TRANSPARENT);

		if (was_hydrating) {
			set_hydrating(true);
			set_hydrate_node(anchor);
		}
	}

	/**
	 * @param {Node} anchor
	 * @param {{ hash: string, code: string }} css
	 */
	function append_styles$1(anchor, css) {
		// Use `queue_micro_task` to ensure `anchor` is in the DOM, otherwise getRootNode() will yield wrong results
		effect(() => {
			var root = anchor.getRootNode();

			var target = /** @type {ShadowRoot} */ (root).host
				? /** @type {ShadowRoot} */ (root)
				: /** @type {Document} */ (root).head ?? /** @type {Document} */ (root.ownerDocument).head;

			// Always querying the DOM is roughly the same perf as additionally checking for presence in a map first assuming
			// that you'll get cache hits half of the time, so we just always query the dom for simplicity and code savings.
			if (!target.querySelector('#' + css.hash)) {
				const style = document.createElement('style');
				style.id = css.hash;
				style.textContent = css.code;

				target.appendChild(style);
			}
		});
	}

	/** @import { Effect } from '#client' */

	// TODO in 6.0 or 7.0, when we remove legacy mode, we can simplify this by
	// getting rid of the block/branch stuff and just letting the effect rip.
	// see https://github.com/sveltejs/svelte/pull/15962

	/**
	 * @param {Element} node
	 * @param {() => (node: Element) => void} get_fn
	 */
	function attach(node, get_fn) {
		/** @type {false | undefined | ((node: Element) => void)} */
		var fn = undefined;

		/** @type {Effect | null} */
		var e;

		block(() => {
			if (fn !== (fn = get_fn())) {
				if (e) {
					destroy_effect(e);
					e = null;
				}

				if (fn) {
					e = branch(() => {
						effect(() => /** @type {(node: Element) => void} */ (fn)(node));
					});
				}
			}
		});
	}

	function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);}else for(f in e)e[f]&&(n&&(n+=" "),n+=f);return n}function clsx$1(){for(var e,t,f=0,n="",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}

	/**
	 * Small wrapper around clsx to preserve Svelte's (weird) handling of falsy values.
	 * TODO Svelte 6 revisit this, and likely turn all falsy values into the empty string (what clsx also does)
	 * @param  {any} value
	 */
	function clsx(value) {
		if (typeof value === 'object') {
			return clsx$1(value);
		} else {
			return value ?? '';
		}
	}

	const whitespace = [...' \t\n\r\f\u00a0\u000b\ufeff'];

	/**
	 * @param {any} value
	 * @param {string | null} [hash]
	 * @param {Record<string, boolean>} [directives]
	 * @returns {string | null}
	 */
	function to_class(value, hash, directives) {
		var classname = value == null ? '' : '' + value;

		if (hash) {
			classname = classname ? classname + ' ' + hash : hash;
		}

		if (directives) {
			for (var key in directives) {
				if (directives[key]) {
					classname = classname ? classname + ' ' + key : key;
				} else if (classname.length) {
					var len = key.length;
					var a = 0;

					while ((a = classname.indexOf(key, a)) >= 0) {
						var b = a + len;

						if (
							(a === 0 || whitespace.includes(classname[a - 1])) &&
							(b === classname.length || whitespace.includes(classname[b]))
						) {
							classname = (a === 0 ? '' : classname.substring(0, a)) + classname.substring(b + 1);
						} else {
							a = b;
						}
					}
				}
			}
		}

		return classname === '' ? null : classname;
	}

	/**
	 *
	 * @param {Record<string,any>} styles
	 * @param {boolean} important
	 */
	function append_styles(styles, important = false) {
		var separator = important ? ' !important;' : ';';
		var css = '';

		for (var key in styles) {
			var value = styles[key];
			if (value != null && value !== '') {
				css += ' ' + key + ': ' + value + separator;
			}
		}

		return css;
	}

	/**
	 * @param {string} name
	 * @returns {string}
	 */
	function to_css_name(name) {
		if (name[0] !== '-' || name[1] !== '-') {
			return name.toLowerCase();
		}
		return name;
	}

	/**
	 * @param {any} value
	 * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [styles]
	 * @returns {string | null}
	 */
	function to_style(value, styles) {
		if (styles) {
			var new_style = '';

			/** @type {Record<string,any> | undefined} */
			var normal_styles;

			/** @type {Record<string,any> | undefined} */
			var important_styles;

			if (Array.isArray(styles)) {
				normal_styles = styles[0];
				important_styles = styles[1];
			} else {
				normal_styles = styles;
			}

			if (value) {
				value = String(value)
					.replaceAll(/\s*\/\*.*?\*\/\s*/g, '')
					.trim();

				/** @type {boolean | '"' | "'"} */
				var in_str = false;
				var in_apo = 0;
				var in_comment = false;

				var reserved_names = [];

				if (normal_styles) {
					reserved_names.push(...Object.keys(normal_styles).map(to_css_name));
				}
				if (important_styles) {
					reserved_names.push(...Object.keys(important_styles).map(to_css_name));
				}

				var start_index = 0;
				var name_index = -1;

				const len = value.length;
				for (var i = 0; i < len; i++) {
					var c = value[i];

					if (in_comment) {
						if (c === '/' && value[i - 1] === '*') {
							in_comment = false;
						}
					} else if (in_str) {
						if (in_str === c) {
							in_str = false;
						}
					} else if (c === '/' && value[i + 1] === '*') {
						in_comment = true;
					} else if (c === '"' || c === "'") {
						in_str = c;
					} else if (c === '(') {
						in_apo++;
					} else if (c === ')') {
						in_apo--;
					}

					if (!in_comment && in_str === false && in_apo === 0) {
						if (c === ':' && name_index === -1) {
							name_index = i;
						} else if (c === ';' || i === len - 1) {
							if (name_index !== -1) {
								var name = to_css_name(value.substring(start_index, name_index).trim());

								if (!reserved_names.includes(name)) {
									if (c !== ';') {
										i++;
									}

									var property = value.substring(start_index, i).trim();
									new_style += ' ' + property + ';';
								}
							}

							start_index = i + 1;
							name_index = -1;
						}
					}
				}
			}

			if (normal_styles) {
				new_style += append_styles(normal_styles);
			}

			if (important_styles) {
				new_style += append_styles(important_styles, true);
			}

			new_style = new_style.trim();
			return new_style === '' ? null : new_style;
		}

		return value == null ? null : String(value);
	}

	/**
	 * @param {Element} dom
	 * @param {boolean | number} is_html
	 * @param {string | null} value
	 * @param {string} [hash]
	 * @param {Record<string, any>} [prev_classes]
	 * @param {Record<string, any>} [next_classes]
	 * @returns {Record<string, boolean> | undefined}
	 */
	function set_class(dom, is_html, value, hash, prev_classes, next_classes) {
		// @ts-expect-error need to add __className to patched prototype
		var prev = dom.__className;

		if (
			hydrating ||
			prev !== value ||
			prev === undefined // for edge case of `class={undefined}`
		) {
			var next_class_name = to_class(value, hash, next_classes);

			if (!hydrating || next_class_name !== dom.getAttribute('class')) {
				// Removing the attribute when the value is only an empty string causes
				// performance issues vs simply making the className an empty string. So
				// we should only remove the class if the value is nullish
				// and there no hash/directives :
				if (next_class_name == null) {
					dom.removeAttribute('class');
				} else if (is_html) {
					dom.className = next_class_name;
				} else {
					dom.setAttribute('class', next_class_name);
				}
			}

			// @ts-expect-error need to add __className to patched prototype
			dom.__className = value;
		} else if (next_classes && prev_classes !== next_classes) {
			for (var key in next_classes) {
				var is_present = !!next_classes[key];

				if (prev_classes == null || is_present !== !!prev_classes[key]) {
					dom.classList.toggle(key, is_present);
				}
			}
		}

		return next_classes;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} dom
	 * @param {Record<string, any>} prev
	 * @param {Record<string, any>} next
	 * @param {string} [priority]
	 */
	function update_styles(dom, prev = {}, next, priority) {
		for (var key in next) {
			var value = next[key];

			if (prev[key] !== value) {
				if (next[key] == null) {
					dom.style.removeProperty(key);
				} else {
					dom.style.setProperty(key, value, priority);
				}
			}
		}
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} dom
	 * @param {string | null} value
	 * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [prev_styles]
	 * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [next_styles]
	 */
	function set_style(dom, value, prev_styles, next_styles) {
		// @ts-expect-error
		var prev = dom.__style;

		if (hydrating || prev !== value) {
			var next_style_attr = to_style(value, next_styles);

			if (!hydrating || next_style_attr !== dom.getAttribute('style')) {
				if (next_style_attr == null) {
					dom.removeAttribute('style');
				} else {
					dom.style.cssText = next_style_attr;
				}
			}

			// @ts-expect-error
			dom.__style = value;
		} else if (next_styles) {
			if (Array.isArray(next_styles)) {
				update_styles(dom, prev_styles?.[0], next_styles[0]);
				update_styles(dom, prev_styles?.[1], next_styles[1], 'important');
			} else {
				update_styles(dom, prev_styles, next_styles);
			}
		}

		return next_styles;
	}

	/**
	 * Selects the correct option(s) (depending on whether this is a multiple select)
	 * @template V
	 * @param {HTMLSelectElement} select
	 * @param {V} value
	 * @param {boolean} mounting
	 */
	function select_option(select, value, mounting = false) {
		if (select.multiple) {
			// If value is null or undefined, keep the selection as is
			if (value == undefined) {
				return;
			}

			// If not an array, warn and keep the selection as is
			if (!is_array(value)) {
				return select_multiple_invalid_value();
			}

			// Otherwise, update the selection
			for (var option of select.options) {
				option.selected = value.includes(get_option_value(option));
			}

			return;
		}

		for (option of select.options) {
			var option_value = get_option_value(option);
			if (is(option_value, value)) {
				option.selected = true;
				return;
			}
		}

		if (!mounting || value !== undefined) {
			select.selectedIndex = -1; // no option should be selected
		}
	}

	/**
	 * Selects the correct option(s) if `value` is given,
	 * and then sets up a mutation observer to sync the
	 * current selection to the dom when it changes. Such
	 * changes could for example occur when options are
	 * inside an `#each` block.
	 * @param {HTMLSelectElement} select
	 */
	function init_select(select) {
		var observer = new MutationObserver(() => {
			// @ts-ignore
			select_option(select, select.__value);
			// Deliberately don't update the potential binding value,
			// the model should be preserved unless explicitly changed
		});

		observer.observe(select, {
			// Listen to option element changes
			childList: true,
			subtree: true, // because of <optgroup>
			// Listen to option element value attribute changes
			// (doesn't get notified of select value changes,
			// because that property is not reflected as an attribute)
			attributes: true,
			attributeFilter: ['value']
		});

		teardown(() => {
			observer.disconnect();
		});
	}

	/** @param {HTMLOptionElement} option */
	function get_option_value(option) {
		// __value only exists if the <option> has a value attribute
		if ('__value' in option) {
			return option.__value;
		} else {
			return option.value;
		}
	}

	/** @import { Effect } from '#client' */

	const CLASS = Symbol('class');
	const STYLE = Symbol('style');

	const IS_CUSTOM_ELEMENT = Symbol('is custom element');
	const IS_HTML = Symbol('is html');

	/**
	 * The value/checked attribute in the template actually corresponds to the defaultValue property, so we need
	 * to remove it upon hydration to avoid a bug when someone resets the form value.
	 * @param {HTMLInputElement} input
	 * @returns {void}
	 */
	function remove_input_defaults(input) {
		if (!hydrating) return;

		var already_removed = false;

		// We try and remove the default attributes later, rather than sync during hydration.
		// Doing it sync during hydration has a negative impact on performance, but deferring the
		// work in an idle task alleviates this greatly. If a form reset event comes in before
		// the idle callback, then we ensure the input defaults are cleared just before.
		var remove_defaults = () => {
			if (already_removed) return;
			already_removed = true;

			// Remove the attributes but preserve the values
			if (input.hasAttribute('value')) {
				var value = input.value;
				set_attribute(input, 'value', null);
				input.value = value;
			}

			if (input.hasAttribute('checked')) {
				var checked = input.checked;
				set_attribute(input, 'checked', null);
				input.checked = checked;
			}
		};

		// @ts-expect-error
		input.__on_r = remove_defaults;
		queue_micro_task(remove_defaults);
		add_form_reset_listener();
	}

	/**
	 * @param {Element} element
	 * @param {any} value
	 */
	function set_value(element, value) {
		var attributes = get_attributes(element);

		if (
			attributes.value ===
				(attributes.value =
					// treat null and undefined the same for the initial value
					value ?? undefined) ||
			// @ts-expect-error
			// `progress` elements always need their value set when it's `0`
			(element.value === value && (value !== 0 || element.nodeName !== 'PROGRESS'))
		) {
			return;
		}

		// @ts-expect-error
		element.value = value ?? '';
	}

	/**
	 * Sets the `selected` attribute on an `option` element.
	 * Not set through the property because that doesn't reflect to the DOM,
	 * which means it wouldn't be taken into account when a form is reset.
	 * @param {HTMLOptionElement} element
	 * @param {boolean} selected
	 */
	function set_selected(element, selected) {
		if (selected) {
			// The selected option could've changed via user selection, and
			// setting the value without this check would set it back.
			if (!element.hasAttribute('selected')) {
				element.setAttribute('selected', '');
			}
		} else {
			element.removeAttribute('selected');
		}
	}

	/**
	 * @param {Element} element
	 * @param {string} attribute
	 * @param {string | null} value
	 * @param {boolean} [skip_warning]
	 */
	function set_attribute(element, attribute, value, skip_warning) {
		var attributes = get_attributes(element);

		if (hydrating) {
			attributes[attribute] = element.getAttribute(attribute);

			if (
				attribute === 'src' ||
				attribute === 'srcset' ||
				(attribute === 'href' && element.nodeName === 'LINK')
			) {

				// If we reset these attributes, they would result in another network request, which we want to avoid.
				// We assume they are the same between client and server as checking if they are equal is expensive
				// (we can't just compare the strings as they can be different between client and server but result in the
				// same url, so we would need to create hidden anchor elements to compare them)
				return;
			}
		}

		if (attributes[attribute] === (attributes[attribute] = value)) return;

		if (attribute === 'loading') {
			// @ts-expect-error
			element[LOADING_ATTR_SYMBOL] = value;
		}

		if (value == null) {
			element.removeAttribute(attribute);
		} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {
			// @ts-ignore
			element[attribute] = value;
		} else {
			element.setAttribute(attribute, value);
		}
	}

	/**
	 * @param {HTMLElement} node
	 * @param {string} prop
	 * @param {any} value
	 */
	function set_custom_element_data(node, prop, value) {
		// We need to ensure that setting custom element props, which can
		// invoke lifecycle methods on other custom elements, does not also
		// associate those lifecycle methods with the current active reaction
		// or effect
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;

		// If we're hydrating but the custom element is from Svelte, and it already scaffolded,
		// then it might run block logic in hydration mode, which we have to prevent.
		let was_hydrating = hydrating;
		if (hydrating) {
			set_hydrating(false);
		}

		set_active_reaction(null);
		set_active_effect(null);

		try {
			if (
				// `style` should use `set_attribute` rather than the setter
				prop !== 'style' &&
				// Don't compute setters for custom elements while they aren't registered yet,
				// because during their upgrade/instantiation they might add more setters.
				// Instead, fall back to a simple "an object, then set as property" heuristic.
				(setters_cache.has(node.getAttribute('is') || node.nodeName) ||
				// customElements may not be available in browser extension contexts
				!customElements ||
				customElements.get(node.getAttribute('is') || node.tagName.toLowerCase())
					? get_setters(node).includes(prop)
					: value && typeof value === 'object')
			) {
				// @ts-expect-error
				node[prop] = value;
			} else {
				// We did getters etc checks already, stringify before passing to set_attribute
				// to ensure it doesn't invoke the same logic again, and potentially populating
				// the setters cache too early.
				set_attribute(node, prop, value == null ? value : String(value));
			}
		} finally {
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
			if (was_hydrating) {
				set_hydrating(true);
			}
		}
	}

	/**
	 * Spreads attributes onto a DOM element, taking into account the currently set attributes
	 * @param {Element & ElementCSSInlineStyle} element
	 * @param {Record<string | symbol, any> | undefined} prev
	 * @param {Record<string | symbol, any>} next New attributes - this function mutates this object
	 * @param {string} [css_hash]
	 * @param {boolean} [should_remove_defaults]
	 * @param {boolean} [skip_warning]
	 * @returns {Record<string, any>}
	 */
	function set_attributes(
		element,
		prev,
		next,
		css_hash,
		should_remove_defaults = false,
		skip_warning = false
	) {
		if (hydrating && should_remove_defaults && element.tagName === 'INPUT') {
			var input = /** @type {HTMLInputElement} */ (element);
			var attribute = input.type === 'checkbox' ? 'defaultChecked' : 'defaultValue';

			if (!(attribute in next)) {
				remove_input_defaults(input);
			}
		}

		var attributes = get_attributes(element);

		var is_custom_element = attributes[IS_CUSTOM_ELEMENT];
		var preserve_attribute_case = !attributes[IS_HTML];

		// If we're hydrating but the custom element is from Svelte, and it already scaffolded,
		// then it might run block logic in hydration mode, which we have to prevent.
		let is_hydrating_custom_element = hydrating && is_custom_element;
		if (is_hydrating_custom_element) {
			set_hydrating(false);
		}

		var current = prev || {};
		var is_option_element = element.tagName === 'OPTION';

		for (var key in prev) {
			if (!(key in next)) {
				next[key] = null;
			}
		}

		if (next.class) {
			next.class = clsx(next.class);
		} else if (next[CLASS]) {
			next.class = null; /* force call to set_class() */
		}

		if (next[STYLE]) {
			next.style ??= null; /* force call to set_style() */
		}

		var setters = get_setters(element);

		// since key is captured we use const
		for (const key in next) {
			// let instead of var because referenced in a closure
			let value = next[key];

			// Up here because we want to do this for the initial value, too, even if it's undefined,
			// and this wouldn't be reached in case of undefined because of the equality check below
			if (is_option_element && key === 'value' && value == null) {
				// The <option> element is a special case because removing the value attribute means
				// the value is set to the text content of the option element, and setting the value
				// to null or undefined means the value is set to the string "null" or "undefined".
				// To align with how we handle this case in non-spread-scenarios, this logic is needed.
				// There's a super-edge-case bug here that is left in in favor of smaller code size:
				// Because of the "set missing props to null" logic above, we can't differentiate
				// between a missing value and an explicitly set value of null or undefined. That means
				// that once set, the value attribute of an <option> element can't be removed. This is
				// a very rare edge case, and removing the attribute altogether isn't possible either
				// for the <option value={undefined}> case, so we're not losing any functionality here.
				// @ts-ignore
				element.value = element.__value = '';
				current[key] = value;
				continue;
			}

			if (key === 'class') {
				var is_html = element.namespaceURI === 'http://www.w3.org/1999/xhtml';
				set_class(element, is_html, value, css_hash, prev?.[CLASS], next[CLASS]);
				current[key] = value;
				current[CLASS] = next[CLASS];
				continue;
			}

			if (key === 'style') {
				set_style(element, value, prev?.[STYLE], next[STYLE]);
				current[key] = value;
				current[STYLE] = next[STYLE];
				continue;
			}

			var prev_value = current[key];

			// Skip if value is unchanged, unless it's `undefined` and the element still has the attribute
			if (value === prev_value && !(value === undefined && element.hasAttribute(key))) {
				continue;
			}

			current[key] = value;

			var prefix = key[0] + key[1]; // this is faster than key.slice(0, 2)
			if (prefix === '$$') continue;

			if (prefix === 'on') {
				/** @type {{ capture?: true }} */
				const opts = {};
				const event_handle_key = '$$' + key;
				let event_name = key.slice(2);
				var delegated = is_delegated(event_name);

				if (is_capture_event(event_name)) {
					event_name = event_name.slice(0, -7);
					opts.capture = true;
				}

				if (!delegated && prev_value) {
					// Listening to same event but different handler -> our handle function below takes care of this
					// If we were to remove and add listeners in this case, it could happen that the event is "swallowed"
					// (the browser seems to not know yet that a new one exists now) and doesn't reach the handler
					// https://github.com/sveltejs/svelte/issues/11903
					if (value != null) continue;

					element.removeEventListener(event_name, current[event_handle_key], opts);
					current[event_handle_key] = null;
				}

				if (value != null) {
					if (!delegated) {
						/**
						 * @this {any}
						 * @param {Event} evt
						 */
						function handle(evt) {
							current[key].call(this, evt);
						}

						current[event_handle_key] = create_event(event_name, element, handle, opts);
					} else {
						// @ts-ignore
						element[`__${event_name}`] = value;
						delegate([event_name]);
					}
				} else if (delegated) {
					// @ts-ignore
					element[`__${event_name}`] = undefined;
				}
			} else if (key === 'style') {
				// avoid using the setter
				set_attribute(element, key, value);
			} else if (key === 'autofocus') {
				autofocus(/** @type {HTMLElement} */ (element), Boolean(value));
			} else if (!is_custom_element && (key === '__value' || (key === 'value' && value != null))) {
				// @ts-ignore We're not running this for custom elements because __value is actually
				// how Lit stores the current value on the element, and messing with that would break things.
				element.value = element.__value = value;
			} else if (key === 'selected' && is_option_element) {
				set_selected(/** @type {HTMLOptionElement} */ (element), value);
			} else {
				var name = key;
				if (!preserve_attribute_case) {
					name = normalize_attribute(name);
				}

				var is_default = name === 'defaultValue' || name === 'defaultChecked';

				if (value == null && !is_custom_element && !is_default) {
					attributes[key] = null;

					if (name === 'value' || name === 'checked') {
						// removing value/checked also removes defaultValue/defaultChecked â preserve
						let input = /** @type {HTMLInputElement} */ (element);
						const use_default = prev === undefined;
						if (name === 'value') {
							let previous = input.defaultValue;
							input.removeAttribute(name);
							input.defaultValue = previous;
							// @ts-ignore
							input.value = input.__value = use_default ? previous : null;
						} else {
							let previous = input.defaultChecked;
							input.removeAttribute(name);
							input.defaultChecked = previous;
							input.checked = use_default ? previous : false;
						}
					} else {
						element.removeAttribute(key);
					}
				} else if (
					is_default ||
					(setters.includes(name) && (is_custom_element || typeof value !== 'string'))
				) {
					// @ts-ignore
					element[name] = value;
					// remove it from attributes's cache
					if (name in attributes) attributes[name] = UNINITIALIZED;
				} else if (typeof value !== 'function') {
					set_attribute(element, name, value);
				}
			}
		}

		if (is_hydrating_custom_element) {
			set_hydrating(true);
		}

		return current;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} element
	 * @param {(...expressions: any) => Record<string | symbol, any>} fn
	 * @param {Array<() => any>} sync
	 * @param {Array<() => Promise<any>>} async
	 * @param {string} [css_hash]
	 * @param {boolean} [should_remove_defaults]
	 * @param {boolean} [skip_warning]
	 */
	function attribute_effect(
		element,
		fn,
		sync = [],
		async = [],
		css_hash,
		should_remove_defaults = false,
		skip_warning = false
	) {
		flatten(sync, async, (values) => {
			/** @type {Record<string | symbol, any> | undefined} */
			var prev = undefined;

			/** @type {Record<symbol, Effect>} */
			var effects = {};

			var is_select = element.nodeName === 'SELECT';
			var inited = false;

			block(() => {
				var next = fn(...values.map(get));
				/** @type {Record<string | symbol, any>} */
				var current = set_attributes(
					element,
					prev,
					next,
					css_hash,
					should_remove_defaults,
					skip_warning
				);

				if (inited && is_select && 'value' in next) {
					select_option(/** @type {HTMLSelectElement} */ (element), next.value);
				}

				for (let symbol of Object.getOwnPropertySymbols(effects)) {
					if (!next[symbol]) destroy_effect(effects[symbol]);
				}

				for (let symbol of Object.getOwnPropertySymbols(next)) {
					var n = next[symbol];

					if (symbol.description === ATTACHMENT_KEY && (!prev || n !== prev[symbol])) {
						if (effects[symbol]) destroy_effect(effects[symbol]);
						effects[symbol] = branch(() => attach(element, () => n));
					}

					current[symbol] = n;
				}

				prev = current;
			});

			if (is_select) {
				var select = /** @type {HTMLSelectElement} */ (element);

				effect(() => {
					select_option(select, /** @type {Record<string | symbol, any>} */ (prev).value, true);
					init_select(select);
				});
			}

			inited = true;
		});
	}

	/**
	 *
	 * @param {Element} element
	 */
	function get_attributes(element) {
		return /** @type {Record<string | symbol, unknown>} **/ (
			// @ts-expect-error
			element.__attributes ??= {
				[IS_CUSTOM_ELEMENT]: element.nodeName.includes('-'),
				[IS_HTML]: element.namespaceURI === NAMESPACE_HTML
			}
		);
	}

	/** @type {Map<string, string[]>} */
	var setters_cache = new Map();

	/** @param {Element} element */
	function get_setters(element) {
		var cache_key = element.getAttribute('is') || element.nodeName;
		var setters = setters_cache.get(cache_key);
		if (setters) return setters;
		setters_cache.set(cache_key, (setters = []));

		var descriptors;
		var proto = element; // In the case of custom elements there might be setters on the instance
		var element_proto = Element.prototype;

		// Stop at Element, from there on there's only unnecessary setters we're not interested in
		// Do not use contructor.name here as that's unreliable in some browser environments
		while (element_proto !== proto) {
			descriptors = get_descriptors(proto);

			for (var key in descriptors) {
				if (descriptors[key].set) {
					setters.push(key);
				}
			}

			proto = get_prototype_of(proto);
		}

		return setters;
	}

	/** @import { Raf } from '#client' */

	const now = () => performance.now() ;

	/** @type {Raf} */
	const raf = {
		// don't access requestAnimationFrame eagerly outside method
		// this allows basic testing of user code without JSDOM
		// bunder will eval and remove ternary when the user's app is built
		tick: /** @param {any} _ */ (_) => (requestAnimationFrame )(_),
		now: () => now(),
		tasks: new Set()
	};

	/** @import { TaskCallback, Task, TaskEntry } from '#client' */

	// TODO move this into timing.js where it probably belongs

	/**
	 * @returns {void}
	 */
	function run_tasks() {
		// use `raf.now()` instead of the `requestAnimationFrame` callback argument, because
		// otherwise things can get wonky https://github.com/sveltejs/svelte/pull/14541
		const now = raf.now();

		raf.tasks.forEach((task) => {
			if (!task.c(now)) {
				raf.tasks.delete(task);
				task.f();
			}
		});

		if (raf.tasks.size !== 0) {
			raf.tick(run_tasks);
		}
	}

	/**
	 * Creates a new task that runs on each raf frame
	 * until it returns a falsy value or is aborted
	 * @param {TaskCallback} callback
	 * @returns {Task}
	 */
	function loop(callback) {
		/** @type {TaskEntry} */
		let task;

		if (raf.tasks.size === 0) {
			raf.tick(run_tasks);
		}

		return {
			promise: new Promise((fulfill) => {
				raf.tasks.add((task = { c: callback, f: fulfill }));
			}),
			abort() {
				raf.tasks.delete(task);
			}
		};
	}

	/** @import { AnimateFn, Animation, AnimationConfig, EachItem, Effect, TransitionFn, TransitionManager } from '#client' */

	/**
	 * @param {Element} element
	 * @param {'introstart' | 'introend' | 'outrostart' | 'outroend'} type
	 * @returns {void}
	 */
	function dispatch_event(element, type) {
		without_reactive_context(() => {
			element.dispatchEvent(new CustomEvent(type));
		});
	}

	/**
	 * Converts a property to the camel-case format expected by Element.animate(), KeyframeEffect(), and KeyframeEffect.setKeyframes().
	 * @param {string} style
	 * @returns {string}
	 */
	function css_property_to_camelcase(style) {
		// in compliance with spec
		if (style === 'float') return 'cssFloat';
		if (style === 'offset') return 'cssOffset';

		// do not rename custom @properties
		if (style.startsWith('--')) return style;

		const parts = style.split('-');
		if (parts.length === 1) return parts[0];
		return (
			parts[0] +
			parts
				.slice(1)
				.map(/** @param {any} word */ (word) => word[0].toUpperCase() + word.slice(1))
				.join('')
		);
	}

	/**
	 * @param {string} css
	 * @returns {Keyframe}
	 */
	function css_to_keyframe(css) {
		/** @type {Keyframe} */
		const keyframe = {};
		const parts = css.split(';');
		for (const part of parts) {
			const [property, value] = part.split(':');
			if (!property || value === undefined) break;

			const formatted_property = css_property_to_camelcase(property.trim());
			keyframe[formatted_property] = value.trim();
		}
		return keyframe;
	}

	/** @param {number} t */
	const linear$1 = (t) => t;

	/**
	 * Called inside block effects as `$.transition(...)`. This creates a transition manager and
	 * attaches it to the current effect â later, inside `pause_effect` and `resume_effect`, we
	 * use this to create `intro` and `outro` transitions.
	 * @template P
	 * @param {number} flags
	 * @param {HTMLElement} element
	 * @param {() => TransitionFn<P | undefined>} get_fn
	 * @param {(() => P) | null} get_params
	 * @returns {void}
	 */
	function transition(flags, element, get_fn, get_params) {
		var is_intro = (flags & TRANSITION_IN) !== 0;
		var is_outro = (flags & TRANSITION_OUT) !== 0;
		var is_both = is_intro && is_outro;
		var is_global = (flags & TRANSITION_GLOBAL) !== 0;

		/** @type {'in' | 'out' | 'both'} */
		var direction = is_both ? 'both' : is_intro ? 'in' : 'out';

		/** @type {AnimationConfig | ((opts: { direction: 'in' | 'out' }) => AnimationConfig) | undefined} */
		var current_options;

		var inert = element.inert;

		/**
		 * The default overflow style, stashed so we can revert changes during the transition
		 * that are necessary to work around a Safari <18 bug
		 * TODO 6.0 remove this, if older versions of Safari have died out enough
		 */
		var overflow = element.style.overflow;

		/** @type {Animation | undefined} */
		var intro;

		/** @type {Animation | undefined} */
		var outro;

		function get_options() {
			return without_reactive_context(() => {
				// If a transition is still ongoing, we use the existing options rather than generating
				// new ones. This ensures that reversible transitions reverse smoothly, rather than
				// jumping to a new spot because (for example) a different `duration` was used
				return (current_options ??= get_fn()(element, get_params?.() ?? /** @type {P} */ ({}), {
					direction
				}));
			});
		}

		/** @type {TransitionManager} */
		var transition = {
			is_global,
			in() {
				element.inert = inert;

				if (!is_intro) {
					outro?.abort();
					outro?.reset?.();
					return;
				}

				if (!is_outro) {
					// if we intro then outro then intro again, we want to abort the first intro,
					// if it's not a bidirectional transition
					intro?.abort();
				}

				dispatch_event(element, 'introstart');

				intro = animate(element, get_options(), outro, 1, () => {
					dispatch_event(element, 'introend');

					// Ensure we cancel the animation to prevent leaking
					intro?.abort();
					intro = current_options = undefined;

					element.style.overflow = overflow;
				});
			},
			out(fn) {
				if (!is_outro) {
					fn?.();
					current_options = undefined;
					return;
				}

				element.inert = true;

				dispatch_event(element, 'outrostart');

				outro = animate(element, get_options(), intro, 0, () => {
					dispatch_event(element, 'outroend');
					fn?.();
				});
			},
			stop: () => {
				intro?.abort();
				outro?.abort();
			}
		};

		var e = /** @type {Effect} */ (active_effect);

		(e.transitions ??= []).push(transition);

		// if this is a local transition, we only want to run it if the parent (branch) effect's
		// parent (block) effect is where the state change happened. we can determine that by
		// looking at whether the block effect is currently initializing
		if (is_intro && should_intro) {
			var run = is_global;

			if (!run) {
				var block = /** @type {Effect | null} */ (e.parent);

				// skip over transparent blocks (e.g. snippets, else-if blocks)
				while (block && (block.f & EFFECT_TRANSPARENT) !== 0) {
					while ((block = block.parent)) {
						if ((block.f & BLOCK_EFFECT) !== 0) break;
					}
				}

				run = !block || (block.f & EFFECT_RAN) !== 0;
			}

			if (run) {
				effect(() => {
					untrack(() => transition.in());
				});
			}
		}
	}

	/**
	 * Animates an element, according to the provided configuration
	 * @param {Element} element
	 * @param {AnimationConfig | ((opts: { direction: 'in' | 'out' }) => AnimationConfig)} options
	 * @param {Animation | undefined} counterpart The corresponding intro/outro to this outro/intro
	 * @param {number} t2 The target `t` value â `1` for intro, `0` for outro
	 * @param {(() => void)} on_finish Called after successfully completing the animation
	 * @returns {Animation}
	 */
	function animate(element, options, counterpart, t2, on_finish) {
		var is_intro = t2 === 1;

		if (is_function(options)) {
			// In the case of a deferred transition (such as `crossfade`), `option` will be
			// a function rather than an `AnimationConfig`. We need to call this function
			// once the DOM has been updated...
			/** @type {Animation} */
			var a;
			var aborted = false;

			queue_micro_task(() => {
				if (aborted) return;
				var o = options({ direction: is_intro ? 'in' : 'out' });
				a = animate(element, o, counterpart, t2, on_finish);
			});

			// ...but we want to do so without using `async`/`await` everywhere, so
			// we return a facade that allows everything to remain synchronous
			return {
				abort: () => {
					aborted = true;
					a?.abort();
				},
				deactivate: () => a.deactivate(),
				reset: () => a.reset(),
				t: () => a.t()
			};
		}

		counterpart?.deactivate();

		if (!options?.duration) {
			on_finish();

			return {
				abort: noop,
				deactivate: noop,
				reset: noop,
				t: () => t2
			};
		}

		const { delay = 0, css, tick, easing = linear$1 } = options;

		var keyframes = [];

		if (is_intro && counterpart === undefined) {
			if (tick) {
				tick(0, 1); // TODO put in nested effect, to avoid interleaved reads/writes?
			}

			if (css) {
				var styles = css_to_keyframe(css(0, 1));
				keyframes.push(styles, styles);
			}
		}

		var get_t = () => 1 - t2;

		// create a dummy animation that lasts as long as the delay (but with whatever devtools
		// multiplier is in effect). in the common case that it is `0`, we keep it anyway so that
		// the CSS keyframes aren't created until the DOM is updated
		//
		// fill forwards to prevent the element from rendering without styles applied
		// see https://github.com/sveltejs/svelte/issues/14732
		var animation = element.animate(keyframes, { duration: delay, fill: 'forwards' });

		animation.onfinish = () => {
			// remove dummy animation from the stack to prevent conflict with main animation
			animation.cancel();

			// for bidirectional transitions, we start from the current position,
			// rather than doing a full intro/outro
			var t1 = counterpart?.t() ?? 1 - t2;
			counterpart?.abort();

			var delta = t2 - t1;
			var duration = /** @type {number} */ (options.duration) * Math.abs(delta);
			var keyframes = [];

			if (duration > 0) {
				/**
				 * Whether or not the CSS includes `overflow: hidden`, in which case we need to
				 * add it as an inline style to work around a Safari <18 bug
				 * TODO 6.0 remove this, if possible
				 */
				var needs_overflow_hidden = false;

				if (css) {
					var n = Math.ceil(duration / (1000 / 60)); // `n` must be an integer, or we risk missing the `t2` value

					for (var i = 0; i <= n; i += 1) {
						var t = t1 + delta * easing(i / n);
						var styles = css_to_keyframe(css(t, 1 - t));
						keyframes.push(styles);

						needs_overflow_hidden ||= styles.overflow === 'hidden';
					}
				}

				if (needs_overflow_hidden) {
					/** @type {HTMLElement} */ (element).style.overflow = 'hidden';
				}

				get_t = () => {
					var time = /** @type {number} */ (
						/** @type {globalThis.Animation} */ (animation).currentTime
					);

					return t1 + delta * easing(time / duration);
				};

				if (tick) {
					loop(() => {
						if (animation.playState !== 'running') return false;

						var t = get_t();
						tick(t, 1 - t);

						return true;
					});
				}
			}

			animation = element.animate(keyframes, { duration, fill: 'forwards' });

			animation.onfinish = () => {
				get_t = () => t2;
				tick?.(t2, 1 - t2);
				on_finish();
			};
		};

		return {
			abort: () => {
				if (animation) {
					animation.cancel();
					// This prevents memory leaks in Chromium
					animation.effect = null;
					// This prevents onfinish to be launched after cancel(),
					// which can happen in some rare cases
					// see https://github.com/sveltejs/svelte/issues/13681
					animation.onfinish = noop;
				}
			},
			deactivate: () => {
				on_finish = noop;
			},
			reset: () => {
				if (t2 === 0) {
					tick?.(1, 0);
				}
			},
			t: () => get_t()
		};
	}

	/** @import { Batch } from '../../../reactivity/batch.js' */

	/**
	 * @param {HTMLInputElement} input
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_value(input, get, set = get) {
		var batches = new WeakSet();

		listen_to_event_and_reset_event(input, 'input', async (is_reset) => {

			/** @type {any} */
			var value = is_reset ? input.defaultValue : input.value;
			value = is_numberlike_input(input) ? to_number(value) : value;
			set(value);

			if (current_batch !== null) {
				batches.add(current_batch);
			}

			// Because `{#each ...}` blocks work by updating sources inside the flush,
			// we need to wait a tick before checking to see if we should forcibly
			// update the input and reset the selection state
			await tick();

			// Respect any validation in accessors
			if (value !== (value = get())) {
				var start = input.selectionStart;
				var end = input.selectionEnd;

				// the value is coerced on assignment
				input.value = value ?? '';

				// Restore selection
				if (end !== null) {
					input.selectionStart = start;
					input.selectionEnd = Math.min(end, input.value.length);
				}
			}
		});

		if (
			// If we are hydrating and the value has since changed,
			// then use the updated value from the input instead.
			(hydrating && input.defaultValue !== input.value) ||
			// If defaultValue is set, then value == defaultValue
			// TODO Svelte 6: remove input.value check and set to empty string?
			(untrack(get) == null && input.value)
		) {
			set(is_numberlike_input(input) ? to_number(input.value) : input.value);

			if (current_batch !== null) {
				batches.add(current_batch);
			}
		}

		render_effect(() => {

			var value = get();

			if (input === document.activeElement) {
				// we need both, because in non-async mode, render effects run before previous_batch is set
				var batch = /** @type {Batch} */ (previous_batch ?? current_batch);

				// Never rewrite the contents of a focused input. We can get here if, for example,
				// an update is deferred because of async work depending on the input:
				//
				// <input bind:value={query}>
				// <p>{await find(query)}</p>
				if (batches.has(batch)) {
					return;
				}
			}

			if (is_numberlike_input(input) && value === to_number(input.value)) {
				// handles 0 vs 00 case (see https://github.com/sveltejs/svelte/issues/9959)
				return;
			}

			if (input.type === 'date' && !value && !input.value) {
				// Handles the case where a temporarily invalid date is set (while typing, for example with a leading 0 for the day)
				// and prevents this state from clearing the other parts of the date input (see https://github.com/sveltejs/svelte/issues/7897)
				return;
			}

			// don't set the value of the input if it's the same to allow
			// minlength to work properly
			if (value !== input.value) {
				// @ts-expect-error the value is coerced on assignment
				input.value = value ?? '';
			}
		});
	}

	/**
	 * @param {HTMLInputElement} input
	 */
	function is_numberlike_input(input) {
		var type = input.type;
		return type === 'number' || type === 'range';
	}

	/**
	 * @param {string} value
	 */
	function to_number(value) {
		return value === '' ? null : +value;
	}

	/**
	 * Substitute for the `preventDefault` event modifier
	 * @deprecated
	 * @param {(event: Event, ...args: Array<unknown>) => void} fn
	 * @returns {(event: Event, ...args: unknown[]) => void}
	 */
	function preventDefault(fn) {
		return function (...args) {
			var event = /** @type {Event} */ (args[0]);
			event.preventDefault();
			// @ts-ignore
			return fn?.apply(this, args);
		};
	}

	/** @import { ComponentContextLegacy } from '#client' */

	/**
	 * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects
	 * @param {boolean} [immutable]
	 */
	function init(immutable = false) {
		const context = /** @type {ComponentContextLegacy} */ (component_context);

		const callbacks = context.l.u;
		if (!callbacks) return;

		let props = () => deep_read_state(context.s);

		if (immutable) {
			let version = 0;
			let prev = /** @type {Record<string, any>} */ ({});

			// In legacy immutable mode, before/afterUpdate only fire if the object identity of a prop changes
			const d = derived(() => {
				let changed = false;
				const props = context.s;
				for (const key in props) {
					if (props[key] !== prev[key]) {
						prev[key] = props[key];
						changed = true;
					}
				}
				if (changed) version++;
				return version;
			});

			props = () => get(d);
		}

		// beforeUpdate
		if (callbacks.b.length) {
			user_pre_effect(() => {
				observe_all(context, props);
				run_all(callbacks.b);
			});
		}

		// onMount (must run before afterUpdate)
		user_effect(() => {
			const fns = untrack(() => callbacks.m.map(run));
			return () => {
				for (const fn of fns) {
					if (typeof fn === 'function') {
						fn();
					}
				}
			};
		});

		// afterUpdate
		if (callbacks.a.length) {
			user_effect(() => {
				observe_all(context, props);
				run_all(callbacks.a);
			});
		}
	}

	/**
	 * Invoke the getter of all signals associated with a component
	 * so they can be registered to the effect this function is called in.
	 * @param {ComponentContextLegacy} context
	 * @param {(() => void)} props
	 */
	function observe_all(context, props) {
		if (context.l.s) {
			for (const signal of context.l.s) get(signal);
		}

		props();
	}

	/**
	 * @this {any}
	 * @param {Record<string, unknown>} $$props
	 * @param {Event} event
	 * @returns {void}
	 */
	function bubble_event($$props, event) {
		var events = /** @type {Record<string, Function[] | Function>} */ ($$props.$$events)?.[
			event.type
		];

		var callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];

		for (var fn of callbacks) {
			// Preserve "this" context
			fn.call(this, event);
		}
	}

	/** @import { StoreReferencesContainer } from '#client' */
	/** @import { Store } from '#shared' */

	/**
	 * Whether or not the prop currently being read is a store binding, as in
	 * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in
	 * runes mode, and skip `binding_property_non_reactive` validation
	 */
	let is_store_binding = false;

	/**
	 * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.
	 * Used to prevent `binding_property_non_reactive` validation false positives and
	 * ensure that these props are treated as mutable even in runes mode
	 * @template T
	 * @param {() => T} fn
	 * @returns {[T, boolean]}
	 */
	function capture_store_binding(fn) {
		var previous_is_store_binding = is_store_binding;

		try {
			is_store_binding = false;
			return [fn(), is_store_binding];
		} finally {
			is_store_binding = previous_is_store_binding;
		}
	}

	/** @import { Effect, Source } from './types.js' */

	/**
	 * This function is responsible for synchronizing a possibly bound prop with the inner component state.
	 * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.
	 * @template V
	 * @param {Record<string, unknown>} props
	 * @param {string} key
	 * @param {number} flags
	 * @param {V | (() => V)} [fallback]
	 * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}
	 */
	function prop(props, key, flags, fallback) {
		var runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;
		var bindable = (flags & PROPS_IS_BINDABLE) !== 0;
		var lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;

		var fallback_value = /** @type {V} */ (fallback);
		var fallback_dirty = true;

		var get_fallback = () => {
			if (fallback_dirty) {
				fallback_dirty = false;

				fallback_value = lazy
					? untrack(/** @type {() => V} */ (fallback))
					: /** @type {V} */ (fallback);
			}

			return fallback_value;
		};

		/** @type {((v: V) => void) | undefined} */
		var setter;

		if (bindable) {
			// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`
			// or `createClassComponent(Component, props)`
			var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;

			setter =
				get_descriptor(props, key)?.set ??
				(is_entry_props && key in props ? (v) => (props[key] = v) : undefined);
		}

		var initial_value;
		var is_store_sub = false;

		if (bindable) {
			[initial_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));
		} else {
			initial_value = /** @type {V} */ (props[key]);
		}

		if (initial_value === undefined && fallback !== undefined) {
			initial_value = get_fallback();

			if (setter) {
				if (runes) props_invalid_value();
				setter(initial_value);
			}
		}

		/** @type {() => V} */
		var getter;

		if (runes) {
			getter = () => {
				var value = /** @type {V} */ (props[key]);
				if (value === undefined) return get_fallback();
				fallback_dirty = true;
				return value;
			};
		} else {
			getter = () => {
				var value = /** @type {V} */ (props[key]);

				if (value !== undefined) {
					// in legacy mode, we don't revert to the fallback value
					// if the prop goes from defined to undefined. The easiest
					// way to model this is to make the fallback undefined
					// as soon as the prop has a value
					fallback_value = /** @type {V} */ (undefined);
				}

				return value === undefined ? fallback_value : value;
			};
		}

		// prop is never written to â we only need a getter
		if (runes && (flags & PROPS_IS_UPDATED) === 0) {
			return getter;
		}

		// prop is written to, but the parent component had `bind:foo` which
		// means we can just call `$$props.foo = value` directly
		if (setter) {
			var legacy_parent = props.$$legacy;
			return /** @type {() => V} */ (
				function (/** @type {V} */ value, /** @type {boolean} */ mutation) {
					if (arguments.length > 0) {
						// We don't want to notify if the value was mutated and the parent is in runes mode.
						// In that case the state proxy (if it exists) should take care of the notification.
						// If the parent is not in runes mode, we need to notify on mutation, too, that the prop
						// has changed because the parent will not be able to detect the change otherwise.
						if (!runes || !mutation || legacy_parent || is_store_sub) {
							/** @type {Function} */ (setter)(mutation ? getter() : value);
						}

						return value;
					}

					return getter();
				}
			);
		}

		// Either prop is written to, but there's no binding, which means we
		// create a derived that we can write to locally.
		// Or we are in legacy mode where we always create a derived to replicate that
		// Svelte 4 did not trigger updates when a primitive value was updated to the same value.
		var overridden = false;

		var d = ((flags & PROPS_IS_IMMUTABLE) !== 0 ? derived : derived_safe_equal)(() => {
			overridden = false;
			return getter();
		});

		// Capture the initial value if it's bindable
		if (bindable) get(d);

		var parent_effect = /** @type {Effect} */ (active_effect);

		return /** @type {() => V} */ (
			function (/** @type {any} */ value, /** @type {boolean} */ mutation) {
				if (arguments.length > 0) {
					const new_value = mutation ? get(d) : runes && bindable ? proxy(value) : value;

					set(d, new_value);
					overridden = true;

					if (fallback_value !== undefined) {
						fallback_value = new_value;
					}

					return value;
				}

				// special case â avoid recalculating the derived if we're in a
				// teardown function and the prop was overridden locally, or the
				// component was already destroyed (this latter part is necessary
				// because `bind:this` can read props after the component has
				// been destroyed. TODO simplify `bind:this`
				if ((is_destroying_effect && overridden) || (parent_effect.f & DESTROYED) !== 0) {
					return d.v;
				}

				return get(d);
			}
		);
	}

	/** @import { ComponentConstructorOptions, ComponentType, SvelteComponent, Component } from 'svelte' */

	/**
	 * Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.
	 *
	 * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @template {Record<string, any>} Events
	 * @template {Record<string, any>} Slots
	 *
	 * @param {ComponentConstructorOptions<Props> & {
	 * 	component: ComponentType<SvelteComponent<Props, Events, Slots>> | Component<Props>;
	 * }} options
	 * @returns {SvelteComponent<Props, Events, Slots> & Exports}
	 */
	function createClassComponent(options) {
		// @ts-expect-error $$prop_def etc are not actually defined
		return new Svelte4Component(options);
	}

	/**
	 * Support using the component as both a class and function during the transition period
	 * @typedef  {{new (o: ComponentConstructorOptions): SvelteComponent;(...args: Parameters<Component<Record<string, any>>>): ReturnType<Component<Record<string, any>, Record<string, any>>>;}} LegacyComponentType
	 */

	class Svelte4Component {
		/** @type {any} */
		#events;

		/** @type {Record<string, any>} */
		#instance;

		/**
		 * @param {ComponentConstructorOptions & {
		 *  component: any;
		 * }} options
		 */
		constructor(options) {
			var sources = new Map();

			/**
			 * @param {string | symbol} key
			 * @param {unknown} value
			 */
			var add_source = (key, value) => {
				var s = mutable_source(value, false, false);
				sources.set(key, s);
				return s;
			};

			// Replicate coarse-grained props through a proxy that has a version source for
			// each property, which is incremented on updates to the property itself. Do not
			// use our $state proxy because that one has fine-grained reactivity.
			const props = new Proxy(
				{ ...(options.props || {}), $$events: {} },
				{
					get(target, prop) {
						return get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));
					},
					has(target, prop) {
						// Necessary to not throw "invalid binding" validation errors on the component side
						if (prop === LEGACY_PROPS) return true;

						get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));
						return Reflect.has(target, prop);
					},
					set(target, prop, value) {
						set(sources.get(prop) ?? add_source(prop, value), value);
						return Reflect.set(target, prop, value);
					}
				}
			);

			this.#instance = (options.hydrate ? hydrate : mount)(options.component, {
				target: options.target,
				anchor: options.anchor,
				props,
				context: options.context,
				intro: options.intro ?? false,
				recover: options.recover
			});

			// We don't flushSync for custom element wrappers or if the user doesn't want it,
			// or if we're in async mode since `flushSync()` will fail
			if ((!options?.props?.$$host || options.sync === false)) {
				flushSync();
			}

			this.#events = props.$$events;

			for (const key of Object.keys(this.#instance)) {
				if (key === '$set' || key === '$destroy' || key === '$on') continue;
				define_property(this, key, {
					get() {
						return this.#instance[key];
					},
					/** @param {any} value */
					set(value) {
						this.#instance[key] = value;
					},
					enumerable: true
				});
			}

			this.#instance.$set = /** @param {Record<string, any>} next */ (next) => {
				Object.assign(props, next);
			};

			this.#instance.$destroy = () => {
				unmount(this.#instance);
			};
		}

		/** @param {Record<string, any>} props */
		$set(props) {
			this.#instance.$set(props);
		}

		/**
		 * @param {string} event
		 * @param {(...args: any[]) => any} callback
		 * @returns {any}
		 */
		$on(event, callback) {
			this.#events[event] = this.#events[event] || [];

			/** @param {any[]} args */
			const cb = (...args) => callback.call(this, ...args);
			this.#events[event].push(cb);
			return () => {
				this.#events[event] = this.#events[event].filter(/** @param {any} fn */ (fn) => fn !== cb);
			};
		}

		$destroy() {
			this.#instance.$destroy();
		}
	}

	/**
	 * @typedef {Object} CustomElementPropDefinition
	 * @property {string} [attribute]
	 * @property {boolean} [reflect]
	 * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]
	 */

	/** @type {any} */
	let SvelteElement;

	if (typeof HTMLElement === 'function') {
		SvelteElement = class extends HTMLElement {
			/** The Svelte component constructor */
			$$ctor;
			/** Slots */
			$$s;
			/** @type {any} The Svelte component instance */
			$$c;
			/** Whether or not the custom element is connected */
			$$cn = false;
			/** @type {Record<string, any>} Component props data */
			$$d = {};
			/** `true` if currently in the process of reflecting component props back to attributes */
			$$r = false;
			/** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
			$$p_d = {};
			/** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
			$$l = {};
			/** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
			$$l_u = new Map();
			/** @type {any} The managed render effect for reflecting attributes */
			$$me;

			/**
			 * @param {*} $$componentCtor
			 * @param {*} $$slots
			 * @param {*} use_shadow_dom
			 */
			constructor($$componentCtor, $$slots, use_shadow_dom) {
				super();
				this.$$ctor = $$componentCtor;
				this.$$s = $$slots;
				if (use_shadow_dom) {
					this.attachShadow({ mode: 'open' });
				}
			}

			/**
			 * @param {string} type
			 * @param {EventListenerOrEventListenerObject} listener
			 * @param {boolean | AddEventListenerOptions} [options]
			 */
			addEventListener(type, listener, options) {
				// We can't determine upfront if the event is a custom event or not, so we have to
				// listen to both. If someone uses a custom event with the same name as a regular
				// browser event, this fires twice - we can't avoid that.
				this.$$l[type] = this.$$l[type] || [];
				this.$$l[type].push(listener);
				if (this.$$c) {
					const unsub = this.$$c.$on(type, listener);
					this.$$l_u.set(listener, unsub);
				}
				super.addEventListener(type, listener, options);
			}

			/**
			 * @param {string} type
			 * @param {EventListenerOrEventListenerObject} listener
			 * @param {boolean | AddEventListenerOptions} [options]
			 */
			removeEventListener(type, listener, options) {
				super.removeEventListener(type, listener, options);
				if (this.$$c) {
					const unsub = this.$$l_u.get(listener);
					if (unsub) {
						unsub();
						this.$$l_u.delete(listener);
					}
				}
			}

			async connectedCallback() {
				this.$$cn = true;
				if (!this.$$c) {
					// We wait one tick to let possible child slot elements be created/mounted
					await Promise.resolve();
					if (!this.$$cn || this.$$c) {
						return;
					}
					/** @param {string} name */
					function create_slot(name) {
						/**
						 * @param {Element} anchor
						 */
						return (anchor) => {
							const slot = document.createElement('slot');
							if (name !== 'default') slot.name = name;

							append(anchor, slot);
						};
					}
					/** @type {Record<string, any>} */
					const $$slots = {};
					const existing_slots = get_custom_elements_slots(this);
					for (const name of this.$$s) {
						if (name in existing_slots) {
							if (name === 'default' && !this.$$d.children) {
								this.$$d.children = create_slot(name);
								$$slots.default = true;
							} else {
								$$slots[name] = create_slot(name);
							}
						}
					}
					for (const attribute of this.attributes) {
						// this.$$data takes precedence over this.attributes
						const name = this.$$g_p(attribute.name);
						if (!(name in this.$$d)) {
							this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp');
						}
					}
					// Port over props that were set programmatically before ce was initialized
					for (const key in this.$$p_d) {
						// @ts-expect-error
						if (!(key in this.$$d) && this[key] !== undefined) {
							// @ts-expect-error
							this.$$d[key] = this[key]; // don't transform, these were set through JavaScript
							// @ts-expect-error
							delete this[key]; // remove the property that shadows the getter/setter
						}
					}
					this.$$c = createClassComponent({
						component: this.$$ctor,
						target: this.shadowRoot || this,
						props: {
							...this.$$d,
							$$slots,
							$$host: this
						}
					});

					// Reflect component props as attributes
					this.$$me = effect_root(() => {
						render_effect(() => {
							this.$$r = true;
							for (const key of object_keys(this.$$c)) {
								if (!this.$$p_d[key]?.reflect) continue;
								this.$$d[key] = this.$$c[key];
								const attribute_value = get_custom_element_value(
									key,
									this.$$d[key],
									this.$$p_d,
									'toAttribute'
								);
								if (attribute_value == null) {
									this.removeAttribute(this.$$p_d[key].attribute || key);
								} else {
									this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
								}
							}
							this.$$r = false;
						});
					});

					for (const type in this.$$l) {
						for (const listener of this.$$l[type]) {
							const unsub = this.$$c.$on(type, listener);
							this.$$l_u.set(listener, unsub);
						}
					}
					this.$$l = {};
				}
			}

			// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
			// and setting attributes through setAttribute etc, this is helpful

			/**
			 * @param {string} attr
			 * @param {string} _oldValue
			 * @param {string} newValue
			 */
			attributeChangedCallback(attr, _oldValue, newValue) {
				if (this.$$r) return;
				attr = this.$$g_p(attr);
				this.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp');
				this.$$c?.$set({ [attr]: this.$$d[attr] });
			}

			disconnectedCallback() {
				this.$$cn = false;
				// In a microtask, because this could be a move within the DOM
				Promise.resolve().then(() => {
					if (!this.$$cn && this.$$c) {
						this.$$c.$destroy();
						this.$$me();
						this.$$c = undefined;
					}
				});
			}

			/**
			 * @param {string} attribute_name
			 */
			$$g_p(attribute_name) {
				return (
					object_keys(this.$$p_d).find(
						(key) =>
							this.$$p_d[key].attribute === attribute_name ||
							(!this.$$p_d[key].attribute && key.toLowerCase() === attribute_name)
					) || attribute_name
				);
			}
		};
	}

	/**
	 * @param {string} prop
	 * @param {any} value
	 * @param {Record<string, CustomElementPropDefinition>} props_definition
	 * @param {'toAttribute' | 'toProp'} [transform]
	 */
	function get_custom_element_value(prop, value, props_definition, transform) {
		const type = props_definition[prop]?.type;
		value = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;
		if (!transform || !props_definition[prop]) {
			return value;
		} else if (transform === 'toAttribute') {
			switch (type) {
				case 'Object':
				case 'Array':
					return value == null ? null : JSON.stringify(value);
				case 'Boolean':
					return value ? '' : null;
				case 'Number':
					return value == null ? null : value;
				default:
					return value;
			}
		} else {
			switch (type) {
				case 'Object':
				case 'Array':
					return value && JSON.parse(value);
				case 'Boolean':
					return value; // conversion already handled above
				case 'Number':
					return value != null ? +value : value;
				default:
					return value;
			}
		}
	}

	/**
	 * @param {HTMLElement} element
	 */
	function get_custom_elements_slots(element) {
		/** @type {Record<string, true>} */
		const result = {};
		element.childNodes.forEach((node) => {
			result[/** @type {Element} node */ (node).slot || 'default'] = true;
		});
		return result;
	}

	/**
	 * @internal
	 *
	 * Turn a Svelte component into a custom element.
	 * @param {any} Component  A Svelte component function
	 * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe
	 * @param {string[]} slots  The slots to create
	 * @param {string[]} exports  Explicitly exported values, other than props
	 * @param {boolean} use_shadow_dom  Whether to use shadow DOM
	 * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend]
	 */
	function create_custom_element(
		Component,
		props_definition,
		slots,
		exports,
		use_shadow_dom,
		extend
	) {
		let Class = class extends SvelteElement {
			constructor() {
				super(Component, slots, use_shadow_dom);
				this.$$p_d = props_definition;
			}
			static get observedAttributes() {
				return object_keys(props_definition).map((key) =>
					(props_definition[key].attribute || key).toLowerCase()
				);
			}
		};
		object_keys(props_definition).forEach((prop) => {
			define_property(Class.prototype, prop, {
				get() {
					return this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];
				},
				set(value) {
					value = get_custom_element_value(prop, value, props_definition);
					this.$$d[prop] = value;
					var component = this.$$c;

					if (component) {
						// // If the instance has an accessor, use that instead
						var setter = get_descriptor(component, prop)?.get;

						if (setter) {
							component[prop] = value;
						} else {
							component.$set({ [prop]: value });
						}
					}
				}
			});
		});
		exports.forEach((property) => {
			define_property(Class.prototype, property, {
				get() {
					return this.$$c?.[property];
				}
			});
		});
		if (extend) {
			// @ts-expect-error - assigning here is fine
			Class = extend(Class);
		}
		Component.element = /** @type {any} */ Class;
		return Class;
	}

	/**
	 * @param {string} method
	 * @param  {...any} objects
	 */
	function log_if_contains_state(method, ...objects) {
		untrack(() => {
			try {
				let has_state = false;
				const transformed = [];

				for (const obj of objects) {
					if (obj && typeof obj === 'object' && STATE_SYMBOL in obj) {
						transformed.push(snapshot(obj, true));
						has_state = true;
					} else {
						transformed.push(obj);
					}
				}

				if (has_state) {
					console_log_state(method);

					// eslint-disable-next-line no-console
					console.log('%c[snapshot]', 'color: grey', ...transformed);
				}
			} catch {}
		});

		return objects;
	}

	/** @import { BlurParams, CrossfadeParams, DrawParams, FadeParams, FlyParams, ScaleParams, SlideParams, TransitionConfig } from './public' */


	/** @param {number} x */
	const linear = (x) => x;

	/** @param {number} t */
	function cubic_out(t) {
		const f = t - 1.0;
		return f * f * f + 1.0;
	}

	/** @param {number | string} value
	 * @returns {[number, string]}
	 */
	function split_css_unit(value) {
		const split = typeof value === 'string' && value.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
		return split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];
	}

	/**
	 * Animates the opacity of an element from 0 to the current opacity for `in` transitions and from the current opacity to 0 for `out` transitions.
	 *
	 * @param {Element} node
	 * @param {FadeParams} [params]
	 * @returns {TransitionConfig}
	 */
	function fade(node, { delay = 0, duration = 400, easing = linear } = {}) {
		const o = +getComputedStyle(node).opacity;
		return {
			delay,
			duration,
			easing,
			css: (t) => `opacity: ${t * o}`
		};
	}

	/**
	 * Animates the x and y positions and the opacity of an element. `in` transitions animate from the provided values, passed as parameters to the element's default values. `out` transitions animate from the element's default values to the provided values.
	 *
	 * @param {Element} node
	 * @param {FlyParams} [params]
	 * @returns {TransitionConfig}
	 */
	function fly(
		node,
		{ delay = 0, duration = 400, easing = cubic_out, x = 0, y = 0, opacity = 0 } = {}
	) {
		const style = getComputedStyle(node);
		const target_opacity = +style.opacity;
		const transform = style.transform === 'none' ? '' : style.transform;
		const od = target_opacity * (1 - opacity);
		const [x_value, x_unit] = split_css_unit(x);
		const [y_value, y_unit] = split_css_unit(y);
		return {
			delay,
			duration,
			easing,
			css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x_value}${x_unit}, ${(1 - t) * y_value}${y_unit});
			opacity: ${target_opacity - od * u}`
		};
	}

	/**
	 * Slides an element in and out.
	 *
	 * @param {Element} node
	 * @param {SlideParams} [params]
	 * @returns {TransitionConfig}
	 */
	function slide(node, { delay = 0, duration = 400, easing = cubic_out, axis = 'y' } = {}) {
		const style = getComputedStyle(node);

		const opacity = +style.opacity;
		const primary_property = axis === 'y' ? 'height' : 'width';
		const primary_property_value = parseFloat(style[primary_property]);
		const secondary_properties = axis === 'y' ? ['top', 'bottom'] : ['left', 'right'];
		const capitalized_secondary_properties = secondary_properties.map(
			(e) => /** @type {'Left' | 'Right' | 'Top' | 'Bottom'} */ (`${e[0].toUpperCase()}${e.slice(1)}`)
		);
		const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);
		const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);
		const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);
		const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);
		const border_width_start_value = parseFloat(
			style[`border${capitalized_secondary_properties[0]}Width`]
		);
		const border_width_end_value = parseFloat(
			style[`border${capitalized_secondary_properties[1]}Width`]
		);
		return {
			delay,
			duration,
			easing,
			css: (t) =>
				'overflow: hidden;' +
				`opacity: ${Math.min(t * 20, 1) * opacity};` +
				`${primary_property}: ${t * primary_property_value}px;` +
				`padding-${secondary_properties[0]}: ${t * padding_start_value}px;` +
				`padding-${secondary_properties[1]}: ${t * padding_end_value}px;` +
				`margin-${secondary_properties[0]}: ${t * margin_start_value}px;` +
				`margin-${secondary_properties[1]}: ${t * margin_end_value}px;` +
				`border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;` +
				`border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;` +
				`min-${primary_property}: 0`
		};
	}

	var es_array_find = {};

	var hasRequiredEs_array_find;

	function requireEs_array_find () {
		if (hasRequiredEs_array_find) return es_array_find;
		hasRequiredEs_array_find = 1;
		var $ = require_export();
		var $find = requireArrayIteration().find;
		var addToUnscopables = requireAddToUnscopables();

		var FIND = 'find';
		var SKIPS_HOLES = true;

		// Shouldn't skip holes
		// eslint-disable-next-line es/no-array-prototype-find -- testing
		if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

		// `Array.prototype.find` method
		// https://tc39.es/ecma262/#sec-array.prototype.find
		$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
		  find: function find(callbackfn /* , that = undefined */) {
		    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
		  }
		});

		// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
		addToUnscopables(FIND);
		return es_array_find;
	}

	requireEs_array_find();

	var es_array_from = {};

	var callWithSafeIterationClosing;
	var hasRequiredCallWithSafeIterationClosing;

	function requireCallWithSafeIterationClosing () {
		if (hasRequiredCallWithSafeIterationClosing) return callWithSafeIterationClosing;
		hasRequiredCallWithSafeIterationClosing = 1;
		var anObject = requireAnObject();
		var iteratorClose = requireIteratorClose();

		// call something on iterator step with safe closing on error
		callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
		  try {
		    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
		  } catch (error) {
		    iteratorClose(iterator, 'throw', error);
		  }
		};
		return callWithSafeIterationClosing;
	}

	var arrayFrom;
	var hasRequiredArrayFrom;

	function requireArrayFrom () {
		if (hasRequiredArrayFrom) return arrayFrom;
		hasRequiredArrayFrom = 1;
		var bind = requireFunctionBindContext();
		var call = requireFunctionCall();
		var toObject = requireToObject();
		var callWithSafeIterationClosing = requireCallWithSafeIterationClosing();
		var isArrayIteratorMethod = requireIsArrayIteratorMethod();
		var isConstructor = requireIsConstructor();
		var lengthOfArrayLike = requireLengthOfArrayLike();
		var createProperty = requireCreateProperty();
		var getIterator = requireGetIterator();
		var getIteratorMethod = requireGetIteratorMethod();

		var $Array = Array;

		// `Array.from` method implementation
		// https://tc39.es/ecma262/#sec-array.from
		arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
		  var O = toObject(arrayLike);
		  var IS_CONSTRUCTOR = isConstructor(this);
		  var argumentsLength = arguments.length;
		  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
		  var mapping = mapfn !== undefined;
		  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
		  var iteratorMethod = getIteratorMethod(O);
		  var index = 0;
		  var length, result, step, iterator, next, value;
		  // if the target is not iterable or it's an array with the default iterator - use a simple case
		  if (iteratorMethod && !(this === $Array && isArrayIteratorMethod(iteratorMethod))) {
		    result = IS_CONSTRUCTOR ? new this() : [];
		    iterator = getIterator(O, iteratorMethod);
		    next = iterator.next;
		    for (;!(step = call(next, iterator)).done; index++) {
		      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
		      createProperty(result, index, value);
		    }
		  } else {
		    length = lengthOfArrayLike(O);
		    result = IS_CONSTRUCTOR ? new this(length) : $Array(length);
		    for (;length > index; index++) {
		      value = mapping ? mapfn(O[index], index) : O[index];
		      createProperty(result, index, value);
		    }
		  }
		  result.length = index;
		  return result;
		};
		return arrayFrom;
	}

	var hasRequiredEs_array_from;

	function requireEs_array_from () {
		if (hasRequiredEs_array_from) return es_array_from;
		hasRequiredEs_array_from = 1;
		var $ = require_export();
		var from = requireArrayFrom();
		var checkCorrectnessOfIteration = requireCheckCorrectnessOfIteration();

		var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
		  // eslint-disable-next-line es/no-array-from -- required for testing
		  Array.from(iterable);
		});

		// `Array.from` method
		// https://tc39.es/ecma262/#sec-array.from
		$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
		  from: from
		});
		return es_array_from;
	}

	requireEs_array_from();

	var correctPrototypeGetter;
	var hasRequiredCorrectPrototypeGetter;

	function requireCorrectPrototypeGetter () {
		if (hasRequiredCorrectPrototypeGetter) return correctPrototypeGetter;
		hasRequiredCorrectPrototypeGetter = 1;
		var fails = requireFails();

		correctPrototypeGetter = !fails(function () {
		  function F() { /* empty */ }
		  F.prototype.constructor = null;
		  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
		  return Object.getPrototypeOf(new F()) !== F.prototype;
		});
		return correctPrototypeGetter;
	}

	var objectGetPrototypeOf;
	var hasRequiredObjectGetPrototypeOf;

	function requireObjectGetPrototypeOf () {
		if (hasRequiredObjectGetPrototypeOf) return objectGetPrototypeOf;
		hasRequiredObjectGetPrototypeOf = 1;
		var hasOwn = requireHasOwnProperty();
		var isCallable = requireIsCallable();
		var toObject = requireToObject();
		var sharedKey = requireSharedKey();
		var CORRECT_PROTOTYPE_GETTER = requireCorrectPrototypeGetter();

		var IE_PROTO = sharedKey('IE_PROTO');
		var $Object = Object;
		var ObjectPrototype = $Object.prototype;

		// `Object.getPrototypeOf` method
		// https://tc39.es/ecma262/#sec-object.getprototypeof
		// eslint-disable-next-line es/no-object-getprototypeof -- safe
		objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
		  var object = toObject(O);
		  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
		  var constructor = object.constructor;
		  if (isCallable(constructor) && object instanceof constructor) {
		    return constructor.prototype;
		  } return object instanceof $Object ? ObjectPrototype : null;
		};
		return objectGetPrototypeOf;
	}

	var iteratorsCore;
	var hasRequiredIteratorsCore;

	function requireIteratorsCore () {
		if (hasRequiredIteratorsCore) return iteratorsCore;
		hasRequiredIteratorsCore = 1;
		var fails = requireFails();
		var isCallable = requireIsCallable();
		var isObject = requireIsObject();
		var create = requireObjectCreate();
		var getPrototypeOf = requireObjectGetPrototypeOf();
		var defineBuiltIn = requireDefineBuiltIn();
		var wellKnownSymbol = requireWellKnownSymbol();
		var IS_PURE = requireIsPure();

		var ITERATOR = wellKnownSymbol('iterator');
		var BUGGY_SAFARI_ITERATORS = false;

		// `%IteratorPrototype%` object
		// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
		var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

		/* eslint-disable es/no-array-prototype-keys -- safe */
		if ([].keys) {
		  arrayIterator = [].keys();
		  // Safari 8 has buggy iterators w/o `next`
		  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
		  else {
		    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
		    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
		  }
		}

		var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
		  var test = {};
		  // FF44- legacy iterators case
		  return IteratorPrototype[ITERATOR].call(test) !== test;
		});

		if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
		else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

		// `%IteratorPrototype%[@@iterator]()` method
		// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
		if (!isCallable(IteratorPrototype[ITERATOR])) {
		  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
		    return this;
		  });
		}

		iteratorsCore = {
		  IteratorPrototype: IteratorPrototype,
		  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
		};
		return iteratorsCore;
	}

	var iteratorCreateConstructor;
	var hasRequiredIteratorCreateConstructor;

	function requireIteratorCreateConstructor () {
		if (hasRequiredIteratorCreateConstructor) return iteratorCreateConstructor;
		hasRequiredIteratorCreateConstructor = 1;
		var IteratorPrototype = requireIteratorsCore().IteratorPrototype;
		var create = requireObjectCreate();
		var createPropertyDescriptor = requireCreatePropertyDescriptor();
		var setToStringTag = requireSetToStringTag();
		var Iterators = requireIterators();

		var returnThis = function () { return this; };

		iteratorCreateConstructor = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
		  var TO_STRING_TAG = NAME + ' Iterator';
		  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
		  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
		  Iterators[TO_STRING_TAG] = returnThis;
		  return IteratorConstructor;
		};
		return iteratorCreateConstructor;
	}

	var iteratorDefine;
	var hasRequiredIteratorDefine;

	function requireIteratorDefine () {
		if (hasRequiredIteratorDefine) return iteratorDefine;
		hasRequiredIteratorDefine = 1;
		var $ = require_export();
		var call = requireFunctionCall();
		var IS_PURE = requireIsPure();
		var FunctionName = requireFunctionName();
		var isCallable = requireIsCallable();
		var createIteratorConstructor = requireIteratorCreateConstructor();
		var getPrototypeOf = requireObjectGetPrototypeOf();
		var setPrototypeOf = requireObjectSetPrototypeOf();
		var setToStringTag = requireSetToStringTag();
		var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
		var defineBuiltIn = requireDefineBuiltIn();
		var wellKnownSymbol = requireWellKnownSymbol();
		var Iterators = requireIterators();
		var IteratorsCore = requireIteratorsCore();

		var PROPER_FUNCTION_NAME = FunctionName.PROPER;
		var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
		var IteratorPrototype = IteratorsCore.IteratorPrototype;
		var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
		var ITERATOR = wellKnownSymbol('iterator');
		var KEYS = 'keys';
		var VALUES = 'values';
		var ENTRIES = 'entries';

		var returnThis = function () { return this; };

		iteratorDefine = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
		  createIteratorConstructor(IteratorConstructor, NAME, next);

		  var getIterationMethod = function (KIND) {
		    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
		    if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];

		    switch (KIND) {
		      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
		      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
		      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
		    }

		    return function () { return new IteratorConstructor(this); };
		  };

		  var TO_STRING_TAG = NAME + ' Iterator';
		  var INCORRECT_VALUES_NAME = false;
		  var IterablePrototype = Iterable.prototype;
		  var nativeIterator = IterablePrototype[ITERATOR]
		    || IterablePrototype['@@iterator']
		    || DEFAULT && IterablePrototype[DEFAULT];
		  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
		  var anyNativeIterator = NAME === 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
		  var CurrentIteratorPrototype, methods, KEY;

		  // fix native
		  if (anyNativeIterator) {
		    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
		    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
		      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
		        if (setPrototypeOf) {
		          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
		        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
		          defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
		        }
		      }
		      // Set @@toStringTag to native iterators
		      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
		      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
		    }
		  }

		  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
		  if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
		    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
		      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
		    } else {
		      INCORRECT_VALUES_NAME = true;
		      defaultIterator = function values() { return call(nativeIterator, this); };
		    }
		  }

		  // export additional methods
		  if (DEFAULT) {
		    methods = {
		      values: getIterationMethod(VALUES),
		      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
		      entries: getIterationMethod(ENTRIES)
		    };
		    if (FORCED) for (KEY in methods) {
		      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
		        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
		      }
		    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
		  }

		  // define iterator
		  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
		    defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
		  }
		  Iterators[NAME] = defaultIterator;

		  return methods;
		};
		return iteratorDefine;
	}

	var createIterResultObject;
	var hasRequiredCreateIterResultObject;

	function requireCreateIterResultObject () {
		if (hasRequiredCreateIterResultObject) return createIterResultObject;
		hasRequiredCreateIterResultObject = 1;
		// `CreateIterResultObject` abstract operation
		// https://tc39.es/ecma262/#sec-createiterresultobject
		createIterResultObject = function (value, done) {
		  return { value: value, done: done };
		};
		return createIterResultObject;
	}

	var es_array_iterator;
	var hasRequiredEs_array_iterator;

	function requireEs_array_iterator () {
		if (hasRequiredEs_array_iterator) return es_array_iterator;
		hasRequiredEs_array_iterator = 1;
		var toIndexedObject = requireToIndexedObject();
		var addToUnscopables = requireAddToUnscopables();
		var Iterators = requireIterators();
		var InternalStateModule = requireInternalState();
		var defineProperty = requireObjectDefineProperty().f;
		var defineIterator = requireIteratorDefine();
		var createIterResultObject = requireCreateIterResultObject();
		var IS_PURE = requireIsPure();
		var DESCRIPTORS = requireDescriptors();

		var ARRAY_ITERATOR = 'Array Iterator';
		var setInternalState = InternalStateModule.set;
		var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

		// `Array.prototype.entries` method
		// https://tc39.es/ecma262/#sec-array.prototype.entries
		// `Array.prototype.keys` method
		// https://tc39.es/ecma262/#sec-array.prototype.keys
		// `Array.prototype.values` method
		// https://tc39.es/ecma262/#sec-array.prototype.values
		// `Array.prototype[@@iterator]` method
		// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
		// `CreateArrayIterator` internal method
		// https://tc39.es/ecma262/#sec-createarrayiterator
		es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
		  setInternalState(this, {
		    type: ARRAY_ITERATOR,
		    target: toIndexedObject(iterated), // target
		    index: 0,                          // next index
		    kind: kind                         // kind
		  });
		// `%ArrayIteratorPrototype%.next` method
		// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
		}, function () {
		  var state = getInternalState(this);
		  var target = state.target;
		  var index = state.index++;
		  if (!target || index >= target.length) {
		    state.target = null;
		    return createIterResultObject(undefined, true);
		  }
		  switch (state.kind) {
		    case 'keys': return createIterResultObject(index, false);
		    case 'values': return createIterResultObject(target[index], false);
		  } return createIterResultObject([index, target[index]], false);
		}, 'values');

		// argumentsList[@@iterator] is %ArrayProto_values%
		// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
		// https://tc39.es/ecma262/#sec-createmappedargumentsobject
		var values = Iterators.Arguments = Iterators.Array;

		// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
		addToUnscopables('keys');
		addToUnscopables('values');
		addToUnscopables('entries');

		// V8 ~ Chrome 45- bug
		if (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {
		  defineProperty(values, 'name', { value: 'values' });
		} catch (error) { /* empty */ }
		return es_array_iterator;
	}

	requireEs_array_iterator();

	var es_array_slice = {};

	var hasRequiredEs_array_slice;

	function requireEs_array_slice () {
		if (hasRequiredEs_array_slice) return es_array_slice;
		hasRequiredEs_array_slice = 1;
		var $ = require_export();
		var isArray = requireIsArray();
		var isConstructor = requireIsConstructor();
		var isObject = requireIsObject();
		var toAbsoluteIndex = requireToAbsoluteIndex();
		var lengthOfArrayLike = requireLengthOfArrayLike();
		var toIndexedObject = requireToIndexedObject();
		var createProperty = requireCreateProperty();
		var wellKnownSymbol = requireWellKnownSymbol();
		var arrayMethodHasSpeciesSupport = requireArrayMethodHasSpeciesSupport();
		var nativeSlice = requireArraySlice();

		var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');

		var SPECIES = wellKnownSymbol('species');
		var $Array = Array;
		var max = Math.max;

		// `Array.prototype.slice` method
		// https://tc39.es/ecma262/#sec-array.prototype.slice
		// fallback for not array-like ES3 strings and DOM objects
		$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
		  slice: function slice(start, end) {
		    var O = toIndexedObject(this);
		    var length = lengthOfArrayLike(O);
		    var k = toAbsoluteIndex(start, length);
		    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
		    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
		    var Constructor, result, n;
		    if (isArray(O)) {
		      Constructor = O.constructor;
		      // cross-realm fallback
		      if (isConstructor(Constructor) && (Constructor === $Array || isArray(Constructor.prototype))) {
		        Constructor = undefined;
		      } else if (isObject(Constructor)) {
		        Constructor = Constructor[SPECIES];
		        if (Constructor === null) Constructor = undefined;
		      }
		      if (Constructor === $Array || Constructor === undefined) {
		        return nativeSlice(O, k, fin);
		      }
		    }
		    result = new (Constructor === undefined ? $Array : Constructor)(max(fin - k, 0));
		    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
		    result.length = n;
		    return result;
		  }
		});
		return es_array_slice;
	}

	requireEs_array_slice();

	var es_string_iterator = {};

	var hasRequiredEs_string_iterator;

	function requireEs_string_iterator () {
		if (hasRequiredEs_string_iterator) return es_string_iterator;
		hasRequiredEs_string_iterator = 1;
		var charAt = requireStringMultibyte().charAt;
		var toString = requireToString();
		var InternalStateModule = requireInternalState();
		var defineIterator = requireIteratorDefine();
		var createIterResultObject = requireCreateIterResultObject();

		var STRING_ITERATOR = 'String Iterator';
		var setInternalState = InternalStateModule.set;
		var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

		// `String.prototype[@@iterator]` method
		// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
		defineIterator(String, 'String', function (iterated) {
		  setInternalState(this, {
		    type: STRING_ITERATOR,
		    string: toString(iterated),
		    index: 0
		  });
		// `%StringIteratorPrototype%.next` method
		// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
		}, function next() {
		  var state = getInternalState(this);
		  var string = state.string;
		  var index = state.index;
		  var point;
		  if (index >= string.length) return createIterResultObject(undefined, true);
		  point = charAt(string, index);
		  state.index += point.length;
		  return createIterResultObject(point, false);
		});
		return es_string_iterator;
	}

	requireEs_string_iterator();

	var es_string_search = {};

	var sameValue;
	var hasRequiredSameValue;

	function requireSameValue () {
		if (hasRequiredSameValue) return sameValue;
		hasRequiredSameValue = 1;
		// `SameValue` abstract operation
		// https://tc39.es/ecma262/#sec-samevalue
		// eslint-disable-next-line es/no-object-is -- safe
		sameValue = Object.is || function is(x, y) {
		  // eslint-disable-next-line no-self-compare -- NaN check
		  return x === y ? x !== 0 || 1 / x === 1 / y : x !== x && y !== y;
		};
		return sameValue;
	}

	var hasRequiredEs_string_search;

	function requireEs_string_search () {
		if (hasRequiredEs_string_search) return es_string_search;
		hasRequiredEs_string_search = 1;
		var call = requireFunctionCall();
		var fixRegExpWellKnownSymbolLogic = requireFixRegexpWellKnownSymbolLogic();
		var anObject = requireAnObject();
		var isObject = requireIsObject();
		var requireObjectCoercible = requireRequireObjectCoercible();
		var sameValue = requireSameValue();
		var toString = requireToString();
		var getMethod = requireGetMethod();
		var regExpExec = requireRegexpExecAbstract();

		// @@search logic
		fixRegExpWellKnownSymbolLogic('search', function (SEARCH, nativeSearch, maybeCallNative) {
		  return [
		    // `String.prototype.search` method
		    // https://tc39.es/ecma262/#sec-string.prototype.search
		    function search(regexp) {
		      var O = requireObjectCoercible(this);
		      var searcher = isObject(regexp) ? getMethod(regexp, SEARCH) : undefined;
		      return searcher ? call(searcher, regexp, O) : new RegExp(regexp)[SEARCH](toString(O));
		    },
		    // `RegExp.prototype[@@search]` method
		    // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
		    function (string) {
		      var rx = anObject(this);
		      var S = toString(string);
		      var res = maybeCallNative(nativeSearch, rx, S);

		      if (res.done) return res.value;

		      var previousLastIndex = rx.lastIndex;
		      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
		      var result = regExpExec(rx, S);
		      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
		      return result === null ? -1 : result.index;
		    }
		  ];
		});
		return es_string_search;
	}

	requireEs_string_search();

	var web_domCollections_iterator = {};

	var hasRequiredWeb_domCollections_iterator;

	function requireWeb_domCollections_iterator () {
		if (hasRequiredWeb_domCollections_iterator) return web_domCollections_iterator;
		hasRequiredWeb_domCollections_iterator = 1;
		var globalThis = requireGlobalThis();
		var DOMIterables = requireDomIterables();
		var DOMTokenListPrototype = requireDomTokenListPrototype();
		var ArrayIteratorMethods = requireEs_array_iterator();
		var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
		var setToStringTag = requireSetToStringTag();
		var wellKnownSymbol = requireWellKnownSymbol();

		var ITERATOR = wellKnownSymbol('iterator');
		var ArrayValues = ArrayIteratorMethods.values;

		var handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {
		  if (CollectionPrototype) {
		    // some Chrome versions have non-configurable methods on DOMTokenList
		    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
		      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
		    } catch (error) {
		      CollectionPrototype[ITERATOR] = ArrayValues;
		    }
		    setToStringTag(CollectionPrototype, COLLECTION_NAME, true);
		    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
		      // some Chrome versions have non-configurable methods on DOMTokenList
		      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
		        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
		      } catch (error) {
		        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
		      }
		    }
		  }
		};

		for (var COLLECTION_NAME in DOMIterables) {
		  handlePrototype(globalThis[COLLECTION_NAME] && globalThis[COLLECTION_NAME].prototype, COLLECTION_NAME);
		}

		handlePrototype(DOMTokenListPrototype, 'DOMTokenList');
		return web_domCollections_iterator;
	}

	requireWeb_domCollections_iterator();

	var web_url = {};

	var web_url_constructor = {};

	var urlConstructorDetection;
	var hasRequiredUrlConstructorDetection;

	function requireUrlConstructorDetection () {
		if (hasRequiredUrlConstructorDetection) return urlConstructorDetection;
		hasRequiredUrlConstructorDetection = 1;
		var fails = requireFails();
		var wellKnownSymbol = requireWellKnownSymbol();
		var DESCRIPTORS = requireDescriptors();
		var IS_PURE = requireIsPure();

		var ITERATOR = wellKnownSymbol('iterator');

		urlConstructorDetection = !fails(function () {
		  // eslint-disable-next-line unicorn/relative-url-style -- required for testing
		  var url = new URL('b?a=1&b=2&c=3', 'https://a');
		  var params = url.searchParams;
		  var params2 = new URLSearchParams('a=1&a=2&b=3');
		  var result = '';
		  url.pathname = 'c%20d';
		  params.forEach(function (value, key) {
		    params['delete']('b');
		    result += key + value;
		  });
		  params2['delete']('a', 2);
		  // `undefined` case is a Chromium 117 bug
		  // https://bugs.chromium.org/p/v8/issues/detail?id=14222
		  params2['delete']('b', undefined);
		  return (IS_PURE && (!url.toJSON || !params2.has('a', 1) || params2.has('a', 2) || !params2.has('a', undefined) || params2.has('b')))
		    || (!params.size && (IS_PURE || !DESCRIPTORS))
		    || !params.sort
		    || url.href !== 'https://a/c%20d?a=1&c=3'
		    || params.get('c') !== '3'
		    || String(new URLSearchParams('?a=1')) !== 'a=1'
		    || !params[ITERATOR]
		    // throws in Edge
		    || new URL('https://a@b').username !== 'a'
		    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
		    // not punycoded in Edge
		    || new URL('https://ÑÐµÑÑ').host !== 'xn--e1aybc'
		    // not escaped in Chrome 62-
		    || new URL('https://a#Ð±').hash !== '#%D0%B1'
		    // fails in Chrome 66-
		    || result !== 'a1c3'
		    // throws in Safari
		    || new URL('https://x', undefined).host !== 'x';
		});
		return urlConstructorDetection;
	}

	var stringPunycodeToAscii;
	var hasRequiredStringPunycodeToAscii;

	function requireStringPunycodeToAscii () {
		if (hasRequiredStringPunycodeToAscii) return stringPunycodeToAscii;
		hasRequiredStringPunycodeToAscii = 1;
		// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
		var uncurryThis = requireFunctionUncurryThis();

		var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
		var base = 36;
		var tMin = 1;
		var tMax = 26;
		var skew = 38;
		var damp = 700;
		var initialBias = 72;
		var initialN = 128; // 0x80
		var delimiter = '-'; // '\x2D'
		var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
		var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
		var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
		var baseMinusTMin = base - tMin;

		var $RangeError = RangeError;
		var exec = uncurryThis(regexSeparators.exec);
		var floor = Math.floor;
		var fromCharCode = String.fromCharCode;
		var charCodeAt = uncurryThis(''.charCodeAt);
		var join = uncurryThis([].join);
		var push = uncurryThis([].push);
		var replace = uncurryThis(''.replace);
		var split = uncurryThis(''.split);
		var toLowerCase = uncurryThis(''.toLowerCase);

		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 */
		var ucs2decode = function (string) {
		  var output = [];
		  var counter = 0;
		  var length = string.length;
		  while (counter < length) {
		    var value = charCodeAt(string, counter++);
		    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
		      // It's a high surrogate, and there is a next character.
		      var extra = charCodeAt(string, counter++);
		      if ((extra & 0xFC00) === 0xDC00) { // Low surrogate.
		        push(output, ((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
		      } else {
		        // It's an unmatched surrogate; only append this code unit, in case the
		        // next code unit is the high surrogate of a surrogate pair.
		        push(output, value);
		        counter--;
		      }
		    } else {
		      push(output, value);
		    }
		  }
		  return output;
		};

		/**
		 * Converts a digit/integer into a basic code point.
		 */
		var digitToBasic = function (digit) {
		  //  0..25 map to ASCII a..z or A..Z
		  // 26..35 map to ASCII 0..9
		  return digit + 22 + 75 * (digit < 26);
		};

		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * https://tools.ietf.org/html/rfc3492#section-3.4
		 */
		var adapt = function (delta, numPoints, firstTime) {
		  var k = 0;
		  delta = firstTime ? floor(delta / damp) : delta >> 1;
		  delta += floor(delta / numPoints);
		  while (delta > baseMinusTMin * tMax >> 1) {
		    delta = floor(delta / baseMinusTMin);
		    k += base;
		  }
		  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		};

		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 */
		var encode = function (input) {
		  var output = [];

		  // Convert the input in UCS-2 to an array of Unicode code points.
		  input = ucs2decode(input);

		  // Cache the length.
		  var inputLength = input.length;

		  // Initialize the state.
		  var n = initialN;
		  var delta = 0;
		  var bias = initialBias;
		  var i, currentValue;

		  // Handle the basic code points.
		  for (i = 0; i < input.length; i++) {
		    currentValue = input[i];
		    if (currentValue < 0x80) {
		      push(output, fromCharCode(currentValue));
		    }
		  }

		  var basicLength = output.length; // number of basic code points.
		  var handledCPCount = basicLength; // number of code points that have been handled;

		  // Finish the basic string with a delimiter unless it's empty.
		  if (basicLength) {
		    push(output, delimiter);
		  }

		  // Main encoding loop:
		  while (handledCPCount < inputLength) {
		    // All non-basic code points < n have been handled already. Find the next larger one:
		    var m = maxInt;
		    for (i = 0; i < input.length; i++) {
		      currentValue = input[i];
		      if (currentValue >= n && currentValue < m) {
		        m = currentValue;
		      }
		    }

		    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
		    var handledCPCountPlusOne = handledCPCount + 1;
		    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
		      throw new $RangeError(OVERFLOW_ERROR);
		    }

		    delta += (m - n) * handledCPCountPlusOne;
		    n = m;

		    for (i = 0; i < input.length; i++) {
		      currentValue = input[i];
		      if (currentValue < n && ++delta > maxInt) {
		        throw new $RangeError(OVERFLOW_ERROR);
		      }
		      if (currentValue === n) {
		        // Represent delta as a generalized variable-length integer.
		        var q = delta;
		        var k = base;
		        while (true) {
		          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
		          if (q < t) break;
		          var qMinusT = q - t;
		          var baseMinusT = base - t;
		          push(output, fromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
		          q = floor(qMinusT / baseMinusT);
		          k += base;
		        }

		        push(output, fromCharCode(digitToBasic(q)));
		        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
		        delta = 0;
		        handledCPCount++;
		      }
		    }

		    delta++;
		    n++;
		  }
		  return join(output, '');
		};

		stringPunycodeToAscii = function (input) {
		  var encoded = [];
		  var labels = split(replace(toLowerCase(input), regexSeparators, '\u002E'), '.');
		  var i, label;
		  for (i = 0; i < labels.length; i++) {
		    label = labels[i];
		    push(encoded, exec(regexNonASCII, label) ? 'xn--' + encode(label) : label);
		  }
		  return join(encoded, '.');
		};
		return stringPunycodeToAscii;
	}

	var es_string_fromCodePoint = {};

	var hasRequiredEs_string_fromCodePoint;

	function requireEs_string_fromCodePoint () {
		if (hasRequiredEs_string_fromCodePoint) return es_string_fromCodePoint;
		hasRequiredEs_string_fromCodePoint = 1;
		var $ = require_export();
		var uncurryThis = requireFunctionUncurryThis();
		var toAbsoluteIndex = requireToAbsoluteIndex();

		var $RangeError = RangeError;
		var fromCharCode = String.fromCharCode;
		// eslint-disable-next-line es/no-string-fromcodepoint -- required for testing
		var $fromCodePoint = String.fromCodePoint;
		var join = uncurryThis([].join);

		// length should be 1, old FF problem
		var INCORRECT_LENGTH = !!$fromCodePoint && $fromCodePoint.length !== 1;

		// `String.fromCodePoint` method
		// https://tc39.es/ecma262/#sec-string.fromcodepoint
		$({ target: 'String', stat: true, arity: 1, forced: INCORRECT_LENGTH }, {
		  // eslint-disable-next-line no-unused-vars -- required for `.length`
		  fromCodePoint: function fromCodePoint(x) {
		    var elements = [];
		    var length = arguments.length;
		    var i = 0;
		    var code;
		    while (length > i) {
		      code = +arguments[i++];
		      if (toAbsoluteIndex(code, 0x10FFFF) !== code) throw new $RangeError(code + ' is not a valid code point');
		      elements[i] = code < 0x10000
		        ? fromCharCode(code)
		        : fromCharCode(((code -= 0x10000) >> 10) + 0xD800, code % 0x400 + 0xDC00);
		    } return join(elements, '');
		  }
		});
		return es_string_fromCodePoint;
	}

	var defineBuiltIns;
	var hasRequiredDefineBuiltIns;

	function requireDefineBuiltIns () {
		if (hasRequiredDefineBuiltIns) return defineBuiltIns;
		hasRequiredDefineBuiltIns = 1;
		var defineBuiltIn = requireDefineBuiltIn();

		defineBuiltIns = function (target, src, options) {
		  for (var key in src) defineBuiltIn(target, key, src[key], options);
		  return target;
		};
		return defineBuiltIns;
	}

	var arraySort;
	var hasRequiredArraySort;

	function requireArraySort () {
		if (hasRequiredArraySort) return arraySort;
		hasRequiredArraySort = 1;
		var arraySlice = requireArraySlice();

		var floor = Math.floor;

		var sort = function (array, comparefn) {
		  var length = array.length;

		  if (length < 8) {
		    // insertion sort
		    var i = 1;
		    var element, j;

		    while (i < length) {
		      j = i;
		      element = array[i];
		      while (j && comparefn(array[j - 1], element) > 0) {
		        array[j] = array[--j];
		      }
		      if (j !== i++) array[j] = element;
		    }
		  } else {
		    // merge sort
		    var middle = floor(length / 2);
		    var left = sort(arraySlice(array, 0, middle), comparefn);
		    var right = sort(arraySlice(array, middle), comparefn);
		    var llength = left.length;
		    var rlength = right.length;
		    var lindex = 0;
		    var rindex = 0;

		    while (lindex < llength || rindex < rlength) {
		      array[lindex + rindex] = (lindex < llength && rindex < rlength)
		        ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]
		        : lindex < llength ? left[lindex++] : right[rindex++];
		    }
		  }

		  return array;
		};

		arraySort = sort;
		return arraySort;
	}

	var web_urlSearchParams_constructor;
	var hasRequiredWeb_urlSearchParams_constructor;

	function requireWeb_urlSearchParams_constructor () {
		if (hasRequiredWeb_urlSearchParams_constructor) return web_urlSearchParams_constructor;
		hasRequiredWeb_urlSearchParams_constructor = 1;
		// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
		requireEs_array_iterator();
		requireEs_string_fromCodePoint();
		var $ = require_export();
		var globalThis = requireGlobalThis();
		var safeGetBuiltIn = requireSafeGetBuiltIn();
		var getBuiltIn = requireGetBuiltIn();
		var call = requireFunctionCall();
		var uncurryThis = requireFunctionUncurryThis();
		var DESCRIPTORS = requireDescriptors();
		var USE_NATIVE_URL = requireUrlConstructorDetection();
		var defineBuiltIn = requireDefineBuiltIn();
		var defineBuiltInAccessor = requireDefineBuiltInAccessor();
		var defineBuiltIns = requireDefineBuiltIns();
		var setToStringTag = requireSetToStringTag();
		var createIteratorConstructor = requireIteratorCreateConstructor();
		var InternalStateModule = requireInternalState();
		var anInstance = requireAnInstance();
		var isCallable = requireIsCallable();
		var hasOwn = requireHasOwnProperty();
		var bind = requireFunctionBindContext();
		var classof = requireClassof();
		var anObject = requireAnObject();
		var isObject = requireIsObject();
		var $toString = requireToString();
		var create = requireObjectCreate();
		var createPropertyDescriptor = requireCreatePropertyDescriptor();
		var getIterator = requireGetIterator();
		var getIteratorMethod = requireGetIteratorMethod();
		var createIterResultObject = requireCreateIterResultObject();
		var validateArgumentsLength = requireValidateArgumentsLength();
		var wellKnownSymbol = requireWellKnownSymbol();
		var arraySort = requireArraySort();

		var ITERATOR = wellKnownSymbol('iterator');
		var URL_SEARCH_PARAMS = 'URLSearchParams';
		var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
		var setInternalState = InternalStateModule.set;
		var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
		var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);

		var nativeFetch = safeGetBuiltIn('fetch');
		var NativeRequest = safeGetBuiltIn('Request');
		var Headers = safeGetBuiltIn('Headers');
		var RequestPrototype = NativeRequest && NativeRequest.prototype;
		var HeadersPrototype = Headers && Headers.prototype;
		var TypeError = globalThis.TypeError;
		var encodeURIComponent = globalThis.encodeURIComponent;
		var fromCharCode = String.fromCharCode;
		var fromCodePoint = getBuiltIn('String', 'fromCodePoint');
		var $parseInt = parseInt;
		var charAt = uncurryThis(''.charAt);
		var join = uncurryThis([].join);
		var push = uncurryThis([].push);
		var replace = uncurryThis(''.replace);
		var shift = uncurryThis([].shift);
		var splice = uncurryThis([].splice);
		var split = uncurryThis(''.split);
		var stringSlice = uncurryThis(''.slice);
		var exec = uncurryThis(/./.exec);

		var plus = /\+/g;
		var FALLBACK_REPLACER = '\uFFFD';
		var VALID_HEX = /^[0-9a-f]+$/i;

		var parseHexOctet = function (string, start) {
		  var substr = stringSlice(string, start, start + 2);
		  if (!exec(VALID_HEX, substr)) return NaN;

		  return $parseInt(substr, 16);
		};

		var getLeadingOnes = function (octet) {
		  var count = 0;
		  for (var mask = 0x80; mask > 0 && (octet & mask) !== 0; mask >>= 1) {
		    count++;
		  }
		  return count;
		};

		var utf8Decode = function (octets) {
		  var codePoint = null;

		  switch (octets.length) {
		    case 1:
		      codePoint = octets[0];
		      break;
		    case 2:
		      codePoint = (octets[0] & 0x1F) << 6 | (octets[1] & 0x3F);
		      break;
		    case 3:
		      codePoint = (octets[0] & 0x0F) << 12 | (octets[1] & 0x3F) << 6 | (octets[2] & 0x3F);
		      break;
		    case 4:
		      codePoint = (octets[0] & 0x07) << 18 | (octets[1] & 0x3F) << 12 | (octets[2] & 0x3F) << 6 | (octets[3] & 0x3F);
		      break;
		  }

		  return codePoint > 0x10FFFF ? null : codePoint;
		};

		var decode = function (input) {
		  input = replace(input, plus, ' ');
		  var length = input.length;
		  var result = '';
		  var i = 0;

		  while (i < length) {
		    var decodedChar = charAt(input, i);

		    if (decodedChar === '%') {
		      if (charAt(input, i + 1) === '%' || i + 3 > length) {
		        result += '%';
		        i++;
		        continue;
		      }

		      var octet = parseHexOctet(input, i + 1);

		      // eslint-disable-next-line no-self-compare -- NaN check
		      if (octet !== octet) {
		        result += decodedChar;
		        i++;
		        continue;
		      }

		      i += 2;
		      var byteSequenceLength = getLeadingOnes(octet);

		      if (byteSequenceLength === 0) {
		        decodedChar = fromCharCode(octet);
		      } else {
		        if (byteSequenceLength === 1 || byteSequenceLength > 4) {
		          result += FALLBACK_REPLACER;
		          i++;
		          continue;
		        }

		        var octets = [octet];
		        var sequenceIndex = 1;

		        while (sequenceIndex < byteSequenceLength) {
		          i++;
		          if (i + 3 > length || charAt(input, i) !== '%') break;

		          var nextByte = parseHexOctet(input, i + 1);

		          // eslint-disable-next-line no-self-compare -- NaN check
		          if (nextByte !== nextByte) {
		            i += 3;
		            break;
		          }
		          if (nextByte > 191 || nextByte < 128) break;

		          push(octets, nextByte);
		          i += 2;
		          sequenceIndex++;
		        }

		        if (octets.length !== byteSequenceLength) {
		          result += FALLBACK_REPLACER;
		          continue;
		        }

		        var codePoint = utf8Decode(octets);
		        if (codePoint === null) {
		          result += FALLBACK_REPLACER;
		        } else {
		          decodedChar = fromCodePoint(codePoint);
		        }
		      }
		    }

		    result += decodedChar;
		    i++;
		  }

		  return result;
		};

		var find = /[!'()~]|%20/g;

		var replacements = {
		  '!': '%21',
		  "'": '%27',
		  '(': '%28',
		  ')': '%29',
		  '~': '%7E',
		  '%20': '+'
		};

		var replacer = function (match) {
		  return replacements[match];
		};

		var serialize = function (it) {
		  return replace(encodeURIComponent(it), find, replacer);
		};

		var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
		  setInternalState(this, {
		    type: URL_SEARCH_PARAMS_ITERATOR,
		    target: getInternalParamsState(params).entries,
		    index: 0,
		    kind: kind
		  });
		}, URL_SEARCH_PARAMS, function next() {
		  var state = getInternalIteratorState(this);
		  var target = state.target;
		  var index = state.index++;
		  if (!target || index >= target.length) {
		    state.target = null;
		    return createIterResultObject(undefined, true);
		  }
		  var entry = target[index];
		  switch (state.kind) {
		    case 'keys': return createIterResultObject(entry.key, false);
		    case 'values': return createIterResultObject(entry.value, false);
		  } return createIterResultObject([entry.key, entry.value], false);
		}, true);

		var URLSearchParamsState = function (init) {
		  this.entries = [];
		  this.url = null;

		  if (init !== undefined) {
		    if (isObject(init)) this.parseObject(init);
		    else this.parseQuery(typeof init == 'string' ? charAt(init, 0) === '?' ? stringSlice(init, 1) : init : $toString(init));
		  }
		};

		URLSearchParamsState.prototype = {
		  type: URL_SEARCH_PARAMS,
		  bindURL: function (url) {
		    this.url = url;
		    this.update();
		  },
		  parseObject: function (object) {
		    var entries = this.entries;
		    var iteratorMethod = getIteratorMethod(object);
		    var iterator, next, step, entryIterator, entryNext, first, second;

		    if (iteratorMethod) {
		      iterator = getIterator(object, iteratorMethod);
		      next = iterator.next;
		      while (!(step = call(next, iterator)).done) {
		        entryIterator = getIterator(anObject(step.value));
		        entryNext = entryIterator.next;
		        if (
		          (first = call(entryNext, entryIterator)).done ||
		          (second = call(entryNext, entryIterator)).done ||
		          !call(entryNext, entryIterator).done
		        ) throw new TypeError('Expected sequence with length 2');
		        push(entries, { key: $toString(first.value), value: $toString(second.value) });
		      }
		    } else for (var key in object) if (hasOwn(object, key)) {
		      push(entries, { key: key, value: $toString(object[key]) });
		    }
		  },
		  parseQuery: function (query) {
		    if (query) {
		      var entries = this.entries;
		      var attributes = split(query, '&');
		      var index = 0;
		      var attribute, entry;
		      while (index < attributes.length) {
		        attribute = attributes[index++];
		        if (attribute.length) {
		          entry = split(attribute, '=');
		          push(entries, {
		            key: decode(shift(entry)),
		            value: decode(join(entry, '='))
		          });
		        }
		      }
		    }
		  },
		  serialize: function () {
		    var entries = this.entries;
		    var result = [];
		    var index = 0;
		    var entry;
		    while (index < entries.length) {
		      entry = entries[index++];
		      push(result, serialize(entry.key) + '=' + serialize(entry.value));
		    } return join(result, '&');
		  },
		  update: function () {
		    this.entries.length = 0;
		    this.parseQuery(this.url.query);
		  },
		  updateURL: function () {
		    if (this.url) this.url.update();
		  }
		};

		// `URLSearchParams` constructor
		// https://url.spec.whatwg.org/#interface-urlsearchparams
		var URLSearchParamsConstructor = function URLSearchParams(/* init */) {
		  anInstance(this, URLSearchParamsPrototype);
		  var init = arguments.length > 0 ? arguments[0] : undefined;
		  var state = setInternalState(this, new URLSearchParamsState(init));
		  if (!DESCRIPTORS) this.size = state.entries.length;
		};

		var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;

		defineBuiltIns(URLSearchParamsPrototype, {
		  // `URLSearchParams.prototype.append` method
		  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
		  append: function append(name, value) {
		    var state = getInternalParamsState(this);
		    validateArgumentsLength(arguments.length, 2);
		    push(state.entries, { key: $toString(name), value: $toString(value) });
		    if (!DESCRIPTORS) this.length++;
		    state.updateURL();
		  },
		  // `URLSearchParams.prototype.delete` method
		  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
		  'delete': function (name /* , value */) {
		    var state = getInternalParamsState(this);
		    var length = validateArgumentsLength(arguments.length, 1);
		    var entries = state.entries;
		    var key = $toString(name);
		    var $value = length < 2 ? undefined : arguments[1];
		    var value = $value === undefined ? $value : $toString($value);
		    var index = 0;
		    while (index < entries.length) {
		      var entry = entries[index];
		      if (entry.key === key && (value === undefined || entry.value === value)) {
		        splice(entries, index, 1);
		        if (value !== undefined) break;
		      } else index++;
		    }
		    if (!DESCRIPTORS) this.size = entries.length;
		    state.updateURL();
		  },
		  // `URLSearchParams.prototype.get` method
		  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
		  get: function get(name) {
		    var entries = getInternalParamsState(this).entries;
		    validateArgumentsLength(arguments.length, 1);
		    var key = $toString(name);
		    var index = 0;
		    for (; index < entries.length; index++) {
		      if (entries[index].key === key) return entries[index].value;
		    }
		    return null;
		  },
		  // `URLSearchParams.prototype.getAll` method
		  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
		  getAll: function getAll(name) {
		    var entries = getInternalParamsState(this).entries;
		    validateArgumentsLength(arguments.length, 1);
		    var key = $toString(name);
		    var result = [];
		    var index = 0;
		    for (; index < entries.length; index++) {
		      if (entries[index].key === key) push(result, entries[index].value);
		    }
		    return result;
		  },
		  // `URLSearchParams.prototype.has` method
		  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
		  has: function has(name /* , value */) {
		    var entries = getInternalParamsState(this).entries;
		    var length = validateArgumentsLength(arguments.length, 1);
		    var key = $toString(name);
		    var $value = length < 2 ? undefined : arguments[1];
		    var value = $value === undefined ? $value : $toString($value);
		    var index = 0;
		    while (index < entries.length) {
		      var entry = entries[index++];
		      if (entry.key === key && (value === undefined || entry.value === value)) return true;
		    }
		    return false;
		  },
		  // `URLSearchParams.prototype.set` method
		  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
		  set: function set(name, value) {
		    var state = getInternalParamsState(this);
		    validateArgumentsLength(arguments.length, 1);
		    var entries = state.entries;
		    var found = false;
		    var key = $toString(name);
		    var val = $toString(value);
		    var index = 0;
		    var entry;
		    for (; index < entries.length; index++) {
		      entry = entries[index];
		      if (entry.key === key) {
		        if (found) splice(entries, index--, 1);
		        else {
		          found = true;
		          entry.value = val;
		        }
		      }
		    }
		    if (!found) push(entries, { key: key, value: val });
		    if (!DESCRIPTORS) this.size = entries.length;
		    state.updateURL();
		  },
		  // `URLSearchParams.prototype.sort` method
		  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
		  sort: function sort() {
		    var state = getInternalParamsState(this);
		    arraySort(state.entries, function (a, b) {
		      return a.key > b.key ? 1 : -1;
		    });
		    state.updateURL();
		  },
		  // `URLSearchParams.prototype.forEach` method
		  forEach: function forEach(callback /* , thisArg */) {
		    var entries = getInternalParamsState(this).entries;
		    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined);
		    var index = 0;
		    var entry;
		    while (index < entries.length) {
		      entry = entries[index++];
		      boundFunction(entry.value, entry.key, this);
		    }
		  },
		  // `URLSearchParams.prototype.keys` method
		  keys: function keys() {
		    return new URLSearchParamsIterator(this, 'keys');
		  },
		  // `URLSearchParams.prototype.values` method
		  values: function values() {
		    return new URLSearchParamsIterator(this, 'values');
		  },
		  // `URLSearchParams.prototype.entries` method
		  entries: function entries() {
		    return new URLSearchParamsIterator(this, 'entries');
		  }
		}, { enumerable: true });

		// `URLSearchParams.prototype[@@iterator]` method
		defineBuiltIn(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, { name: 'entries' });

		// `URLSearchParams.prototype.toString` method
		// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
		defineBuiltIn(URLSearchParamsPrototype, 'toString', function toString() {
		  return getInternalParamsState(this).serialize();
		}, { enumerable: true });

		// `URLSearchParams.prototype.size` getter
		// https://github.com/whatwg/url/pull/734
		if (DESCRIPTORS) defineBuiltInAccessor(URLSearchParamsPrototype, 'size', {
		  get: function size() {
		    return getInternalParamsState(this).entries.length;
		  },
		  configurable: true,
		  enumerable: true
		});

		setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);

		$({ global: true, constructor: true, forced: !USE_NATIVE_URL }, {
		  URLSearchParams: URLSearchParamsConstructor
		});

		// Wrap `fetch` and `Request` for correct work with polyfilled `URLSearchParams`
		if (!USE_NATIVE_URL && isCallable(Headers)) {
		  var headersHas = uncurryThis(HeadersPrototype.has);
		  var headersSet = uncurryThis(HeadersPrototype.set);

		  var wrapRequestOptions = function (init) {
		    if (isObject(init)) {
		      var body = init.body;
		      var headers;
		      if (classof(body) === URL_SEARCH_PARAMS) {
		        headers = init.headers ? new Headers(init.headers) : new Headers();
		        if (!headersHas(headers, 'content-type')) {
		          headersSet(headers, 'content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
		        }
		        return create(init, {
		          body: createPropertyDescriptor(0, $toString(body)),
		          headers: createPropertyDescriptor(0, headers)
		        });
		      }
		    } return init;
		  };

		  if (isCallable(nativeFetch)) {
		    $({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, {
		      fetch: function fetch(input /* , init */) {
		        return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
		      }
		    });
		  }

		  if (isCallable(NativeRequest)) {
		    var RequestConstructor = function Request(input /* , init */) {
		      anInstance(this, RequestPrototype);
		      return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
		    };

		    RequestPrototype.constructor = RequestConstructor;
		    RequestConstructor.prototype = RequestPrototype;

		    $({ global: true, constructor: true, dontCallGetSet: true, forced: true }, {
		      Request: RequestConstructor
		    });
		  }
		}

		web_urlSearchParams_constructor = {
		  URLSearchParams: URLSearchParamsConstructor,
		  getState: getInternalParamsState
		};
		return web_urlSearchParams_constructor;
	}

	var hasRequiredWeb_url_constructor;

	function requireWeb_url_constructor () {
		if (hasRequiredWeb_url_constructor) return web_url_constructor;
		hasRequiredWeb_url_constructor = 1;
		// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
		requireEs_string_iterator();
		var $ = require_export();
		var DESCRIPTORS = requireDescriptors();
		var USE_NATIVE_URL = requireUrlConstructorDetection();
		var globalThis = requireGlobalThis();
		var bind = requireFunctionBindContext();
		var uncurryThis = requireFunctionUncurryThis();
		var defineBuiltIn = requireDefineBuiltIn();
		var defineBuiltInAccessor = requireDefineBuiltInAccessor();
		var anInstance = requireAnInstance();
		var hasOwn = requireHasOwnProperty();
		var assign = requireObjectAssign();
		var arrayFrom = requireArrayFrom();
		var arraySlice = requireArraySlice();
		var codeAt = requireStringMultibyte().codeAt;
		var toASCII = requireStringPunycodeToAscii();
		var $toString = requireToString();
		var setToStringTag = requireSetToStringTag();
		var validateArgumentsLength = requireValidateArgumentsLength();
		var URLSearchParamsModule = requireWeb_urlSearchParams_constructor();
		var InternalStateModule = requireInternalState();

		var setInternalState = InternalStateModule.set;
		var getInternalURLState = InternalStateModule.getterFor('URL');
		var URLSearchParams = URLSearchParamsModule.URLSearchParams;
		var getInternalSearchParamsState = URLSearchParamsModule.getState;

		var NativeURL = globalThis.URL;
		var TypeError = globalThis.TypeError;
		var parseInt = globalThis.parseInt;
		var floor = Math.floor;
		var pow = Math.pow;
		var charAt = uncurryThis(''.charAt);
		var exec = uncurryThis(/./.exec);
		var join = uncurryThis([].join);
		var numberToString = uncurryThis(1.1.toString);
		var pop = uncurryThis([].pop);
		var push = uncurryThis([].push);
		var replace = uncurryThis(''.replace);
		var shift = uncurryThis([].shift);
		var split = uncurryThis(''.split);
		var stringSlice = uncurryThis(''.slice);
		var toLowerCase = uncurryThis(''.toLowerCase);
		var unshift = uncurryThis([].unshift);

		var INVALID_AUTHORITY = 'Invalid authority';
		var INVALID_SCHEME = 'Invalid scheme';
		var INVALID_HOST = 'Invalid host';
		var INVALID_PORT = 'Invalid port';

		var ALPHA = /[a-z]/i;
		// eslint-disable-next-line regexp/no-obscure-range -- safe
		var ALPHANUMERIC = /[\d+-.a-z]/i;
		var DIGIT = /\d/;
		var HEX_START = /^0x/i;
		var OCT = /^[0-7]+$/;
		var DEC = /^\d+$/;
		var HEX = /^[\da-f]+$/i;
		/* eslint-disable regexp/no-control-character -- safe */
		var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
		var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
		var LEADING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+/;
		var TRAILING_C0_CONTROL_OR_SPACE = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/;
		var TAB_AND_NEW_LINE = /[\t\n\r]/g;
		/* eslint-enable regexp/no-control-character -- safe */
		// eslint-disable-next-line no-unassigned-vars -- expected `undefined` value
		var EOF;

		// https://url.spec.whatwg.org/#ipv4-number-parser
		var parseIPv4 = function (input) {
		  var parts = split(input, '.');
		  var partsLength, numbers, index, part, radix, number, ipv4;
		  if (parts.length && parts[parts.length - 1] === '') {
		    parts.length--;
		  }
		  partsLength = parts.length;
		  if (partsLength > 4) return input;
		  numbers = [];
		  for (index = 0; index < partsLength; index++) {
		    part = parts[index];
		    if (part === '') return input;
		    radix = 10;
		    if (part.length > 1 && charAt(part, 0) === '0') {
		      radix = exec(HEX_START, part) ? 16 : 8;
		      part = stringSlice(part, radix === 8 ? 1 : 2);
		    }
		    if (part === '') {
		      number = 0;
		    } else {
		      if (!exec(radix === 10 ? DEC : radix === 8 ? OCT : HEX, part)) return input;
		      number = parseInt(part, radix);
		    }
		    push(numbers, number);
		  }
		  for (index = 0; index < partsLength; index++) {
		    number = numbers[index];
		    if (index === partsLength - 1) {
		      if (number >= pow(256, 5 - partsLength)) return null;
		    } else if (number > 255) return null;
		  }
		  ipv4 = pop(numbers);
		  for (index = 0; index < numbers.length; index++) {
		    ipv4 += numbers[index] * pow(256, 3 - index);
		  }
		  return ipv4;
		};

		// https://url.spec.whatwg.org/#concept-ipv6-parser
		// eslint-disable-next-line max-statements -- TODO
		var parseIPv6 = function (input) {
		  var address = [0, 0, 0, 0, 0, 0, 0, 0];
		  var pieceIndex = 0;
		  var compress = null;
		  var pointer = 0;
		  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

		  var chr = function () {
		    return charAt(input, pointer);
		  };

		  if (chr() === ':') {
		    if (charAt(input, 1) !== ':') return;
		    pointer += 2;
		    pieceIndex++;
		    compress = pieceIndex;
		  }
		  while (chr()) {
		    if (pieceIndex === 8) return;
		    if (chr() === ':') {
		      if (compress !== null) return;
		      pointer++;
		      pieceIndex++;
		      compress = pieceIndex;
		      continue;
		    }
		    value = length = 0;
		    while (length < 4 && exec(HEX, chr())) {
		      value = value * 16 + parseInt(chr(), 16);
		      pointer++;
		      length++;
		    }
		    if (chr() === '.') {
		      if (length === 0) return;
		      pointer -= length;
		      if (pieceIndex > 6) return;
		      numbersSeen = 0;
		      while (chr()) {
		        ipv4Piece = null;
		        if (numbersSeen > 0) {
		          if (chr() === '.' && numbersSeen < 4) pointer++;
		          else return;
		        }
		        if (!exec(DIGIT, chr())) return;
		        while (exec(DIGIT, chr())) {
		          number = parseInt(chr(), 10);
		          if (ipv4Piece === null) ipv4Piece = number;
		          else if (ipv4Piece === 0) return;
		          else ipv4Piece = ipv4Piece * 10 + number;
		          if (ipv4Piece > 255) return;
		          pointer++;
		        }
		        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
		        numbersSeen++;
		        if (numbersSeen === 2 || numbersSeen === 4) pieceIndex++;
		      }
		      if (numbersSeen !== 4) return;
		      break;
		    } else if (chr() === ':') {
		      pointer++;
		      if (!chr()) return;
		    } else if (chr()) return;
		    address[pieceIndex++] = value;
		  }
		  if (compress !== null) {
		    swaps = pieceIndex - compress;
		    pieceIndex = 7;
		    while (pieceIndex !== 0 && swaps > 0) {
		      swap = address[pieceIndex];
		      address[pieceIndex--] = address[compress + swaps - 1];
		      address[compress + --swaps] = swap;
		    }
		  } else if (pieceIndex !== 8) return;
		  return address;
		};

		var findLongestZeroSequence = function (ipv6) {
		  var maxIndex = null;
		  var maxLength = 1;
		  var currStart = null;
		  var currLength = 0;
		  var index = 0;
		  for (; index < 8; index++) {
		    if (ipv6[index] !== 0) {
		      if (currLength > maxLength) {
		        maxIndex = currStart;
		        maxLength = currLength;
		      }
		      currStart = null;
		      currLength = 0;
		    } else {
		      if (currStart === null) currStart = index;
		      ++currLength;
		    }
		  }
		  return currLength > maxLength ? currStart : maxIndex;
		};

		// https://url.spec.whatwg.org/#host-serializing
		var serializeHost = function (host) {
		  var result, index, compress, ignore0;

		  // ipv4
		  if (typeof host == 'number') {
		    result = [];
		    for (index = 0; index < 4; index++) {
		      unshift(result, host % 256);
		      host = floor(host / 256);
		    }
		    return join(result, '.');
		  }

		  // ipv6
		  if (typeof host == 'object') {
		    result = '';
		    compress = findLongestZeroSequence(host);
		    for (index = 0; index < 8; index++) {
		      if (ignore0 && host[index] === 0) continue;
		      if (ignore0) ignore0 = false;
		      if (compress === index) {
		        result += index ? ':' : '::';
		        ignore0 = true;
		      } else {
		        result += numberToString(host[index], 16);
		        if (index < 7) result += ':';
		      }
		    }
		    return '[' + result + ']';
		  }

		  return host;
		};

		var C0ControlPercentEncodeSet = {};
		var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
		  ' ': 1, '"': 1, '<': 1, '>': 1, '`': 1
		});
		var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
		  '#': 1, '?': 1, '{': 1, '}': 1
		});
		var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
		  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\': 1, ']': 1, '^': 1, '|': 1
		});

		var percentEncode = function (chr, set) {
		  var code = codeAt(chr, 0);
		  return code > 0x20 && code < 0x7F && !hasOwn(set, chr) ? chr : encodeURIComponent(chr);
		};

		// https://url.spec.whatwg.org/#special-scheme
		var specialSchemes = {
		  ftp: 21,
		  file: null,
		  http: 80,
		  https: 443,
		  ws: 80,
		  wss: 443
		};

		// https://url.spec.whatwg.org/#windows-drive-letter
		var isWindowsDriveLetter = function (string, normalized) {
		  var second;
		  return string.length === 2 && exec(ALPHA, charAt(string, 0))
		    && ((second = charAt(string, 1)) === ':' || (!normalized && second === '|'));
		};

		// https://url.spec.whatwg.org/#start-with-a-windows-drive-letter
		var startsWithWindowsDriveLetter = function (string) {
		  var third;
		  return string.length > 1 && isWindowsDriveLetter(stringSlice(string, 0, 2)) && (
		    string.length === 2 ||
		    ((third = charAt(string, 2)) === '/' || third === '\\' || third === '?' || third === '#')
		  );
		};

		// https://url.spec.whatwg.org/#single-dot-path-segment
		var isSingleDot = function (segment) {
		  return segment === '.' || toLowerCase(segment) === '%2e';
		};

		// https://url.spec.whatwg.org/#double-dot-path-segment
		var isDoubleDot = function (segment) {
		  segment = toLowerCase(segment);
		  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
		};

		// States:
		var SCHEME_START = {};
		var SCHEME = {};
		var NO_SCHEME = {};
		var SPECIAL_RELATIVE_OR_AUTHORITY = {};
		var PATH_OR_AUTHORITY = {};
		var RELATIVE = {};
		var RELATIVE_SLASH = {};
		var SPECIAL_AUTHORITY_SLASHES = {};
		var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
		var AUTHORITY = {};
		var HOST = {};
		var HOSTNAME = {};
		var PORT = {};
		var FILE = {};
		var FILE_SLASH = {};
		var FILE_HOST = {};
		var PATH_START = {};
		var PATH = {};
		var CANNOT_BE_A_BASE_URL_PATH = {};
		var QUERY = {};
		var FRAGMENT = {};

		var URLState = function (url, isBase, base) {
		  var urlString = $toString(url);
		  var baseState, failure, searchParams;
		  if (isBase) {
		    failure = this.parse(urlString);
		    if (failure) throw new TypeError(failure);
		    this.searchParams = null;
		  } else {
		    if (base !== undefined) baseState = new URLState(base, true);
		    failure = this.parse(urlString, null, baseState);
		    if (failure) throw new TypeError(failure);
		    searchParams = getInternalSearchParamsState(new URLSearchParams());
		    searchParams.bindURL(this);
		    this.searchParams = searchParams;
		  }
		};

		URLState.prototype = {
		  type: 'URL',
		  // https://url.spec.whatwg.org/#url-parsing
		  // eslint-disable-next-line max-statements -- TODO
		  parse: function (input, stateOverride, base) {
		    var url = this;
		    var state = stateOverride || SCHEME_START;
		    var pointer = 0;
		    var buffer = '';
		    var seenAt = false;
		    var seenBracket = false;
		    var seenPasswordToken = false;
		    var codePoints, chr, bufferCodePoints, failure;

		    input = $toString(input);

		    if (!stateOverride) {
		      url.scheme = '';
		      url.username = '';
		      url.password = '';
		      url.host = null;
		      url.port = null;
		      url.path = [];
		      url.query = null;
		      url.fragment = null;
		      url.cannotBeABaseURL = false;
		      input = replace(input, LEADING_C0_CONTROL_OR_SPACE, '');
		      input = replace(input, TRAILING_C0_CONTROL_OR_SPACE, '$1');
		    }

		    input = replace(input, TAB_AND_NEW_LINE, '');

		    codePoints = arrayFrom(input);

		    while (pointer <= codePoints.length) {
		      chr = codePoints[pointer];
		      switch (state) {
		        case SCHEME_START:
		          if (chr && exec(ALPHA, chr)) {
		            buffer += toLowerCase(chr);
		            state = SCHEME;
		          } else if (!stateOverride) {
		            state = NO_SCHEME;
		            continue;
		          } else return INVALID_SCHEME;
		          break;

		        case SCHEME:
		          if (chr && (exec(ALPHANUMERIC, chr) || chr === '+' || chr === '-' || chr === '.')) {
		            buffer += toLowerCase(chr);
		          } else if (chr === ':') {
		            if (stateOverride && (
		              (url.isSpecial() !== hasOwn(specialSchemes, buffer)) ||
		              (buffer === 'file' && (url.includesCredentials() || url.port !== null)) ||
		              (url.scheme === 'file' && !url.host)
		            )) return;
		            url.scheme = buffer;
		            if (stateOverride) {
		              if (url.isSpecial() && specialSchemes[url.scheme] === url.port) url.port = null;
		              return;
		            }
		            buffer = '';
		            if (url.scheme === 'file') {
		              state = FILE;
		            } else if (url.isSpecial() && base && base.scheme === url.scheme) {
		              state = SPECIAL_RELATIVE_OR_AUTHORITY;
		            } else if (url.isSpecial()) {
		              state = SPECIAL_AUTHORITY_SLASHES;
		            } else if (codePoints[pointer + 1] === '/') {
		              state = PATH_OR_AUTHORITY;
		              pointer++;
		            } else {
		              url.cannotBeABaseURL = true;
		              push(url.path, '');
		              state = CANNOT_BE_A_BASE_URL_PATH;
		            }
		          } else if (!stateOverride) {
		            buffer = '';
		            state = NO_SCHEME;
		            pointer = 0;
		            continue;
		          } else return INVALID_SCHEME;
		          break;

		        case NO_SCHEME:
		          if (!base || (base.cannotBeABaseURL && chr !== '#')) return INVALID_SCHEME;
		          if (base.cannotBeABaseURL && chr === '#') {
		            url.scheme = base.scheme;
		            url.path = arraySlice(base.path);
		            url.query = base.query;
		            url.fragment = '';
		            url.cannotBeABaseURL = true;
		            state = FRAGMENT;
		            break;
		          }
		          state = base.scheme === 'file' ? FILE : RELATIVE;
		          continue;

		        case SPECIAL_RELATIVE_OR_AUTHORITY:
		          if (chr === '/' && codePoints[pointer + 1] === '/') {
		            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
		            pointer++;
		          } else {
		            state = RELATIVE;
		            continue;
		          } break;

		        case PATH_OR_AUTHORITY:
		          if (chr === '/') {
		            state = AUTHORITY;
		            break;
		          } else {
		            state = PATH;
		            continue;
		          }

		        case RELATIVE:
		          url.scheme = base.scheme;
		          if (chr === EOF) {
		            url.username = base.username;
		            url.password = base.password;
		            url.host = base.host;
		            url.port = base.port;
		            url.path = arraySlice(base.path);
		            url.query = base.query;
		          } else if (chr === '/' || (chr === '\\' && url.isSpecial())) {
		            state = RELATIVE_SLASH;
		          } else if (chr === '?') {
		            url.username = base.username;
		            url.password = base.password;
		            url.host = base.host;
		            url.port = base.port;
		            url.path = arraySlice(base.path);
		            url.query = '';
		            state = QUERY;
		          } else if (chr === '#') {
		            url.username = base.username;
		            url.password = base.password;
		            url.host = base.host;
		            url.port = base.port;
		            url.path = arraySlice(base.path);
		            url.query = base.query;
		            url.fragment = '';
		            state = FRAGMENT;
		          } else {
		            url.username = base.username;
		            url.password = base.password;
		            url.host = base.host;
		            url.port = base.port;
		            url.path = arraySlice(base.path);
		            url.path.length--;
		            state = PATH;
		            continue;
		          } break;

		        case RELATIVE_SLASH:
		          if (url.isSpecial() && (chr === '/' || chr === '\\')) {
		            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
		          } else if (chr === '/') {
		            state = AUTHORITY;
		          } else {
		            url.username = base.username;
		            url.password = base.password;
		            url.host = base.host;
		            url.port = base.port;
		            state = PATH;
		            continue;
		          } break;

		        case SPECIAL_AUTHORITY_SLASHES:
		          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
		          if (chr !== '/' || charAt(buffer, pointer + 1) !== '/') continue;
		          pointer++;
		          break;

		        case SPECIAL_AUTHORITY_IGNORE_SLASHES:
		          if (chr !== '/' && chr !== '\\') {
		            state = AUTHORITY;
		            continue;
		          } break;

		        case AUTHORITY:
		          if (chr === '@') {
		            if (seenAt) buffer = '%40' + buffer;
		            seenAt = true;
		            bufferCodePoints = arrayFrom(buffer);
		            for (var i = 0; i < bufferCodePoints.length; i++) {
		              var codePoint = bufferCodePoints[i];
		              if (codePoint === ':' && !seenPasswordToken) {
		                seenPasswordToken = true;
		                continue;
		              }
		              var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
		              if (seenPasswordToken) url.password += encodedCodePoints;
		              else url.username += encodedCodePoints;
		            }
		            buffer = '';
		          } else if (
		            chr === EOF || chr === '/' || chr === '?' || chr === '#' ||
		            (chr === '\\' && url.isSpecial())
		          ) {
		            if (seenAt && buffer === '') return INVALID_AUTHORITY;
		            pointer -= arrayFrom(buffer).length + 1;
		            buffer = '';
		            state = HOST;
		          } else buffer += chr;
		          break;

		        case HOST:
		        case HOSTNAME:
		          if (stateOverride && url.scheme === 'file') {
		            state = FILE_HOST;
		            continue;
		          } else if (chr === ':' && !seenBracket) {
		            if (buffer === '') return INVALID_HOST;
		            failure = url.parseHost(buffer);
		            if (failure) return failure;
		            buffer = '';
		            state = PORT;
		            if (stateOverride === HOSTNAME) return;
		          } else if (
		            chr === EOF || chr === '/' || chr === '?' || chr === '#' ||
		            (chr === '\\' && url.isSpecial())
		          ) {
		            if (url.isSpecial() && buffer === '') return INVALID_HOST;
		            if (stateOverride && buffer === '' && (url.includesCredentials() || url.port !== null)) return;
		            failure = url.parseHost(buffer);
		            if (failure) return failure;
		            buffer = '';
		            state = PATH_START;
		            if (stateOverride) return;
		            continue;
		          } else {
		            if (chr === '[') seenBracket = true;
		            else if (chr === ']') seenBracket = false;
		            buffer += chr;
		          } break;

		        case PORT:
		          if (exec(DIGIT, chr)) {
		            buffer += chr;
		          } else if (
		            chr === EOF || chr === '/' || chr === '?' || chr === '#' ||
		            (chr === '\\' && url.isSpecial()) ||
		            stateOverride
		          ) {
		            if (buffer !== '') {
		              var port = parseInt(buffer, 10);
		              if (port > 0xFFFF) return INVALID_PORT;
		              url.port = (url.isSpecial() && port === specialSchemes[url.scheme]) ? null : port;
		              buffer = '';
		            }
		            if (stateOverride) return;
		            state = PATH_START;
		            continue;
		          } else return INVALID_PORT;
		          break;

		        case FILE:
		          url.scheme = 'file';
		          if (chr === '/' || chr === '\\') state = FILE_SLASH;
		          else if (base && base.scheme === 'file') {
		            switch (chr) {
		              case EOF:
		                url.host = base.host;
		                url.path = arraySlice(base.path);
		                url.query = base.query;
		                break;
		              case '?':
		                url.host = base.host;
		                url.path = arraySlice(base.path);
		                url.query = '';
		                state = QUERY;
		                break;
		              case '#':
		                url.host = base.host;
		                url.path = arraySlice(base.path);
		                url.query = base.query;
		                url.fragment = '';
		                state = FRAGMENT;
		                break;
		              default:
		                if (!startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ''))) {
		                  url.host = base.host;
		                  url.path = arraySlice(base.path);
		                  url.shortenPath();
		                }
		                state = PATH;
		                continue;
		            }
		          } else {
		            state = PATH;
		            continue;
		          } break;

		        case FILE_SLASH:
		          if (chr === '/' || chr === '\\') {
		            state = FILE_HOST;
		            break;
		          }
		          if (base && base.scheme === 'file' && !startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ''))) {
		            if (isWindowsDriveLetter(base.path[0], true)) push(url.path, base.path[0]);
		            else url.host = base.host;
		          }
		          state = PATH;
		          continue;

		        case FILE_HOST:
		          if (chr === EOF || chr === '/' || chr === '\\' || chr === '?' || chr === '#') {
		            if (!stateOverride && isWindowsDriveLetter(buffer)) {
		              state = PATH;
		            } else if (buffer === '') {
		              url.host = '';
		              if (stateOverride) return;
		              state = PATH_START;
		            } else {
		              failure = url.parseHost(buffer);
		              if (failure) return failure;
		              if (url.host === 'localhost') url.host = '';
		              if (stateOverride) return;
		              buffer = '';
		              state = PATH_START;
		            } continue;
		          } else buffer += chr;
		          break;

		        case PATH_START:
		          if (url.isSpecial()) {
		            state = PATH;
		            if (chr !== '/' && chr !== '\\') continue;
		          } else if (!stateOverride && chr === '?') {
		            url.query = '';
		            state = QUERY;
		          } else if (!stateOverride && chr === '#') {
		            url.fragment = '';
		            state = FRAGMENT;
		          } else if (chr !== EOF) {
		            state = PATH;
		            if (chr !== '/') continue;
		          } break;

		        case PATH:
		          if (
		            chr === EOF || chr === '/' ||
		            (chr === '\\' && url.isSpecial()) ||
		            (!stateOverride && (chr === '?' || chr === '#'))
		          ) {
		            if (isDoubleDot(buffer)) {
		              url.shortenPath();
		              if (chr !== '/' && !(chr === '\\' && url.isSpecial())) {
		                push(url.path, '');
		              }
		            } else if (isSingleDot(buffer)) {
		              if (chr !== '/' && !(chr === '\\' && url.isSpecial())) {
		                push(url.path, '');
		              }
		            } else {
		              if (url.scheme === 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
		                if (url.host) url.host = '';
		                buffer = charAt(buffer, 0) + ':'; // normalize windows drive letter
		              }
		              push(url.path, buffer);
		            }
		            buffer = '';
		            if (url.scheme === 'file' && (chr === EOF || chr === '?' || chr === '#')) {
		              while (url.path.length > 1 && url.path[0] === '') {
		                shift(url.path);
		              }
		            }
		            if (chr === '?') {
		              url.query = '';
		              state = QUERY;
		            } else if (chr === '#') {
		              url.fragment = '';
		              state = FRAGMENT;
		            }
		          } else {
		            buffer += percentEncode(chr, pathPercentEncodeSet);
		          } break;

		        case CANNOT_BE_A_BASE_URL_PATH:
		          if (chr === '?') {
		            url.query = '';
		            state = QUERY;
		          } else if (chr === '#') {
		            url.fragment = '';
		            state = FRAGMENT;
		          } else if (chr !== EOF) {
		            url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
		          } break;

		        case QUERY:
		          if (!stateOverride && chr === '#') {
		            url.fragment = '';
		            state = FRAGMENT;
		          } else if (chr !== EOF) {
		            if (chr === "'" && url.isSpecial()) url.query += '%27';
		            else if (chr === '#') url.query += '%23';
		            else url.query += percentEncode(chr, C0ControlPercentEncodeSet);
		          } break;

		        case FRAGMENT:
		          if (chr !== EOF) url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
		          break;
		      }

		      pointer++;
		    }
		  },
		  // https://url.spec.whatwg.org/#host-parsing
		  parseHost: function (input) {
		    var result, codePoints, index;
		    if (charAt(input, 0) === '[') {
		      if (charAt(input, input.length - 1) !== ']') return INVALID_HOST;
		      result = parseIPv6(stringSlice(input, 1, -1));
		      if (!result) return INVALID_HOST;
		      this.host = result;
		    // opaque host
		    } else if (!this.isSpecial()) {
		      if (exec(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input)) return INVALID_HOST;
		      result = '';
		      codePoints = arrayFrom(input);
		      for (index = 0; index < codePoints.length; index++) {
		        result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
		      }
		      this.host = result;
		    } else {
		      input = toASCII(input);
		      if (exec(FORBIDDEN_HOST_CODE_POINT, input)) return INVALID_HOST;
		      result = parseIPv4(input);
		      if (result === null) return INVALID_HOST;
		      this.host = result;
		    }
		  },
		  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port
		  cannotHaveUsernamePasswordPort: function () {
		    return !this.host || this.cannotBeABaseURL || this.scheme === 'file';
		  },
		  // https://url.spec.whatwg.org/#include-credentials
		  includesCredentials: function () {
		    return this.username !== '' || this.password !== '';
		  },
		  // https://url.spec.whatwg.org/#is-special
		  isSpecial: function () {
		    return hasOwn(specialSchemes, this.scheme);
		  },
		  // https://url.spec.whatwg.org/#shorten-a-urls-path
		  shortenPath: function () {
		    var path = this.path;
		    var pathSize = path.length;
		    if (pathSize && (this.scheme !== 'file' || pathSize !== 1 || !isWindowsDriveLetter(path[0], true))) {
		      path.length--;
		    }
		  },
		  // https://url.spec.whatwg.org/#concept-url-serializer
		  serialize: function () {
		    var url = this;
		    var scheme = url.scheme;
		    var username = url.username;
		    var password = url.password;
		    var host = url.host;
		    var port = url.port;
		    var path = url.path;
		    var query = url.query;
		    var fragment = url.fragment;
		    var output = scheme + ':';
		    if (host !== null) {
		      output += '//';
		      if (url.includesCredentials()) {
		        output += username + (password ? ':' + password : '') + '@';
		      }
		      output += serializeHost(host);
		      if (port !== null) output += ':' + port;
		    } else if (scheme === 'file') output += '//';
		    output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';
		    if (query !== null) output += '?' + query;
		    if (fragment !== null) output += '#' + fragment;
		    return output;
		  },
		  // https://url.spec.whatwg.org/#dom-url-href
		  setHref: function (href) {
		    var failure = this.parse(href);
		    if (failure) throw new TypeError(failure);
		    this.searchParams.update();
		  },
		  // https://url.spec.whatwg.org/#dom-url-origin
		  getOrigin: function () {
		    var scheme = this.scheme;
		    var port = this.port;
		    if (scheme === 'blob') try {
		      return new URLConstructor(scheme.path[0]).origin;
		    } catch (error) {
		      return 'null';
		    }
		    if (scheme === 'file' || !this.isSpecial()) return 'null';
		    return scheme + '://' + serializeHost(this.host) + (port !== null ? ':' + port : '');
		  },
		  // https://url.spec.whatwg.org/#dom-url-protocol
		  getProtocol: function () {
		    return this.scheme + ':';
		  },
		  setProtocol: function (protocol) {
		    this.parse($toString(protocol) + ':', SCHEME_START);
		  },
		  // https://url.spec.whatwg.org/#dom-url-username
		  getUsername: function () {
		    return this.username;
		  },
		  setUsername: function (username) {
		    var codePoints = arrayFrom($toString(username));
		    if (this.cannotHaveUsernamePasswordPort()) return;
		    this.username = '';
		    for (var i = 0; i < codePoints.length; i++) {
		      this.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
		    }
		  },
		  // https://url.spec.whatwg.org/#dom-url-password
		  getPassword: function () {
		    return this.password;
		  },
		  setPassword: function (password) {
		    var codePoints = arrayFrom($toString(password));
		    if (this.cannotHaveUsernamePasswordPort()) return;
		    this.password = '';
		    for (var i = 0; i < codePoints.length; i++) {
		      this.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
		    }
		  },
		  // https://url.spec.whatwg.org/#dom-url-host
		  getHost: function () {
		    var host = this.host;
		    var port = this.port;
		    return host === null ? ''
		      : port === null ? serializeHost(host)
		      : serializeHost(host) + ':' + port;
		  },
		  setHost: function (host) {
		    if (this.cannotBeABaseURL) return;
		    this.parse(host, HOST);
		  },
		  // https://url.spec.whatwg.org/#dom-url-hostname
		  getHostname: function () {
		    var host = this.host;
		    return host === null ? '' : serializeHost(host);
		  },
		  setHostname: function (hostname) {
		    if (this.cannotBeABaseURL) return;
		    this.parse(hostname, HOSTNAME);
		  },
		  // https://url.spec.whatwg.org/#dom-url-port
		  getPort: function () {
		    var port = this.port;
		    return port === null ? '' : $toString(port);
		  },
		  setPort: function (port) {
		    if (this.cannotHaveUsernamePasswordPort()) return;
		    port = $toString(port);
		    if (port === '') this.port = null;
		    else this.parse(port, PORT);
		  },
		  // https://url.spec.whatwg.org/#dom-url-pathname
		  getPathname: function () {
		    var path = this.path;
		    return this.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';
		  },
		  setPathname: function (pathname) {
		    if (this.cannotBeABaseURL) return;
		    this.path = [];
		    this.parse(pathname, PATH_START);
		  },
		  // https://url.spec.whatwg.org/#dom-url-search
		  getSearch: function () {
		    var query = this.query;
		    return query ? '?' + query : '';
		  },
		  setSearch: function (search) {
		    search = $toString(search);
		    if (search === '') {
		      this.query = null;
		    } else {
		      if (charAt(search, 0) === '?') search = stringSlice(search, 1);
		      this.query = '';
		      this.parse(search, QUERY);
		    }
		    this.searchParams.update();
		  },
		  // https://url.spec.whatwg.org/#dom-url-searchparams
		  getSearchParams: function () {
		    return this.searchParams.facade;
		  },
		  // https://url.spec.whatwg.org/#dom-url-hash
		  getHash: function () {
		    var fragment = this.fragment;
		    return fragment ? '#' + fragment : '';
		  },
		  setHash: function (hash) {
		    hash = $toString(hash);
		    if (hash === '') {
		      this.fragment = null;
		      return;
		    }
		    if (charAt(hash, 0) === '#') hash = stringSlice(hash, 1);
		    this.fragment = '';
		    this.parse(hash, FRAGMENT);
		  },
		  update: function () {
		    this.query = this.searchParams.serialize() || null;
		  }
		};

		// `URL` constructor
		// https://url.spec.whatwg.org/#url-class
		var URLConstructor = function URL(url /* , base */) {
		  var that = anInstance(this, URLPrototype);
		  var base = validateArgumentsLength(arguments.length, 1) > 1 ? arguments[1] : undefined;
		  var state = setInternalState(that, new URLState(url, false, base));
		  if (!DESCRIPTORS) {
		    that.href = state.serialize();
		    that.origin = state.getOrigin();
		    that.protocol = state.getProtocol();
		    that.username = state.getUsername();
		    that.password = state.getPassword();
		    that.host = state.getHost();
		    that.hostname = state.getHostname();
		    that.port = state.getPort();
		    that.pathname = state.getPathname();
		    that.search = state.getSearch();
		    that.searchParams = state.getSearchParams();
		    that.hash = state.getHash();
		  }
		};

		var URLPrototype = URLConstructor.prototype;

		var accessorDescriptor = function (getter, setter) {
		  return {
		    get: function () {
		      return getInternalURLState(this)[getter]();
		    },
		    set: setter && function (value) {
		      return getInternalURLState(this)[setter](value);
		    },
		    configurable: true,
		    enumerable: true
		  };
		};

		if (DESCRIPTORS) {
		  // `URL.prototype.href` accessors pair
		  // https://url.spec.whatwg.org/#dom-url-href
		  defineBuiltInAccessor(URLPrototype, 'href', accessorDescriptor('serialize', 'setHref'));
		  // `URL.prototype.origin` getter
		  // https://url.spec.whatwg.org/#dom-url-origin
		  defineBuiltInAccessor(URLPrototype, 'origin', accessorDescriptor('getOrigin'));
		  // `URL.prototype.protocol` accessors pair
		  // https://url.spec.whatwg.org/#dom-url-protocol
		  defineBuiltInAccessor(URLPrototype, 'protocol', accessorDescriptor('getProtocol', 'setProtocol'));
		  // `URL.prototype.username` accessors pair
		  // https://url.spec.whatwg.org/#dom-url-username
		  defineBuiltInAccessor(URLPrototype, 'username', accessorDescriptor('getUsername', 'setUsername'));
		  // `URL.prototype.password` accessors pair
		  // https://url.spec.whatwg.org/#dom-url-password
		  defineBuiltInAccessor(URLPrototype, 'password', accessorDescriptor('getPassword', 'setPassword'));
		  // `URL.prototype.host` accessors pair
		  // https://url.spec.whatwg.org/#dom-url-host
		  defineBuiltInAccessor(URLPrototype, 'host', accessorDescriptor('getHost', 'setHost'));
		  // `URL.prototype.hostname` accessors pair
		  // https://url.spec.whatwg.org/#dom-url-hostname
		  defineBuiltInAccessor(URLPrototype, 'hostname', accessorDescriptor('getHostname', 'setHostname'));
		  // `URL.prototype.port` accessors pair
		  // https://url.spec.whatwg.org/#dom-url-port
		  defineBuiltInAccessor(URLPrototype, 'port', accessorDescriptor('getPort', 'setPort'));
		  // `URL.prototype.pathname` accessors pair
		  // https://url.spec.whatwg.org/#dom-url-pathname
		  defineBuiltInAccessor(URLPrototype, 'pathname', accessorDescriptor('getPathname', 'setPathname'));
		  // `URL.prototype.search` accessors pair
		  // https://url.spec.whatwg.org/#dom-url-search
		  defineBuiltInAccessor(URLPrototype, 'search', accessorDescriptor('getSearch', 'setSearch'));
		  // `URL.prototype.searchParams` getter
		  // https://url.spec.whatwg.org/#dom-url-searchparams
		  defineBuiltInAccessor(URLPrototype, 'searchParams', accessorDescriptor('getSearchParams'));
		  // `URL.prototype.hash` accessors pair
		  // https://url.spec.whatwg.org/#dom-url-hash
		  defineBuiltInAccessor(URLPrototype, 'hash', accessorDescriptor('getHash', 'setHash'));
		}

		// `URL.prototype.toJSON` method
		// https://url.spec.whatwg.org/#dom-url-tojson
		defineBuiltIn(URLPrototype, 'toJSON', function toJSON() {
		  return getInternalURLState(this).serialize();
		}, { enumerable: true });

		// `URL.prototype.toString` method
		// https://url.spec.whatwg.org/#URL-stringification-behavior
		defineBuiltIn(URLPrototype, 'toString', function toString() {
		  return getInternalURLState(this).serialize();
		}, { enumerable: true });

		if (NativeURL) {
		  var nativeCreateObjectURL = NativeURL.createObjectURL;
		  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
		  // `URL.createObjectURL` method
		  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
		  if (nativeCreateObjectURL) defineBuiltIn(URLConstructor, 'createObjectURL', bind(nativeCreateObjectURL, NativeURL));
		  // `URL.revokeObjectURL` method
		  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
		  if (nativeRevokeObjectURL) defineBuiltIn(URLConstructor, 'revokeObjectURL', bind(nativeRevokeObjectURL, NativeURL));
		}

		setToStringTag(URLConstructor, 'URL');

		$({ global: true, constructor: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
		  URL: URLConstructor
		});
		return web_url_constructor;
	}

	var hasRequiredWeb_url;

	function requireWeb_url () {
		if (hasRequiredWeb_url) return web_url;
		hasRequiredWeb_url = 1;
		// TODO: Remove this module from `core-js@4` since it's replaced to module below
		requireWeb_url_constructor();
		return web_url;
	}

	requireWeb_url();

	var web_url_toJson = {};

	var hasRequiredWeb_url_toJson;

	function requireWeb_url_toJson () {
		if (hasRequiredWeb_url_toJson) return web_url_toJson;
		hasRequiredWeb_url_toJson = 1;
		var $ = require_export();
		var call = requireFunctionCall();

		// `URL.prototype.toJSON` method
		// https://url.spec.whatwg.org/#dom-url-tojson
		$({ target: 'URL', proto: true, enumerable: true }, {
		  toJSON: function toJSON() {
		    return call(URL.prototype.toString, this);
		  }
		});
		return web_url_toJson;
	}

	requireWeb_url_toJson();

	var web_urlSearchParams = {};

	var hasRequiredWeb_urlSearchParams;

	function requireWeb_urlSearchParams () {
		if (hasRequiredWeb_urlSearchParams) return web_urlSearchParams;
		hasRequiredWeb_urlSearchParams = 1;
		// TODO: Remove this module from `core-js@4` since it's replaced to module below
		requireWeb_urlSearchParams_constructor();
		return web_urlSearchParams;
	}

	requireWeb_urlSearchParams();

	var _Utils;
	var Utils = /*#__PURE__*/function () {
	  function Utils() {
	    _classCallCheck(this, Utils);
	  }
	  return _createClass(Utils, null, [{
	    key: "conserverFocusElement",
	    value: function conserverFocusElement(componentShadow, componentRoot) {
	      var elementsFocusablesShadow = Array.from(this.obtenirElementsFocusables(componentShadow, false));
	      var elementsFocusablesRoot = Array.from(this.obtenirElementsFocusables(componentRoot, false));
	      var elementsFocusables = elementsFocusablesShadow.concat(elementsFocusablesRoot);
	      var premierElementFocusable = elementsFocusables[0];
	      var dernierElementFocusable = elementsFocusables[elementsFocusables.length - 1];
	      var KEYCODE_TAB = 9;
	      componentShadow.addEventListener('keydown', function (e) {
	        var estToucheTab = e.key === 'Tab' || e.keyCode === KEYCODE_TAB;
	        if (!estToucheTab) {
	          return;
	        }
	        var elementActif = document.activeElement.shadowRoot ? document.activeElement.shadowRoot.activeElement : document.activeElement;
	        if (e.shiftKey) /* shift + tab */{
	            if (elementActif === premierElementFocusable) {
	              dernierElementFocusable.focus();
	              e.preventDefault();
	            }
	          } else /* tab */{
	            if (elementsFocusables.length === 1 || elementActif === dernierElementFocusable) {
	              premierElementFocusable.focus();
	              e.preventDefault();
	            }
	          }
	      });
	    }
	  }, {
	    key: "obtenirElementsFocusables",
	    value: function obtenirElementsFocusables(element, inclureListeDeroulante, exclureHyperliens) {
	      var selecteursControleFocusables = ['button:not([disabled])', 'textarea:not([disabled])', 'input:not([type="hidden"]):not([disabled])', 'select:not([disabled])'];
	      if (inclureListeDeroulante) {
	        selecteursControleFocusables.push('utd-liste-deroulante');
	      }
	      if (!exclureHyperliens) {
	        selecteursControleFocusables.push('a[href]:not([disabled])');
	      }
	      return element.querySelectorAll(selecteursControleFocusables.join(','));
	    }
	    /**
	     * GÃ©nÃ¨re un id unique.
	     * @returns L'id unique gÃ©nÃ©rÃ©.
	     */
	  }, {
	    key: "genererId",
	    value: function genererId() {
	      return Date.now().toString(36) + '-' + Math.random().toString(36).substr(2, 9);
	    }
	    /**
	     * CrÃ©Ã© un Ã©vÃ©nement custom pour un webComponent.
	     * @param {*} component Objet associÃ© Ã  notre composant (objet DOM).
	     * @param {*} nomEvenement Nom de l'Ã©vÃ©nement. 
	     * @param {*} detailsEvenement DÃ©tails de l'Ã©vÃ©nement.
	     */
	  }, {
	    key: "estMobile",
	    value: function estMobile() {
	      return "ontouchstart" in document.documentElement;
	    }
	  }, {
	    key: "ajusterInterfaceAvantAffichageModale",
	    value: function ajusterInterfaceAvantAffichageModale(html, body) {
	      if (Utils.estMobile()) {
	        html.classList.add("est-mobile");
	      } else {
	        html.classList.remove("est-mobile");
	        var largeurScrollbarHtml = window.innerWidth - html.offsetWidth;
	        if (largeurScrollbarHtml > 0) {
	          body.style['padding-right'] = largeurScrollbarHtml + 'px';
	        } else {
	          var largeurScrollbarBody = window.innerWidth - body.offsetWidth;
	          if (largeurScrollbarBody > 0) {
	            body.style['padding-right'] = largeurScrollbarBody + 'px';
	          }
	        }
	      }

	      /* On s'assure que le scroll ne changera pas une fois le body modifiÃ© avec position fixe */
	      var scrollY = window.scrollY;
	      html.classList.add("utd-modale-ouverte");
	      document.body.style.top = "-".concat(scrollY, "px");
	    }
	  }, {
	    key: "ajusterInterfacePendantAffichageModale",
	    value: function ajusterInterfacePendantAffichageModale(body, modale) {
	      if (!this.estMobile()) {
	        var largeurScrollbarModale = window.innerWidth - modale.offsetWidth;
	        if (largeurScrollbarModale > 0) {
	          body.style['padding-right'] = largeurScrollbarModale + 'px';
	        }
	      }
	    }
	  }, {
	    key: "ajusterInterfaceApresFermetureModale",
	    value: function ajusterInterfaceApresFermetureModale(html, body) {
	      html.style.removeProperty('padding-right');
	      body.style.removeProperty('padding-right');
	      html.classList.remove("utd-modale-ouverte");

	      /* Repositionner l'Ã©cran oÃ¹ il Ã©tait avant l'affichage de la modale. */
	      var scrollY = document.body.style.top;
	      document.body.style.position = '';
	      document.body.style.top = '';
	      window.scrollTo(0, parseInt(scrollY || '0') * -1);
	    }
	  }, {
	    key: "slotExiste",
	    value: function slotExiste(slots, nomSlot) {
	      return slots.some(function (s) {
	        return s.slot === nomSlot;
	      });
	    }
	  }, {
	    key: "obtenirSlot",
	    value: function obtenirSlot(slots, nomSlot) {
	      return slots.find(function (s) {
	        return s.slot === nomSlot;
	      });
	    }
	  }, {
	    key: "obtenirTextesDefaut",
	    value: function obtenirTextesDefaut() {
	      var textes = {
	        texteSrOuvertureNouvelOnglet: this.estPageLangueFrancais() ? ". Ce lien sera ouvert dans un nouvel onglet." : ". This link will open in a new tab."
	      };
	      return textes;
	    }
	    /**
	     * Obtient la langue de la page courante.
	     * @returns {string} Code de langue de la page courante (fr/en).
	     */
	  }, {
	    key: "obtenirLanguePage",
	    value: function obtenirLanguePage() {
	      return document.getElementsByTagName("html")[0].getAttribute("lang") || "fr";
	    }

	    /**
	     * Indique si la page courante est en franÃ§ais.
	     * @returns {boolean} Indicateur de langue de page franÃ§aise.
	     */
	  }, {
	    key: "estPageLangueFrancais",
	    value: function estPageLangueFrancais() {
	      var langue = this.obtenirLanguePage();
	      return langue.startsWith('fr');
	    }

	    /**
	     * Permet de palier au fait que svelte converti en booleen la valeur d'un attribut si celui-ci est vide (ex. titre="", la valeur considÃ©rÃ©e par svelte est true, alors que nous c'est une attribut vide, qu'on ne devrait pas traiter. Nos if ne fonctionnent pas comme prÃ©vu dans cette situation)
	     * On considÃ¨re donc qu'un attribut est absent, si l'attribut n'est pas spÃ©cifiÃ©, vide ou true (valeur boolÃ©enne que svelte utilise si attribut est vide, et Ã§a ne peut jamais arriver sauf dans cette circonstance car normalement les attributs sont toujours des strings)
	     * @param {*} attribut Valeur de l'attribut Ã  vÃ©rifier
	     * @returns BoolÃ©en indiquant si l'attribut doit Ãªtre considÃ©rÃ© comme prÃ©sent ou non
	     */
	  }, {
	    key: "estAttributPresent",
	    value: function estAttributPresent(attribut) {
	      return attribut && attribut !== true;
	    }
	  }, {
	    key: "obtenirParents",
	    value: function obtenirParents(element) {
	      var parents = [];
	      for (; element && element !== document; element = element.parentNode) {
	        parents.push(element);
	      }
	      return parents;
	    }

	    /**
	     * Permet de debouncer une fonction.
	     * @param {Object} func Fonction Ã  debouncer.
	     * @param {Number} timeout DÃ©lai du debounce.
	     */
	  }, {
	    key: "debounce",
	    value: function debounce(func) {
	      var _this = this;
	      var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 400;
	      var timer;
	      return function () {
	        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	          args[_key] = arguments[_key];
	        }
	        clearTimeout(timer);
	        timer = setTimeout(function () {
	          func.apply(_this, args);
	        }, timeout);
	      };
	    }
	  }, {
	    key: "extend",
	    value: function extend(first, second) {
	      for (var secondProp in second) {
	        var secondVal = second[secondProp];
	        // Is this value an object?  If so, iterate over its properties, copying them over
	        if (secondVal && Object.prototype.toString.call(secondVal) === "[object Object]") {
	          first[secondProp] = first[secondProp] || {};
	          this.extend(first[secondProp], secondVal);
	        } else {
	          first[secondProp] = secondVal;
	        }
	      }
	      return first;
	    }
	  }, {
	    key: "reafficherApresChargement",
	    value: function reafficherApresChargement(composant) {
	      setTimeout(function () {
	        composant.classList.add('mounted');
	      });
	    }

	    /**
	     * Normalise une chaÃ®ne de caractÃ¨res pour utilisation insensible Ã  la case et aux accents.
	     * @param {string} chaineCaracteres ChaÃ®ne de caractÃ¨res.
	     * */
	  }, {
	    key: "normaliserChaineCaracteres",
	    value: function normaliserChaineCaracteres(chaineCaracteres) {
	      return this.normaliserApostrophes(this.remplacerAccents(chaineCaracteres).toLowerCase());
	    }

	    /**
	    * Normaliser les apostrophes d'une chaÃ®ne de caractÃ¨res.
	    * @param {string} chaineCaracteres ChaÃ®ne de caractÃ¨res.
	    **/
	  }, {
	    key: "normaliserApostrophes",
	    value: function normaliserApostrophes(chaineCaracteres) {
	      return chaineCaracteres.replace(/[\u2018-\u2019]/g, "'");
	    }

	    /**
	     * Remplace les accents d'une chaÃ®ne de caractÃ¨res.
	     * @param {string} chaineCaracteres ChaÃ®ne de caractÃ¨res.
	     * */
	  }, {
	    key: "remplacerAccents",
	    value: function remplacerAccents(chaineCaracteres) {
	      return chaineCaracteres.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
	    }

	    /**
	     * GÃ©nÃ¨re un id Ã  partir du texte spÃ©cifiÃ©. Le texte est normalisÃ©, puis tous les caractÃ¨res non textuels sont remplacÃ©s par des underscore "_".
	     * @param {string} texte Texte Ã  partir duquel il faut crÃ©er un id.
	     * @returns Un id gÃ©nÃ©rÃ© Ã  partir du texte.
	     */
	  }, {
	    key: "obtenirIdSelonTexte",
	    value: function obtenirIdSelonTexte(texte) {
	      var texteNormalise = this.normaliserChaineCaracteres(texte);
	      return texteNormalise.replace(/\W/g, '_');
	    }
	  }, {
	    key: "definirEvenementClickAncre",
	    value: function definirEvenementClickAncre() {
	      var selecteur = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '.ancre';
	      setTimeout(function () {
	        var ancres = document.querySelectorAll(selecteur);
	        for (var i = 0; i < ancres.length; i++) {
	          ancres[i].addEventListener("click", function (e) {
	            e.preventDefault();
	            location.hash = '';
	            location.href = e.target.getAttribute('href');
	          });
	        }
	      });
	    }
	  }, {
	    key: "scrollIntoViewSiRequis",
	    value: function scrollIntoViewSiRequis(el) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
	        behavior: 'smooth',
	        block: 'center'
	      };
	      var rect = el.getBoundingClientRect();
	      var estVisible = rect.top >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight);
	      if (!estVisible) {
	        el.scrollIntoView(options);
	      }
	    }
	  }]);
	}();
	_Utils = Utils;
	//static relativeBasePath = document.currentScript.getAttribute('relative-base-path') || '';
	_defineProperty(Utils, "url", new URL(document.currentScript.src));
	_defineProperty(Utils, "fullBasePath", _Utils.url.href.split('/').slice(0, -2).join('/'));
	_defineProperty(Utils, "imagesFullPath", "".concat(_Utils.fullBasePath.replace(/\/$/, ''), "/images/"));
	_defineProperty(Utils, "cssFullPath", "".concat(_Utils.fullBasePath.replace(/\/$/, ''), "/css/utd-webcomponents.min.css").concat(_Utils.url.search));
	_defineProperty(Utils, "dispatchWcEvent", function (component, nomEvenement, detailsEvenement) {
	  component.dispatchEvent(new CustomEvent(nomEvenement, {
	    detail: detailsEvenement,
	    composed: true // propage l'Ã©vÃ©nement Ã  travers le shadow DOM (Remonte au document)
	  }));
	});

	function _callSuper$r(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$r() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$r() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$r = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$r(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$r(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$r(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$r(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	Accordeon[FILENAME] = 'src/components/accordeon.svelte';
	var root_2$b = add_locations(from_html("<img width=\"24px\"/>"), Accordeon[FILENAME], [[154, 12]]);
	var root_1$f = add_locations(from_html("<button type=\"button\"><span class=\"titre\"><!> <!> <!></span> <span></span></button>"), Accordeon[FILENAME], [[151, 6, [[152, 8], [161, 8]]]]);
	var root_6$4 = add_locations(from_html("<!> <!>", 1), Accordeon[FILENAME], []);
	var root_4$4 = add_locations(from_html("<div class=\"conteneur\"><!></div>"), Accordeon[FILENAME], [[168, 8]]);
	var root$r = add_locations(from_html("<div><div class=\"entete\"><!></div> <div class=\"contenu\"><!></div></div> <link rel=\"stylesheet\"/>", 1), Accordeon[FILENAME], [[148, 0, [[149, 2], [166, 4]]], [181, 0]]);
	function Accordeon($$anchor, $$props) {
	  check_target(this instanceof Accordeon ? this.constructor : void 0);
	  push($$props, false);
	  var estLangueFrancaise = Utils.estPageLangueFrancais();

	  /* PropriÃ©tÃ©s "publiques" */
	  var reduit = prop($$props, 'reduit', 12, "true");
	  var type = prop($$props, 'type', 12, "");
	  var titre = prop($$props, 'titre', 12, "");
	  var contenu = prop($$props, 'contenu', 12, "");
	  var tagTitre = prop($$props, 'tagTitre', 12, "h2");
	  var conserverEtatAffichage = prop($$props, 'conserverEtatAffichage', 12, "false");

	  /* PropriÃ©tÃ©s "internes" */
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var idEntete = Utils.genererId();
	  var idContenu = 'corps' + idEntete;
	  var estReduit = mutable_source(strict_equals(reduit(), 'true') ? true : false);
	  var mounted = false;
	  var estCssCharge = false;
	  var hauteurImage = mutable_source(strict_equals(type(), 'avertissement') ? '22px' : '24px');
	  var nomIconeSvg = mutable_source('ico-information');
	  var texteAlternatifImage = mutable_source('');
	  onMount(function () {
	    definirEtatAffichageInitial();
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    definirIconeEtTexteAlternatif();
	    mounted = true;
	  });
	  function definirEtatAffichageInitial() {
	    if (strict_equals(conserverEtatAffichage(), 'true')) {
	      if (thisComponent().id) {
	        var valeur = sessionStorage.getItem(thisComponent().id);

	        //Si null (clÃ© non trouvÃ©e dans le session storage, on va utiliser la valeur par dÃ©faut reÃ§ue en paramÃ¨tre, sinon on l'Ã©crase avec celle du session storage)
	        if (strict_equals(valeur, null, false)) {
	          if (strict_equals(valeur, '1')) {
	            thisComponent().setAttribute('reduit', 'false');
	          } else {
	            thisComponent().setAttribute('reduit', 'true');
	          }
	        }
	      }
	    }
	    set(estReduit, strict_equals(reduit(), 'true') ? true : false);
	    conserverEtatAffichageSession();
	  }
	  function definirIconeEtTexteAlternatif() {
	    set(hauteurImage, strict_equals(type(), 'avertissement') ? '22px' : '24px');
	    switch (type()) {
	      case 'avertissement':
	        set(texteAlternatifImage, estLangueFrancaise ? "Avis d'avertissement" : "Warning notice");
	        set(nomIconeSvg, "ico-".concat(type()));
	        break;
	      case 'erreur':
	        set(texteAlternatifImage, estLangueFrancaise ? "Avis d'erreur" : "Error notice");
	        set(nomIconeSvg, "ico-".concat(type()));
	        break;
	      case 'succes':
	        set(texteAlternatifImage, estLangueFrancaise ? "Avis de succÃ¨s" : "Success notice");
	        set(nomIconeSvg, "ico-".concat(type()));
	        break;
	      case 'complementaire astuce':
	        set(texteAlternatifImage, estLangueFrancaise ? "Avis complÃ©mentaire" : "Additional notice");
	        set(nomIconeSvg, 'ico-ampoule');
	        break;
	      case 'complementaire rappel':
	        set(texteAlternatifImage, estLangueFrancaise ? "Avis complÃ©mentaire" : "Additional notice");
	        set(nomIconeSvg, 'ico-rappel');
	        break;
	      default:
	        set(texteAlternatifImage, estLangueFrancaise ? "Avis gÃ©nÃ©ral" : "General notice");
	        set(nomIconeSvg, 'ico-information');
	    }
	  }
	  function conserverEtatAffichageSession() {
	    if (strict_equals(conserverEtatAffichage(), 'true') && thisComponent().id) {
	      sessionStorage.setItem(thisComponent().id, get(estReduit) ? '0' : '1');
	    }
	  }
	  function gererEtatAffichage() {
	    if (!mounted) {
	      return;
	    }
	    set(estReduit, strict_equals(reduit(), 'true') ? true : false);
	    conserverEtatAffichageSession();
	    Utils.dispatchWcEvent(thisComponent(), "changementEtat", {
	      reduit: get(estReduit)
	    });
	  }
	  function toggleAffichageContenu() {
	    thisComponent().setAttribute('reduit', get(estReduit) ? 'false' : 'true');
	  }
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  legacy_pre_effect(function () {
	    return deep_read_state(reduit());
	  }, function () {
	    gererEtatAffichage(reduit());
	  });
	  legacy_pre_effect(function () {
	    return deep_read_state(type());
	  }, function () {
	    definirIconeEtTexteAlternatif(type());
	  });
	  legacy_pre_effect_reset();
	  var $$exports = _objectSpread$r({
	    get reduit() {
	      return reduit();
	    },
	    set reduit($$value) {
	      reduit($$value);
	      flushSync();
	    },
	    get type() {
	      return type();
	    },
	    set type($$value) {
	      type($$value);
	      flushSync();
	    },
	    get titre() {
	      return titre();
	    },
	    set titre($$value) {
	      titre($$value);
	      flushSync();
	    },
	    get contenu() {
	      return contenu();
	    },
	    set contenu($$value) {
	      contenu($$value);
	      flushSync();
	    },
	    get tagTitre() {
	      return tagTitre();
	    },
	    set tagTitre($$value) {
	      tagTitre($$value);
	      flushSync();
	    },
	    get conserverEtatAffichage() {
	      return conserverEtatAffichage();
	    },
	    set conserverEtatAffichage($$value) {
	      conserverEtatAffichage($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$r();
	  var div = first_child(fragment);
	  var div_1 = child(div);
	  var node = child(div_1);
	  {
	    validate_void_dynamic_element(tagTitre);
	    validate_dynamic_element_tag(tagTitre);
	    element(node, tagTitre, false, function ($$element, $$anchor) {
	      set_class($$element, 0, 'titre');
	      var button = root_1$f();
	      var span = child(button);
	      var node_1 = child(span);
	      {
	        var consequent = function consequent($$anchor) {
	          var img = root_2$b();
	          template_effect(function () {
	            var _ref, _$$get;
	            set_attribute(img, 'src', "".concat((_ref = (deep_read_state(Utils), untrack(function () {
	              return Utils.imagesFullPath;
	            }))) !== null && _ref !== void 0 ? _ref : '', "utd-sprite.svg?v=3.5.0#").concat((_$$get = get(nomIconeSvg)) !== null && _$$get !== void 0 ? _$$get : ''));
	            set_attribute(img, 'alt', get(texteAlternatifImage));
	            set_attribute(img, 'height', get(hauteurImage));
	          });
	          append($$anchor, img);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_1, function ($$render) {
	            if (type() && strict_equals(type(), 'general', false)) $$render(consequent);
	          });
	        }, 'if', Accordeon, 153, 10);
	      }
	      var node_2 = sibling(node_1, 2);
	      {
	        var consequent_1 = function consequent_1($$anchor) {
	          var text$1 = text();
	          template_effect(function () {
	            return set_text(text$1, titre());
	          });
	          append($$anchor, text$1);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_2, function ($$render) {
	            if (titre()) $$render(consequent_1);
	          });
	        }, 'if', Accordeon, 156, 10);
	      }
	      var node_3 = sibling(node_2, 2);
	      slot(node_3, $$props, 'titre', {});
	      reset(span);
	      var span_1 = sibling(span, 2);
	      reset(button);
	      template_effect(function () {
	        set_attribute(button, 'aria-controls', idContenu);
	        set_attribute(button, 'aria-expanded', !get(estReduit));
	        set_class(span_1, 1, "utd-icone-svg ".concat(!get(estReduit) ? 'moins' : 'plus'));
	      });
	      event('click', button, toggleAffichageContenu);
	      append($$anchor, button);
	    });
	  }
	  reset(div_1);
	  var div_2 = sibling(div_1, 2);
	  var node_4 = child(div_2);
	  {
	    var consequent_3 = function consequent_3($$anchor) {
	      var div_3 = root_4$4();
	      var node_5 = child(div_3);
	      {
	        var consequent_2 = function consequent_2($$anchor) {
	          var fragment_2 = comment();
	          var node_6 = first_child(fragment_2);
	          html(node_6, contenu);
	          append($$anchor, fragment_2);
	        };
	        var alternate = function alternate($$anchor) {
	          var fragment_3 = root_6$4();
	          var node_7 = first_child(fragment_3);
	          slot(node_7, $$props, 'default', {});
	          var node_8 = sibling(node_7, 2);
	          slot(node_8, $$props, 'contenu', {});
	          append($$anchor, fragment_3);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_5, function ($$render) {
	            if (contenu()) $$render(consequent_2);else $$render(alternate, false);
	          });
	        }, 'if', Accordeon, 169, 10);
	      }
	      reset(div_3);
	      transition(3, div_3, function () {
	        return slide;
	      }, function () {
	        return {
	          duration: 250
	        };
	      });
	      append($$anchor, div_3);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_4, function ($$render) {
	        if (!get(estReduit)) $$render(consequent_3);
	      });
	    }, 'if', Accordeon, 167, 6);
	  }
	  reset(div_2);
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function () {
	    var _type;
	    set_class(div, 1, "utd-component utd-accordeon ".concat((_type = type()) !== null && _type !== void 0 ? _type : '').concat(!get(estReduit) ? ' ouvert' : ''));
	    set_attribute(div_2, 'id', idContenu);
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-accordeon', create_custom_element(Accordeon, {
	  reduit: {
	    attribute: 'reduit'
	  },
	  type: {
	    attribute: 'type'
	  },
	  titre: {
	    attribute: 'titre'
	  },
	  contenu: {
	    attribute: 'contenu'
	  },
	  tagTitre: {
	    attribute: 'tag-titre'
	  },
	  conserverEtatAffichage: {
	    attribute: 'conserver-etat-affichage'
	  },
	  thisComponent: {}
	}, ['titre', 'default', 'contenu'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$r(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$q(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$q() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$q() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$q = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$q(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$q(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$q(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$q(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	AlerteGenerale[FILENAME] = 'src/components/alerteGenerale.svelte';
	var root_1$e = add_locations(from_html("<button type=\"button\" class=\"masquer\"><span class=\"utd-icone-svg x-fermer bleu-piv\" aria-hidden=\"true\"></span></button>"), AlerteGenerale[FILENAME], [[144, 6, [[145, 8]]]]);
	var root$q = add_locations(from_html("<div tabindex=\"0\"><div class=\"utd-container\"><div class=\"zone-icone\"><div aria-hidden=\"true\"></div></div> <div class=\"contenu\"><!></div> <!></div></div> <link rel=\"stylesheet\"/>", 1), AlerteGenerale[FILENAME], [[135, 0, [[136, 2, [[137, 4, [[138, 6]]], [140, 4]]]]], [151, 0]]);
	function AlerteGenerale($$anchor, $$props) {
	  check_target(this instanceof AlerteGenerale ? this.constructor : void 0);
	  push($$props, false);

	  /* PropriÃ©tÃ©s "publiques" */
	  var type = prop($$props, 'type', 12, "information");
	  var masquable = prop($$props, 'masquable', 12, "false");
	  var identifiant = prop($$props, 'identifiant', 12, "");
	  var reinit = prop($$props, 'reinit', 12, "");

	  //TODO un attribut pour conserver l'Ã©tat affichage?
	  /* PropriÃ©tÃ©s "internes" */
	  var focus = prop($$props, 'focus', 12, 'false');
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var mounted = false;
	  var estCssCharge = false;
	  var titleBoutonMasquer = Utils.estPageLangueFrancais() ? "Masquer cette alerte" : "Hide this alert";
	  onMount(function () {
	    type(strict_equals(type(), 'avertissement') ? 'avertissement' : 'information');
	    definirEtatAffichage();
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    mounted = true;
	  });

	  // Watch sur la prop focus
	  // Watch sur le type
	  // Watch sur reinit
	  // Watch sur masquable
	  function definirEtatAffichage() {
	    var estAlerteAffichee = true;
	    if (strict_equals(masquable(), 'true') && identifiant()) {
	      estAlerteAffichee = !!!localStorage.getItem(identifiant());
	    }
	    if (estAlerteAffichee) {
	      thisComponent().classList.remove('masquee');
	    } else {
	      thisComponent().classList.add('masquee');
	    }
	  }
	  function toggleFocus() {
	    if (strict_equals(focus(), 'true')) {
	      var element = thisComponent().shadowRoot.querySelector('.utd-alerte-generale');
	      if (element) {
	        element.focus();
	        element.removeAttribute('focus');
	      }
	      focus('false');
	    }
	  }
	  function changementType() {
	    if (mounted) {
	      definirType();
	    }
	  }
	  function changementReinit() {
	    if (mounted && strict_equals(reinit(), 'true')) {
	      thisComponent().removeAttribute('reinit');
	      if (identifiant()) {
	        localStorage.removeItem(identifiant());
	      }
	      definirEtatAffichage();
	    }
	  }
	  function changementMasquable() {
	    if (mounted) {
	      definirEtatAffichage();
	    }
	  }
	  function definirType() {
	    type(strict_equals(type(), 'avertissement') ? 'avertissement' : 'information');
	  }
	  function masquerAlerte() {
	    thisComponent().classList.add('masquee');
	    localStorage.setItem(identifiant(), 'masquee');
	  }
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  legacy_pre_effect(function () {
	    return deep_read_state(focus());
	  }, function () {
	    toggleFocus(focus());
	  });
	  legacy_pre_effect(function () {
	    return deep_read_state(type());
	  }, function () {
	    changementType(type());
	  });
	  legacy_pre_effect(function () {
	    return deep_read_state(reinit());
	  }, function () {
	    changementReinit(reinit());
	  });
	  legacy_pre_effect(function () {
	    return deep_read_state(masquable());
	  }, function () {
	    changementMasquable(masquable());
	  });
	  legacy_pre_effect_reset();
	  var $$exports = _objectSpread$q({
	    get type() {
	      return type();
	    },
	    set type($$value) {
	      type($$value);
	      flushSync();
	    },
	    get masquable() {
	      return masquable();
	    },
	    set masquable($$value) {
	      masquable($$value);
	      flushSync();
	    },
	    get identifiant() {
	      return identifiant();
	    },
	    set identifiant($$value) {
	      identifiant($$value);
	      flushSync();
	    },
	    get reinit() {
	      return reinit();
	    },
	    set reinit($$value) {
	      reinit($$value);
	      flushSync();
	    },
	    get focus() {
	      return focus();
	    },
	    set focus($$value) {
	      focus($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$q();
	  var div = first_child(fragment);
	  var div_1 = child(div);
	  var div_2 = child(div_1);
	  var div_3 = child(div_2);
	  reset(div_2);
	  var div_4 = sibling(div_2, 2);
	  var node = child(div_4);
	  slot(node, $$props, 'default', {});
	  reset(div_4);
	  var node_1 = sibling(div_4, 2);
	  {
	    var consequent = function consequent($$anchor) {
	      var button = root_1$e();
	      template_effect(function () {
	        return set_attribute(button, 'title', titleBoutonMasquer);
	      });
	      event('click', button, masquerAlerte);
	      append($$anchor, button);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_1, function ($$render) {
	        if (strict_equals(masquable(), "true")) $$render(consequent);
	      });
	    }, 'if', AlerteGenerale, 143, 4);
	  }
	  reset(div_1);
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function () {
	    var _type, _type2;
	    set_class(div, 1, "utd-component utd-alerte-generale ".concat((_type = type()) !== null && _type !== void 0 ? _type : ''));
	    set_class(div_3, 1, "utd-icone-svg ".concat((_type2 = type()) !== null && _type2 !== void 0 ? _type2 : ''));
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-alerte-generale', create_custom_element(AlerteGenerale, {
	  type: {
	    attribute: 'type'
	  },
	  masquable: {
	    attribute: 'masquable'
	  },
	  identifiant: {
	    attribute: 'identifiant'
	  },
	  reinit: {
	    attribute: 'reinit'
	  },
	  focus: {
	    attribute: 'focus'
	  },
	  thisComponent: {}
	}, ['default'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$q(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _arrayLikeToArray(r, a) {
	  (null == a || a > r.length) && (a = r.length);
	  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
	  return n;
	}

	function _arrayWithoutHoles(r) {
	  if (Array.isArray(r)) return _arrayLikeToArray(r);
	}

	function _iterableToArray(r) {
	  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
	}

	function _unsupportedIterableToArray(r, a) {
	  if (r) {
	    if ("string" == typeof r) return _arrayLikeToArray(r, a);
	    var t = {}.toString.call(r).slice(8, -1);
	    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
	  }
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _toConsumableArray(r) {
	  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
	}

	function _callSuper$p(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$p() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$p() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$p = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$p(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$p(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$p(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$p(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	Avis[FILENAME] = 'src/components/avis.svelte';
	var root$p = add_locations(from_html("<div tabindex=\"0\"><div class=\"zone-icone\"><img width=\"24px\"/></div> <div class=\"contenu\"><h2 class=\"titre\"> </h2> <div class=\"texte\"><!> <!> <!></div></div></div> <link rel=\"stylesheet\"/>", 1), Avis[FILENAME], [[147, 0, [[148, 2, [[149, 4]]], [151, 2, [[152, 4], [155, 4]]]]], [165, 0]]);
	function Avis($$anchor, $$props) {
	  check_target(this instanceof Avis ? this.constructor : void 0);
	  push($$props, true);

	  // Conserve la rÃ©fÃ©rence Ã  l'Ã©lÃ©ment pour les appels Utils et $host()
	  // @svelte-rune directive requise pour les runes
	  var estLangueFrancaise = Utils.estPageLangueFrancais();

	  // DÃ©claration des propriÃ©tÃ©s
	  var titre = prop($$props, 'titre', 7, ""),
	    type = prop($$props, 'type', 7, "information"),
	    contenu = prop($$props, 'contenu', 7, ""),
	    focus = prop($$props, 'focus', 7, "false"),
	    thisComponent = prop($$props, 'thisComponent', 7);

	  // --- Ãtats internes ($state) ---
	  var mounted = tag(state(false), 'mounted');
	  var estCssCharge = tag(state(false), 'estCssCharge');
	  onMount(function () {
	    if (get(estCssCharge)) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    set(mounted, true);
	  });

	  // --- Logique (fonctions) ---
	  function toggleFocus() {
	    var _console;
	    // La fonction s'exÃ©cute si la prop est passÃ©e Ã  'true'
	    (_console = console).log.apply(_console, _toConsumableArray(log_if_contains_state('log', focus())));
	    if (strict_equals(focus(), 'true')) {
	      var element = thisComponent().shadowRoot.querySelector('.utd-avis');
	      if (element) {
	        element.focus();

	        // Retrait de l'attribut directement sur l'Ã©lÃ©ment hÃ´te du Custom Element.
	        // Cela consomme le dÃ©clencheur sans crÃ©er de dÃ©pendance de rÃ©activitÃ© sur un $state.
	        $$props.$$host.removeAttribute('focus');
	      }
	    }
	  }

	  /**
	   * GÃ¨re le chargement de la CSS externe.
	   */
	  function cssCharge(e) {
	    if (get(mounted)) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    set(estCssCharge, true);
	  }

	  /**
	   * Calcule la dÃ©finition de l'icÃ´ne et le texte alternatif en fonction du type.
	   */
	  function definirParametresAvis(type) {
	    var definitionMap = {
	      'avertissement': {
	        alt: estLangueFrancaise ? "Avis d'avertissement" : "Warning notice",
	        icon: "ico-".concat(type),
	        hauteur: '22px'
	      },
	      'erreur': {
	        alt: estLangueFrancaise ? "Avis d'erreur" : "Error notice",
	        icon: "ico-".concat(type),
	        hauteur: '24px'
	      },
	      'succes': {
	        alt: estLangueFrancaise ? "Avis de succÃ¨s" : "Success notice",
	        icon: "ico-".concat(type),
	        hauteur: '24px'
	      },
	      'complementaire astuce': {
	        alt: estLangueFrancaise ? "Avis complÃ©mentaire" : "Additional notice",
	        icon: 'ico-ampoule',
	        hauteur: '24px'
	      },
	      'complementaire notification': {
	        alt: estLangueFrancaise ? "Avis complÃ©mentaire" : "Additional notice",
	        icon: 'ico-alarme',
	        hauteur: '24px'
	      },
	      'complementaire communication': {
	        alt: estLangueFrancaise ? "Avis complÃ©mentaire" : "Additional notice",
	        icon: 'ico-bulles',
	        hauteur: '24px'
	      },
	      'complementaire rappel': {
	        alt: estLangueFrancaise ? "Avis complÃ©mentaire" : "Additional notice",
	        icon: 'ico-rappel',
	        hauteur: '24px'
	      },
	      'default': {
	        alt: estLangueFrancaise ? "Avis gÃ©nÃ©ral" : "General notice",
	        icon: 'ico-information',
	        hauteur: '24px'
	      }
	    };
	    return definitionMap[type] || definitionMap['default'];
	  }

	  // --- DÃ©clarations rÃ©actives ($derived, $effect) ---
	  // ----------- COMPUTED  -----------  
	  var parametresAvis = tag(user_derived(function () {
	    return definirParametresAvis(type());
	  }), 'parametresAvis');
	  var texteAlternatifImage = tag(user_derived(function () {
	    return get(parametresAvis).alt;
	  }), 'texteAlternatifImage');
	  var nomIconeSvg = tag(user_derived(function () {
	    return get(parametresAvis).icon;
	  }), 'nomIconeSvg');
	  var hauteurImage = tag(user_derived(function () {
	    return get(parametresAvis).hauteur;
	  }), 'hauteurImage');

	  // ----------- WATCHS  -----------
	  user_effect(function () {
	    toggleFocus();
	  });
	  var $$exports = _objectSpread$p({
	    get titre() {
	      return titre();
	    },
	    set titre($$value) {
	      if ($$value === void 0) {
	        $$value = "";
	      }
	      titre($$value);
	      flushSync();
	    },
	    get type() {
	      return type();
	    },
	    set type($$value) {
	      if ($$value === void 0) {
	        $$value = "information";
	      }
	      type($$value);
	      flushSync();
	    },
	    get contenu() {
	      return contenu();
	    },
	    set contenu($$value) {
	      if ($$value === void 0) {
	        $$value = "";
	      }
	      contenu($$value);
	      flushSync();
	    },
	    get focus() {
	      return focus();
	    },
	    set focus($$value) {
	      if ($$value === void 0) {
	        $$value = "false";
	      }
	      focus($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  var fragment = root$p();
	  var div = first_child(fragment);
	  var div_1 = child(div);
	  var img = child(div_1);
	  reset(div_1);
	  var div_2 = sibling(div_1, 2);
	  var h2 = child(div_2);
	  var text = child(h2, true);
	  reset(h2);
	  var div_3 = sibling(h2, 2);
	  var node = child(div_3);
	  {
	    var consequent = function consequent($$anchor) {
	      var fragment_1 = comment();
	      var node_1 = first_child(fragment_1);
	      html(node_1, contenu);
	      append($$anchor, fragment_1);
	    };
	    add_svelte_meta(function () {
	      return if_block(node, function ($$render) {
	        if (contenu()) $$render(consequent);
	      });
	    }, 'if', Avis, 156, 6);
	  }
	  var node_2 = sibling(node, 2);
	  slot(node_2, $$props, 'default', {});
	  var node_3 = sibling(node_2, 2);
	  slot(node_3, $$props, 'contenu', {});
	  reset(div_3);
	  reset(div_2);
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function () {
	    var _type, _Utils$imagesFullPath, _$$get;
	    set_class(div, 1, "utd-component utd-avis ".concat((_type = type()) !== null && _type !== void 0 ? _type : ''));
	    set_attribute(img, 'src', "".concat((_Utils$imagesFullPath = Utils.imagesFullPath) !== null && _Utils$imagesFullPath !== void 0 ? _Utils$imagesFullPath : '', "utd-sprite.svg?v=3.5.0#").concat((_$$get = get(nomIconeSvg)) !== null && _$$get !== void 0 ? _$$get : ''));
	    set_attribute(img, 'alt', get(texteAlternatifImage));
	    set_attribute(img, 'height', get(hauteurImage));
	    set_text(text, titre());
	    set_attribute(link, 'href', Utils.cssFullPath);
	  });
	  event('load', link, cssCharge);
	  replay_events(link);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-avis', create_custom_element(Avis, {
	  titre: {
	    attribute: 'titre',
	    type: 'String'
	  },
	  type: {
	    attribute: 'type',
	    type: 'String'
	  },
	  contenu: {
	    attribute: 'contenu',
	    type: 'String'
	  },
	  focus: {
	    attribute: 'focus',
	    type: 'String'
	  },
	  thisComponent: {}
	}, ['default', 'contenu'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$p(this, _class);

	      // Conserve la rÃ©fÃ©rence Ã  l'Ã©lÃ©ment pour les appels Utils et $host()
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	var es_array_findIndex = {};

	var hasRequiredEs_array_findIndex;

	function requireEs_array_findIndex () {
		if (hasRequiredEs_array_findIndex) return es_array_findIndex;
		hasRequiredEs_array_findIndex = 1;
		var $ = require_export();
		var $findIndex = requireArrayIteration().findIndex;
		var addToUnscopables = requireAddToUnscopables();

		var FIND_INDEX = 'findIndex';
		var SKIPS_HOLES = true;

		// Shouldn't skip holes
		// eslint-disable-next-line es/no-array-prototype-findindex -- testing
		if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });

		// `Array.prototype.findIndex` method
		// https://tc39.es/ecma262/#sec-array.prototype.findindex
		$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
		  findIndex: function findIndex(callbackfn /* , that = undefined */) {
		    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
		  }
		});

		// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
		addToUnscopables(FIND_INDEX);
		return es_array_findIndex;
	}

	requireEs_array_findIndex();

	var es_array_map = {};

	var hasRequiredEs_array_map;

	function requireEs_array_map () {
		if (hasRequiredEs_array_map) return es_array_map;
		hasRequiredEs_array_map = 1;
		var $ = require_export();
		var $map = requireArrayIteration().map;
		var arrayMethodHasSpeciesSupport = requireArrayMethodHasSpeciesSupport();

		var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');

		// `Array.prototype.map` method
		// https://tc39.es/ecma262/#sec-array.prototype.map
		// with adding support of @@species
		$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
		  map: function map(callbackfn /* , thisArg */) {
		    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
		  }
		});
		return es_array_map;
	}

	requireEs_array_map();

	var es_set = {};

	var es_set_constructor = {};

	var internalMetadata = {exports: {}};

	var arrayBufferNonExtensible;
	var hasRequiredArrayBufferNonExtensible;

	function requireArrayBufferNonExtensible () {
		if (hasRequiredArrayBufferNonExtensible) return arrayBufferNonExtensible;
		hasRequiredArrayBufferNonExtensible = 1;
		// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it
		var fails = requireFails();

		arrayBufferNonExtensible = fails(function () {
		  if (typeof ArrayBuffer == 'function') {
		    var buffer = new ArrayBuffer(8);
		    // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe
		    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', { value: 8 });
		  }
		});
		return arrayBufferNonExtensible;
	}

	var objectIsExtensible;
	var hasRequiredObjectIsExtensible;

	function requireObjectIsExtensible () {
		if (hasRequiredObjectIsExtensible) return objectIsExtensible;
		hasRequiredObjectIsExtensible = 1;
		var fails = requireFails();
		var isObject = requireIsObject();
		var classof = requireClassofRaw();
		var ARRAY_BUFFER_NON_EXTENSIBLE = requireArrayBufferNonExtensible();

		// eslint-disable-next-line es/no-object-isextensible -- safe
		var $isExtensible = Object.isExtensible;
		var FAILS_ON_PRIMITIVES = fails(function () { });

		// `Object.isExtensible` method
		// https://tc39.es/ecma262/#sec-object.isextensible
		objectIsExtensible = (FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE) ? function isExtensible(it) {
		  if (!isObject(it)) return false;
		  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) === 'ArrayBuffer') return false;
		  return $isExtensible ? $isExtensible(it) : true;
		} : $isExtensible;
		return objectIsExtensible;
	}

	var freezing;
	var hasRequiredFreezing;

	function requireFreezing () {
		if (hasRequiredFreezing) return freezing;
		hasRequiredFreezing = 1;
		var fails = requireFails();

		freezing = !fails(function () {
		  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
		  return Object.isExtensible(Object.preventExtensions({}));
		});
		return freezing;
	}

	var hasRequiredInternalMetadata;

	function requireInternalMetadata () {
		if (hasRequiredInternalMetadata) return internalMetadata.exports;
		hasRequiredInternalMetadata = 1;
		var $ = require_export();
		var uncurryThis = requireFunctionUncurryThis();
		var hiddenKeys = requireHiddenKeys();
		var isObject = requireIsObject();
		var hasOwn = requireHasOwnProperty();
		var defineProperty = requireObjectDefineProperty().f;
		var getOwnPropertyNamesModule = requireObjectGetOwnPropertyNames();
		var getOwnPropertyNamesExternalModule = requireObjectGetOwnPropertyNamesExternal();
		var isExtensible = requireObjectIsExtensible();
		var uid = requireUid();
		var FREEZING = requireFreezing();

		var REQUIRED = false;
		var METADATA = uid('meta');
		var id = 0;

		var setMetadata = function (it) {
		  defineProperty(it, METADATA, { value: {
		    objectID: 'O' + id++, // object ID
		    weakData: {}          // weak collections IDs
		  } });
		};

		var fastKey = function (it, create) {
		  // return a primitive with prefix
		  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
		  if (!hasOwn(it, METADATA)) {
		    // can't set metadata to uncaught frozen object
		    if (!isExtensible(it)) return 'F';
		    // not necessary to add metadata
		    if (!create) return 'E';
		    // add missing metadata
		    setMetadata(it);
		  // return object ID
		  } return it[METADATA].objectID;
		};

		var getWeakData = function (it, create) {
		  if (!hasOwn(it, METADATA)) {
		    // can't set metadata to uncaught frozen object
		    if (!isExtensible(it)) return true;
		    // not necessary to add metadata
		    if (!create) return false;
		    // add missing metadata
		    setMetadata(it);
		  // return the store of weak collections IDs
		  } return it[METADATA].weakData;
		};

		// add metadata on freeze-family methods calling
		var onFreeze = function (it) {
		  if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);
		  return it;
		};

		var enable = function () {
		  meta.enable = function () { /* empty */ };
		  REQUIRED = true;
		  var getOwnPropertyNames = getOwnPropertyNamesModule.f;
		  var splice = uncurryThis([].splice);
		  var test = {};
		  test[METADATA] = 1;

		  // prevent exposing of metadata key
		  if (getOwnPropertyNames(test).length) {
		    getOwnPropertyNamesModule.f = function (it) {
		      var result = getOwnPropertyNames(it);
		      for (var i = 0, length = result.length; i < length; i++) {
		        if (result[i] === METADATA) {
		          splice(result, i, 1);
		          break;
		        }
		      } return result;
		    };

		    $({ target: 'Object', stat: true, forced: true }, {
		      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
		    });
		  }
		};

		var meta = internalMetadata.exports = {
		  enable: enable,
		  fastKey: fastKey,
		  getWeakData: getWeakData,
		  onFreeze: onFreeze
		};

		hiddenKeys[METADATA] = true;
		return internalMetadata.exports;
	}

	var inheritIfRequired;
	var hasRequiredInheritIfRequired;

	function requireInheritIfRequired () {
		if (hasRequiredInheritIfRequired) return inheritIfRequired;
		hasRequiredInheritIfRequired = 1;
		var isCallable = requireIsCallable();
		var isObject = requireIsObject();
		var setPrototypeOf = requireObjectSetPrototypeOf();

		// makes subclassing work correct for wrapped built-ins
		inheritIfRequired = function ($this, dummy, Wrapper) {
		  var NewTarget, NewTargetPrototype;
		  if (
		    // it can work only with native `setPrototypeOf`
		    setPrototypeOf &&
		    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
		    isCallable(NewTarget = dummy.constructor) &&
		    NewTarget !== Wrapper &&
		    isObject(NewTargetPrototype = NewTarget.prototype) &&
		    NewTargetPrototype !== Wrapper.prototype
		  ) setPrototypeOf($this, NewTargetPrototype);
		  return $this;
		};
		return inheritIfRequired;
	}

	var collection;
	var hasRequiredCollection;

	function requireCollection () {
		if (hasRequiredCollection) return collection;
		hasRequiredCollection = 1;
		var $ = require_export();
		var globalThis = requireGlobalThis();
		var uncurryThis = requireFunctionUncurryThis();
		var isForced = requireIsForced();
		var defineBuiltIn = requireDefineBuiltIn();
		var InternalMetadataModule = requireInternalMetadata();
		var iterate = requireIterate();
		var anInstance = requireAnInstance();
		var isCallable = requireIsCallable();
		var isNullOrUndefined = requireIsNullOrUndefined();
		var isObject = requireIsObject();
		var fails = requireFails();
		var checkCorrectnessOfIteration = requireCheckCorrectnessOfIteration();
		var setToStringTag = requireSetToStringTag();
		var inheritIfRequired = requireInheritIfRequired();

		collection = function (CONSTRUCTOR_NAME, wrapper, common) {
		  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
		  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
		  var ADDER = IS_MAP ? 'set' : 'add';
		  var NativeConstructor = globalThis[CONSTRUCTOR_NAME];
		  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
		  var Constructor = NativeConstructor;
		  var exported = {};

		  var fixMethod = function (KEY) {
		    var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
		    defineBuiltIn(NativePrototype, KEY,
		      KEY === 'add' ? function add(value) {
		        uncurriedNativeMethod(this, value === 0 ? 0 : value);
		        return this;
		      } : KEY === 'delete' ? function (key) {
		        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
		      } : KEY === 'get' ? function get(key) {
		        return IS_WEAK && !isObject(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);
		      } : KEY === 'has' ? function has(key) {
		        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
		      } : function set(key, value) {
		        uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
		        return this;
		      }
		    );
		  };

		  var REPLACE = isForced(
		    CONSTRUCTOR_NAME,
		    !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
		      new NativeConstructor().entries().next();
		    }))
		  );

		  if (REPLACE) {
		    // create collection constructor
		    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
		    InternalMetadataModule.enable();
		  } else if (isForced(CONSTRUCTOR_NAME, true)) {
		    var instance = new Constructor();
		    // early implementations not supports chaining
		    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) !== instance;
		    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
		    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
		    // most early implementations doesn't supports iterables, most modern - not close it correctly
		    // eslint-disable-next-line no-new -- required for testing
		    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
		    // for early implementations -0 and +0 not the same
		    var BUGGY_ZERO = !IS_WEAK && fails(function () {
		      // V8 ~ Chromium 42- fails only with 5+ elements
		      var $instance = new NativeConstructor();
		      var index = 5;
		      while (index--) $instance[ADDER](index, index);
		      return !$instance.has(-0);
		    });

		    if (!ACCEPT_ITERABLES) {
		      Constructor = wrapper(function (dummy, iterable) {
		        anInstance(dummy, NativePrototype);
		        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
		        if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
		        return that;
		      });
		      Constructor.prototype = NativePrototype;
		      NativePrototype.constructor = Constructor;
		    }

		    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
		      fixMethod('delete');
		      fixMethod('has');
		      IS_MAP && fixMethod('get');
		    }

		    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

		    // weak collections should not contains .clear method
		    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
		  }

		  exported[CONSTRUCTOR_NAME] = Constructor;
		  $({ global: true, constructor: true, forced: Constructor !== NativeConstructor }, exported);

		  setToStringTag(Constructor, CONSTRUCTOR_NAME);

		  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

		  return Constructor;
		};
		return collection;
	}

	var collectionStrong;
	var hasRequiredCollectionStrong;

	function requireCollectionStrong () {
		if (hasRequiredCollectionStrong) return collectionStrong;
		hasRequiredCollectionStrong = 1;
		var create = requireObjectCreate();
		var defineBuiltInAccessor = requireDefineBuiltInAccessor();
		var defineBuiltIns = requireDefineBuiltIns();
		var bind = requireFunctionBindContext();
		var anInstance = requireAnInstance();
		var isNullOrUndefined = requireIsNullOrUndefined();
		var iterate = requireIterate();
		var defineIterator = requireIteratorDefine();
		var createIterResultObject = requireCreateIterResultObject();
		var setSpecies = requireSetSpecies();
		var DESCRIPTORS = requireDescriptors();
		var fastKey = requireInternalMetadata().fastKey;
		var InternalStateModule = requireInternalState();

		var setInternalState = InternalStateModule.set;
		var internalStateGetterFor = InternalStateModule.getterFor;

		collectionStrong = {
		  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
		    var Constructor = wrapper(function (that, iterable) {
		      anInstance(that, Prototype);
		      setInternalState(that, {
		        type: CONSTRUCTOR_NAME,
		        index: create(null),
		        first: null,
		        last: null,
		        size: 0
		      });
		      if (!DESCRIPTORS) that.size = 0;
		      if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
		    });

		    var Prototype = Constructor.prototype;

		    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

		    var define = function (that, key, value) {
		      var state = getInternalState(that);
		      var entry = getEntry(that, key);
		      var previous, index;
		      // change existing entry
		      if (entry) {
		        entry.value = value;
		      // create new entry
		      } else {
		        state.last = entry = {
		          index: index = fastKey(key, true),
		          key: key,
		          value: value,
		          previous: previous = state.last,
		          next: null,
		          removed: false
		        };
		        if (!state.first) state.first = entry;
		        if (previous) previous.next = entry;
		        if (DESCRIPTORS) state.size++;
		        else that.size++;
		        // add to index
		        if (index !== 'F') state.index[index] = entry;
		      } return that;
		    };

		    var getEntry = function (that, key) {
		      var state = getInternalState(that);
		      // fast case
		      var index = fastKey(key);
		      var entry;
		      if (index !== 'F') return state.index[index];
		      // frozen object case
		      for (entry = state.first; entry; entry = entry.next) {
		        if (entry.key === key) return entry;
		      }
		    };

		    defineBuiltIns(Prototype, {
		      // `{ Map, Set }.prototype.clear()` methods
		      // https://tc39.es/ecma262/#sec-map.prototype.clear
		      // https://tc39.es/ecma262/#sec-set.prototype.clear
		      clear: function clear() {
		        var that = this;
		        var state = getInternalState(that);
		        var entry = state.first;
		        while (entry) {
		          entry.removed = true;
		          if (entry.previous) entry.previous = entry.previous.next = null;
		          entry = entry.next;
		        }
		        state.first = state.last = null;
		        state.index = create(null);
		        if (DESCRIPTORS) state.size = 0;
		        else that.size = 0;
		      },
		      // `{ Map, Set }.prototype.delete(key)` methods
		      // https://tc39.es/ecma262/#sec-map.prototype.delete
		      // https://tc39.es/ecma262/#sec-set.prototype.delete
		      'delete': function (key) {
		        var that = this;
		        var state = getInternalState(that);
		        var entry = getEntry(that, key);
		        if (entry) {
		          var next = entry.next;
		          var prev = entry.previous;
		          delete state.index[entry.index];
		          entry.removed = true;
		          if (prev) prev.next = next;
		          if (next) next.previous = prev;
		          if (state.first === entry) state.first = next;
		          if (state.last === entry) state.last = prev;
		          if (DESCRIPTORS) state.size--;
		          else that.size--;
		        } return !!entry;
		      },
		      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
		      // https://tc39.es/ecma262/#sec-map.prototype.foreach
		      // https://tc39.es/ecma262/#sec-set.prototype.foreach
		      forEach: function forEach(callbackfn /* , that = undefined */) {
		        var state = getInternalState(this);
		        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
		        var entry;
		        while (entry = entry ? entry.next : state.first) {
		          boundFunction(entry.value, entry.key, this);
		          // revert to the last existing entry
		          while (entry && entry.removed) entry = entry.previous;
		        }
		      },
		      // `{ Map, Set}.prototype.has(key)` methods
		      // https://tc39.es/ecma262/#sec-map.prototype.has
		      // https://tc39.es/ecma262/#sec-set.prototype.has
		      has: function has(key) {
		        return !!getEntry(this, key);
		      }
		    });

		    defineBuiltIns(Prototype, IS_MAP ? {
		      // `Map.prototype.get(key)` method
		      // https://tc39.es/ecma262/#sec-map.prototype.get
		      get: function get(key) {
		        var entry = getEntry(this, key);
		        return entry && entry.value;
		      },
		      // `Map.prototype.set(key, value)` method
		      // https://tc39.es/ecma262/#sec-map.prototype.set
		      set: function set(key, value) {
		        return define(this, key === 0 ? 0 : key, value);
		      }
		    } : {
		      // `Set.prototype.add(value)` method
		      // https://tc39.es/ecma262/#sec-set.prototype.add
		      add: function add(value) {
		        return define(this, value = value === 0 ? 0 : value, value);
		      }
		    });
		    if (DESCRIPTORS) defineBuiltInAccessor(Prototype, 'size', {
		      configurable: true,
		      get: function () {
		        return getInternalState(this).size;
		      }
		    });
		    return Constructor;
		  },
		  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
		    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
		    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
		    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
		    // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
		    // https://tc39.es/ecma262/#sec-map.prototype.entries
		    // https://tc39.es/ecma262/#sec-map.prototype.keys
		    // https://tc39.es/ecma262/#sec-map.prototype.values
		    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
		    // https://tc39.es/ecma262/#sec-set.prototype.entries
		    // https://tc39.es/ecma262/#sec-set.prototype.keys
		    // https://tc39.es/ecma262/#sec-set.prototype.values
		    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator
		    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
		      setInternalState(this, {
		        type: ITERATOR_NAME,
		        target: iterated,
		        state: getInternalCollectionState(iterated),
		        kind: kind,
		        last: null
		      });
		    }, function () {
		      var state = getInternalIteratorState(this);
		      var kind = state.kind;
		      var entry = state.last;
		      // revert to the last existing entry
		      while (entry && entry.removed) entry = entry.previous;
		      // get next entry
		      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
		        // or finish the iteration
		        state.target = null;
		        return createIterResultObject(undefined, true);
		      }
		      // return step by kind
		      if (kind === 'keys') return createIterResultObject(entry.key, false);
		      if (kind === 'values') return createIterResultObject(entry.value, false);
		      return createIterResultObject([entry.key, entry.value], false);
		    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

		    // `{ Map, Set }.prototype[@@species]` accessors
		    // https://tc39.es/ecma262/#sec-get-map-@@species
		    // https://tc39.es/ecma262/#sec-get-set-@@species
		    setSpecies(CONSTRUCTOR_NAME);
		  }
		};
		return collectionStrong;
	}

	var hasRequiredEs_set_constructor;

	function requireEs_set_constructor () {
		if (hasRequiredEs_set_constructor) return es_set_constructor;
		hasRequiredEs_set_constructor = 1;
		var collection = requireCollection();
		var collectionStrong = requireCollectionStrong();

		// `Set` constructor
		// https://tc39.es/ecma262/#sec-set-objects
		collection('Set', function (init) {
		  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
		}, collectionStrong);
		return es_set_constructor;
	}

	var hasRequiredEs_set;

	function requireEs_set () {
		if (hasRequiredEs_set) return es_set;
		hasRequiredEs_set = 1;
		// TODO: Remove this module from `core-js@4` since it's replaced to module below
		requireEs_set_constructor();
		return es_set;
	}

	requireEs_set();

	var es_string_match = {};

	var hasRequiredEs_string_match;

	function requireEs_string_match () {
		if (hasRequiredEs_string_match) return es_string_match;
		hasRequiredEs_string_match = 1;
		var call = requireFunctionCall();
		var uncurryThis = requireFunctionUncurryThis();
		var fixRegExpWellKnownSymbolLogic = requireFixRegexpWellKnownSymbolLogic();
		var anObject = requireAnObject();
		var isObject = requireIsObject();
		var toLength = requireToLength();
		var toString = requireToString();
		var requireObjectCoercible = requireRequireObjectCoercible();
		var getMethod = requireGetMethod();
		var advanceStringIndex = requireAdvanceStringIndex();
		var getRegExpFlags = requireRegexpGetFlags();
		var regExpExec = requireRegexpExecAbstract();

		var stringIndexOf = uncurryThis(''.indexOf);

		// @@match logic
		fixRegExpWellKnownSymbolLogic('match', function (MATCH, nativeMatch, maybeCallNative) {
		  return [
		    // `String.prototype.match` method
		    // https://tc39.es/ecma262/#sec-string.prototype.match
		    function match(regexp) {
		      var O = requireObjectCoercible(this);
		      var matcher = isObject(regexp) ? getMethod(regexp, MATCH) : undefined;
		      return matcher ? call(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString(O));
		    },
		    // `RegExp.prototype[@@match]` method
		    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
		    function (string) {
		      var rx = anObject(this);
		      var S = toString(string);
		      var res = maybeCallNative(nativeMatch, rx, S);

		      if (res.done) return res.value;

		      var flags = toString(getRegExpFlags(rx));

		      if (stringIndexOf(flags, 'g') === -1) return regExpExec(rx, S);

		      var fullUnicode = stringIndexOf(flags, 'u') !== -1;
		      rx.lastIndex = 0;
		      var A = [];
		      var n = 0;
		      var result;
		      while ((result = regExpExec(rx, S)) !== null) {
		        var matchStr = toString(result[0]);
		        A[n] = matchStr;
		        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
		        n++;
		      }
		      return n === 0 ? null : A;
		    }
		  ];
		});
		return es_string_match;
	}

	requireEs_string_match();

	/******************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	/* global Reflect, Promise, SuppressedError, Symbol */


	var __assign = function() {
	    __assign = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};

	function __awaiter(thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, [])).next());
	    });
	}

	function __generator(thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (g && (g = 0, op[0] && (_ = 0)), _) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	}

	function __values(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	}

	function __read(o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	}

	typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
	    var e = new Error(message);
	    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
	};

	/** @ignore */
	var ENTRIES = 'ENTRIES';
	/** @ignore */
	var KEYS = 'KEYS';
	/** @ignore */
	var VALUES = 'VALUES';
	/** @ignore */
	var LEAF = '';
	/**
	 * @private
	 */
	var TreeIterator = /** @class */ (function () {
	    function TreeIterator(set, type) {
	        var node = set._tree;
	        var keys = Array.from(node.keys());
	        this.set = set;
	        this._type = type;
	        this._path = keys.length > 0 ? [{ node: node, keys: keys }] : [];
	    }
	    TreeIterator.prototype.next = function () {
	        var value = this.dive();
	        this.backtrack();
	        return value;
	    };
	    TreeIterator.prototype.dive = function () {
	        if (this._path.length === 0) {
	            return { done: true, value: undefined };
	        }
	        var _a = last$1(this._path), node = _a.node, keys = _a.keys;
	        if (last$1(keys) === LEAF) {
	            return { done: false, value: this.result() };
	        }
	        var child = node.get(last$1(keys));
	        this._path.push({ node: child, keys: Array.from(child.keys()) });
	        return this.dive();
	    };
	    TreeIterator.prototype.backtrack = function () {
	        if (this._path.length === 0) {
	            return;
	        }
	        var keys = last$1(this._path).keys;
	        keys.pop();
	        if (keys.length > 0) {
	            return;
	        }
	        this._path.pop();
	        this.backtrack();
	    };
	    TreeIterator.prototype.key = function () {
	        return this.set._prefix + this._path
	            .map(function (_a) {
	            var keys = _a.keys;
	            return last$1(keys);
	        })
	            .filter(function (key) { return key !== LEAF; })
	            .join('');
	    };
	    TreeIterator.prototype.value = function () {
	        return last$1(this._path).node.get(LEAF);
	    };
	    TreeIterator.prototype.result = function () {
	        switch (this._type) {
	            case VALUES: return this.value();
	            case KEYS: return this.key();
	            default: return [this.key(), this.value()];
	        }
	    };
	    TreeIterator.prototype[Symbol.iterator] = function () {
	        return this;
	    };
	    return TreeIterator;
	}());
	var last$1 = function (array) {
	    return array[array.length - 1];
	};

	/**
	 * @ignore
	 */
	var fuzzySearch = function (node, query, maxDistance) {
	    var results = new Map();
	    if (query === undefined)
	        return results;
	    // Number of columns in the Levenshtein matrix.
	    var n = query.length + 1;
	    // Matching terms can never be longer than N + maxDistance.
	    var m = n + maxDistance;
	    // Fill first matrix row and column with numbers: 0 1 2 3 ...
	    var matrix = new Uint8Array(m * n).fill(maxDistance + 1);
	    for (var j = 0; j < n; ++j)
	        matrix[j] = j;
	    for (var i = 1; i < m; ++i)
	        matrix[i * n] = i;
	    recurse(node, query, maxDistance, results, matrix, 1, n, '');
	    return results;
	};
	// Modified version of http://stevehanov.ca/blog/?id=114
	// This builds a Levenshtein matrix for a given query and continuously updates
	// it for nodes in the radix tree that fall within the given maximum edit
	// distance. Keeping the same matrix around is beneficial especially for larger
	// edit distances.
	//
	//           k   a   t   e   <-- query
	//       0   1   2   3   4
	//   c   1   1   2   3   4
	//   a   2   2   1   2   3
	//   t   3   3   2   1  [2]  <-- edit distance
	//   ^
	//   ^ term in radix tree, rows are added and removed as needed
	var recurse = function (node, query, maxDistance, results, matrix, m, n, prefix) {
	    var e_1, _a;
	    var offset = m * n;
	    try {
	        key: for (var _b = __values(node.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
	            var key = _c.value;
	            if (key === LEAF) {
	                // We've reached a leaf node. Check if the edit distance acceptable and
	                // store the result if it is.
	                var distance = matrix[offset - 1];
	                if (distance <= maxDistance) {
	                    results.set(prefix, [node.get(key), distance]);
	                }
	            }
	            else {
	                // Iterate over all characters in the key. Update the Levenshtein matrix
	                // and check if the minimum distance in the last row is still within the
	                // maximum edit distance. If it is, we can recurse over all child nodes.
	                var i = m;
	                for (var pos = 0; pos < key.length; ++pos, ++i) {
	                    var char = key[pos];
	                    var thisRowOffset = n * i;
	                    var prevRowOffset = thisRowOffset - n;
	                    // Set the first column based on the previous row, and initialize the
	                    // minimum distance in the current row.
	                    var minDistance = matrix[thisRowOffset];
	                    var jmin = Math.max(0, i - maxDistance - 1);
	                    var jmax = Math.min(n - 1, i + maxDistance);
	                    // Iterate over remaining columns (characters in the query).
	                    for (var j = jmin; j < jmax; ++j) {
	                        var different = char !== query[j];
	                        // It might make sense to only read the matrix positions used for
	                        // deletion/insertion if the characters are different. But we want to
	                        // avoid conditional reads for performance reasons.
	                        var rpl = matrix[prevRowOffset + j] + +different;
	                        var del = matrix[prevRowOffset + j + 1] + 1;
	                        var ins = matrix[thisRowOffset + j] + 1;
	                        var dist = matrix[thisRowOffset + j + 1] = Math.min(rpl, del, ins);
	                        if (dist < minDistance)
	                            minDistance = dist;
	                    }
	                    // Because distance will never decrease, we can stop. There will be no
	                    // matching child nodes.
	                    if (minDistance > maxDistance) {
	                        continue key;
	                    }
	                }
	                recurse(node.get(key), query, maxDistance, results, matrix, i, n, prefix + key);
	            }
	        }
	    }
	    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	    finally {
	        try {
	            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	        }
	        finally { if (e_1) throw e_1.error; }
	    }
	};

	/**
	 * A class implementing the same interface as a standard JavaScript
	 * [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)
	 * with string keys, but adding support for efficiently searching entries with
	 * prefix or fuzzy search. This class is used internally by {@link MiniSearch}
	 * as the inverted index data structure. The implementation is a radix tree
	 * (compressed prefix tree).
	 *
	 * Since this class can be of general utility beyond _MiniSearch_, it is
	 * exported by the `minisearch` package and can be imported (or required) as
	 * `minisearch/SearchableMap`.
	 *
	 * @typeParam T  The type of the values stored in the map.
	 */
	var SearchableMap = /** @class */ (function () {
	    /**
	     * The constructor is normally called without arguments, creating an empty
	     * map. In order to create a {@link SearchableMap} from an iterable or from an
	     * object, check {@link SearchableMap.from} and {@link
	     * SearchableMap.fromObject}.
	     *
	     * The constructor arguments are for internal use, when creating derived
	     * mutable views of a map at a prefix.
	     */
	    function SearchableMap(tree, prefix) {
	        if (tree === void 0) { tree = new Map(); }
	        if (prefix === void 0) { prefix = ''; }
	        this._size = undefined;
	        this._tree = tree;
	        this._prefix = prefix;
	    }
	    /**
	     * Creates and returns a mutable view of this {@link SearchableMap},
	     * containing only entries that share the given prefix.
	     *
	     * ### Usage:
	     *
	     * ```javascript
	     * let map = new SearchableMap()
	     * map.set("unicorn", 1)
	     * map.set("universe", 2)
	     * map.set("university", 3)
	     * map.set("unique", 4)
	     * map.set("hello", 5)
	     *
	     * let uni = map.atPrefix("uni")
	     * uni.get("unique") // => 4
	     * uni.get("unicorn") // => 1
	     * uni.get("hello") // => undefined
	     *
	     * let univer = map.atPrefix("univer")
	     * univer.get("unique") // => undefined
	     * univer.get("universe") // => 2
	     * univer.get("university") // => 3
	     * ```
	     *
	     * @param prefix  The prefix
	     * @return A {@link SearchableMap} representing a mutable view of the original
	     * Map at the given prefix
	     */
	    SearchableMap.prototype.atPrefix = function (prefix) {
	        var e_1, _a;
	        if (!prefix.startsWith(this._prefix)) {
	            throw new Error('Mismatched prefix');
	        }
	        var _b = __read(trackDown(this._tree, prefix.slice(this._prefix.length)), 2), node = _b[0], path = _b[1];
	        if (node === undefined) {
	            var _c = __read(last(path), 2), parentNode = _c[0], key = _c[1];
	            try {
	                for (var _d = __values(parentNode.keys()), _e = _d.next(); !_e.done; _e = _d.next()) {
	                    var k = _e.value;
	                    if (k !== LEAF && k.startsWith(key)) {
	                        var node_1 = new Map();
	                        node_1.set(k.slice(key.length), parentNode.get(k));
	                        return new SearchableMap(node_1, prefix);
	                    }
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        return new SearchableMap(node, prefix);
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear
	     */
	    SearchableMap.prototype.clear = function () {
	        this._size = undefined;
	        this._tree.clear();
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete
	     * @param key  Key to delete
	     */
	    SearchableMap.prototype.delete = function (key) {
	        this._size = undefined;
	        return remove(this._tree, key);
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries
	     * @return An iterator iterating through `[key, value]` entries.
	     */
	    SearchableMap.prototype.entries = function () {
	        return new TreeIterator(this, ENTRIES);
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach
	     * @param fn  Iteration function
	     */
	    SearchableMap.prototype.forEach = function (fn) {
	        var e_2, _a;
	        try {
	            for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
	                fn(key, value, this);
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	    };
	    /**
	     * Returns a Map of all the entries that have a key within the given edit
	     * distance from the search key. The keys of the returned Map are the matching
	     * keys, while the values are two-element arrays where the first element is
	     * the value associated to the key, and the second is the edit distance of the
	     * key to the search key.
	     *
	     * ### Usage:
	     *
	     * ```javascript
	     * let map = new SearchableMap()
	     * map.set('hello', 'world')
	     * map.set('hell', 'yeah')
	     * map.set('ciao', 'mondo')
	     *
	     * // Get all entries that match the key 'hallo' with a maximum edit distance of 2
	     * map.fuzzyGet('hallo', 2)
	     * // => Map(2) { 'hello' => ['world', 1], 'hell' => ['yeah', 2] }
	     *
	     * // In the example, the "hello" key has value "world" and edit distance of 1
	     * // (change "e" to "a"), the key "hell" has value "yeah" and edit distance of 2
	     * // (change "e" to "a", delete "o")
	     * ```
	     *
	     * @param key  The search key
	     * @param maxEditDistance  The maximum edit distance (Levenshtein)
	     * @return A Map of the matching keys to their value and edit distance
	     */
	    SearchableMap.prototype.fuzzyGet = function (key, maxEditDistance) {
	        return fuzzySearch(this._tree, key, maxEditDistance);
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get
	     * @param key  Key to get
	     * @return Value associated to the key, or `undefined` if the key is not
	     * found.
	     */
	    SearchableMap.prototype.get = function (key) {
	        var node = lookup(this._tree, key);
	        return node !== undefined ? node.get(LEAF) : undefined;
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has
	     * @param key  Key
	     * @return True if the key is in the map, false otherwise
	     */
	    SearchableMap.prototype.has = function (key) {
	        var node = lookup(this._tree, key);
	        return node !== undefined && node.has(LEAF);
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys
	     * @return An `Iterable` iterating through keys
	     */
	    SearchableMap.prototype.keys = function () {
	        return new TreeIterator(this, KEYS);
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set
	     * @param key  Key to set
	     * @param value  Value to associate to the key
	     * @return The {@link SearchableMap} itself, to allow chaining
	     */
	    SearchableMap.prototype.set = function (key, value) {
	        if (typeof key !== 'string') {
	            throw new Error('key must be a string');
	        }
	        this._size = undefined;
	        var node = createPath(this._tree, key);
	        node.set(LEAF, value);
	        return this;
	    };
	    Object.defineProperty(SearchableMap.prototype, "size", {
	        /**
	         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size
	         */
	        get: function () {
	            if (this._size) {
	                return this._size;
	            }
	            /** @ignore */
	            this._size = 0;
	            var iter = this.entries();
	            while (!iter.next().done)
	                this._size += 1;
	            return this._size;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * Updates the value at the given key using the provided function. The function
	     * is called with the current value at the key, and its return value is used as
	     * the new value to be set.
	     *
	     * ### Example:
	     *
	     * ```javascript
	     * // Increment the current value by one
	     * searchableMap.update('somekey', (currentValue) => currentValue == null ? 0 : currentValue + 1)
	     * ```
	     *
	     * If the value at the given key is or will be an object, it might not require
	     * re-assignment. In that case it is better to use `fetch()`, because it is
	     * faster.
	     *
	     * @param key  The key to update
	     * @param fn  The function used to compute the new value from the current one
	     * @return The {@link SearchableMap} itself, to allow chaining
	     */
	    SearchableMap.prototype.update = function (key, fn) {
	        if (typeof key !== 'string') {
	            throw new Error('key must be a string');
	        }
	        this._size = undefined;
	        var node = createPath(this._tree, key);
	        node.set(LEAF, fn(node.get(LEAF)));
	        return this;
	    };
	    /**
	     * Fetches the value of the given key. If the value does not exist, calls the
	     * given function to create a new value, which is inserted at the given key
	     * and subsequently returned.
	     *
	     * ### Example:
	     *
	     * ```javascript
	     * const map = searchableMap.fetch('somekey', () => new Map())
	     * map.set('foo', 'bar')
	     * ```
	     *
	     * @param key  The key to update
	     * @param defaultValue  A function that creates a new value if the key does not exist
	     * @return The existing or new value at the given key
	     */
	    SearchableMap.prototype.fetch = function (key, initial) {
	        if (typeof key !== 'string') {
	            throw new Error('key must be a string');
	        }
	        this._size = undefined;
	        var node = createPath(this._tree, key);
	        var value = node.get(LEAF);
	        if (value === undefined) {
	            node.set(LEAF, value = initial());
	        }
	        return value;
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values
	     * @return An `Iterable` iterating through values.
	     */
	    SearchableMap.prototype.values = function () {
	        return new TreeIterator(this, VALUES);
	    };
	    /**
	     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator
	     */
	    SearchableMap.prototype[Symbol.iterator] = function () {
	        return this.entries();
	    };
	    /**
	     * Creates a {@link SearchableMap} from an `Iterable` of entries
	     *
	     * @param entries  Entries to be inserted in the {@link SearchableMap}
	     * @return A new {@link SearchableMap} with the given entries
	     */
	    SearchableMap.from = function (entries) {
	        var e_3, _a;
	        var tree = new SearchableMap();
	        try {
	            for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
	                var _b = __read(entries_1_1.value, 2), key = _b[0], value = _b[1];
	                tree.set(key, value);
	            }
	        }
	        catch (e_3_1) { e_3 = { error: e_3_1 }; }
	        finally {
	            try {
	                if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return)) _a.call(entries_1);
	            }
	            finally { if (e_3) throw e_3.error; }
	        }
	        return tree;
	    };
	    /**
	     * Creates a {@link SearchableMap} from the iterable properties of a JavaScript object
	     *
	     * @param object  Object of entries for the {@link SearchableMap}
	     * @return A new {@link SearchableMap} with the given entries
	     */
	    SearchableMap.fromObject = function (object) {
	        return SearchableMap.from(Object.entries(object));
	    };
	    return SearchableMap;
	}());
	var trackDown = function (tree, key, path) {
	    var e_4, _a;
	    if (path === void 0) { path = []; }
	    if (key.length === 0 || tree == null) {
	        return [tree, path];
	    }
	    try {
	        for (var _b = __values(tree.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
	            var k = _c.value;
	            if (k !== LEAF && key.startsWith(k)) {
	                path.push([tree, k]); // performance: update in place
	                return trackDown(tree.get(k), key.slice(k.length), path);
	            }
	        }
	    }
	    catch (e_4_1) { e_4 = { error: e_4_1 }; }
	    finally {
	        try {
	            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	        }
	        finally { if (e_4) throw e_4.error; }
	    }
	    path.push([tree, key]); // performance: update in place
	    return trackDown(undefined, '', path);
	};
	var lookup = function (tree, key) {
	    var e_5, _a;
	    if (key.length === 0 || tree == null) {
	        return tree;
	    }
	    try {
	        for (var _b = __values(tree.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
	            var k = _c.value;
	            if (k !== LEAF && key.startsWith(k)) {
	                return lookup(tree.get(k), key.slice(k.length));
	            }
	        }
	    }
	    catch (e_5_1) { e_5 = { error: e_5_1 }; }
	    finally {
	        try {
	            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	        }
	        finally { if (e_5) throw e_5.error; }
	    }
	};
	// Create a path in the radix tree for the given key, and returns the deepest
	// node. This function is in the hot path for indexing. It avoids unnecessary
	// string operations and recursion for performance.
	var createPath = function (node, key) {
	    var e_6, _a;
	    var keyLength = key.length;
	    outer: for (var pos = 0; node && pos < keyLength;) {
	        try {
	            for (var _b = (e_6 = void 0, __values(node.keys())), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var k = _c.value;
	                // Check whether this key is a candidate: the first characters must match.
	                if (k !== LEAF && key[pos] === k[0]) {
	                    var len = Math.min(keyLength - pos, k.length);
	                    // Advance offset to the point where key and k no longer match.
	                    var offset = 1;
	                    while (offset < len && key[pos + offset] === k[offset])
	                        ++offset;
	                    var child_1 = node.get(k);
	                    if (offset === k.length) {
	                        // The existing key is shorter than the key we need to create.
	                        node = child_1;
	                    }
	                    else {
	                        // Partial match: we need to insert an intermediate node to contain
	                        // both the existing subtree and the new node.
	                        var intermediate = new Map();
	                        intermediate.set(k.slice(offset), child_1);
	                        node.set(key.slice(pos, pos + offset), intermediate);
	                        node.delete(k);
	                        node = intermediate;
	                    }
	                    pos += offset;
	                    continue outer;
	                }
	            }
	        }
	        catch (e_6_1) { e_6 = { error: e_6_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_6) throw e_6.error; }
	        }
	        // Create a final child node to contain the final suffix of the key.
	        var child = new Map();
	        node.set(key.slice(pos), child);
	        return child;
	    }
	    return node;
	};
	var remove = function (tree, key) {
	    var _a = __read(trackDown(tree, key), 2), node = _a[0], path = _a[1];
	    if (node === undefined) {
	        return;
	    }
	    node.delete(LEAF);
	    if (node.size === 0) {
	        cleanup(path);
	    }
	    else if (node.size === 1) {
	        var _b = __read(node.entries().next().value, 2), key_1 = _b[0], value = _b[1];
	        merge(path, key_1, value);
	    }
	};
	var cleanup = function (path) {
	    if (path.length === 0) {
	        return;
	    }
	    var _a = __read(last(path), 2), node = _a[0], key = _a[1];
	    node.delete(key);
	    if (node.size === 0) {
	        cleanup(path.slice(0, -1));
	    }
	    else if (node.size === 1) {
	        var _b = __read(node.entries().next().value, 2), key_2 = _b[0], value = _b[1];
	        if (key_2 !== LEAF) {
	            merge(path.slice(0, -1), key_2, value);
	        }
	    }
	};
	var merge = function (path, key, value) {
	    if (path.length === 0) {
	        return;
	    }
	    var _a = __read(last(path), 2), node = _a[0], nodeKey = _a[1];
	    node.set(nodeKey + key, value);
	    node.delete(nodeKey);
	};
	var last = function (array) {
	    return array[array.length - 1];
	};

	var _a;
	var OR = 'or';
	var AND = 'and';
	var AND_NOT = 'and_not';
	/**
	 * {@link MiniSearch} is the main entrypoint class, implementing a full-text
	 * search engine in memory.
	 *
	 * @typeParam T  The type of the documents being indexed.
	 *
	 * ### Basic example:
	 *
	 * ```javascript
	 * const documents = [
	 *   {
	 *     id: 1,
	 *     title: 'Moby Dick',
	 *     text: 'Call me Ishmael. Some years ago...',
	 *     category: 'fiction'
	 *   },
	 *   {
	 *     id: 2,
	 *     title: 'Zen and the Art of Motorcycle Maintenance',
	 *     text: 'I can see by my watch...',
	 *     category: 'fiction'
	 *   },
	 *   {
	 *     id: 3,
	 *     title: 'Neuromancer',
	 *     text: 'The sky above the port was...',
	 *     category: 'fiction'
	 *   },
	 *   {
	 *     id: 4,
	 *     title: 'Zen and the Art of Archery',
	 *     text: 'At first sight it must seem...',
	 *     category: 'non-fiction'
	 *   },
	 *   // ...and more
	 * ]
	 *
	 * // Create a search engine that indexes the 'title' and 'text' fields for
	 * // full-text search. Search results will include 'title' and 'category' (plus the
	 * // id field, that is always stored and returned)
	 * const miniSearch = new MiniSearch({
	 *   fields: ['title', 'text'],
	 *   storeFields: ['title', 'category']
	 * })
	 *
	 * // Add documents to the index
	 * miniSearch.addAll(documents)
	 *
	 * // Search for documents:
	 * let results = miniSearch.search('zen art motorcycle')
	 * // => [
	 * //   { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258 },
	 * //   { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629 }
	 * // ]
	 * ```
	 */
	var MiniSearch = /** @class */ (function () {
	    /**
	     * @param options  Configuration options
	     *
	     * ### Examples:
	     *
	     * ```javascript
	     * // Create a search engine that indexes the 'title' and 'text' fields of your
	     * // documents:
	     * const miniSearch = new MiniSearch({ fields: ['title', 'text'] })
	     * ```
	     *
	     * ### ID Field:
	     *
	     * ```javascript
	     * // Your documents are assumed to include a unique 'id' field, but if you want
	     * // to use a different field for document identification, you can set the
	     * // 'idField' option:
	     * const miniSearch = new MiniSearch({ idField: 'key', fields: ['title', 'text'] })
	     * ```
	     *
	     * ### Options and defaults:
	     *
	     * ```javascript
	     * // The full set of options (here with their default value) is:
	     * const miniSearch = new MiniSearch({
	     *   // idField: field that uniquely identifies a document
	     *   idField: 'id',
	     *
	     *   // extractField: function used to get the value of a field in a document.
	     *   // By default, it assumes the document is a flat object with field names as
	     *   // property keys and field values as string property values, but custom logic
	     *   // can be implemented by setting this option to a custom extractor function.
	     *   extractField: (document, fieldName) => document[fieldName],
	     *
	     *   // tokenize: function used to split fields into individual terms. By
	     *   // default, it is also used to tokenize search queries, unless a specific
	     *   // `tokenize` search option is supplied. When tokenizing an indexed field,
	     *   // the field name is passed as the second argument.
	     *   tokenize: (string, _fieldName) => string.split(SPACE_OR_PUNCTUATION),
	     *
	     *   // processTerm: function used to process each tokenized term before
	     *   // indexing. It can be used for stemming and normalization. Return a falsy
	     *   // value in order to discard a term. By default, it is also used to process
	     *   // search queries, unless a specific `processTerm` option is supplied as a
	     *   // search option. When processing a term from a indexed field, the field
	     *   // name is passed as the second argument.
	     *   processTerm: (term, _fieldName) => term.toLowerCase(),
	     *
	     *   // searchOptions: default search options, see the `search` method for
	     *   // details
	     *   searchOptions: undefined,
	     *
	     *   // fields: document fields to be indexed. Mandatory, but not set by default
	     *   fields: undefined
	     *
	     *   // storeFields: document fields to be stored and returned as part of the
	     *   // search results.
	     *   storeFields: []
	     * })
	     * ```
	     */
	    function MiniSearch(options) {
	        if ((options === null || options === void 0 ? void 0 : options.fields) == null) {
	            throw new Error('MiniSearch: option "fields" must be provided');
	        }
	        var autoVacuum = (options.autoVacuum == null || options.autoVacuum === true) ? defaultAutoVacuumOptions : options.autoVacuum;
	        this._options = __assign(__assign(__assign({}, defaultOptions), options), { autoVacuum: autoVacuum, searchOptions: __assign(__assign({}, defaultSearchOptions), (options.searchOptions || {})), autoSuggestOptions: __assign(__assign({}, defaultAutoSuggestOptions), (options.autoSuggestOptions || {})) });
	        this._index = new SearchableMap();
	        this._documentCount = 0;
	        this._documentIds = new Map();
	        this._idToShortId = new Map();
	        // Fields are defined during initialization, don't change, are few in
	        // number, rarely need iterating over, and have string keys. Therefore in
	        // this case an object is a better candidate than a Map to store the mapping
	        // from field key to ID.
	        this._fieldIds = {};
	        this._fieldLength = new Map();
	        this._avgFieldLength = [];
	        this._nextId = 0;
	        this._storedFields = new Map();
	        this._dirtCount = 0;
	        this._currentVacuum = null;
	        this._enqueuedVacuum = null;
	        this._enqueuedVacuumConditions = defaultVacuumConditions;
	        this.addFields(this._options.fields);
	    }
	    /**
	     * Adds a document to the index
	     *
	     * @param document  The document to be indexed
	     */
	    MiniSearch.prototype.add = function (document) {
	        var e_1, _a, e_2, _b, e_3, _c;
	        var _d = this._options, extractField = _d.extractField, tokenize = _d.tokenize, processTerm = _d.processTerm, fields = _d.fields, idField = _d.idField;
	        var id = extractField(document, idField);
	        if (id == null) {
	            throw new Error("MiniSearch: document does not have ID field \"".concat(idField, "\""));
	        }
	        if (this._idToShortId.has(id)) {
	            throw new Error("MiniSearch: duplicate ID ".concat(id));
	        }
	        var shortDocumentId = this.addDocumentId(id);
	        this.saveStoredFields(shortDocumentId, document);
	        try {
	            for (var fields_1 = __values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {
	                var field = fields_1_1.value;
	                var fieldValue = extractField(document, field);
	                if (fieldValue == null)
	                    continue;
	                var tokens = tokenize(fieldValue.toString(), field);
	                var fieldId = this._fieldIds[field];
	                var uniqueTerms = new Set(tokens).size;
	                this.addFieldLength(shortDocumentId, fieldId, this._documentCount - 1, uniqueTerms);
	                try {
	                    for (var tokens_1 = (e_2 = void 0, __values(tokens)), tokens_1_1 = tokens_1.next(); !tokens_1_1.done; tokens_1_1 = tokens_1.next()) {
	                        var term = tokens_1_1.value;
	                        var processedTerm = processTerm(term, field);
	                        if (Array.isArray(processedTerm)) {
	                            try {
	                                for (var processedTerm_1 = (e_3 = void 0, __values(processedTerm)), processedTerm_1_1 = processedTerm_1.next(); !processedTerm_1_1.done; processedTerm_1_1 = processedTerm_1.next()) {
	                                    var t = processedTerm_1_1.value;
	                                    this.addTerm(fieldId, shortDocumentId, t);
	                                }
	                            }
	                            catch (e_3_1) { e_3 = { error: e_3_1 }; }
	                            finally {
	                                try {
	                                    if (processedTerm_1_1 && !processedTerm_1_1.done && (_c = processedTerm_1.return)) _c.call(processedTerm_1);
	                                }
	                                finally { if (e_3) throw e_3.error; }
	                            }
	                        }
	                        else if (processedTerm) {
	                            this.addTerm(fieldId, shortDocumentId, processedTerm);
	                        }
	                    }
	                }
	                catch (e_2_1) { e_2 = { error: e_2_1 }; }
	                finally {
	                    try {
	                        if (tokens_1_1 && !tokens_1_1.done && (_b = tokens_1.return)) _b.call(tokens_1);
	                    }
	                    finally { if (e_2) throw e_2.error; }
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (fields_1_1 && !fields_1_1.done && (_a = fields_1.return)) _a.call(fields_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	    };
	    /**
	     * Adds all the given documents to the index
	     *
	     * @param documents  An array of documents to be indexed
	     */
	    MiniSearch.prototype.addAll = function (documents) {
	        var e_4, _a;
	        try {
	            for (var documents_1 = __values(documents), documents_1_1 = documents_1.next(); !documents_1_1.done; documents_1_1 = documents_1.next()) {
	                var document_1 = documents_1_1.value;
	                this.add(document_1);
	            }
	        }
	        catch (e_4_1) { e_4 = { error: e_4_1 }; }
	        finally {
	            try {
	                if (documents_1_1 && !documents_1_1.done && (_a = documents_1.return)) _a.call(documents_1);
	            }
	            finally { if (e_4) throw e_4.error; }
	        }
	    };
	    /**
	     * Adds all the given documents to the index asynchronously.
	     *
	     * Returns a promise that resolves (to `undefined`) when the indexing is done.
	     * This method is useful when index many documents, to avoid blocking the main
	     * thread. The indexing is performed asynchronously and in chunks.
	     *
	     * @param documents  An array of documents to be indexed
	     * @param options  Configuration options
	     * @return A promise resolving to `undefined` when the indexing is done
	     */
	    MiniSearch.prototype.addAllAsync = function (documents, options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        var _a = options.chunkSize, chunkSize = _a === void 0 ? 10 : _a;
	        var acc = { chunk: [], promise: Promise.resolve() };
	        var _b = documents.reduce(function (_a, document, i) {
	            var chunk = _a.chunk, promise = _a.promise;
	            chunk.push(document);
	            if ((i + 1) % chunkSize === 0) {
	                return {
	                    chunk: [],
	                    promise: promise
	                        .then(function () { return new Promise(function (resolve) { return setTimeout(resolve, 0); }); })
	                        .then(function () { return _this.addAll(chunk); })
	                };
	            }
	            else {
	                return { chunk: chunk, promise: promise };
	            }
	        }, acc), chunk = _b.chunk, promise = _b.promise;
	        return promise.then(function () { return _this.addAll(chunk); });
	    };
	    /**
	     * Removes the given document from the index.
	     *
	     * The document to remove must NOT have changed between indexing and removal,
	     * otherwise the index will be corrupted.
	     *
	     * This method requires passing the full document to be removed (not just the
	     * ID), and immediately removes the document from the inverted index, allowing
	     * memory to be released. A convenient alternative is {@link
	     * MiniSearch#discard}, which needs only the document ID, and has the same
	     * visible effect, but delays cleaning up the index until the next vacuuming.
	     *
	     * @param document  The document to be removed
	     */
	    MiniSearch.prototype.remove = function (document) {
	        var e_5, _a, e_6, _b, e_7, _c;
	        var _d = this._options, tokenize = _d.tokenize, processTerm = _d.processTerm, extractField = _d.extractField, fields = _d.fields, idField = _d.idField;
	        var id = extractField(document, idField);
	        if (id == null) {
	            throw new Error("MiniSearch: document does not have ID field \"".concat(idField, "\""));
	        }
	        var shortId = this._idToShortId.get(id);
	        if (shortId == null) {
	            throw new Error("MiniSearch: cannot remove document with ID ".concat(id, ": it is not in the index"));
	        }
	        try {
	            for (var fields_2 = __values(fields), fields_2_1 = fields_2.next(); !fields_2_1.done; fields_2_1 = fields_2.next()) {
	                var field = fields_2_1.value;
	                var fieldValue = extractField(document, field);
	                if (fieldValue == null)
	                    continue;
	                var tokens = tokenize(fieldValue.toString(), field);
	                var fieldId = this._fieldIds[field];
	                var uniqueTerms = new Set(tokens).size;
	                this.removeFieldLength(shortId, fieldId, this._documentCount, uniqueTerms);
	                try {
	                    for (var tokens_2 = (e_6 = void 0, __values(tokens)), tokens_2_1 = tokens_2.next(); !tokens_2_1.done; tokens_2_1 = tokens_2.next()) {
	                        var term = tokens_2_1.value;
	                        var processedTerm = processTerm(term, field);
	                        if (Array.isArray(processedTerm)) {
	                            try {
	                                for (var processedTerm_2 = (e_7 = void 0, __values(processedTerm)), processedTerm_2_1 = processedTerm_2.next(); !processedTerm_2_1.done; processedTerm_2_1 = processedTerm_2.next()) {
	                                    var t = processedTerm_2_1.value;
	                                    this.removeTerm(fieldId, shortId, t);
	                                }
	                            }
	                            catch (e_7_1) { e_7 = { error: e_7_1 }; }
	                            finally {
	                                try {
	                                    if (processedTerm_2_1 && !processedTerm_2_1.done && (_c = processedTerm_2.return)) _c.call(processedTerm_2);
	                                }
	                                finally { if (e_7) throw e_7.error; }
	                            }
	                        }
	                        else if (processedTerm) {
	                            this.removeTerm(fieldId, shortId, processedTerm);
	                        }
	                    }
	                }
	                catch (e_6_1) { e_6 = { error: e_6_1 }; }
	                finally {
	                    try {
	                        if (tokens_2_1 && !tokens_2_1.done && (_b = tokens_2.return)) _b.call(tokens_2);
	                    }
	                    finally { if (e_6) throw e_6.error; }
	                }
	            }
	        }
	        catch (e_5_1) { e_5 = { error: e_5_1 }; }
	        finally {
	            try {
	                if (fields_2_1 && !fields_2_1.done && (_a = fields_2.return)) _a.call(fields_2);
	            }
	            finally { if (e_5) throw e_5.error; }
	        }
	        this._storedFields.delete(shortId);
	        this._documentIds.delete(shortId);
	        this._idToShortId.delete(id);
	        this._fieldLength.delete(shortId);
	        this._documentCount -= 1;
	    };
	    /**
	     * Removes all the given documents from the index. If called with no arguments,
	     * it removes _all_ documents from the index.
	     *
	     * @param documents  The documents to be removed. If this argument is omitted,
	     * all documents are removed. Note that, for removing all documents, it is
	     * more efficient to call this method with no arguments than to pass all
	     * documents.
	     */
	    MiniSearch.prototype.removeAll = function (documents) {
	        var e_8, _a;
	        if (documents) {
	            try {
	                for (var documents_2 = __values(documents), documents_2_1 = documents_2.next(); !documents_2_1.done; documents_2_1 = documents_2.next()) {
	                    var document_2 = documents_2_1.value;
	                    this.remove(document_2);
	                }
	            }
	            catch (e_8_1) { e_8 = { error: e_8_1 }; }
	            finally {
	                try {
	                    if (documents_2_1 && !documents_2_1.done && (_a = documents_2.return)) _a.call(documents_2);
	                }
	                finally { if (e_8) throw e_8.error; }
	            }
	        }
	        else if (arguments.length > 0) {
	            throw new Error('Expected documents to be present. Omit the argument to remove all documents.');
	        }
	        else {
	            this._index = new SearchableMap();
	            this._documentCount = 0;
	            this._documentIds = new Map();
	            this._idToShortId = new Map();
	            this._fieldLength = new Map();
	            this._avgFieldLength = [];
	            this._storedFields = new Map();
	            this._nextId = 0;
	        }
	    };
	    /**
	     * Discards the document with the given ID, so it won't appear in search results
	     *
	     * It has the same visible effect of {@link MiniSearch.remove} (both cause the
	     * document to stop appearing in searches), but a different effect on the
	     * internal data structures:
	     *
	     *   - {@link MiniSearch#remove} requires passing the full document to be
	     *   removed as argument, and removes it from the inverted index immediately.
	     *
	     *   - {@link MiniSearch#discard} instead only needs the document ID, and
	     *   works by marking the current version of the document as discarded, so it
	     *   is immediately ignored by searches. This is faster and more convenient
	     *   than {@link MiniSearch#remove}, but the index is not immediately
	     *   modified. To take care of that, vacuuming is performed after a certain
	     *   number of documents are discarded, cleaning up the index and allowing
	     *   memory to be released.
	     *
	     * After discarding a document, it is possible to re-add a new version, and
	     * only the new version will appear in searches. In other words, discarding
	     * and re-adding a document works exactly like removing and re-adding it. The
	     * {@link MiniSearch.replace} method can also be used to replace a document
	     * with a new version.
	     *
	     * #### Details about vacuuming
	     *
	     * Repetite calls to this method would leave obsolete document references in
	     * the index, invisible to searches. Two mechanisms take care of cleaning up:
	     * clean up during search, and vacuuming.
	     *
	     *   - Upon search, whenever a discarded ID is found (and ignored for the
	     *   results), references to the discarded document are removed from the
	     *   inverted index entries for the search terms. This ensures that subsequent
	     *   searches for the same terms do not need to skip these obsolete references
	     *   again.
	     *
	     *   - In addition, vacuuming is performed automatically by default (see the
	     *   `autoVacuum` field in {@link Options}) after a certain number of
	     *   documents are discarded. Vacuuming traverses all terms in the index,
	     *   cleaning up all references to discarded documents. Vacuuming can also be
	     *   triggered manually by calling {@link MiniSearch#vacuum}.
	     *
	     * @param id  The ID of the document to be discarded
	     */
	    MiniSearch.prototype.discard = function (id) {
	        var _this = this;
	        var shortId = this._idToShortId.get(id);
	        if (shortId == null) {
	            throw new Error("MiniSearch: cannot discard document with ID ".concat(id, ": it is not in the index"));
	        }
	        this._idToShortId.delete(id);
	        this._documentIds.delete(shortId);
	        this._storedFields.delete(shortId);
	        (this._fieldLength.get(shortId) || []).forEach(function (fieldLength, fieldId) {
	            _this.removeFieldLength(shortId, fieldId, _this._documentCount, fieldLength);
	        });
	        this._fieldLength.delete(shortId);
	        this._documentCount -= 1;
	        this._dirtCount += 1;
	        this.maybeAutoVacuum();
	    };
	    MiniSearch.prototype.maybeAutoVacuum = function () {
	        if (this._options.autoVacuum === false) {
	            return;
	        }
	        var _a = this._options.autoVacuum, minDirtFactor = _a.minDirtFactor, minDirtCount = _a.minDirtCount, batchSize = _a.batchSize, batchWait = _a.batchWait;
	        this.conditionalVacuum({ batchSize: batchSize, batchWait: batchWait }, { minDirtCount: minDirtCount, minDirtFactor: minDirtFactor });
	    };
	    /**
	     * Discards the documents with the given IDs, so they won't appear in search
	     * results
	     *
	     * It is equivalent to calling {@link MiniSearch#discard} for all the given
	     * IDs, but with the optimization of triggering at most one automatic
	     * vacuuming at the end.
	     *
	     * Note: to remove all documents from the index, it is faster and more
	     * convenient to call {@link MiniSearch.removeAll} with no argument, instead
	     * of passing all IDs to this method.
	     */
	    MiniSearch.prototype.discardAll = function (ids) {
	        var e_9, _a;
	        var autoVacuum = this._options.autoVacuum;
	        try {
	            this._options.autoVacuum = false;
	            try {
	                for (var ids_1 = __values(ids), ids_1_1 = ids_1.next(); !ids_1_1.done; ids_1_1 = ids_1.next()) {
	                    var id = ids_1_1.value;
	                    this.discard(id);
	                }
	            }
	            catch (e_9_1) { e_9 = { error: e_9_1 }; }
	            finally {
	                try {
	                    if (ids_1_1 && !ids_1_1.done && (_a = ids_1.return)) _a.call(ids_1);
	                }
	                finally { if (e_9) throw e_9.error; }
	            }
	        }
	        finally {
	            this._options.autoVacuum = autoVacuum;
	        }
	        this.maybeAutoVacuum();
	    };
	    /**
	     * It replaces an existing document with the given updated version
	     *
	     * It works by discarding the current version and adding the updated one, so
	     * it is functionally equivalent to calling {@link MiniSearch#discard}
	     * followed by {@link MiniSearch#add}. The ID of the updated document should
	     * be the same as the original one.
	     *
	     * Since it uses {@link MiniSearch#discard} internally, this method relies on
	     * vacuuming to clean up obsolete document references from the index, allowing
	     * memory to be released (see {@link MiniSearch#discard}).
	     *
	     * @param updatedDocument  The updated document to replace the old version
	     * with
	     */
	    MiniSearch.prototype.replace = function (updatedDocument) {
	        var _a = this._options, idField = _a.idField, extractField = _a.extractField;
	        var id = extractField(updatedDocument, idField);
	        this.discard(id);
	        this.add(updatedDocument);
	    };
	    /**
	     * Triggers a manual vacuuming, cleaning up references to discarded documents
	     * from the inverted index
	     *
	     * Vacuuming is only useful for applications that use the {@link
	     * MiniSearch#discard} or {@link MiniSearch#replace} methods.
	     *
	     * By default, vacuuming is performed automatically when needed (controlled by
	     * the `autoVacuum` field in {@link Options}), so there is usually no need to
	     * call this method, unless one wants to make sure to perform vacuuming at a
	     * specific moment.
	     *
	     * Vacuuming traverses all terms in the inverted index in batches, and cleans
	     * up references to discarded documents from the posting list, allowing memory
	     * to be released.
	     *
	     * The method takes an optional object as argument with the following keys:
	     *
	     *   - `batchSize`: the size of each batch (1000 by default)
	     *
	     *   - `batchWait`: the number of milliseconds to wait between batches (10 by
	     *   default)
	     *
	     * On large indexes, vacuuming could have a non-negligible cost: batching
	     * avoids blocking the thread for long, diluting this cost so that it is not
	     * negatively affecting the application. Nonetheless, this method should only
	     * be called when necessary, and relying on automatic vacuuming is usually
	     * better.
	     *
	     * It returns a promise that resolves (to undefined) when the clean up is
	     * completed. If vacuuming is already ongoing at the time this method is
	     * called, a new one is enqueued immediately after the ongoing one, and a
	     * corresponding promise is returned. However, no more than one vacuuming is
	     * enqueued on top of the ongoing one, even if this method is called more
	     * times (enqueuing multiple ones would be useless).
	     *
	     * @param options  Configuration options for the batch size and delay. See
	     * {@link VacuumOptions}.
	     */
	    MiniSearch.prototype.vacuum = function (options) {
	        if (options === void 0) { options = {}; }
	        return this.conditionalVacuum(options);
	    };
	    MiniSearch.prototype.conditionalVacuum = function (options, conditions) {
	        var _this = this;
	        // If a vacuum is already ongoing, schedule another as soon as it finishes,
	        // unless there's already one enqueued. If one was already enqueued, do not
	        // enqueue another on top, but make sure that the conditions are the
	        // broadest.
	        if (this._currentVacuum) {
	            this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && conditions;
	            if (this._enqueuedVacuum != null) {
	                return this._enqueuedVacuum;
	            }
	            this._enqueuedVacuum = this._currentVacuum.then(function () {
	                var conditions = _this._enqueuedVacuumConditions;
	                _this._enqueuedVacuumConditions = defaultVacuumConditions;
	                return _this.performVacuuming(options, conditions);
	            });
	            return this._enqueuedVacuum;
	        }
	        if (this.vacuumConditionsMet(conditions) === false) {
	            return Promise.resolve();
	        }
	        this._currentVacuum = this.performVacuuming(options);
	        return this._currentVacuum;
	    };
	    MiniSearch.prototype.performVacuuming = function (options, conditions) {
	        return __awaiter(this, void 0, void 0, function () {
	            var initialDirtCount, batchSize, batchWait_1, i, _a, _b, _c, term, fieldsData, fieldsData_1, fieldsData_1_1, _d, fieldId, fieldIndex, fieldIndex_1, fieldIndex_1_1, _e, shortId, e_10_1;
	            var e_10, _f, e_11, _g, e_12, _h;
	            return __generator(this, function (_j) {
	                switch (_j.label) {
	                    case 0:
	                        initialDirtCount = this._dirtCount;
	                        if (!this.vacuumConditionsMet(conditions)) return [3 /*break*/, 10];
	                        batchSize = options.batchSize || defaultVacuumOptions.batchSize;
	                        batchWait_1 = options.batchWait || defaultVacuumOptions.batchWait;
	                        i = 1;
	                        _j.label = 1;
	                    case 1:
	                        _j.trys.push([1, 7, 8, 9]);
	                        _a = __values(this._index), _b = _a.next();
	                        _j.label = 2;
	                    case 2:
	                        if (!!_b.done) return [3 /*break*/, 6];
	                        _c = __read(_b.value, 2), term = _c[0], fieldsData = _c[1];
	                        try {
	                            for (fieldsData_1 = (e_11 = void 0, __values(fieldsData)), fieldsData_1_1 = fieldsData_1.next(); !fieldsData_1_1.done; fieldsData_1_1 = fieldsData_1.next()) {
	                                _d = __read(fieldsData_1_1.value, 2), fieldId = _d[0], fieldIndex = _d[1];
	                                try {
	                                    for (fieldIndex_1 = (e_12 = void 0, __values(fieldIndex)), fieldIndex_1_1 = fieldIndex_1.next(); !fieldIndex_1_1.done; fieldIndex_1_1 = fieldIndex_1.next()) {
	                                        _e = __read(fieldIndex_1_1.value, 1), shortId = _e[0];
	                                        if (this._documentIds.has(shortId)) {
	                                            continue;
	                                        }
	                                        if (fieldIndex.size <= 1) {
	                                            fieldsData.delete(fieldId);
	                                        }
	                                        else {
	                                            fieldIndex.delete(shortId);
	                                        }
	                                    }
	                                }
	                                catch (e_12_1) { e_12 = { error: e_12_1 }; }
	                                finally {
	                                    try {
	                                        if (fieldIndex_1_1 && !fieldIndex_1_1.done && (_h = fieldIndex_1.return)) _h.call(fieldIndex_1);
	                                    }
	                                    finally { if (e_12) throw e_12.error; }
	                                }
	                            }
	                        }
	                        catch (e_11_1) { e_11 = { error: e_11_1 }; }
	                        finally {
	                            try {
	                                if (fieldsData_1_1 && !fieldsData_1_1.done && (_g = fieldsData_1.return)) _g.call(fieldsData_1);
	                            }
	                            finally { if (e_11) throw e_11.error; }
	                        }
	                        if (this._index.get(term).size === 0) {
	                            this._index.delete(term);
	                        }
	                        if (!(i % batchSize === 0)) return [3 /*break*/, 4];
	                        return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, batchWait_1); })];
	                    case 3:
	                        _j.sent();
	                        _j.label = 4;
	                    case 4:
	                        i += 1;
	                        _j.label = 5;
	                    case 5:
	                        _b = _a.next();
	                        return [3 /*break*/, 2];
	                    case 6: return [3 /*break*/, 9];
	                    case 7:
	                        e_10_1 = _j.sent();
	                        e_10 = { error: e_10_1 };
	                        return [3 /*break*/, 9];
	                    case 8:
	                        try {
	                            if (_b && !_b.done && (_f = _a.return)) _f.call(_a);
	                        }
	                        finally { if (e_10) throw e_10.error; }
	                        return [7 /*endfinally*/];
	                    case 9:
	                        this._dirtCount -= initialDirtCount;
	                        _j.label = 10;
	                    case 10: 
	                    // Make the next lines always async, so they execute after this function returns
	                    return [4 /*yield*/, null];
	                    case 11:
	                        // Make the next lines always async, so they execute after this function returns
	                        _j.sent();
	                        this._currentVacuum = this._enqueuedVacuum;
	                        this._enqueuedVacuum = null;
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    MiniSearch.prototype.vacuumConditionsMet = function (conditions) {
	        if (conditions == null) {
	            return true;
	        }
	        var minDirtCount = conditions.minDirtCount, minDirtFactor = conditions.minDirtFactor;
	        minDirtCount = minDirtCount || defaultAutoVacuumOptions.minDirtCount;
	        minDirtFactor = minDirtFactor || defaultAutoVacuumOptions.minDirtFactor;
	        return this.dirtCount >= minDirtCount && this.dirtFactor >= minDirtFactor;
	    };
	    Object.defineProperty(MiniSearch.prototype, "isVacuuming", {
	        /**
	         * Is `true` if a vacuuming operation is ongoing, `false` otherwise
	         */
	        get: function () {
	            return this._currentVacuum != null;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(MiniSearch.prototype, "dirtCount", {
	        /**
	         * The number of documents discarded since the most recent vacuuming
	         */
	        get: function () {
	            return this._dirtCount;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(MiniSearch.prototype, "dirtFactor", {
	        /**
	         * A number between 0 and 1 giving an indication about the proportion of
	         * documents that are discarded, and can therefore be cleaned up by vacuuming.
	         * A value close to 0 means that the index is relatively clean, while a higher
	         * value means that the index is relatively dirty, and vacuuming could release
	         * memory.
	         */
	        get: function () {
	            return this._dirtCount / (1 + this._documentCount + this._dirtCount);
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * Returns `true` if a document with the given ID is present in the index and
	     * available for search, `false` otherwise
	     *
	     * @param id  The document ID
	     */
	    MiniSearch.prototype.has = function (id) {
	        return this._idToShortId.has(id);
	    };
	    /**
	     * Returns the stored fields (as configured in the `storeFields` constructor
	     * option) for the given document ID. Returns `undefined` if the document is
	     * not present in the index.
	     *
	     * @param id  The document ID
	     */
	    MiniSearch.prototype.getStoredFields = function (id) {
	        var shortId = this._idToShortId.get(id);
	        if (shortId == null) {
	            return undefined;
	        }
	        return this._storedFields.get(shortId);
	    };
	    /**
	     * Search for documents matching the given search query.
	     *
	     * The result is a list of scored document IDs matching the query, sorted by
	     * descending score, and each including data about which terms were matched and
	     * in which fields.
	     *
	     * ### Basic usage:
	     *
	     * ```javascript
	     * // Search for "zen art motorcycle" with default options: terms have to match
	     * // exactly, and individual terms are joined with OR
	     * miniSearch.search('zen art motorcycle')
	     * // => [ { id: 2, score: 2.77258, match: { ... } }, { id: 4, score: 1.38629, match: { ... } } ]
	     * ```
	     *
	     * ### Restrict search to specific fields:
	     *
	     * ```javascript
	     * // Search only in the 'title' field
	     * miniSearch.search('zen', { fields: ['title'] })
	     * ```
	     *
	     * ### Field boosting:
	     *
	     * ```javascript
	     * // Boost a field
	     * miniSearch.search('zen', { boost: { title: 2 } })
	     * ```
	     *
	     * ### Prefix search:
	     *
	     * ```javascript
	     * // Search for "moto" with prefix search (it will match documents
	     * // containing terms that start with "moto" or "neuro")
	     * miniSearch.search('moto neuro', { prefix: true })
	     * ```
	     *
	     * ### Fuzzy search:
	     *
	     * ```javascript
	     * // Search for "ismael" with fuzzy search (it will match documents containing
	     * // terms similar to "ismael", with a maximum edit distance of 0.2 term.length
	     * // (rounded to nearest integer)
	     * miniSearch.search('ismael', { fuzzy: 0.2 })
	     * ```
	     *
	     * ### Combining strategies:
	     *
	     * ```javascript
	     * // Mix of exact match, prefix search, and fuzzy search
	     * miniSearch.search('ismael mob', {
	     *  prefix: true,
	     *  fuzzy: 0.2
	     * })
	     * ```
	     *
	     * ### Advanced prefix and fuzzy search:
	     *
	     * ```javascript
	     * // Perform fuzzy and prefix search depending on the search term. Here
	     * // performing prefix and fuzzy search only on terms longer than 3 characters
	     * miniSearch.search('ismael mob', {
	     *  prefix: term => term.length > 3
	     *  fuzzy: term => term.length > 3 ? 0.2 : null
	     * })
	     * ```
	     *
	     * ### Combine with AND:
	     *
	     * ```javascript
	     * // Combine search terms with AND (to match only documents that contain both
	     * // "motorcycle" and "art")
	     * miniSearch.search('motorcycle art', { combineWith: 'AND' })
	     * ```
	     *
	     * ### Combine with AND_NOT:
	     *
	     * There is also an AND_NOT combinator, that finds documents that match the
	     * first term, but do not match any of the other terms. This combinator is
	     * rarely useful with simple queries, and is meant to be used with advanced
	     * query combinations (see later for more details).
	     *
	     * ### Filtering results:
	     *
	     * ```javascript
	     * // Filter only results in the 'fiction' category (assuming that 'category'
	     * // is a stored field)
	     * miniSearch.search('motorcycle art', {
	     *   filter: (result) => result.category === 'fiction'
	     * })
	     * ```
	     *
	     * ### Wildcard query
	     *
	     * Searching for an empty string (assuming the default tokenizer) returns no
	     * results. Sometimes though, one needs to match all documents, like in a
	     * "wildcard" search. This is possible by passing the special value
	     * {@link MiniSearch.wildcard} as the query:
	     *
	     * ```javascript
	     * // Return search results for all documents
	     * miniSearch.search(MiniSearch.wildcard)
	     * ```
	     *
	     * Note that search options such as `filter` and `boostDocument` are still
	     * applied, influencing which results are returned, and their order:
	     *
	     * ```javascript
	     * // Return search results for all documents in the 'fiction' category
	     * miniSearch.search(MiniSearch.wildcard, {
	     *   filter: (result) => result.category === 'fiction'
	     * })
	     * ```
	     *
	     * ### Advanced combination of queries:
	     *
	     * It is possible to combine different subqueries with OR, AND, and AND_NOT,
	     * and even with different search options, by passing a query expression
	     * tree object as the first argument, instead of a string.
	     *
	     * ```javascript
	     * // Search for documents that contain "zen" and ("motorcycle" or "archery")
	     * miniSearch.search({
	     *   combineWith: 'AND',
	     *   queries: [
	     *     'zen',
	     *     {
	     *       combineWith: 'OR',
	     *       queries: ['motorcycle', 'archery']
	     *     }
	     *   ]
	     * })
	     *
	     * // Search for documents that contain ("apple" or "pear") but not "juice" and
	     * // not "tree"
	     * miniSearch.search({
	     *   combineWith: 'AND_NOT',
	     *   queries: [
	     *     {
	     *       combineWith: 'OR',
	     *       queries: ['apple', 'pear']
	     *     },
	     *     'juice',
	     *     'tree'
	     *   ]
	     * })
	     * ```
	     *
	     * Each node in the expression tree can be either a string, or an object that
	     * supports all {@link SearchOptions} fields, plus a `queries` array field for
	     * subqueries.
	     *
	     * Note that, while this can become complicated to do by hand for complex or
	     * deeply nested queries, it provides a formalized expression tree API for
	     * external libraries that implement a parser for custom query languages.
	     *
	     * @param query  Search query
	     * @param options  Search options. Each option, if not given, defaults to the corresponding value of `searchOptions` given to the constructor, or to the library default.
	     */
	    MiniSearch.prototype.search = function (query, searchOptions) {
	        var e_13, _a;
	        if (searchOptions === void 0) { searchOptions = {}; }
	        var rawResults = this.executeQuery(query, searchOptions);
	        var results = [];
	        try {
	            for (var rawResults_1 = __values(rawResults), rawResults_1_1 = rawResults_1.next(); !rawResults_1_1.done; rawResults_1_1 = rawResults_1.next()) {
	                var _b = __read(rawResults_1_1.value, 2), docId = _b[0], _c = _b[1], score = _c.score, terms = _c.terms, match = _c.match;
	                // terms are the matched query terms, which will be returned to the user
	                // as queryTerms. The quality is calculated based on them, as opposed to
	                // the matched terms in the document (which can be different due to
	                // prefix and fuzzy match)
	                var quality = terms.length || 1;
	                var result = {
	                    id: this._documentIds.get(docId),
	                    score: score * quality,
	                    terms: Object.keys(match),
	                    queryTerms: terms,
	                    match: match
	                };
	                Object.assign(result, this._storedFields.get(docId));
	                if (searchOptions.filter == null || searchOptions.filter(result)) {
	                    results.push(result);
	                }
	            }
	        }
	        catch (e_13_1) { e_13 = { error: e_13_1 }; }
	        finally {
	            try {
	                if (rawResults_1_1 && !rawResults_1_1.done && (_a = rawResults_1.return)) _a.call(rawResults_1);
	            }
	            finally { if (e_13) throw e_13.error; }
	        }
	        // If it's a wildcard query, and no document boost is applied, skip sorting
	        // the results, as all results have the same score of 1
	        if (query === MiniSearch.wildcard &&
	            searchOptions.boostDocument == null &&
	            this._options.searchOptions.boostDocument == null) {
	            return results;
	        }
	        results.sort(byScore);
	        return results;
	    };
	    /**
	     * Provide suggestions for the given search query
	     *
	     * The result is a list of suggested modified search queries, derived from the
	     * given search query, each with a relevance score, sorted by descending score.
	     *
	     * By default, it uses the same options used for search, except that by
	     * default it performs prefix search on the last term of the query, and
	     * combine terms with `'AND'` (requiring all query terms to match). Custom
	     * options can be passed as a second argument. Defaults can be changed upon
	     * calling the {@link MiniSearch} constructor, by passing a
	     * `autoSuggestOptions` option.
	     *
	     * ### Basic usage:
	     *
	     * ```javascript
	     * // Get suggestions for 'neuro':
	     * miniSearch.autoSuggest('neuro')
	     * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 0.46240 } ]
	     * ```
	     *
	     * ### Multiple words:
	     *
	     * ```javascript
	     * // Get suggestions for 'zen ar':
	     * miniSearch.autoSuggest('zen ar')
	     * // => [
	     * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },
	     * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }
	     * // ]
	     * ```
	     *
	     * ### Fuzzy suggestions:
	     *
	     * ```javascript
	     * // Correct spelling mistakes using fuzzy search:
	     * miniSearch.autoSuggest('neromancer', { fuzzy: 0.2 })
	     * // => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]
	     * ```
	     *
	     * ### Filtering:
	     *
	     * ```javascript
	     * // Get suggestions for 'zen ar', but only within the 'fiction' category
	     * // (assuming that 'category' is a stored field):
	     * miniSearch.autoSuggest('zen ar', {
	     *   filter: (result) => result.category === 'fiction'
	     * })
	     * // => [
	     * //  { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },
	     * //  { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 }
	     * // ]
	     * ```
	     *
	     * @param queryString  Query string to be expanded into suggestions
	     * @param options  Search options. The supported options and default values
	     * are the same as for the {@link MiniSearch#search} method, except that by
	     * default prefix search is performed on the last term in the query, and terms
	     * are combined with `'AND'`.
	     * @return  A sorted array of suggestions sorted by relevance score.
	     */
	    MiniSearch.prototype.autoSuggest = function (queryString, options) {
	        var e_14, _a, e_15, _b;
	        if (options === void 0) { options = {}; }
	        options = __assign(__assign({}, this._options.autoSuggestOptions), options);
	        var suggestions = new Map();
	        try {
	            for (var _c = __values(this.search(queryString, options)), _d = _c.next(); !_d.done; _d = _c.next()) {
	                var _e = _d.value, score = _e.score, terms = _e.terms;
	                var phrase = terms.join(' ');
	                var suggestion = suggestions.get(phrase);
	                if (suggestion != null) {
	                    suggestion.score += score;
	                    suggestion.count += 1;
	                }
	                else {
	                    suggestions.set(phrase, { score: score, terms: terms, count: 1 });
	                }
	            }
	        }
	        catch (e_14_1) { e_14 = { error: e_14_1 }; }
	        finally {
	            try {
	                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	            }
	            finally { if (e_14) throw e_14.error; }
	        }
	        var results = [];
	        try {
	            for (var suggestions_1 = __values(suggestions), suggestions_1_1 = suggestions_1.next(); !suggestions_1_1.done; suggestions_1_1 = suggestions_1.next()) {
	                var _f = __read(suggestions_1_1.value, 2), suggestion = _f[0], _g = _f[1], score = _g.score, terms = _g.terms, count = _g.count;
	                results.push({ suggestion: suggestion, terms: terms, score: score / count });
	            }
	        }
	        catch (e_15_1) { e_15 = { error: e_15_1 }; }
	        finally {
	            try {
	                if (suggestions_1_1 && !suggestions_1_1.done && (_b = suggestions_1.return)) _b.call(suggestions_1);
	            }
	            finally { if (e_15) throw e_15.error; }
	        }
	        results.sort(byScore);
	        return results;
	    };
	    Object.defineProperty(MiniSearch.prototype, "documentCount", {
	        /**
	         * Total number of documents available to search
	         */
	        get: function () {
	            return this._documentCount;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(MiniSearch.prototype, "termCount", {
	        /**
	         * Number of terms in the index
	         */
	        get: function () {
	            return this._index.size;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * Deserializes a JSON index (serialized with `JSON.stringify(miniSearch)`)
	     * and instantiates a MiniSearch instance. It should be given the same options
	     * originally used when serializing the index.
	     *
	     * ### Usage:
	     *
	     * ```javascript
	     * // If the index was serialized with:
	     * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })
	     * miniSearch.addAll(documents)
	     *
	     * const json = JSON.stringify(miniSearch)
	     * // It can later be deserialized like this:
	     * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })
	     * ```
	     *
	     * @param json  JSON-serialized index
	     * @param options  configuration options, same as the constructor
	     * @return An instance of MiniSearch deserialized from the given JSON.
	     */
	    MiniSearch.loadJSON = function (json, options) {
	        if (options == null) {
	            throw new Error('MiniSearch: loadJSON should be given the same options used when serializing the index');
	        }
	        return this.loadJS(JSON.parse(json), options);
	    };
	    /**
	     * Returns the default value of an option. It will throw an error if no option
	     * with the given name exists.
	     *
	     * @param optionName  Name of the option
	     * @return The default value of the given option
	     *
	     * ### Usage:
	     *
	     * ```javascript
	     * // Get default tokenizer
	     * MiniSearch.getDefault('tokenize')
	     *
	     * // Get default term processor
	     * MiniSearch.getDefault('processTerm')
	     *
	     * // Unknown options will throw an error
	     * MiniSearch.getDefault('notExisting')
	     * // => throws 'MiniSearch: unknown option "notExisting"'
	     * ```
	     */
	    MiniSearch.getDefault = function (optionName) {
	        if (defaultOptions.hasOwnProperty(optionName)) {
	            return getOwnProperty(defaultOptions, optionName);
	        }
	        else {
	            throw new Error("MiniSearch: unknown option \"".concat(optionName, "\""));
	        }
	    };
	    /**
	     * @ignore
	     */
	    MiniSearch.loadJS = function (js, options) {
	        var e_16, _a, e_17, _b, e_18, _c;
	        var index = js.index, documentCount = js.documentCount, nextId = js.nextId, documentIds = js.documentIds, fieldIds = js.fieldIds, fieldLength = js.fieldLength, averageFieldLength = js.averageFieldLength, storedFields = js.storedFields, dirtCount = js.dirtCount, serializationVersion = js.serializationVersion;
	        if (serializationVersion !== 1 && serializationVersion !== 2) {
	            throw new Error('MiniSearch: cannot deserialize an index created with an incompatible version');
	        }
	        var miniSearch = new MiniSearch(options);
	        miniSearch._documentCount = documentCount;
	        miniSearch._nextId = nextId;
	        miniSearch._documentIds = objectToNumericMap(documentIds);
	        miniSearch._idToShortId = new Map();
	        miniSearch._fieldIds = fieldIds;
	        miniSearch._fieldLength = objectToNumericMap(fieldLength);
	        miniSearch._avgFieldLength = averageFieldLength;
	        miniSearch._storedFields = objectToNumericMap(storedFields);
	        miniSearch._dirtCount = dirtCount || 0;
	        miniSearch._index = new SearchableMap();
	        try {
	            for (var _d = __values(miniSearch._documentIds), _e = _d.next(); !_e.done; _e = _d.next()) {
	                var _f = __read(_e.value, 2), shortId = _f[0], id = _f[1];
	                miniSearch._idToShortId.set(id, shortId);
	            }
	        }
	        catch (e_16_1) { e_16 = { error: e_16_1 }; }
	        finally {
	            try {
	                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
	            }
	            finally { if (e_16) throw e_16.error; }
	        }
	        try {
	            for (var index_1 = __values(index), index_1_1 = index_1.next(); !index_1_1.done; index_1_1 = index_1.next()) {
	                var _g = __read(index_1_1.value, 2), term = _g[0], data = _g[1];
	                var dataMap = new Map();
	                try {
	                    for (var _h = (e_18 = void 0, __values(Object.keys(data))), _j = _h.next(); !_j.done; _j = _h.next()) {
	                        var fieldId = _j.value;
	                        var indexEntry = data[fieldId];
	                        // Version 1 used to nest the index entry inside a field called ds
	                        if (serializationVersion === 1) {
	                            indexEntry = indexEntry.ds;
	                        }
	                        dataMap.set(parseInt(fieldId, 10), objectToNumericMap(indexEntry));
	                    }
	                }
	                catch (e_18_1) { e_18 = { error: e_18_1 }; }
	                finally {
	                    try {
	                        if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
	                    }
	                    finally { if (e_18) throw e_18.error; }
	                }
	                miniSearch._index.set(term, dataMap);
	            }
	        }
	        catch (e_17_1) { e_17 = { error: e_17_1 }; }
	        finally {
	            try {
	                if (index_1_1 && !index_1_1.done && (_b = index_1.return)) _b.call(index_1);
	            }
	            finally { if (e_17) throw e_17.error; }
	        }
	        return miniSearch;
	    };
	    /**
	     * @ignore
	     */
	    MiniSearch.prototype.executeQuery = function (query, searchOptions) {
	        var _this = this;
	        if (searchOptions === void 0) { searchOptions = {}; }
	        if (query === MiniSearch.wildcard) {
	            return this.executeWildcardQuery(searchOptions);
	        }
	        if (typeof query !== 'string') {
	            var options_1 = __assign(__assign(__assign({}, searchOptions), query), { queries: undefined });
	            var results_1 = query.queries.map(function (subquery) { return _this.executeQuery(subquery, options_1); });
	            return this.combineResults(results_1, options_1.combineWith);
	        }
	        var _a = this._options, tokenize = _a.tokenize, processTerm = _a.processTerm, globalSearchOptions = _a.searchOptions;
	        var options = __assign(__assign({ tokenize: tokenize, processTerm: processTerm }, globalSearchOptions), searchOptions);
	        var searchTokenize = options.tokenize, searchProcessTerm = options.processTerm;
	        var terms = searchTokenize(query)
	            .flatMap(function (term) { return searchProcessTerm(term); })
	            .filter(function (term) { return !!term; });
	        var queries = terms.map(termToQuerySpec(options));
	        var results = queries.map(function (query) { return _this.executeQuerySpec(query, options); });
	        return this.combineResults(results, options.combineWith);
	    };
	    /**
	     * @ignore
	     */
	    MiniSearch.prototype.executeQuerySpec = function (query, searchOptions) {
	        var e_19, _a, e_20, _b;
	        var options = __assign(__assign({}, this._options.searchOptions), searchOptions);
	        var boosts = (options.fields || this._options.fields).reduce(function (boosts, field) {
	            var _a;
	            return (__assign(__assign({}, boosts), (_a = {}, _a[field] = getOwnProperty(options.boost, field) || 1, _a)));
	        }, {});
	        var boostDocument = options.boostDocument, weights = options.weights, maxFuzzy = options.maxFuzzy, bm25params = options.bm25;
	        var _c = __assign(__assign({}, defaultSearchOptions.weights), weights), fuzzyWeight = _c.fuzzy, prefixWeight = _c.prefix;
	        var data = this._index.get(query.term);
	        var results = this.termResults(query.term, query.term, 1, data, boosts, boostDocument, bm25params);
	        var prefixMatches;
	        var fuzzyMatches;
	        if (query.prefix) {
	            prefixMatches = this._index.atPrefix(query.term);
	        }
	        if (query.fuzzy) {
	            var fuzzy = (query.fuzzy === true) ? 0.2 : query.fuzzy;
	            var maxDistance = fuzzy < 1 ? Math.min(maxFuzzy, Math.round(query.term.length * fuzzy)) : fuzzy;
	            if (maxDistance)
	                fuzzyMatches = this._index.fuzzyGet(query.term, maxDistance);
	        }
	        if (prefixMatches) {
	            try {
	                for (var prefixMatches_1 = __values(prefixMatches), prefixMatches_1_1 = prefixMatches_1.next(); !prefixMatches_1_1.done; prefixMatches_1_1 = prefixMatches_1.next()) {
	                    var _d = __read(prefixMatches_1_1.value, 2), term = _d[0], data_1 = _d[1];
	                    var distance = term.length - query.term.length;
	                    if (!distance) {
	                        continue;
	                    } // Skip exact match.
	                    // Delete the term from fuzzy results (if present) if it is also a
	                    // prefix result. This entry will always be scored as a prefix result.
	                    fuzzyMatches === null || fuzzyMatches === void 0 ? void 0 : fuzzyMatches.delete(term);
	                    // Weight gradually approaches 0 as distance goes to infinity, with the
	                    // weight for the hypothetical distance 0 being equal to prefixWeight.
	                    // The rate of change is much lower than that of fuzzy matches to
	                    // account for the fact that prefix matches stay more relevant than
	                    // fuzzy matches for longer distances.
	                    var weight = prefixWeight * term.length / (term.length + 0.3 * distance);
	                    this.termResults(query.term, term, weight, data_1, boosts, boostDocument, bm25params, results);
	                }
	            }
	            catch (e_19_1) { e_19 = { error: e_19_1 }; }
	            finally {
	                try {
	                    if (prefixMatches_1_1 && !prefixMatches_1_1.done && (_a = prefixMatches_1.return)) _a.call(prefixMatches_1);
	                }
	                finally { if (e_19) throw e_19.error; }
	            }
	        }
	        if (fuzzyMatches) {
	            try {
	                for (var _e = __values(fuzzyMatches.keys()), _f = _e.next(); !_f.done; _f = _e.next()) {
	                    var term = _f.value;
	                    var _g = __read(fuzzyMatches.get(term), 2), data_2 = _g[0], distance = _g[1];
	                    if (!distance) {
	                        continue;
	                    } // Skip exact match.
	                    // Weight gradually approaches 0 as distance goes to infinity, with the
	                    // weight for the hypothetical distance 0 being equal to fuzzyWeight.
	                    var weight = fuzzyWeight * term.length / (term.length + distance);
	                    this.termResults(query.term, term, weight, data_2, boosts, boostDocument, bm25params, results);
	                }
	            }
	            catch (e_20_1) { e_20 = { error: e_20_1 }; }
	            finally {
	                try {
	                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
	                }
	                finally { if (e_20) throw e_20.error; }
	            }
	        }
	        return results;
	    };
	    /**
	     * @ignore
	     */
	    MiniSearch.prototype.executeWildcardQuery = function (searchOptions) {
	        var e_21, _a;
	        var results = new Map();
	        var options = __assign(__assign({}, this._options.searchOptions), searchOptions);
	        try {
	            for (var _b = __values(this._documentIds), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var _d = __read(_c.value, 2), shortId = _d[0], id = _d[1];
	                var score = options.boostDocument ? options.boostDocument(id, '', this._storedFields.get(shortId)) : 1;
	                results.set(shortId, {
	                    score: score,
	                    terms: [],
	                    match: {}
	                });
	            }
	        }
	        catch (e_21_1) { e_21 = { error: e_21_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_21) throw e_21.error; }
	        }
	        return results;
	    };
	    /**
	     * @ignore
	     */
	    MiniSearch.prototype.combineResults = function (results, combineWith) {
	        if (combineWith === void 0) { combineWith = OR; }
	        if (results.length === 0) {
	            return new Map();
	        }
	        var operator = combineWith.toLowerCase();
	        return results.reduce(combinators[operator]) || new Map();
	    };
	    /**
	     * Allows serialization of the index to JSON, to possibly store it and later
	     * deserialize it with {@link MiniSearch.loadJSON}.
	     *
	     * Normally one does not directly call this method, but rather call the
	     * standard JavaScript `JSON.stringify()` passing the {@link MiniSearch}
	     * instance, and JavaScript will internally call this method. Upon
	     * deserialization, one must pass to {@link MiniSearch.loadJSON} the same
	     * options used to create the original instance that was serialized.
	     *
	     * ### Usage:
	     *
	     * ```javascript
	     * // Serialize the index:
	     * let miniSearch = new MiniSearch({ fields: ['title', 'text'] })
	     * miniSearch.addAll(documents)
	     * const json = JSON.stringify(miniSearch)
	     *
	     * // Later, to deserialize it:
	     * miniSearch = MiniSearch.loadJSON(json, { fields: ['title', 'text'] })
	     * ```
	     *
	     * @return A plain-object serializable representation of the search index.
	     */
	    MiniSearch.prototype.toJSON = function () {
	        var e_22, _a, e_23, _b;
	        var index = [];
	        try {
	            for (var _c = __values(this._index), _d = _c.next(); !_d.done; _d = _c.next()) {
	                var _e = __read(_d.value, 2), term = _e[0], fieldIndex = _e[1];
	                var data = {};
	                try {
	                    for (var fieldIndex_2 = (e_23 = void 0, __values(fieldIndex)), fieldIndex_2_1 = fieldIndex_2.next(); !fieldIndex_2_1.done; fieldIndex_2_1 = fieldIndex_2.next()) {
	                        var _f = __read(fieldIndex_2_1.value, 2), fieldId = _f[0], freqs = _f[1];
	                        data[fieldId] = Object.fromEntries(freqs);
	                    }
	                }
	                catch (e_23_1) { e_23 = { error: e_23_1 }; }
	                finally {
	                    try {
	                        if (fieldIndex_2_1 && !fieldIndex_2_1.done && (_b = fieldIndex_2.return)) _b.call(fieldIndex_2);
	                    }
	                    finally { if (e_23) throw e_23.error; }
	                }
	                index.push([term, data]);
	            }
	        }
	        catch (e_22_1) { e_22 = { error: e_22_1 }; }
	        finally {
	            try {
	                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	            }
	            finally { if (e_22) throw e_22.error; }
	        }
	        return {
	            documentCount: this._documentCount,
	            nextId: this._nextId,
	            documentIds: Object.fromEntries(this._documentIds),
	            fieldIds: this._fieldIds,
	            fieldLength: Object.fromEntries(this._fieldLength),
	            averageFieldLength: this._avgFieldLength,
	            storedFields: Object.fromEntries(this._storedFields),
	            dirtCount: this._dirtCount,
	            index: index,
	            serializationVersion: 2
	        };
	    };
	    /**
	     * @ignore
	     */
	    MiniSearch.prototype.termResults = function (sourceTerm, derivedTerm, termWeight, fieldTermData, fieldBoosts, boostDocumentFn, bm25params, results) {
	        var e_24, _a, e_25, _b, _c;
	        if (results === void 0) { results = new Map(); }
	        if (fieldTermData == null)
	            return results;
	        try {
	            for (var _d = __values(Object.keys(fieldBoosts)), _e = _d.next(); !_e.done; _e = _d.next()) {
	                var field = _e.value;
	                var fieldBoost = fieldBoosts[field];
	                var fieldId = this._fieldIds[field];
	                var fieldTermFreqs = fieldTermData.get(fieldId);
	                if (fieldTermFreqs == null)
	                    continue;
	                var matchingFields = fieldTermFreqs.size;
	                var avgFieldLength = this._avgFieldLength[fieldId];
	                try {
	                    for (var _f = (e_25 = void 0, __values(fieldTermFreqs.keys())), _g = _f.next(); !_g.done; _g = _f.next()) {
	                        var docId = _g.value;
	                        if (!this._documentIds.has(docId)) {
	                            this.removeTerm(fieldId, docId, derivedTerm);
	                            matchingFields -= 1;
	                            continue;
	                        }
	                        var docBoost = boostDocumentFn ? boostDocumentFn(this._documentIds.get(docId), derivedTerm, this._storedFields.get(docId)) : 1;
	                        if (!docBoost)
	                            continue;
	                        var termFreq = fieldTermFreqs.get(docId);
	                        var fieldLength = this._fieldLength.get(docId)[fieldId];
	                        // NOTE: The total number of fields is set to the number of documents
	                        // `this._documentCount`. It could also make sense to use the number of
	                        // documents where the current field is non-blank as a normalization
	                        // factor. This will make a difference in scoring if the field is rarely
	                        // present. This is currently not supported, and may require further
	                        // analysis to see if it is a valid use case.
	                        var rawScore = calcBM25Score(termFreq, matchingFields, this._documentCount, fieldLength, avgFieldLength, bm25params);
	                        var weightedScore = termWeight * fieldBoost * docBoost * rawScore;
	                        var result = results.get(docId);
	                        if (result) {
	                            result.score += weightedScore;
	                            assignUniqueTerm(result.terms, sourceTerm);
	                            var match = getOwnProperty(result.match, derivedTerm);
	                            if (match) {
	                                match.push(field);
	                            }
	                            else {
	                                result.match[derivedTerm] = [field];
	                            }
	                        }
	                        else {
	                            results.set(docId, {
	                                score: weightedScore,
	                                terms: [sourceTerm],
	                                match: (_c = {}, _c[derivedTerm] = [field], _c)
	                            });
	                        }
	                    }
	                }
	                catch (e_25_1) { e_25 = { error: e_25_1 }; }
	                finally {
	                    try {
	                        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
	                    }
	                    finally { if (e_25) throw e_25.error; }
	                }
	            }
	        }
	        catch (e_24_1) { e_24 = { error: e_24_1 }; }
	        finally {
	            try {
	                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
	            }
	            finally { if (e_24) throw e_24.error; }
	        }
	        return results;
	    };
	    /**
	     * @ignore
	     */
	    MiniSearch.prototype.addTerm = function (fieldId, documentId, term) {
	        var indexData = this._index.fetch(term, createMap);
	        var fieldIndex = indexData.get(fieldId);
	        if (fieldIndex == null) {
	            fieldIndex = new Map();
	            fieldIndex.set(documentId, 1);
	            indexData.set(fieldId, fieldIndex);
	        }
	        else {
	            var docs = fieldIndex.get(documentId);
	            fieldIndex.set(documentId, (docs || 0) + 1);
	        }
	    };
	    /**
	     * @ignore
	     */
	    MiniSearch.prototype.removeTerm = function (fieldId, documentId, term) {
	        if (!this._index.has(term)) {
	            this.warnDocumentChanged(documentId, fieldId, term);
	            return;
	        }
	        var indexData = this._index.fetch(term, createMap);
	        var fieldIndex = indexData.get(fieldId);
	        if (fieldIndex == null || fieldIndex.get(documentId) == null) {
	            this.warnDocumentChanged(documentId, fieldId, term);
	        }
	        else if (fieldIndex.get(documentId) <= 1) {
	            if (fieldIndex.size <= 1) {
	                indexData.delete(fieldId);
	            }
	            else {
	                fieldIndex.delete(documentId);
	            }
	        }
	        else {
	            fieldIndex.set(documentId, fieldIndex.get(documentId) - 1);
	        }
	        if (this._index.get(term).size === 0) {
	            this._index.delete(term);
	        }
	    };
	    /**
	     * @ignore
	     */
	    MiniSearch.prototype.warnDocumentChanged = function (shortDocumentId, fieldId, term) {
	        var e_26, _a;
	        try {
	            for (var _b = __values(Object.keys(this._fieldIds)), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var fieldName = _c.value;
	                if (this._fieldIds[fieldName] === fieldId) {
	                    this._options.logger('warn', "MiniSearch: document with ID ".concat(this._documentIds.get(shortDocumentId), " has changed before removal: term \"").concat(term, "\" was not present in field \"").concat(fieldName, "\". Removing a document after it has changed can corrupt the index!"), 'version_conflict');
	                    return;
	                }
	            }
	        }
	        catch (e_26_1) { e_26 = { error: e_26_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_26) throw e_26.error; }
	        }
	    };
	    /**
	     * @ignore
	     */
	    MiniSearch.prototype.addDocumentId = function (documentId) {
	        var shortDocumentId = this._nextId;
	        this._idToShortId.set(documentId, shortDocumentId);
	        this._documentIds.set(shortDocumentId, documentId);
	        this._documentCount += 1;
	        this._nextId += 1;
	        return shortDocumentId;
	    };
	    /**
	     * @ignore
	     */
	    MiniSearch.prototype.addFields = function (fields) {
	        for (var i = 0; i < fields.length; i++) {
	            this._fieldIds[fields[i]] = i;
	        }
	    };
	    /**
	     * @ignore
	     */
	    MiniSearch.prototype.addFieldLength = function (documentId, fieldId, count, length) {
	        var fieldLengths = this._fieldLength.get(documentId);
	        if (fieldLengths == null)
	            this._fieldLength.set(documentId, fieldLengths = []);
	        fieldLengths[fieldId] = length;
	        var averageFieldLength = this._avgFieldLength[fieldId] || 0;
	        var totalFieldLength = (averageFieldLength * count) + length;
	        this._avgFieldLength[fieldId] = totalFieldLength / (count + 1);
	    };
	    /**
	     * @ignore
	     */
	    MiniSearch.prototype.removeFieldLength = function (documentId, fieldId, count, length) {
	        if (count === 1) {
	            this._avgFieldLength[fieldId] = 0;
	            return;
	        }
	        var totalFieldLength = (this._avgFieldLength[fieldId] * count) - length;
	        this._avgFieldLength[fieldId] = totalFieldLength / (count - 1);
	    };
	    /**
	     * @ignore
	     */
	    MiniSearch.prototype.saveStoredFields = function (documentId, doc) {
	        var e_27, _a;
	        var _b = this._options, storeFields = _b.storeFields, extractField = _b.extractField;
	        if (storeFields == null || storeFields.length === 0) {
	            return;
	        }
	        var documentFields = this._storedFields.get(documentId);
	        if (documentFields == null)
	            this._storedFields.set(documentId, documentFields = {});
	        try {
	            for (var storeFields_1 = __values(storeFields), storeFields_1_1 = storeFields_1.next(); !storeFields_1_1.done; storeFields_1_1 = storeFields_1.next()) {
	                var fieldName = storeFields_1_1.value;
	                var fieldValue = extractField(doc, fieldName);
	                if (fieldValue !== undefined)
	                    documentFields[fieldName] = fieldValue;
	            }
	        }
	        catch (e_27_1) { e_27 = { error: e_27_1 }; }
	        finally {
	            try {
	                if (storeFields_1_1 && !storeFields_1_1.done && (_a = storeFields_1.return)) _a.call(storeFields_1);
	            }
	            finally { if (e_27) throw e_27.error; }
	        }
	    };
	    /**
	     * The special wildcard symbol that can be passed to {@link MiniSearch#search}
	     * to match all documents
	     */
	    MiniSearch.wildcard = Symbol('*');
	    return MiniSearch;
	}());
	var getOwnProperty = function (object, property) {
	    return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined;
	};
	var combinators = (_a = {},
	    _a[OR] = function (a, b) {
	        var e_28, _a;
	        try {
	            for (var _b = __values(b.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var docId = _c.value;
	                var existing = a.get(docId);
	                if (existing == null) {
	                    a.set(docId, b.get(docId));
	                }
	                else {
	                    var _d = b.get(docId), score = _d.score, terms = _d.terms, match = _d.match;
	                    existing.score = existing.score + score;
	                    existing.match = Object.assign(existing.match, match);
	                    assignUniqueTerms(existing.terms, terms);
	                }
	            }
	        }
	        catch (e_28_1) { e_28 = { error: e_28_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_28) throw e_28.error; }
	        }
	        return a;
	    },
	    _a[AND] = function (a, b) {
	        var e_29, _a;
	        var combined = new Map();
	        try {
	            for (var _b = __values(b.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var docId = _c.value;
	                var existing = a.get(docId);
	                if (existing == null)
	                    continue;
	                var _d = b.get(docId), score = _d.score, terms = _d.terms, match = _d.match;
	                assignUniqueTerms(existing.terms, terms);
	                combined.set(docId, {
	                    score: existing.score + score,
	                    terms: existing.terms,
	                    match: Object.assign(existing.match, match)
	                });
	            }
	        }
	        catch (e_29_1) { e_29 = { error: e_29_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_29) throw e_29.error; }
	        }
	        return combined;
	    },
	    _a[AND_NOT] = function (a, b) {
	        var e_30, _a;
	        try {
	            for (var _b = __values(b.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var docId = _c.value;
	                a.delete(docId);
	            }
	        }
	        catch (e_30_1) { e_30 = { error: e_30_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_30) throw e_30.error; }
	        }
	        return a;
	    },
	    _a);
	var defaultBM25params = { k: 1.2, b: 0.7, d: 0.5 };
	var calcBM25Score = function (termFreq, matchingCount, totalCount, fieldLength, avgFieldLength, bm25params) {
	    var k = bm25params.k, b = bm25params.b, d = bm25params.d;
	    var invDocFreq = Math.log(1 + (totalCount - matchingCount + 0.5) / (matchingCount + 0.5));
	    return invDocFreq * (d + termFreq * (k + 1) / (termFreq + k * (1 - b + b * fieldLength / avgFieldLength)));
	};
	var termToQuerySpec = function (options) { return function (term, i, terms) {
	    var fuzzy = (typeof options.fuzzy === 'function')
	        ? options.fuzzy(term, i, terms)
	        : (options.fuzzy || false);
	    var prefix = (typeof options.prefix === 'function')
	        ? options.prefix(term, i, terms)
	        : (options.prefix === true);
	    return { term: term, fuzzy: fuzzy, prefix: prefix };
	}; };
	var defaultOptions = {
	    idField: 'id',
	    extractField: function (document, fieldName) { return document[fieldName]; },
	    tokenize: function (text) { return text.split(SPACE_OR_PUNCTUATION); },
	    processTerm: function (term) { return term.toLowerCase(); },
	    fields: undefined,
	    searchOptions: undefined,
	    storeFields: [],
	    logger: function (level, message) {
	        if (typeof (console === null || console === void 0 ? void 0 : console[level]) === 'function')
	            console[level](message);
	    },
	    autoVacuum: true
	};
	var defaultSearchOptions = {
	    combineWith: OR,
	    prefix: false,
	    fuzzy: false,
	    maxFuzzy: 6,
	    boost: {},
	    weights: { fuzzy: 0.45, prefix: 0.375 },
	    bm25: defaultBM25params
	};
	var defaultAutoSuggestOptions = {
	    combineWith: AND,
	    prefix: function (term, i, terms) {
	        return i === terms.length - 1;
	    }
	};
	var defaultVacuumOptions = { batchSize: 1000, batchWait: 10 };
	var defaultVacuumConditions = { minDirtFactor: 0.1, minDirtCount: 20 };
	var defaultAutoVacuumOptions = __assign(__assign({}, defaultVacuumOptions), defaultVacuumConditions);
	var assignUniqueTerm = function (target, term) {
	    // Avoid adding duplicate terms.
	    if (!target.includes(term))
	        target.push(term);
	};
	var assignUniqueTerms = function (target, source) {
	    var e_31, _a;
	    try {
	        for (var source_1 = __values(source), source_1_1 = source_1.next(); !source_1_1.done; source_1_1 = source_1.next()) {
	            var term = source_1_1.value;
	            // Avoid adding duplicate terms.
	            if (!target.includes(term))
	                target.push(term);
	        }
	    }
	    catch (e_31_1) { e_31 = { error: e_31_1 }; }
	    finally {
	        try {
	            if (source_1_1 && !source_1_1.done && (_a = source_1.return)) _a.call(source_1);
	        }
	        finally { if (e_31) throw e_31.error; }
	    }
	};
	var byScore = function (_a, _b) {
	    var a = _a.score;
	    var b = _b.score;
	    return b - a;
	};
	var createMap = function () { return new Map(); };
	var objectToNumericMap = function (object) {
	    var e_32, _a;
	    var map = new Map();
	    try {
	        for (var _b = __values(Object.keys(object)), _c = _b.next(); !_c.done; _c = _b.next()) {
	            var key = _c.value;
	            map.set(parseInt(key, 10), object[key]);
	        }
	    }
	    catch (e_32_1) { e_32 = { error: e_32_1 }; }
	    finally {
	        try {
	            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	        }
	        finally { if (e_32) throw e_32.error; }
	    }
	    return map;
	};
	// This regular expression matches any Unicode space or punctuation character
	// Adapted from https://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5Cp%7BZ%7D%5Cp%7BP%7D&abb=on&c=on&esc=on
	var SPACE_OR_PUNCTUATION = /[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u;

	function _callSuper$o(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$o() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$o() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$o = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$o(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$o(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$o(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$o(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	BarreRecherche[FILENAME] = 'src/components/barreRecherche.svelte';
	var root_1$d = add_locations(from_html("<button class=\"reinitialiser-recherche utd-btn secondaire\" type=\"button\"><span aria-hidden=\"true\" class=\"utd-icone-svg x-fermer-bleu-moyen\"></span></button>"), BarreRecherche[FILENAME], [[507, 8, [[508, 12]]]]);
	var root_5$8 = add_locations(from_html("<li role=\"option\"><span class=\"message-precision-recherche\"><span aria-hidden=\"true\" class=\"utd-icone-svg information\"></span> <span> </span></span></li>"), BarreRecherche[FILENAME], [[520, 14, [[521, 16, [[522, 18], [523, 18]]]]]]);
	var root_6$3 = add_locations(from_html("<li role=\"option\"><a><span class=\"texte-option\"> </span></a></li>"), BarreRecherche[FILENAME], [[527, 14, [[528, 16, [[528, 72]]]]]]);
	var root_10$4 = add_locations(from_html("<li role=\"option\"><span class=\"message-precision-recherche\"><span aria-hidden=\"true\" class=\"utd-icone-svg information\"></span> <span> </span></span></li>"), BarreRecherche[FILENAME], [[538, 22, [[539, 24, [[540, 26], [541, 26]]]]]]);
	var root_11$3 = add_locations(from_html("<li role=\"option\"><a><span class=\"texte-option\"> </span></a></li>"), BarreRecherche[FILENAME], [[545, 22, [[546, 24, [[546, 78]]]]]]);
	var root_8$3 = add_locations(from_html("<li role=\"group\"><span class=\"titre-niveau1\"> </span> <ul role=\"none\"></ul></li>"), BarreRecherche[FILENAME], [[533, 14, [[534, 16], [535, 16]]]]);
	var root_15$1 = add_locations(from_html("<li role=\"option\"><span class=\"message-precision-recherche\"><span aria-hidden=\"true\" class=\"utd-icone-svg information\"></span> <span> </span></span></li>"), BarreRecherche[FILENAME], [[562, 26, [[563, 28, [[564, 30], [565, 30]]]]]]);
	var root_16$1 = add_locations(from_html("<li role=\"option\"><a><span class=\"texte-option\"> </span></a></li>"), BarreRecherche[FILENAME], [[569, 26, [[570, 28, [[570, 82]]]]]]);
	var root_13$1 = add_locations(from_html("<span class=\"titre-niveau2\"> </span> <ul role=\"group\"></ul>", 1), BarreRecherche[FILENAME], [[558, 22], [559, 22]]);
	var root_12$2 = add_locations(from_html("<li role=\"group\"><span class=\"titre-niveau1\"> </span> <ul role=\"none\"></ul></li>"), BarreRecherche[FILENAME], [[554, 16, [[555, 18], [556, 18]]]]);
	var root_2$a = add_locations(from_html("<ul role=\"listbox\"></ul>"), BarreRecherche[FILENAME], [[515, 6]]);
	var root_17$1 = add_locations(from_html("<span class=\"texte-aucun-resultat\" aria-hidden=\"true\"> </span>"), BarreRecherche[FILENAME], [[583, 6]]);
	var root$o = add_locations(from_html("<div class=\"utd-barre-recherche\"><div><input type=\"text\" autocomplete=\"off\" role=\"combobox\" aria-autocomplete=\"list\" class=\"utd-form-control xxl texte-recherche\"/> <!></div> <div><!></div> <span role=\"status\" class=\"utd-sr-only\" tabindex=\"-1\"> </span></div> <link rel=\"stylesheet\"/>", 1), BarreRecherche[FILENAME], [[503, 0, [[504, 2, [[505, 6]]], [513, 2], [586, 2]]], [592, 0]]);
	function BarreRecherche($$anchor, $$props) {
	  check_target(this instanceof BarreRecherche ? this.constructor : void 0);
	  push($$props, false);
	  var doitAfficherResultatsRecherche = mutable_source();
	  var nombreMaxResultats = mutable_source();
	  var estLangueFrancaise = Utils.estPageLangueFrancais();

	  /* Attributs publics */
	  var urlContenuRecherche = prop($$props, 'urlContenuRecherche', 12, '');
	  var placeholder = prop($$props, 'placeholder', 12, estLangueFrancaise ? "Rechercher..." : "Search...");
	  var nbMaxResultats = prop($$props, 'nbMaxResultats', 12, '10');

	  /* Attributs privÃ©s */
	  var focus = prop($$props, 'focus', 12, 'false');
	  var rechercheFloue = prop($$props, 'rechercheFloue', 12, 'true');
	  var precisionRecherche = prop($$props, 'precisionRecherche', 12, "0.2");
	  var contextePiv = prop($$props, 'contextePiv', 12, 'false');
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var ariaDescriptionRecherche = estLangueFrancaise ? "Saisir le terme recherchÃ©, puis utilisez les touches flÃ¨ches haut et bas pour naviguer dans la liste des rÃ©sultats, et ensuite EntrÃ©e ou Espace pour accÃ©der au rÃ©sultat dÃ©sirÃ©" : "Enter the search term, then use the up and down arrow keys to navigate the list of results, and then Enter or Space to access the desired result";
	  var srResultatsTrouves = estLangueFrancaise ? "{x} rÃ©sultats trouvÃ©s" : "{x} results found.";
	  var texteAucunResultat = estLangueFrancaise ? "Aucun rÃ©sultat trouvÃ©." : "No result found.";
	  var srAucunResultat = texteAucunResultat;
	  var titleBoutonReinitialiserRecherche = estLangueFrancaise ? "RÃ©initialiser la recherche" : "Reset search";
	  var textePrecisionRecherche = mutable_source();
	  "".concat(Utils.imagesFullPath, "utd-sprite.svg?v=3.5.0#");
	  var idControleRecherche = Utils.genererId();
	  var idControleResultats = Utils.genererId();
	  var nbCaracteresMinimalRecherche = 3;
	  var mounted = false;
	  var estCssCharge = false;
	  var nbNiveaux = mutable_source(1);
	  var idActiveDescendant = mutable_source(null);
	  var miniSearch;
	  var optionsMiniSearch;
	  var controleConteneurResultats;
	  var contenuRecherche = mutable_source(null);
	  var resultatsRecherche = mutable_source(null);
	  var resultatsRechercheFlat = mutable_source(null);
	  var texteRecherche = mutable_source("");
	  var texteNotificationLecteurEcran = mutable_source("");
	  var doitAfficherMessagePreciserRecherche = mutable_source(false);

	  /* ContrÃ´les */
	  var controleRecherche;
	  onMount(function () {
	    set(textePrecisionRecherche, estLangueFrancaise ? "Seuls les ".concat(nbMaxResultats(), " premiers r\xE9sultats sont affich\xE9s. Pr\xE9cisez votre recherche au besoin.") : "(en)Seuls les ".concat(nbMaxResultats(), " premiers r\xE9sultats sont affich\xE9s. Pr\xE9cisez votre recherche au besoin."));
	    controleRecherche = thisComponent().shadowRoot.getElementById(idControleRecherche);
	    optionsMiniSearch = {
	      fuzzy: strict_equals(rechercheFloue(), 'true') ? parseFloat(precisionRecherche()) : null,
	      prefix: true,
	      fields: ['c', 'sc', 't', 'mc'],
	      storeFields: ['id', 'c', 'sc', 'r', 't', 'h'],
	      stopWords: new Set([]),
	      combineWith: 'OR',
	      filter: null,
	      processTerm: function processTerm(term, _fieldName) {
	        return indexerTerme(term);
	      }
	    };
	    controleConteneurResultats = thisComponent().shadowRoot.querySelector('.resultats-recherche');
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    mounted = true;
	  });

	  /* ============== Watches ============== */
	  // Watch sur la prop focus
	  function toggleFocus() {
	    if (strict_equals(focus(), 'true')) {
	      controleRecherche.focus();
	      thisComponent().setAttribute('focus', 'false');
	    }
	  }
	  function majContenuRecherche() {
	    if (get(contenuRecherche) && get(contenuRecherche).length > 0) {
	      var contenuAvecId = get(contenuRecherche).map(function (c, i) {
	        c.id = Utils.genererId();
	        c.indexe = i;
	        return c;
	      });
	      miniSearch = new MiniSearch(optionsMiniSearch);
	      miniSearch.addAll(contenuAvecId);
	      set(nbNiveaux, obtenirNombreNiveaux(contenuAvecId));
	      rechercher();
	    }
	  }
	  function traiterSaisieRecherche() {
	    // EmpÃªche le traitement si simplement un focus ou un blur (l'Ã©vÃ©nement input est lancÃ© sur focus et blur)
	    if (strict_equals(get(texteRecherche), controleRecherche.value)) {
	      return;
	    }
	    set(texteRecherche, controleRecherche.value);
	    rechercherDebounced();
	  }
	  var rechercherDebounced = Utils.debounce(function () {
	    if (strict_equals(get(resultatsRecherche), null) && strict_equals(get(contenuRecherche), null)) {
	      initialiserRecherche();
	    } else {
	      rechercher();
	    }
	  }, 750);
	  function initialiserRecherche() {
	    // console.log('initialiserRecherche ' + urlContenuRecherche)
	    if (urlContenuRecherche()) {
	      obtenirContenuRechercheViaUrl().then(function (contenu) {
	        set(contenuRecherche, contenu);
	      });
	    } else {
	      Utils.dispatchWcEvent(thisComponent(), "initialiser", {
	        definirContenuRecherche: function definirContenuRecherche(donnees) {
	          set(contenuRecherche, donnees.contenu);
	        }
	      });
	    }
	  }
	  function obtenirContenuRechercheViaUrl() {
	    return fetch(urlContenuRecherche()).then(function (response) {
	      if (!response.ok) {
	        throw new Error("HTTP error " + response.status);
	      }
	      return response.json();
	    });
	  }
	  function obtenirNombreNiveaux(contenuRecherche) {
	    if (contenuRecherche && contenuRecherche.length > 0) {
	      if (contenuRecherche[0].sc && strict_equals(contenuRecherche[0].sc, '', false)) {
	        return 3;
	      } else if (contenuRecherche[0].c && strict_equals(contenuRecherche[0].c, '', false)) {
	        return 2;
	      } else {
	        return 1;
	      }
	    }
	  }
	  function rechercher(doitNotifierLecteurEcran) {
	    set(doitAfficherMessagePreciserRecherche, false);

	    //TODO retirer? si tjrs 3 caractÃ¨res minimal
	    var optionsRecherche = _objectSpread$o(_objectSpread$o({}, optionsMiniSearch), {
	      fuzzy: function fuzzy(term) {
	        return term.length > nbCaracteresMinimalRecherche ? optionsMiniSearch.fuzzy : null;
	      }
	    });
	    var texteRechercheSansEspace = get(texteRecherche).trim();
	    set(idActiveDescendant, null);
	    if (strict_equals(texteRechercheSansEspace, "", false) && texteRechercheSansEspace.length >= nbCaracteresMinimalRecherche) {
	      var retourMiniSearch = miniSearch.search(texteRechercheSansEspace, optionsRecherche);
	      if (retourMiniSearch.length > get(nombreMaxResultats)) {
	        retourMiniSearch.length = get(nombreMaxResultats);
	        set(doitAfficherMessagePreciserRecherche, true);
	      }
	      var resultats = obtenirResultatsGroupes(retourMiniSearch);
	      if (get(doitAfficherMessagePreciserRecherche)) {
	        ajouterMessagePrecisionRecherche(resultats);
	      }
	      applatirResultatRecherche(resultats);
	      set(resultatsRecherche, resultats);
	      {
	        if (strict_equals(get(resultatsRecherche).length, 0)) {
	          notifierLecteurEcran(srAucunResultat);
	        } else {
	          notifierLecteurEcran(srResultatsTrouves.replace("{x}", get(resultatsRechercheFlat).length));
	        }
	      }
	    } else {
	      // console.log('rechercher -> rÃ©initialiser Ã  null')
	      set(resultatsRecherche, null);
	    }

	    //VÃ©rifier si scrollbar visible ou non (servira a ajouter une marge de droite afin que la scrollbar ne soit pas collÃ©e sur la bordure du contrÃ´le)
	    //definirPresenceScrollbarResultats()
	  }
	  function ajouterMessagePrecisionRecherche(resultats) {
	    var parent = resultats;
	    if (strict_equals(get(nbNiveaux), 1)) {
	      parent = resultats;
	    } else if (strict_equals(get(nbNiveaux), 2)) {
	      parent = resultats[resultats.length - 1].values;
	    } else {
	      // 3 niveaux
	      parent = resultats[resultats.length - 1].values;
	      parent = parent[parent.length - 1].values;
	    }

	    //Deep copy, on veut un nouvel objet, pas une rÃ©fÃ©rence Ã  celui copiÃ©
	    parent.push(JSON.parse(JSON.stringify(parent[parent.length - 1])));
	    parent[parent.length - 1].r = "MessagePrecisionRecherche";
	    parent[parent.length - 1].id = Utils.genererId();
	    parent[parent.length - 1].i = get(nombreMaxResultats);
	    parent[parent.length - 1].t = '';
	    parent[parent.length - 1].h = '';
	    parent[parent.length - 1].match = {};
	    parent[parent.length - 1].terms = {};
	  }
	  function obtenirResultatsGroupes(retourMiniSearch) {
	    set(resultatsRechercheFlat, []);

	    //Ajouter un indexe (i). Servira lors de la navigation au clavier pour savoir si nous sommes sur le 1er ou dernier Ã©lÃ©ment (mÃªme s'ils sont regroupÃ©s)
	    for (var i = 0; i < retourMiniSearch.length; i++) {
	      retourMiniSearch[i].i = i;
	    }
	    if (strict_equals(get(nbNiveaux), 1)) {
	      return retourMiniSearch;
	    } else if (strict_equals(get(nbNiveaux), 2)) {
	      return regrouper(retourMiniSearch, "c");
	    } else {
	      // 3 niveaux
	      var niveau1 = regrouper(retourMiniSearch, "c");
	      if (niveau1) {
	        niveau1.forEach(function (item) {
	          item.values = regrouper(item.values, "sc");
	        });
	      }
	      return niveau1;
	    }
	  }
	  function applatirResultatRecherche(tableau) {
	    if (strict_equals(get(nbNiveaux), 1)) {
	      set(resultatsRechercheFlat, tableau);
	      return;
	    }
	    tableau.forEach(function (item) {
	      if (item.values) {
	        applatirResultatRecherche(item.values);
	      } else {
	        get(resultatsRechercheFlat).push(item);
	      }
	    });
	  }
	  function regrouper(source, propriete) {
	    return source.reduce(function (final, val) {
	      var groupe = final.find(function (r) {
	        return strict_equals(r[propriete], "".concat(val[propriete]));
	      });
	      if (groupe) {
	        groupe.values.push(val);
	      } else {
	        var obj = {};
	        obj[propriete] = val[propriete];
	        obj['values'] = [val];
	        final.push(obj);
	      }
	      return final;
	    }, []);
	  }
	  function clickBoutonReinitialiser() {
	    reinitialiserRecherche(true, true);
	  }
	  function reinitialiserRecherche(donnerFocusControleRecherche, initialiserValeurControleRecherche) {
	    set(resultatsRecherche, null);
	    set(idActiveDescendant, null);
	    if (donnerFocusControleRecherche) {
	      controleRecherche.focus();
	    }
	    if (initialiserValeurControleRecherche) {
	      set(texteRecherche, "");
	      controleRecherche.value = "";
	    }
	  }
	  function notifierLecteurEcran(texte) {
	    set(texteNotificationLecteurEcran, texte);

	    //On s'assure que le texte va Ãªtre lu (car parfois c'est le mÃªme texte, s'il ne change pas, il n'est pas lu)
	    setTimeout(function () {
	      set(texteNotificationLecteurEcran, "");
	    }, 400);
	  }
	  function mouseoverResultat(e) {
	    set(idActiveDescendant, this.parentNode.id);
	  }

	  /**
	   * Obtient le terme Ã  indexer (normalisÃ© et tout).
	   * @param terme
	   */
	  function indexerTerme(terme) {
	    if (terme.length <= 1 || optionsMiniSearch.stopWords.has(terme)) {
	      return null;
	    }
	    return Utils.normaliserChaineCaracteres(terme);
	  }
	  function onKeyDownRecherche(e) {
	    switch (e.key) {
	      case "Enter":
	      case " ":
	        if (strict_equals(get(idActiveDescendant), null)) {
	          if (strict_equals(e.key, "Enter")) {
	            reinitialiserRecherche();
	          }
	        } else {
	          // Le focus visuel est dans la liste de rÃ©sultats. Si ENTER ou SPACE on doit accÃ©der au rÃ©sultat.
	          e.preventDefault();
	          var lienActiveDescendant = thisComponent().shadowRoot.getElementById(get(idActiveDescendant)).querySelector('a');
	          if (lienActiveDescendant) {
	            controleRecherche.value = lienActiveDescendant.innerText;
	            reinitialiserRecherche();
	            lienActiveDescendant.click();
	          }
	        }
	        break;
	      case "Escape":
	        reinitialiserRecherche(true, strict_equals(get(resultatsRecherche), null));
	        break;
	      case "ArrowDown":
	        e.preventDefault();
	        if (strict_equals(get(resultatsRecherche), null, false)) {
	          //Les rÃ©sultats sont visibles, on donne le focus au rÃ©sultat suivant
	          definirProchainActiveDescendant(1);
	          assurerOptionCouranteVisible();
	        }
	        break;
	      case "ArrowUp":
	        e.preventDefault();
	        if (strict_equals(get(resultatsRecherche), null, false)) {
	          //Les rÃ©sultats sont visibles, on donne le focus au rÃ©sultat prÃ©cÃ©dent
	          definirProchainActiveDescendant(-1);
	          assurerOptionCouranteVisible();
	        }
	        break;
	      case "ArrowLeft":
	      case "ArrowRight":
	      case "Home":
	      case "End":
	        if (strict_equals(get(resultatsRecherche), null, false)) {
	          controleRecherche.focus();
	          set(idActiveDescendant, null);
	        }
	        break;
	    }
	  }
	  function definirProchainActiveDescendant(step) {
	    var indexeActiveDescendant = get(resultatsRechercheFlat).findIndex(function (r) {
	      return strict_equals(r.id, get(idActiveDescendant));
	    });
	    if (indexeActiveDescendant >= 0) {
	      if (strict_equals(step, 1)) {
	        if (indexeActiveDescendant < get(resultatsRechercheFlat).length - 1) {
	          set(idActiveDescendant, get(resultatsRechercheFlat)[indexeActiveDescendant + 1].id);
	        } else {
	          set(idActiveDescendant, get(resultatsRechercheFlat)[0].id);
	        }
	      } else {
	        if (indexeActiveDescendant > 0) {
	          set(idActiveDescendant, get(resultatsRechercheFlat)[indexeActiveDescendant - 1].id);
	        } else {
	          set(idActiveDescendant, get(resultatsRechercheFlat)[get(resultatsRechercheFlat).length - 1].id);
	        }
	      }
	    } else {
	      if (strict_equals(step, 1)) {
	        set(idActiveDescendant, get(resultatsRechercheFlat)[0].id);
	      } else {
	        set(idActiveDescendant, get(resultatsRechercheFlat)[get(resultatsRechercheFlat).length - 1].id);
	      }
	    }
	  }

	  //TODO Ã©ventuellement vÃ©rifier pour faire une fonction rÃ©utilisable dans Utils. Est utilisÃ© aussi dans liste dÃ©roulante. Seul le bout du premier et dernier Ã©lÃ©ment est diffÃ©rent... Ã regarder Ã©ventuellement.
	  function assurerOptionCouranteVisible() {
	    //SetTimeout nÃ©cessaire afin que le paint de la page soit fait et qu'on puisse travailler avec l'option qui vient de recevoir le focus.
	    setTimeout(function () {
	      var option = thisComponent().shadowRoot.querySelector('.lien-resultat[aria-selected="true"]');
	      if (!option) {
	        return;
	      }
	      var hauteurConteneur = controleConteneurResultats.getBoundingClientRect().height;
	      var hauteurOption = option.getBoundingClientRect().height;
	      var offsetConteneur = controleConteneurResultats.scrollTop + hauteurConteneur;

	      //Si nous sommes sur la 1ere ou la derniÃ¨re suggestion on gÃ¨re manuellement le scroll
	      if (option.classList.contains('premier')) {
	        controleConteneurResultats.scroll({
	          top: 0
	        });
	        return;
	      } else if (option.classList.contains('dernier')) {
	        controleConteneurResultats.scroll({
	          top: option.offsetTop
	        });
	        return;
	      }
	      if (option.offsetTop + hauteurOption > offsetConteneur) {
	        if (option.offsetTop + hauteurOption > offsetConteneur + hauteurOption) {
	          //Ici on traite le cas ou le user aurait modifiÃ© la position du scroll (ex. avec la souris), dans ce cas on remet l'option courant en haut de liste
	          controleConteneurResultats.scroll({
	            top: option.offsetTop
	          });
	        } else {
	          controleConteneurResultats.scroll({
	            top: controleConteneurResultats.scrollTop + hauteurOption
	          });
	        }
	      } else if (option.offsetTop < offsetConteneur - hauteurConteneur) {
	        if (option.offsetTop < offsetConteneur - hauteurOption) {
	          //Ici on traite le cas ou le user aurait modifiÃ© la position du scroll (ex. avec la souris), dans ce cas on remet l'option courant en haut de liste
	          controleConteneurResultats.scroll({
	            top: option.offsetTop
	          });
	        } else {
	          controleConteneurResultats.scroll({
	            top: controleConteneurResultats.scrollTop - hauteurOption
	          });
	        }
	      }
	    });
	  }
	  function onBlurRecherche() {
	    reinitialiserRecherche();
	  }

	  /**
	   * Petite twist permettant de ne pas avoir de blur sur le contrÃ´le de recherche lors d'un click dans les rÃ©sultats.
	   * @param e
	   */
	  function mouseDownResultatsRecherche(e) {
	    e.preventDefault();
	  }
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  legacy_pre_effect(function () {
	    return deep_read_state(focus());
	  }, function () {
	    toggleFocus(focus());
	  });
	  legacy_pre_effect(function () {
	    return get(contenuRecherche);
	  }, function () {
	    majContenuRecherche(get(contenuRecherche));
	  });
	  legacy_pre_effect(function () {
	    return get(resultatsRecherche);
	  }, function () {
	    set(doitAfficherResultatsRecherche, get(resultatsRecherche) && get(resultatsRecherche).length > 0);
	  });
	  legacy_pre_effect(function () {
	    return deep_read_state(nbMaxResultats());
	  }, function () {
	    set(nombreMaxResultats, parseInt(nbMaxResultats()));
	  });
	  legacy_pre_effect_reset();
	  var $$exports = _objectSpread$o({
	    get urlContenuRecherche() {
	      return urlContenuRecherche();
	    },
	    set urlContenuRecherche($$value) {
	      urlContenuRecherche($$value);
	      flushSync();
	    },
	    get placeholder() {
	      return placeholder();
	    },
	    set placeholder($$value) {
	      placeholder($$value);
	      flushSync();
	    },
	    get nbMaxResultats() {
	      return nbMaxResultats();
	    },
	    set nbMaxResultats($$value) {
	      nbMaxResultats($$value);
	      flushSync();
	    },
	    get focus() {
	      return focus();
	    },
	    set focus($$value) {
	      focus($$value);
	      flushSync();
	    },
	    get rechercheFloue() {
	      return rechercheFloue();
	    },
	    set rechercheFloue($$value) {
	      rechercheFloue($$value);
	      flushSync();
	    },
	    get precisionRecherche() {
	      return precisionRecherche();
	    },
	    set precisionRecherche($$value) {
	      precisionRecherche($$value);
	      flushSync();
	    },
	    get contextePiv() {
	      return contextePiv();
	    },
	    set contextePiv($$value) {
	      contextePiv($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$o();
	  var div = first_child(fragment);
	  var div_1 = child(div);
	  var input = child(div_1);
	  var node = sibling(input, 2);
	  {
	    var consequent = function consequent($$anchor) {
	      var button = root_1$d();
	      template_effect(function () {
	        return set_attribute(button, 'title', titleBoutonReinitialiserRecherche);
	      });
	      event('click', button, clickBoutonReinitialiser);
	      append($$anchor, button);
	    };
	    add_svelte_meta(function () {
	      return if_block(node, function ($$render) {
	        if (strict_equals(get(texteRecherche), '', false)) $$render(consequent);
	      });
	    }, 'if', BarreRecherche, 506, 6);
	  }
	  reset(div_1);
	  var div_2 = sibling(div_1, 2);
	  var node_1 = child(div_2);
	  {
	    var consequent_6 = function consequent_6($$anchor) {
	      var ul = root_2$a();
	      add_svelte_meta(function () {
	        return each(ul, 5, function () {
	          return get(resultatsRecherche);
	        }, index, function ($$anchor, resultat) {
	          var fragment_1 = comment();
	          var node_2 = first_child(fragment_1);
	          {
	            var consequent_2 = function consequent_2($$anchor) {
	              var fragment_2 = comment();
	              var node_3 = first_child(fragment_2);
	              {
	                var consequent_1 = function consequent_1($$anchor) {
	                  var li = root_5$8();
	                  var span = child(li);
	                  var span_1 = sibling(child(span), 2);
	                  var text = child(span_1, true);
	                  reset(span_1);
	                  reset(span);
	                  reset(li);
	                  template_effect(function () {
	                    var _ref, _ref2;
	                    set_attribute(li, 'id', (get(resultat), untrack(function () {
	                      return get(resultat).id;
	                    })));
	                    set_class(li, 1, "lien-resultat".concat((_ref = (get(resultat), untrack(function () {
	                      return strict_equals(get(resultat).i, 0) ? ' premier' : '';
	                    }))) !== null && _ref !== void 0 ? _ref : '').concat((_ref2 = (get(resultat), get(resultatsRechercheFlat), untrack(function () {
	                      return strict_equals(get(resultat).i, get(resultatsRechercheFlat).length - 1) ? ' dernier' : '';
	                    }))) !== null && _ref2 !== void 0 ? _ref2 : ''));
	                    set_attribute(li, 'aria-selected', (get(resultat), get(idActiveDescendant), untrack(function () {
	                      return strict_equals(get(resultat).id, get(idActiveDescendant)) ? 'true' : 'false';
	                    })));
	                    set_text(text, get(textePrecisionRecherche));
	                  });
	                  append($$anchor, li);
	                };
	                var alternate = function alternate($$anchor) {
	                  var li_1 = root_6$3();
	                  var a = child(li_1);
	                  var span_2 = child(a);
	                  var text_1 = child(span_2, true);
	                  reset(span_2);
	                  reset(a);
	                  reset(li_1);
	                  template_effect(function () {
	                    var _ref3, _ref4;
	                    set_attribute(li_1, 'id', (get(resultat), untrack(function () {
	                      return get(resultat).id;
	                    })));
	                    set_class(li_1, 1, "lien-resultat".concat((_ref3 = (get(resultat), untrack(function () {
	                      return strict_equals(get(resultat).i, 0) ? ' premier' : '';
	                    }))) !== null && _ref3 !== void 0 ? _ref3 : '').concat((_ref4 = (get(resultat), get(resultatsRechercheFlat), untrack(function () {
	                      return strict_equals(get(resultat).i, get(resultatsRechercheFlat).length - 1) ? ' dernier' : '';
	                    }))) !== null && _ref4 !== void 0 ? _ref4 : ''));
	                    set_attribute(li_1, 'aria-selected', (get(resultat), get(idActiveDescendant), untrack(function () {
	                      return strict_equals(get(resultat).id, get(idActiveDescendant)) ? 'true' : 'false';
	                    })));
	                    set_attribute(a, 'href', (get(resultat), untrack(function () {
	                      return get(resultat).h;
	                    })));
	                    set_text(text_1, (get(resultat), untrack(function () {
	                      return get(resultat).r;
	                    })));
	                  });
	                  event('mouseover', a, mouseoverResultat);
	                  append($$anchor, li_1);
	                };
	                add_svelte_meta(function () {
	                  return if_block(node_3, function ($$render) {
	                    if (get(doitAfficherMessagePreciserRecherche), get(resultat), get(resultatsRechercheFlat), untrack(function () {
	                      return get(doitAfficherMessagePreciserRecherche) && strict_equals(get(resultat).i, get(resultatsRechercheFlat).length - 1);
	                    })) $$render(consequent_1);else $$render(alternate, false);
	                  });
	                }, 'if', BarreRecherche, 519, 12);
	              }
	              append($$anchor, fragment_2);
	            };
	            var alternate_4 = function alternate_4($$anchor) {
	              var fragment_3 = comment();
	              var node_4 = first_child(fragment_3);
	              {
	                var consequent_4 = function consequent_4($$anchor) {
	                  var li_2 = root_8$3();
	                  var span_3 = child(li_2);
	                  var text_2 = child(span_3, true);
	                  reset(span_3);
	                  var ul_1 = sibling(span_3, 2);
	                  add_svelte_meta(function () {
	                    return each(ul_1, 5, function () {
	                      return get(resultat), untrack(function () {
	                        return get(resultat).values;
	                      });
	                    }, index, function ($$anchor, valeur) {
	                      var fragment_4 = comment();
	                      var node_5 = first_child(fragment_4);
	                      {
	                        var consequent_3 = function consequent_3($$anchor) {
	                          var li_3 = root_10$4();
	                          var span_4 = child(li_3);
	                          var span_5 = sibling(child(span_4), 2);
	                          var text_3 = child(span_5, true);
	                          reset(span_5);
	                          reset(span_4);
	                          reset(li_3);
	                          template_effect(function () {
	                            var _ref5, _ref6;
	                            set_attribute(li_3, 'id', (get(valeur), untrack(function () {
	                              return get(valeur).id;
	                            })));
	                            set_class(li_3, 1, "lien-resultat".concat((_ref5 = (get(valeur), untrack(function () {
	                              return strict_equals(get(valeur).i, 0) ? ' premier' : '';
	                            }))) !== null && _ref5 !== void 0 ? _ref5 : '').concat((_ref6 = (get(valeur), get(resultatsRechercheFlat), untrack(function () {
	                              return strict_equals(get(valeur).i, get(resultatsRechercheFlat).length - 1) ? ' dernier' : '';
	                            }))) !== null && _ref6 !== void 0 ? _ref6 : ''));
	                            set_attribute(li_3, 'aria-selected', (get(valeur), get(idActiveDescendant), untrack(function () {
	                              return strict_equals(get(valeur).id, get(idActiveDescendant)) ? 'true' : 'false';
	                            })));
	                            set_text(text_3, get(textePrecisionRecherche));
	                          });
	                          append($$anchor, li_3);
	                        };
	                        var alternate_1 = function alternate_1($$anchor) {
	                          var li_4 = root_11$3();
	                          var a_1 = child(li_4);
	                          var span_6 = child(a_1);
	                          var text_4 = child(span_6, true);
	                          reset(span_6);
	                          reset(a_1);
	                          reset(li_4);
	                          template_effect(function () {
	                            var _ref7, _ref8;
	                            set_attribute(li_4, 'id', (get(valeur), untrack(function () {
	                              return get(valeur).id;
	                            })));
	                            set_class(li_4, 1, "lien-resultat".concat((_ref7 = (get(valeur), untrack(function () {
	                              return strict_equals(get(valeur).i, 0) ? ' premier' : '';
	                            }))) !== null && _ref7 !== void 0 ? _ref7 : '').concat((_ref8 = (get(valeur), get(resultatsRechercheFlat), untrack(function () {
	                              return strict_equals(get(valeur).i, get(resultatsRechercheFlat).length - 1) ? ' dernier' : '';
	                            }))) !== null && _ref8 !== void 0 ? _ref8 : ''));
	                            set_attribute(li_4, 'aria-selected', (get(valeur), get(idActiveDescendant), untrack(function () {
	                              return strict_equals(get(valeur).id, get(idActiveDescendant)) ? 'true' : 'false';
	                            })));
	                            set_attribute(a_1, 'href', (get(valeur), untrack(function () {
	                              return get(valeur).h;
	                            })));
	                            set_text(text_4, (get(valeur), untrack(function () {
	                              return get(valeur).r;
	                            })));
	                          });
	                          event('mouseover', a_1, mouseoverResultat);
	                          append($$anchor, li_4);
	                        };
	                        add_svelte_meta(function () {
	                          return if_block(node_5, function ($$render) {
	                            if (get(doitAfficherMessagePreciserRecherche), get(valeur), get(resultatsRechercheFlat), untrack(function () {
	                              return get(doitAfficherMessagePreciserRecherche) && strict_equals(get(valeur).i, get(resultatsRechercheFlat).length - 1);
	                            })) $$render(consequent_3);else $$render(alternate_1, false);
	                          });
	                        }, 'if', BarreRecherche, 537, 20);
	                      }
	                      append($$anchor, fragment_4);
	                    });
	                  }, 'each', BarreRecherche, 536, 18);
	                  reset(ul_1);
	                  reset(li_2);
	                  template_effect(function () {
	                    set_attribute(li_2, 'aria-label', (get(resultat), untrack(function () {
	                      return get(resultat).c;
	                    })));
	                    set_text(text_2, (get(resultat), untrack(function () {
	                      return get(resultat).c;
	                    })));
	                  });
	                  append($$anchor, li_2);
	                };
	                var alternate_3 = function alternate_3($$anchor) {
	                  var li_5 = root_12$2();
	                  var span_7 = child(li_5);
	                  var text_5 = child(span_7, true);
	                  reset(span_7);
	                  var ul_2 = sibling(span_7, 2);
	                  add_svelte_meta(function () {
	                    return each(ul_2, 5, function () {
	                      return get(resultat), untrack(function () {
	                        return get(resultat).values;
	                      });
	                    }, index, function ($$anchor, sousCategorie) {
	                      var fragment_5 = root_13$1();
	                      var span_8 = first_child(fragment_5);
	                      var text_6 = child(span_8, true);
	                      reset(span_8);
	                      var ul_3 = sibling(span_8, 2);
	                      add_svelte_meta(function () {
	                        return each(ul_3, 5, function () {
	                          return get(sousCategorie), untrack(function () {
	                            return get(sousCategorie).values;
	                          });
	                        }, index, function ($$anchor, valeur) {
	                          var fragment_6 = comment();
	                          var node_6 = first_child(fragment_6);
	                          {
	                            var consequent_5 = function consequent_5($$anchor) {
	                              var li_6 = root_15$1();
	                              var span_9 = child(li_6);
	                              var span_10 = sibling(child(span_9), 2);
	                              var text_7 = child(span_10, true);
	                              reset(span_10);
	                              reset(span_9);
	                              reset(li_6);
	                              template_effect(function () {
	                                var _ref9, _ref0;
	                                set_attribute(li_6, 'id', (get(valeur), untrack(function () {
	                                  return get(valeur).id;
	                                })));
	                                set_class(li_6, 1, "lien-resultat".concat((_ref9 = (get(valeur), untrack(function () {
	                                  return strict_equals(get(valeur).i, 0) ? ' premier' : '';
	                                }))) !== null && _ref9 !== void 0 ? _ref9 : '').concat((_ref0 = (get(valeur), get(resultatsRechercheFlat), untrack(function () {
	                                  return strict_equals(get(valeur).i, get(resultatsRechercheFlat).length - 1) ? ' dernier' : '';
	                                }))) !== null && _ref0 !== void 0 ? _ref0 : ''));
	                                set_attribute(li_6, 'aria-selected', (get(valeur), get(idActiveDescendant), untrack(function () {
	                                  return strict_equals(get(valeur).id, get(idActiveDescendant)) ? 'true' : 'false';
	                                })));
	                                set_text(text_7, get(textePrecisionRecherche));
	                              });
	                              append($$anchor, li_6);
	                            };
	                            var alternate_2 = function alternate_2($$anchor) {
	                              var li_7 = root_16$1();
	                              var a_2 = child(li_7);
	                              var span_11 = child(a_2);
	                              var text_8 = child(span_11, true);
	                              reset(span_11);
	                              reset(a_2);
	                              reset(li_7);
	                              template_effect(function () {
	                                var _ref1, _ref10;
	                                set_attribute(li_7, 'id', (get(valeur), untrack(function () {
	                                  return get(valeur).id;
	                                })));
	                                set_class(li_7, 1, "lien-resultat".concat((_ref1 = (get(valeur), untrack(function () {
	                                  return strict_equals(get(valeur).i, 0) ? ' premier' : '';
	                                }))) !== null && _ref1 !== void 0 ? _ref1 : '').concat((_ref10 = (get(valeur), get(resultatsRechercheFlat), untrack(function () {
	                                  return strict_equals(get(valeur).i, get(resultatsRechercheFlat).length - 1) ? ' dernier' : '';
	                                }))) !== null && _ref10 !== void 0 ? _ref10 : ''));
	                                set_attribute(li_7, 'aria-selected', (get(valeur), get(idActiveDescendant), untrack(function () {
	                                  return strict_equals(get(valeur).id, get(idActiveDescendant)) ? 'true' : 'false';
	                                })));
	                                set_attribute(a_2, 'href', (get(valeur), untrack(function () {
	                                  return get(valeur).h;
	                                })));
	                                set_text(text_8, (get(valeur), untrack(function () {
	                                  return get(valeur).r;
	                                })));
	                              });
	                              event('mouseover', a_2, mouseoverResultat);
	                              append($$anchor, li_7);
	                            };
	                            add_svelte_meta(function () {
	                              return if_block(node_6, function ($$render) {
	                                if (get(doitAfficherMessagePreciserRecherche), get(valeur), get(resultatsRechercheFlat), untrack(function () {
	                                  return get(doitAfficherMessagePreciserRecherche) && strict_equals(get(valeur).i, get(resultatsRechercheFlat).length - 1);
	                                })) $$render(consequent_5);else $$render(alternate_2, false);
	                              });
	                            }, 'if', BarreRecherche, 561, 24);
	                          }
	                          append($$anchor, fragment_6);
	                        });
	                      }, 'each', BarreRecherche, 560, 22);
	                      reset(ul_3);
	                      template_effect(function () {
	                        set_text(text_6, (get(sousCategorie), untrack(function () {
	                          return get(sousCategorie).sc;
	                        })));
	                        set_attribute(ul_3, 'aria-label', (get(sousCategorie), untrack(function () {
	                          return get(sousCategorie).sc;
	                        })));
	                      });
	                      append($$anchor, fragment_5);
	                    });
	                  }, 'each', BarreRecherche, 557, 20);
	                  reset(ul_2);
	                  reset(li_5);
	                  template_effect(function () {
	                    set_attribute(li_5, 'aria-label', (get(resultat), untrack(function () {
	                      return get(resultat).c;
	                    })));
	                    set_text(text_5, (get(resultat), untrack(function () {
	                      return get(resultat).c;
	                    })));
	                  });
	                  append($$anchor, li_5);
	                };
	                add_svelte_meta(function () {
	                  return if_block(node_4, function ($$render) {
	                    if (strict_equals(get(nbNiveaux), 2)) $$render(consequent_4);else $$render(alternate_3, false);
	                  });
	                }, 'if', BarreRecherche, 532, 12);
	              }
	              append($$anchor, fragment_3);
	            };
	            add_svelte_meta(function () {
	              return if_block(node_2, function ($$render) {
	                if (strict_equals(get(nbNiveaux), 1)) $$render(consequent_2);else $$render(alternate_4, false);
	              });
	            }, 'if', BarreRecherche, 518, 10);
	          }
	          append($$anchor, fragment_1);
	        });
	      }, 'each', BarreRecherche, 517, 8);
	      reset(ul);
	      template_effect(function () {
	        set_attribute(ul, 'id', idControleResultats);
	        set_class(ul, 1, "liste-resultats ".concat('nb-niveaux-' + get(nbNiveaux)));
	      });
	      transition(3, ul, function () {
	        return slide;
	      }, function () {
	        return {
	          duration: 250
	        };
	      });
	      append($$anchor, ul);
	    };
	    var alternate_5 = function alternate_5($$anchor) {
	      var span_12 = root_17$1();
	      var text_9 = child(span_12, true);
	      reset(span_12);
	      template_effect(function () {
	        return set_text(text_9, texteAucunResultat);
	      });
	      append($$anchor, span_12);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_1, function ($$render) {
	        if (get(doitAfficherResultatsRecherche)) $$render(consequent_6);else $$render(alternate_5, false);
	      });
	    }, 'if', BarreRecherche, 514, 4);
	  }
	  reset(div_2);
	  var span_13 = sibling(div_2, 2);
	  var text_10 = child(span_13, true);
	  reset(span_13);
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function () {
	    set_class(div_1, 1, "controle-recherche ".concat(strict_equals(contextePiv(), 'true') ? ' contexte-piv' : ''));
	    set_attribute(input, 'id', idControleRecherche);
	    set_attribute(input, 'aria-expanded', get(doitAfficherResultatsRecherche) ? 'true' : 'false');
	    set_attribute(input, 'aria-controls', idControleResultats);
	    set_attribute(input, 'aria-activedescendant', get(doitAfficherResultatsRecherche) && get(idActiveDescendant) ? get(idActiveDescendant) : null);
	    set_attribute(input, 'placeholder', placeholder());
	    set_attribute(input, 'aria-description', ariaDescriptionRecherche);
	    set_class(div_2, 1, "resultats-recherche ".concat(strict_equals(get(resultatsRecherche), null) ? ' utd-d-none' : ''));
	    set_text(text_10, get(texteNotificationLecteurEcran));
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('input', input, traiterSaisieRecherche);
	  event('keydown', input, onKeyDownRecherche);
	  event('blur', input, onBlurRecherche);
	  event('mousedown', div_2, mouseDownResultatsRecherche);
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-barre-recherche', create_custom_element(BarreRecherche, {
	  urlContenuRecherche: {
	    attribute: 'url-contenu-recherche'
	  },
	  placeholder: {
	    attribute: 'placeholder'
	  },
	  nbMaxResultats: {
	    attribute: 'nb-max-resultats'
	  },
	  focus: {
	    attribute: 'focus'
	  },
	  rechercheFloue: {
	    attribute: 'recherche-floue'
	  },
	  precisionRecherche: {
	    attribute: 'precision-recherche'
	  },
	  contextePiv: {
	    attribute: 'contexte-piv'
	  },
	  thisComponent: {}
	}, [], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$o(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$n(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$n() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$n() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$n = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$n(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$n(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$n(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$n(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	BarreRechercheSimple[FILENAME] = 'src/components/barreRechercheSimple.svelte';
	var root_1$c = add_locations(from_html("<button class=\"reinitialiser-recherche utd-btn secondaire\" type=\"button\"><span aria-hidden=\"true\" class=\"utd-icone-svg x-fermer-bleu-moyen\"></span></button>"), BarreRechercheSimple[FILENAME], [[104, 8, [[105, 12]]]]);
	var root$n = add_locations(from_html("<div class=\"utd-barre-recherche-simple\"><div><input type=\"text\"/> <!> <button class=\"utd-btn secondaire rechercher\" type=\"button\"><span aria-hidden=\"true\" class=\"utd-icone-svg loupe-mince\"></span></button></div></div> <link rel=\"stylesheet\"/>", 1), BarreRechercheSimple[FILENAME], [[100, 0, [[101, 2, [[102, 6], [109, 6, [[110, 8]]]]]]], [114, 0]]);
	function BarreRechercheSimple($$anchor, $$props) {
	  check_target(this instanceof BarreRechercheSimple ? this.constructor : void 0);
	  push($$props, false);
	  var estLangueFrancaise = Utils.estPageLangueFrancais();

	  /* Attributs publics */
	  var placeholder = prop($$props, 'placeholder', 12, estLangueFrancaise ? "Rechercher..." : "Search...");
	  var urlRedirection = prop($$props, 'urlRedirection', 12, '?q=$(texteRecherche)');
	  var mode = prop($$props, 'mode', 12, 'redirection');

	  /* Attributs privÃ©s */
	  var focus = prop($$props, 'focus', 12, 'false');
	  var contextePiv = prop($$props, 'contextePiv', 12, 'false');
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var titleBoutonRecherche = estLangueFrancaise ? "Rechercher" : "Search";
	  var titleBoutonReinitialiserRecherche = estLangueFrancaise ? "RÃ©initialiser la recherche" : "Reset search";
	  var idControleRecherche = Utils.genererId();
	  var mounted = false;
	  var estCssCharge = false;

	  /* ContrÃ´les */
	  var controleRecherche;
	  var texteRecherche = mutable_source();
	  onMount(function () {
	    var _console;
	    controleRecherche = thisComponent().shadowRoot.getElementById(idControleRecherche);
	    (_console = console).log.apply(_console, _toConsumableArray(log_if_contains_state('log', controleRecherche)));
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    mounted = true;
	  });

	  /* ============== Watches ============== */
	  // Watch sur la prop focus
	  function toggleFocus() {
	    if (strict_equals(focus(), 'true')) {
	      controleRecherche.focus();
	      thisComponent().setAttribute('focus', 'false');
	    }
	  }
	  function onKeyPressRecherche(e) {
	    if (strict_equals(e.key, 'Enter')) {
	      rechercher();
	    }
	  }
	  function rechercher() {
	    if (strict_equals(mode(), 'callback')) {
	      Utils.dispatchWcEvent(thisComponent(), "rechercher", {
	        texteRecherche: get(texteRecherche)
	      });
	    } else {
	      window.location.href = urlRedirection().replace('$(texteRecherche)', get(texteRecherche));
	    }
	  }
	  function clickBoutonReinitialiser() {
	    set(texteRecherche, '');
	    controleRecherche.focus();
	  }
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  legacy_pre_effect(function () {
	    return deep_read_state(focus());
	  }, function () {
	    toggleFocus(focus());
	  });
	  legacy_pre_effect_reset();
	  var $$exports = _objectSpread$n({
	    get placeholder() {
	      return placeholder();
	    },
	    set placeholder($$value) {
	      placeholder($$value);
	      flushSync();
	    },
	    get urlRedirection() {
	      return urlRedirection();
	    },
	    set urlRedirection($$value) {
	      urlRedirection($$value);
	      flushSync();
	    },
	    get mode() {
	      return mode();
	    },
	    set mode($$value) {
	      mode($$value);
	      flushSync();
	    },
	    get focus() {
	      return focus();
	    },
	    set focus($$value) {
	      focus($$value);
	      flushSync();
	    },
	    get contextePiv() {
	      return contextePiv();
	    },
	    set contextePiv($$value) {
	      contextePiv($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$n();
	  var div = first_child(fragment);
	  var div_1 = child(div);
	  var input = child(div_1);
	  remove_input_defaults(input);
	  var node = sibling(input, 2);
	  {
	    var consequent = function consequent($$anchor) {
	      var button = root_1$c();
	      template_effect(function () {
	        return set_attribute(button, 'title', titleBoutonReinitialiserRecherche);
	      });
	      event('click', button, clickBoutonReinitialiser);
	      append($$anchor, button);
	    };
	    add_svelte_meta(function () {
	      return if_block(node, function ($$render) {
	        if (get(texteRecherche)) $$render(consequent);
	      });
	    }, 'if', BarreRechercheSimple, 103, 6);
	  }
	  var button_1 = sibling(node, 2);
	  reset(div_1);
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function () {
	    set_class(div_1, 1, "controle-recherche ".concat(strict_equals(contextePiv(), 'true') ? ' contexte-piv' : ''));
	    set_attribute(input, 'id', idControleRecherche);
	    set_class(input, 1, "utd-form-control xxl texte-recherche".concat(get(texteRecherche) ? ' avec-texte' : ''));
	    set_attribute(input, 'placeholder', placeholder());
	    set_attribute(button_1, 'title', titleBoutonRecherche);
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  bind_value(input, function () {
	    return get(texteRecherche);
	  }, function ($$value) {
	    return set(texteRecherche, $$value);
	  });
	  event('keypress', input, onKeyPressRecherche);
	  event('click', button_1, rechercher);
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-barre-recherche-simple', create_custom_element(BarreRechercheSimple, {
	  placeholder: {
	    attribute: 'placeholder'
	  },
	  urlRedirection: {
	    attribute: 'url-redirection'
	  },
	  mode: {
	    attribute: 'mode'
	  },
	  focus: {
	    attribute: 'focus'
	  },
	  contextePiv: {
	    attribute: 'contexte-piv'
	  },
	  thisComponent: {}
	}, [], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$n(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$m(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$m() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$m() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$m = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$m(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$m(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$m(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$m(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	BoutonMenu[FILENAME] = 'src/components/boutonMenu.svelte';
	var root$m = add_locations(from_html("<div class=\"utd-btn-menu\"><button type=\"button\" aria-haspopup=\"true\"><span> </span> <span aria-hidden=\"true\"></span></button> <div role=\"menu\"><!></div></div> <link rel=\"stylesheet\"/>", 1), BoutonMenu[FILENAME], [[155, 0, [[156, 2, [[157, 4], [158, 4]]], [161, 2]]], [166, 0]]);
	var $$css$4 = {
	  hash: 'svelte-o38pj8',
	  code: '\r\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYm91dG9uTWVudS5zdmVsdGUiLCJzb3VyY2VzIjpbImJvdXRvbk1lbnUuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzdmVsdGU6b3B0aW9ucyBjdXN0b21FbGVtZW50PXt7XHJcbiAgdGFnOiAndXRkLWJ0bi1tZW51JyxcclxuICBleHRlbmQ6IChjdXN0b21FbGVtZW50Q29uc3RydWN0b3IpID0+IHtcclxuICAgIHJldHVybiBjbGFzcyBleHRlbmRzIGN1c3RvbUVsZW1lbnRDb25zdHJ1Y3RvciB7XHJcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50aGlzQ29tcG9uZW50ID0gdGhpcztcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LFxyXG4gIHByb3BzOiB7XHJcbiAgICBsaWJlbGxlIDoge2F0dHJpYnV0ZTogJ2xpYmVsbGUnfSxcclxuICAgIHR5cGUgOiB7YXR0cmlidXRlOiAndHlwZSd9LFxyXG4gICAgY29tcGFjdCA6IHthdHRyaWJ1dGU6ICdjb21wYWN0J30sXHJcbiAgICBkaXNhYmxlZCA6IHthdHRyaWJ1dGU6ICdkaXNhYmxlZCd9LFxyXG4gICAgYWZmaWNoZXIgOiB7YXR0cmlidXRlOiAnYWZmaWNoZXInfSxcclxuICAgIGZvY3VzIDoge2F0dHJpYnV0ZTogJ2ZvY3VzJ31cclxuICB9ICBcclxufX0vPlxyXG5cclxuPHNjcmlwdD5cclxuICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xyXG4gIGltcG9ydCB7IFV0aWxzIH0gZnJvbSBcIi4vanMvdXRpbHNcIlxyXG5cclxuICAvKiBQcm9wcmnDqXTDqXMgXCJwdWJsaXF1ZXNcIiAqL1xyXG4gIGV4cG9ydCBsZXQgbGliZWxsZSA9ICdCb3V0b24nO1xyXG4gIGV4cG9ydCBsZXQgdHlwZSA9ICdzZWNvbmRhaXJlJzsgLy9UeXBlIGR1IGJvdXRvblxyXG4gIGV4cG9ydCBsZXQgY29tcGFjdCA9ICdmYWxzZSc7IC8vQ29tcGFjdFxyXG4gIGV4cG9ydCBsZXQgZGlzYWJsZWQgPSBmYWxzZTsgXHJcblxyXG4gIC8qIFByb3ByacOpdMOpcyBcImludGVybmVzXCIgKi9cclxuICBleHBvcnQgbGV0IGFmZmljaGVyID0gJ2ZhbHNlJztcclxuICBleHBvcnQgbGV0IGZvY3VzID0gJ2ZhbHNlJzsgXHJcbiAgZXhwb3J0IGxldCB0aGlzQ29tcG9uZW50XHJcblxyXG4gIGNvbnN0IGlkQm91dG9uID0gVXRpbHMuZ2VuZXJlcklkKCk7XHJcbiAgY29uc3QgaWRTb3VzTWVudSA9IFV0aWxzLmdlbmVyZXJJZCgpO1xyXG4gIGNvbnN0IGlkVGl0cmVNZW51ID0gVXRpbHMuZ2VuZXJlcklkKCk7XHJcbiAgbGV0IGNvbnRyb2xlQm91dG9uIDtcclxuICBsZXQgbW91bnRlZCA9IGZhbHNlO1xyXG4gIGxldCBlc3RDc3NDaGFyZ2UgPSBmYWxzZTtcclxuICBsZXQgZXN0VGVzdEJhY2tzdG9wSnNFbkNvdXJzID0gZmFsc2VcclxuICBsZXQgY2xhc3NlSWNvbmUgPSBcIiB0cmlhbmdsZS1ibGV1LXBpdlwiXHJcbiAgY29uc3QgdHlwZXNQb3NzaWJsZXMgPSBbXCJwcmltYWlyZVwiLCBcInNlY29uZGFpcmVcIiwgXCJhdmVydGlzc2VtZW50XCJdO1xyXG5cclxuICAvLyBSw6lmw6lyZW5jZXMgcG91ciBhY2Nlc3NpYmlsaXTDqVxyXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvbWVudS1idXR0b24vZXhhbXBsZXMvbWVudS1idXR0b24tYWN0aW9ucy9cclxuXHJcbiAgXHJcbiAgb25Nb3VudCgoKSA9PiB7ICAgICAgXHJcbiAgICBlc3RUZXN0QmFja3N0b3BKc0VuQ291cnMgPSB3aW5kb3cubG9jYXRpb24uaGFzaC5pbmRleE9mKCdicy10ZXN0JykgPj0gMDtcclxuXHJcbiAgICB0eXBlID0gdHlwZXNQb3NzaWJsZXMuaW5jbHVkZXModHlwZSkgPyB0eXBlIDogJ3NlY29uZGFpcmUnO1xyXG5cclxuICAgIGRlZmluaXJDbGFzc2VJY29uZSgpO1xyXG5cclxuICAgIGNvbnRyb2xlQm91dG9uID0gdGhpc0NvbXBvbmVudC5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKGlkQm91dG9uKTtcclxuXHJcbiAgICAvLyDDiXbDqW5lbWVudCBuw6ljZXNzYWlyZSBwb3VyIElPUy4uLiBDYXIgcG91ciBsdWkgbCfDqXbDqW5lbWVudCBibHVyIGRlIGwnw6lsw6ltZW50IGRlIG1lbnUgbidlc3QgcGFzIGV4w6ljdXTDqS4gUGVybWV0IGRlIHMnYXNzdXJlciBxdWUgbG9yc3F1ZSBsZSBtZW51IHBlcmQgbGUgZm9jdXMsIGxlIG1lbnUgZXN0IGZlcm3DqS4gICAgXHJcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcclxuICAgICAgaWYoYWZmaWNoZXIgPT09ICd0cnVlJykge1xyXG5cclxuICAgICAgICBpZihlLnRhcmdldC5jbG9zZXN0KCd1dGQtYnRuLW1lbnUnKSAhPT0gdGhpc0NvbXBvbmVudCB8fCAoIWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmNsb3Nlc3QoJ3V0ZC1idG4tbWVudScpICE9PSB0aGlzQ29tcG9uZW50ICkpe1xyXG4gICAgICAgICAgYWZmaWNoZXIgPSAnZmFsc2UnOyAgXHJcbiAgICAgICAgfSAgICAgICBcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICBpZihlc3RDc3NDaGFyZ2UpIHtcclxuICAgICAgVXRpbHMucmVhZmZpY2hlckFwcmVzQ2hhcmdlbWVudCh0aGlzQ29tcG9uZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBtb3VudGVkID0gdHJ1ZTsgICAgXHJcbiAgfSlcclxuXHJcbiAgLy8gV2F0Y2ggc3VyIGxhIHByb3AgZm9jdXNcclxuICAkOiB0b2dnbGVGb2N1cyhmb2N1cykgXHJcblxyXG4gIGZ1bmN0aW9uIHRvZ2dsZUZvY3VzKCl7XHJcbiAgICBpZihmb2N1cyA9PT0gJ3RydWUnKXtcclxuICAgICAgY29udHJvbGVCb3V0b24uZm9jdXMoKTtcclxuICAgICAgZm9jdXMgPSAnZmFsc2UnO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGVmaW5pckNsYXNzZUljb25lKCkge1xyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgIGNhc2UgJ3ByaW1haXJlJzpcclxuICAgICAgY2FzZSAnYXZlcnRpc3NlbWVudCc6XHJcbiAgICAgICAgY2xhc3NlSWNvbmUgPSAndHJpYW5nbGUtYmxhbmMnO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGNsYXNzZUljb25lID0gJ3RyaWFuZ2xlLWJsZXUtcGl2JzsgICAgICAgIFxyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiB0b2dnbGVBZmZpY2hlcigpIHtcclxuICAgIGFmZmljaGVyID0gYWZmaWNoZXIgPT09ICd0cnVlJyA/ICdmYWxzZScgOiAndHJ1ZSc7XHJcbiAgICBcclxuICAgIGlmKGFmZmljaGVyID09PSAndHJ1ZScpe1xyXG4gICAgICBkb25uZXJGb2N1c1ByZW1pZXJFbGVtZW50KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvbktleURvd24oZSkge1xyXG4gICAgc3dpdGNoKGUua2V5KSB7XHJcbiAgICAgIGNhc2UgXCJFc2NhcGVcIjpcclxuICAgICAgICBhZmZpY2hlciA9ICdmYWxzZSc7XHJcbiAgICAgICAgY29udHJvbGVCb3V0b24uZm9jdXMoKTtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJFbnRlclwiOlxyXG4gICAgICBjYXNlIFwiIFwiOiAgICAgICAgICAgICAgICBcclxuICAgICAgICB0b2dnbGVBZmZpY2hlcigpO1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcIkFycm93VXBcIjpcclxuICAgICAgICBhZmZpY2hlciA9ICd0cnVlJzsgICAgICAgICAgICAgIFxyXG4gICAgICAgIGRvbm5lckZvY3VzRGVybmllckVsZW1lbnQoKTtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjogICAgICAgIFxyXG4gICAgICAgIGFmZmljaGVyID0gJ3RydWUnO1xyXG4gICAgICAgIGRvbm5lckZvY3VzUHJlbWllckVsZW1lbnQoKTtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgYnJlYWs7ICAgICAgICBcclxuXHQgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRvbm5lckZvY3VzUHJlbWllckVsZW1lbnQoKSB7XHJcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpc0NvbXBvbmVudC5xdWVyeVNlbGVjdG9yKCd1dGQtYnRuLW1lbnUtaXRlbScpO1xyXG4gICAgaWYoZWxlbWVudCl7XHJcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdmb2N1cycsICd0cnVlJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkb25uZXJGb2N1c0Rlcm5pZXJFbGVtZW50KCkge1xyXG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzQ29tcG9uZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3V0ZC1idG4tbWVudS1pdGVtJyk7XHJcbiAgICBpZighZWxlbWVudHMubGVuZ3RoKXtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0uc2V0QXR0cmlidXRlKCdmb2N1cycsICd0cnVlJyk7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gY3NzQ2hhcmdlKGUpIHsgICAgXHJcbiAgICBpZihtb3VudGVkKSB7XHJcbiAgICAgIFV0aWxzLnJlYWZmaWNoZXJBcHJlc0NoYXJnZW1lbnQodGhpc0NvbXBvbmVudCk7ICBcclxuICAgIH1cclxuICBcclxuICAgIGVzdENzc0NoYXJnZSA9IHRydWU7XHJcbiAgfVxyXG5cclxuPC9zY3JpcHQ+XHJcblxyXG48ZGl2IGNsYXNzPVwidXRkLWJ0bi1tZW51XCIgYXJpYS1sYWJlbGxlZGJ5PVwie2lkVGl0cmVNZW51fVwiPlxyXG4gIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGlkPVwie2lkQm91dG9ufVwiIGNsYXNzPVwidXRkLWJ0biB7dHlwZX0gYXZlYy1pY29uZS1kcm9pdGVcIiBhcmlhLWV4cGFuZGVkPVwie2FmZmljaGVyID09PSAndHJ1ZScgPyAndHJ1ZScgOiBudWxsfVwiIGRpc2FibGVkPVwie2Rpc2FibGVkfVwiIGNsYXNzOmNvbXBhY3Q9e2NvbXBhY3QgPT09ICd0cnVlJ30gYXJpYS1oYXNwb3B1cD1cInRydWVcIiBhcmlhLWNvbnRyb2xzPVwie2lkU291c01lbnV9XCIgb246Y2xpY2t8cHJldmVudERlZmF1bHQ9e3RvZ2dsZUFmZmljaGVyfSBvbjprZXlkb3duPXtvbktleURvd259ID5cclxuICAgIDxzcGFuPntsaWJlbGxlfTwvc3Bhbj5cclxuICAgIDxzcGFuIGNsYXNzPVwidXRkLWljb25lLXN2ZyB7Y2xhc3NlSWNvbmV9XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9zcGFuPlxyXG4gIDwvYnV0dG9uPiAgXHJcblxyXG4gIDxkaXYgaWQ9XCJ7aWRTb3VzTWVudX1cIiBjbGFzczp2aXNpYmxlPXthZmZpY2hlciA9PT0gJ3RydWUnfSBjbGFzcz1cImNvbnRlbmV1ci1tZW51XCIgcm9sZT1cIm1lbnVcIiBhcmlhLWxhYmVsbGVkYnk9XCJ7aWRCb3V0b259XCI+XHJcbiAgICA8c2xvdD48L3Nsb3Q+XHJcbiAgPC9kaXY+XHJcblxyXG48L2Rpdj5cclxuPGxpbmsgcmVsPSdzdHlsZXNoZWV0JyBocmVmPSd7VXRpbHMuY3NzRnVsbFBhdGh9JyBvbjpsb2FkPVwie2Nzc0NoYXJnZX1cIj5cclxuXHJcbjxzdHlsZT5cclxuPC9zdHlsZT5cclxuXHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUF1S087In0= */'
	};
	function BoutonMenu($$anchor, $$props) {
	  check_target(this instanceof BoutonMenu ? this.constructor : void 0);
	  push($$props, false);
	  append_styles$1($$anchor, $$css$4);

	  /* PropriÃ©tÃ©s "publiques" */
	  var libelle = prop($$props, 'libelle', 12, 'Bouton');
	  var type = prop($$props, 'type', 12, 'secondaire' //Type du bouton
	  );
	  var compact = prop($$props, 'compact', 12, 'false' //Compact
	  );
	  var disabled = prop($$props, 'disabled', 12, false);

	  /* PropriÃ©tÃ©s "internes" */
	  var afficher = prop($$props, 'afficher', 12, 'false');
	  var focus = prop($$props, 'focus', 12, 'false');
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var idBouton = Utils.genererId();
	  var idSousMenu = Utils.genererId();
	  var idTitreMenu = Utils.genererId();
	  var controleBouton;
	  var mounted = false;
	  var estCssCharge = false;
	  var classeIcone = mutable_source(" triangle-bleu-piv");
	  var typesPossibles = ["primaire", "secondaire", "avertissement"];

	  // RÃ©fÃ©rences pour accessibilitÃ©
	  // https://www.w3.org/WAI/ARIA/apg/patterns/menu-button/examples/menu-button-actions/
	  onMount(function () {
	    window.location.hash.indexOf('bs-test') >= 0;
	    type(typesPossibles.includes(type()) ? type() : 'secondaire');
	    definirClasseIcone();
	    controleBouton = thisComponent().shadowRoot.getElementById(idBouton);

	    // ÃvÃ©nement nÃ©cessaire pour IOS... Car pour lui l'Ã©vÃ©nement blur de l'Ã©lÃ©ment de menu n'est pas exÃ©cutÃ©. Permet de s'assurer que lorsque le menu perd le focus, le menu est fermÃ©.    
	    document.body.addEventListener('click', function (e) {
	      if (strict_equals(afficher(), 'true')) {
	        if (strict_equals(e.target.closest('utd-btn-menu'), thisComponent(), false) || !document.activeElement || document.activeElement && strict_equals(document.activeElement.closest('utd-btn-menu'), thisComponent(), false)) {
	          afficher('false');
	        }
	      }
	    });
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    mounted = true;
	  });

	  // Watch sur la prop focus
	  function toggleFocus() {
	    if (strict_equals(focus(), 'true')) {
	      controleBouton.focus();
	      focus('false');
	    }
	  }
	  function definirClasseIcone() {
	    switch (type()) {
	      case 'primaire':
	      case 'avertissement':
	        set(classeIcone, 'triangle-blanc');
	        break;
	      default:
	        set(classeIcone, 'triangle-bleu-piv');
	    }
	  }
	  function toggleAfficher() {
	    afficher(strict_equals(afficher(), 'true') ? 'false' : 'true');
	    if (strict_equals(afficher(), 'true')) {
	      donnerFocusPremierElement();
	    }
	  }
	  function onKeyDown(e) {
	    switch (e.key) {
	      case "Escape":
	        afficher('false');
	        controleBouton.focus();
	        e.preventDefault();
	        break;
	      case "Enter":
	      case " ":
	        toggleAfficher();
	        e.preventDefault();
	        break;
	      case "ArrowUp":
	        afficher('true');
	        donnerFocusDernierElement();
	        e.preventDefault();
	        break;
	      case "ArrowDown":
	        afficher('true');
	        donnerFocusPremierElement();
	        e.preventDefault();
	        break;
	    }
	  }
	  function donnerFocusPremierElement() {
	    var element = thisComponent().querySelector('utd-btn-menu-item');
	    if (element) {
	      element.setAttribute('focus', 'true');
	    }
	  }
	  function donnerFocusDernierElement() {
	    var elements = thisComponent().querySelectorAll('utd-btn-menu-item');
	    if (!elements.length) {
	      return;
	    }
	    elements[elements.length - 1].setAttribute('focus', 'true');
	  }
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  legacy_pre_effect(function () {
	    return deep_read_state(focus());
	  }, function () {
	    toggleFocus(focus());
	  });
	  legacy_pre_effect_reset();
	  var $$exports = _objectSpread$m({
	    get libelle() {
	      return libelle();
	    },
	    set libelle($$value) {
	      libelle($$value);
	      flushSync();
	    },
	    get type() {
	      return type();
	    },
	    set type($$value) {
	      type($$value);
	      flushSync();
	    },
	    get compact() {
	      return compact();
	    },
	    set compact($$value) {
	      compact($$value);
	      flushSync();
	    },
	    get disabled() {
	      return disabled();
	    },
	    set disabled($$value) {
	      disabled($$value);
	      flushSync();
	    },
	    get afficher() {
	      return afficher();
	    },
	    set afficher($$value) {
	      afficher($$value);
	      flushSync();
	    },
	    get focus() {
	      return focus();
	    },
	    set focus($$value) {
	      focus($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$m();
	  var div = first_child(fragment);
	  var button = child(div);
	  var classes;
	  var span = child(button);
	  var text = child(span, true);
	  reset(span);
	  var span_1 = sibling(span, 2);
	  reset(button);
	  var div_1 = sibling(button, 2);
	  var classes_1;
	  var node = child(div_1);
	  slot(node, $$props, 'default', {});
	  reset(div_1);
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function ($0, $1) {
	    var _type, _$$get;
	    set_attribute(div, 'aria-labelledby', idTitreMenu);
	    set_attribute(button, 'id', idBouton);
	    classes = set_class(button, 1, "utd-btn ".concat((_type = type()) !== null && _type !== void 0 ? _type : '', " avec-icone-droite"), null, classes, $0);
	    set_attribute(button, 'aria-expanded', strict_equals(afficher(), 'true') ? 'true' : null);
	    button.disabled = disabled();
	    set_attribute(button, 'aria-controls', idSousMenu);
	    set_text(text, libelle());
	    set_class(span_1, 1, "utd-icone-svg ".concat((_$$get = get(classeIcone)) !== null && _$$get !== void 0 ? _$$get : ''));
	    set_attribute(div_1, 'id', idSousMenu);
	    classes_1 = set_class(div_1, 1, 'conteneur-menu', null, classes_1, $1);
	    set_attribute(div_1, 'aria-labelledby', idBouton);
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  }, [function () {
	    return {
	      compact: strict_equals(compact(), 'true')
	    };
	  }, function () {
	    return {
	      visible: strict_equals(afficher(), 'true')
	    };
	  }]);
	  event('click', button, preventDefault(toggleAfficher));
	  event('keydown', button, onKeyDown);
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-btn-menu', create_custom_element(BoutonMenu, {
	  libelle: {
	    attribute: 'libelle'
	  },
	  type: {
	    attribute: 'type'
	  },
	  compact: {
	    attribute: 'compact'
	  },
	  disabled: {
	    attribute: 'disabled',
	    type: 'Boolean'
	  },
	  afficher: {
	    attribute: 'afficher'
	  },
	  focus: {
	    attribute: 'focus'
	  },
	  thisComponent: {}
	}, ['default'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$m(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$l(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$l() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$l() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$l = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$l(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$l(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$l(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$l(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	BoutonMenuItem[FILENAME] = 'src/components/boutonMenuItem.svelte';
	var root_1$b = add_locations(from_html("<span class=\"utd-sr-only\"> </span>"), BoutonMenuItem[FILENAME], [[181, 6]]);
	var root$l = add_locations(from_html("<button type=\"button\" class=\"utd-btn-menu-item\" role=\"menuitem\" tabindex=\"-1\"><span><!></span> <!></button> <link rel=\"stylesheet\"/>", 1), BoutonMenuItem[FILENAME], [[178, 0, [[179, 4]]], [185, 0]]);
	function BoutonMenuItem($$anchor, $$props) {
	  check_target(this instanceof BoutonMenuItem ? this.constructor : void 0);
	  push($$props, false);

	  /* PropriÃ©tÃ©s "publiques" */
	  var libelle = prop($$props, 'libelle', 12, '');
	  var srTexte = prop($$props, 'srTexte', 12, '');

	  /* PropriÃ©tÃ©s "internes" */
	  var focus = prop($$props, 'focus', 12, 'false' //PrivÃ©
	  );
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var utdBoutonMenuParent;
	  var mounted = false;
	  var estCssCharge = false;
	  onMount(function () {
	    //Patch pour Vue js qui flush les attributs spÃ©cifiÃ©s dans le modÃ¨le (en les remplacants par des props). On remet nos attributs.
	    thisComponent().setAttribute('libelle', libelle());
	    thisComponent().setAttribute('sr-texte', srTexte());
	    utdBoutonMenuParent = thisComponent().closest('utd-btn-menu');
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    mounted = true;
	  });

	  // Watch sur la prop focus
	  function toggleFocus() {
	    if (strict_equals(focus(), 'true')) {
	      var element = thisComponent().shadowRoot.querySelector('.utd-btn-menu-item');
	      if (element) {
	        element.focus();
	      }
	      focus('false');
	    }
	    thisComponent().setAttribute('focus', 'false');
	  }
	  function obtenirElementsNiveauCourant() {
	    if (thisComponent()) {
	      var items = Array.from(thisComponent().parentElement.children).filter(function (enfant) {
	        return enfant.matches('utd-btn-menu-item:not(.utd-d-none)');
	      });
	      return items;
	    }
	    return null;
	  }
	  function onKeyDown(e) {
	    thisComponent().parentElement;
	    switch (e.key) {
	      case "Escape":
	        utdBoutonMenuParent.setAttribute('afficher', 'false');
	        utdBoutonMenuParent.setAttribute('focus', 'true');
	        e.preventDefault();
	        break;
	      case "ArrowUp":
	        donnerFocusElementPrecedent(obtenirElementsNiveauCourant());
	        e.preventDefault();
	        break;
	      case "ArrowDown":
	        donnerFocusElementSuivant(obtenirElementsNiveauCourant());
	        e.preventDefault();
	        break;
	      case "Home":
	        donnerFocusPremierElement(obtenirElementsNiveauCourant());
	        e.preventDefault();
	        break;
	      case "End":
	        donnerFocusDernierElement(obtenirElementsNiveauCourant());
	        e.preventDefault();
	        break;
	    }
	  }
	  function donnerFocusElementSuivant(elements) {
	    if (!elements.length) {
	      return;
	    }
	    var indexeCourant = elements.indexOf(thisComponent());
	    if (indexeCourant >= 0) {
	      if (strict_equals(indexeCourant, elements.length - 1)) {
	        elements[0].setAttribute('focus', 'true');
	      } else {
	        var prochainIndexe = indexeCourant + 1;
	        elements[prochainIndexe].setAttribute('focus', 'true');
	      }
	    } else {
	      elements[0].setAttribute('focus', 'true');
	    }
	  }
	  function donnerFocusDernierElement(elements) {
	    if (!elements.length) {
	      return;
	    }
	    elements[elements.length - 1].setAttribute('focus', 'true');
	  }
	  function donnerFocusPremierElement(elements) {
	    if (!elements.length) {
	      return;
	    }
	    elements[0].setAttribute('focus', 'true');
	  }
	  function donnerFocusElementPrecedent(elements) {
	    if (!elements.length) {
	      return;
	    }
	    var indexeCourant = elements.indexOf(thisComponent());
	    if (indexeCourant > 0) {
	      var prochainIndexe = indexeCourant - 1;
	      elements[prochainIndexe].setAttribute('focus', 'true');
	    } else {
	      elements[elements.length - 1].setAttribute('focus', 'true');
	    }
	  }
	  function onBlur(e) {
	    if (!utdBoutonMenuParent.contains(e.relatedTarget)) {
	      utdBoutonMenuParent.setAttribute('afficher', 'false');
	      if (strict_equals(e.relatedTarget, null)) {
	        utdBoutonMenuParent.setAttribute('focus', 'true');
	      }
	    }
	  }
	  function onMouseOver(e) {
	    e.currentTarget.focus();
	  }
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  legacy_pre_effect(function () {
	    return deep_read_state(focus());
	  }, function () {
	    toggleFocus(focus());
	  });
	  legacy_pre_effect_reset();
	  var $$exports = _objectSpread$l({
	    get libelle() {
	      return libelle();
	    },
	    set libelle($$value) {
	      libelle($$value);
	      flushSync();
	    },
	    get srTexte() {
	      return srTexte();
	    },
	    set srTexte($$value) {
	      srTexte($$value);
	      flushSync();
	    },
	    get focus() {
	      return focus();
	    },
	    set focus($$value) {
	      focus($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$l();
	  var button = first_child(fragment);
	  var span = child(button);
	  var node = child(span);
	  html(node, libelle);
	  reset(span);
	  var node_1 = sibling(span, 2);
	  {
	    var consequent = function consequent($$anchor) {
	      var span_1 = root_1$b();
	      var text = child(span_1);
	      reset(span_1);
	      template_effect(function () {
	        var _srTexte;
	        return set_text(text, "\xA0".concat((_srTexte = srTexte()) !== null && _srTexte !== void 0 ? _srTexte : ''));
	      });
	      append($$anchor, span_1);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_1, function ($$render) {
	        if (srTexte()) $$render(consequent);
	      });
	    }, 'if', BoutonMenuItem, 180, 4);
	  }
	  reset(button);
	  var link = sibling(button, 2);
	  template_effect(function () {
	    return set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('keydown', button, onKeyDown);
	  event('blur', button, onBlur);
	  event('mouseover', button, onMouseOver);
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-btn-menu-item', create_custom_element(BoutonMenuItem, {
	  libelle: {
	    attribute: 'libelle'
	  },
	  srTexte: {
	    attribute: 'sr-texte'
	  },
	  focus: {
	    attribute: 'focus'
	  },
	  thisComponent: {}
	}, [], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$l(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$k(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$k() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$k() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$k = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$k(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$k(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$k(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$k(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	ChampForm[FILENAME] = 'src/components/champForm.svelte';
	var root$k = add_locations(from_html("<!> <link rel=\"stylesheet\"/>", 1), ChampForm[FILENAME], [[796, 0]]);
	function ChampForm($$anchor, $$props) {
	  check_target(this instanceof ChampForm ? this.constructor : void 0);
	  push($$props, false);
	  var $$ownership_validator = create_ownership_validator($$props);

	  /* PropriÃ©tÃ©s "publiques" */
	  var obligatoire = prop($$props, 'obligatoire', 12, "false");
	  var invalide = prop($$props, 'invalide', 12, "false");
	  var format = prop($$props, 'format', 12, null);
	  var libelle = prop($$props, 'libelle', 12, "");
	  var precision = prop($$props, 'precision', 12, "");
	  var messageErreur = prop($$props, 'messageErreur', 12, "");
	  var bloquerColler = prop($$props, 'bloquerColler', 12, "false");
	  var maxCaracteres = prop($$props, 'maxCaracteres', 12, "0");
	  var hauteurAutomatique = prop($$props, 'hauteurAutomatique', 12, "false");

	  /* PropriÃ©tÃ©s "privÃ©es" */
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var mounted = false;
	  var estCssCharge = false;
	  var estTransformationCompletee = false;
	  var typeChamp = null;
	  var elementLabel = null;
	  var elementWrapper = null;
	  var elementIndicateurObligatoire = null;
	  var elementObligatoireTexte = null;
	  var elementChamp = null;
	  var elementPrecision = null;
	  var elementMaxCaracteres = null;
	  var elementErreur = null;
	  var idElementErreur = null;
	  var reaffectationClassEnCours = false;
	  var hauteurAutomatiqueActivee = false;
	  var maxCaracteresAncienneValeur = "0";
	  var estPageLangueFrancais = Utils.estPageLangueFrancais();
	  var idChamp = Utils.genererId();
	  var idParentUtd = Utils.genererId();
	  var idLabelInitial = Utils.genererId();
	  var idPrecisionInitial = Utils.genererId();
	  var idTexteAideMaxCaracteres = Utils.genererId();
	  var idErreurInitial = Utils.genererId();
	  var texteSrChampObligatoire = estPageLangueFrancais ? ' obligatoire ' : ' required ';

	  /* ===========================================================================================
	    RÃFÃRENCES
	  
	    - Liste de boutons radio et checkbox
	      https://blog.tenon.io/accessible-validation-of-checkbox-and-radiobutton-groups/
	  
	  
	    - Compteur de caractÃ¨res
	      https://designsystem.digital.gov/components/character-count/  
	  =============================================================================================*/
	  onMount(function () {
	    //Patch pour Vue js qui flush les attributs spÃ©cifiÃ©s dans le modÃ¨le (en les remplacants par des props). On remet nos attributs.
	    thisComponent().setAttribute('obligatoire', obligatoire());
	    typeChamp = obtenirTypeChamp();
	    mounted = true;
	    if (typeChamp) {
	      wrapperControles();
	      gererChamp();
	      gererLabel();
	      gererChampObligatoire();
	      gererInfobulle();
	      if (strict_equals(typeChamp, 'checkbox-seul', false)) {
	        gererPrecision();
	      }
	      gererHauteurAutomatique();
	      gererMaxCaracteres();
	      gererErreur();
	      observerAttributs();
	    }
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estTransformationCompletee = true;
	  });
	  function wrapperControles() {
	    var wrapper = thisComponent().querySelector('.utd-wrapper');
	    if (wrapper) {
	      elementWrapper = wrapper;
	      return;
	    }

	    //    elementWrapper = document.createElement('div') 
	    elementWrapper = thisComponent();
	    var classeType = strict_equals(typeChamp, 'checkbox-seul') ? 'checkbox' : typeChamp;
	    elementWrapper.classList.add('utd-form-group', 'utd-wrapper', classeType);

	    /*    const nbEnfants = thisComponent.childNodes.length
	        for (let i = 0; i < nbEnfants; i++) {
	    
	          const element = thisComponent.childNodes[0];
	          elementWrapper.append(element)  
	        }*/
	    if (strict_equals(typeChamp, 'radio')) {
	      elementWrapper.setAttribute('role', 'radiogroup');
	    }
	    if (strict_equals(typeChamp, 'checkbox')) {
	      elementWrapper.setAttribute('role', 'group');
	    }
	    if (format()) {
	      elementWrapper.classList.add(format());
	    }

	    //    thisComponent.prepend(elementWrapper)
	  }
	  function gererChamp() {
	    elementChamp.id = elementChamp.id || idChamp;
	    var idUtd = thisComponent().id || idParentUtd;
	    elementChamp.setAttribute('idutd', idUtd);
	    $$ownership_validator.mutation(null, ['thisComponent', 'id'], thisComponent(thisComponent().id = idUtd, true), 164, 4);
	    ajouterClassesChamp();
	    if (strict_equals(bloquerColler(), 'true') && strict_equals(typeChamp, 'standard')) {
	      bloquerCollerChamp();
	    }
	  }

	  /**
	   * On s'assure de mettre/remettre les classes requises sur le champ. Ex. Blazor rÃ©initalise les classes avec sa gestion d'erreurs... On veut donc remettre nos classes si elle ont Ã©tÃ© retirÃ©es pour que tout s'affiche correctement.
	   */
	  function ajouterClassesChamp() {
	    if (strict_equals(typeChamp, 'select') && strict_equals(elementChamp.parentElement.tagName.toLowerCase(), 'utd-liste-deroulante')) {
	      if (!elementChamp.classList.contains('utd-sr-only')) {
	        elementChamp.classList.add('utd-sr-only');
	      }
	      return;
	    }

	    //Ici on traite un champ standard OU un select natif (car nous avons traitÃ© les select de type utd-liste-deroulante juste avant)
	    if (strict_equals(typeChamp, 'standard') || strict_equals(typeChamp, 'select')) {
	      if (!elementChamp.classList.contains('utd-form-control')) {
	        elementChamp.classList.add('utd-form-control');
	      }
	      if (format()) {
	        if (!elementChamp.classList.contains(format())) {
	          elementChamp.classList.add(format());
	        }
	      }
	    }
	  }

	  /**
	   * EmpÃªcher le collage dans le champ.
	   */
	  function bloquerCollerChamp() {
	    elementChamp.addEventListener("paste", function (e) {
	      e.preventDefault();
	      return false;
	    });
	  }
	  function obtenirTypeChamp() {
	    var input = thisComponent().querySelector("input");
	    if (input) {
	      elementChamp = input;
	      var type = input.getAttribute("type");
	      if (strict_equals(format(), 'commutateur')) {
	        return format();
	      } else if (strict_equals(type, 'radio')) {
	        return type;
	      } else if (strict_equals(type, 'checkbox')) {
	        return thisComponent().querySelectorAll("input").length > 1 ? 'checkbox' : 'checkbox-seul';
	      } else if (strict_equals(type, 'button') || strict_equals(type, 'submit')) {
	        return null;
	      } else {
	        return 'standard';
	      }
	    } else if (thisComponent().querySelector("textarea")) {
	      elementChamp = thisComponent().querySelector("textarea");
	      return 'standard';
	    } else if (thisComponent().querySelector("select")) {
	      elementChamp = thisComponent().querySelector("select");
	      return 'select';
	    } else {
	      return null;
	    }
	  }
	  function gererLabel() {
	    if (!mounted) {
	      return;
	    }
	    if (estGroupeControles()) {
	      elementLabel = thisComponent().querySelector(".label");
	    } else {
	      elementLabel = thisComponent().querySelector("label");
	    }
	    if (elementLabel) {
	      //Le label existe dÃ©jÃ . On s'assure qu'il est bien liÃ© au champ.
	      if (estGroupeControles()) {
	        if (!elementLabel.id) {
	          elementLabel.id = idLabelInitial;
	        }
	        ajusterChampAriaDescribedBy('ajout', elementLabel.id);
	      } else {
	        elementLabel.setAttribute('for', elementChamp.id);
	      }
	      if (libelle()) {
	        elementLabel.innerText = libelle();
	      }
	    } else if (libelle()) {
	      //Le contrÃ´le label n'existe pas      
	      var element;
	      if (estGroupeControles()) {
	        element = document.createElement('span');
	        element.classList.add('label');
	        element.id = idLabelInitial;
	        ajusterChampAriaDescribedBy('ajout', element.id, strict_equals(typeChamp, 'radio') ? 'aria-labelledby' : null);
	      } else {
	        element = document.createElement('label');
	        element.setAttribute('for', elementChamp.id);
	      }
	      element.innerText = libelle();
	      elementWrapper.prepend(element);
	      elementLabel = element;
	    }
	    definirClasseDisabledLabelEtPrecision();
	  }
	  function gererPrecision() {
	    if (!mounted) {
	      return;
	    }
	    if (elementLabel) {
	      elementPrecision = thisComponent().querySelector(".utd-precision");
	      if (precision()) {
	        if (elementPrecision) {
	          elementPrecision.id = elementPrecision.id || idPrecisionInitial;
	        } else {
	          var span = document.createElement('span');
	          span.classList.add("utd-precision", "utd");
	          span.id = idPrecisionInitial;
	          elementPrecision = span;
	          elementLabel.after(elementPrecision);
	        }
	        elementPrecision.innerText = precision();
	        ajusterChampAriaDescribedBy('ajout', elementPrecision.id);
	      } else {
	        //Pas de prÃ©cision en paramÃ¨tre
	        if (elementPrecision) {
	          if (elementPrecision.classList.contains('utd')) {
	            //Il s'agit d'une prÃ©cision gÃ©nÃ©rÃ©e par utd, on doit la retirer puisque l'attribut precision n'est plus lÃ .
	            ajusterChampAriaDescribedBy('retrait', idPrecisionInitial);
	            elementPrecision.remove();
	          } else {
	            //ContrÃ´le prÃ©cision dans le HTML on gÃ¨re son id et on ajoute le lien avec aria-describedby
	            elementPrecision.id = elementPrecision.id || idPrecisionInitial;
	            ajusterChampAriaDescribedBy('ajout', elementPrecision.id);
	          }
	        } else {
	          //Pas de contrÃ´le de prÃ©cision dans le html, on retire la prÃ©cision du aria-describedby
	          ajusterChampAriaDescribedBy('retrait', idPrecisionInitial);
	        }
	      }
	      definirClasseDisabledLabelEtPrecision();
	    }
	  }
	  function ajusterChampAriaDescribedBy() {
	    var operation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'ajout';
	    var valeur = arguments.length > 1 ? arguments[1] : undefined;
	    var aria = arguments.length > 2 ? arguments[2] : undefined;
	    var attribut;
	    if (aria) {
	      attribut = aria;
	    } else {
	      attribut = strict_equals(typeChamp, 'checkbox') ? 'aria-labelledby' : 'aria-describedby';
	    }
	    var controle = elementChamp;
	    if (estGroupeControles()) {
	      controle = elementWrapper;
	    }
	    var valeurActuelle = controle.getAttribute(attribut) || '';
	    var nouvelleValeur = '';
	    if (strict_equals(operation, 'ajout')) {
	      nouvelleValeur = valeurActuelle + (valeurActuelle.indexOf(valeur) >= 0 ? '' : ' ' + valeur);
	    } else {
	      nouvelleValeur = valeurActuelle.replace(valeur, '');
	    }
	    if (nouvelleValeur.trim()) {
	      controle.setAttribute(attribut, nouvelleValeur.trim());
	    } else {
	      controle.removeAttribute(attribut);
	    }
	  }
	  function gererChampObligatoire() {
	    if (!mounted) {
	      return;
	    }
	    if (elementLabel) {
	      elementIndicateurObligatoire = thisComponent().querySelector(".utd-icone-champ-requis");
	      elementObligatoireTexte = thisComponent().querySelector(".texte-obligatoire");
	      if (strict_equals(obligatoire(), 'true')) {
	        if (strict_equals(typeChamp, 'checkbox')) {
	          //Pour les listes de checkbox, on doit ajouter un texte hors Ã©cran afin d'indiquer que le champ est obligatoire (aria-required ne fonctionne pas pour ces types de champs).
	          elementObligatoireTexte = thisComponent().querySelector(".texte-obligatoire");
	          if (!elementObligatoireTexte) {
	            elementObligatoireTexte = document.createElement('span');
	            elementObligatoireTexte.classList.add("texte-obligatoire", "utd-sr-only");
	            elementObligatoireTexte.innerHTML = texteSrChampObligatoire;
	            elementLabel.append(elementObligatoireTexte);
	          }
	        }
	        if (!elementIndicateurObligatoire) {
	          elementIndicateurObligatoire = document.createElement('span');
	          elementIndicateurObligatoire.classList.add("utd-icone-champ-requis");
	          elementIndicateurObligatoire.innerHTML = "*";
	          if (strict_equals(typeChamp, 'checkbox-seul')) {
	            var spanTexteLabel = elementLabel.querySelector('span');
	            if (spanTexteLabel) {
	              spanTexteLabel.append(elementIndicateurObligatoire);
	            } else {
	              elementLabel.append(elementIndicateurObligatoire);
	            }
	          } else {
	            elementLabel.append(elementIndicateurObligatoire);
	          }
	        }
	        elementIndicateurObligatoire.setAttribute('aria-hidden', 'true');
	      } else {
	        if (elementIndicateurObligatoire) {
	          elementIndicateurObligatoire.remove();
	        }
	        if (elementObligatoireTexte) {
	          elementObligatoireTexte.remove();
	        }
	      }
	    }
	    if (strict_equals(obligatoire(), 'true') && strict_equals(typeChamp, 'checkbox', false)) {
	      if (strict_equals(typeChamp, 'radio')) {
	        elementWrapper.setAttribute('aria-required', 'true');
	      } else {
	        elementChamp.setAttribute('aria-required', 'true');
	      }
	    } else {
	      if (strict_equals(typeChamp, 'radio')) {
	        elementWrapper.removeAttribute('aria-required');
	      } else {
	        elementChamp.removeAttribute('aria-required');
	      }
	    }
	  }
	  function gererInfobulle() {
	    if (!mounted) {
	      return;
	    }
	    if (elementLabel) {
	      var elementInfobulle = thisComponent().querySelector("utd-infobulle");
	      if (elementInfobulle) {
	        if (strict_equals(elementInfobulle.parentElement, elementLabel)) {
	          if (strict_equals(typeChamp, 'checkbox-seul')) {
	            var spanTexteLabel = elementLabel.querySelector('span');
	            if (spanTexteLabel) {
	              spanTexteLabel.append(elementInfobulle);
	              return;
	            }
	          }
	        }
	        elementLabel.appendChild(elementInfobulle);
	      }
	    }
	  }
	  function gererErreur() {
	    if (!mounted) {
	      return;
	    }
	    var controle = elementChamp;
	    if (estGroupeControles()) {
	      controle = elementWrapper;
	    }
	    var wrapperChampsCombines = thisComponent().closest('.utd-groupe-champs-combines');
	    if (wrapperChampsCombines) {
	      elementErreur = document.getElementById(idErreurInitial);
	    } else {
	      elementErreur = thisComponent().querySelector(".utd-erreur-champ");
	    }
	    if (strict_equals(invalide(), 'true')) {
	      if (elementErreur) {
	        elementErreur.id = elementErreur.id || idErreurInitial;
	      } else {
	        var span = document.createElement('span');
	        span.classList.add("utd-erreur-champ");
	        span.id = idErreurInitial;
	        elementErreur = span;
	        if (wrapperChampsCombines) {
	          wrapperChampsCombines.append(elementErreur);
	        } else {
	          elementWrapper.append(elementErreur);
	        }
	      }
	      if (messageErreur()) {
	        elementErreur.innerText = messageErreur();
	      }
	      idElementErreur = elementErreur.id;
	      var attribut = strict_equals(typeChamp, 'checkbox') ? 'aria-labelledby' : 'aria-describedby';

	      //On conserve la valeur du aria-describedby avant la maj en lui retirant l'id de l'Ã©lÃ©ment en erreur (Ã©vite d'avoir l'id du champ plusieurs fois dans l'attribut)
	      var descByAvant = controle.getAttribute(attribut) ? controle.getAttribute(attribut).replace(elementErreur.id, '') : null;
	      controle.setAttribute(attribut, elementErreur.id);
	      if (strict_equals(typeChamp, 'checkbox', false)) {
	        controle.setAttribute('aria-invalid', 'true');
	      }

	      //setTimeout nÃ©cessaire pour lecteur Ã©cran
	      if (descByAvant) {
	        setTimeout(function () {
	          controle.setAttribute(attribut, "".concat(descByAvant, " ").concat(idElementErreur));
	        }, 100);
	      }
	      elementErreur.classList.remove('utd-d-none');
	    } else {
	      controle.removeAttribute('aria-invalid');
	      if (elementErreur) {
	        if (wrapperChampsCombines) {
	          elementErreur.remove();
	        } else {
	          elementErreur.classList.add('utd-d-none');
	          if (messageErreur()) {
	            elementErreur.innerText = messageErreur();
	          }
	        }
	      }
	      if (idElementErreur) {
	        setTimeout(function () {
	          ajusterChampAriaDescribedBy('retrait', idElementErreur);
	        }, 100);
	      }
	    }
	  }
	  function gererErreurDelayee() {
	    if (!mounted) {
	      return;
	    }
	    var delaiMs = obtenirDelaiAffichageErreurs();
	    if (delaiMs) {
	      setTimeout(function () {
	        gererErreur();
	      }, delaiMs);
	    } else {
	      gererErreur();
	    }
	  }
	  function obtenirDelaiAffichageErreurs() {
	    var parent = elementChamp.closest('[data-delai-affichage-erreurs]');
	    var valeurDelai = parent ? parent.getAttribute('data-delai-affichage-erreurs') : null;
	    var delaiMs = parseInt(valeurDelai, 10);

	    // VÃ©rifier que câest bien un nombre valide
	    if (!isNaN(delaiMs)) {
	      return delaiMs;
	    }

	    //Si l'attribut data-delai-affichage-erreurs est prÃ©sent mais qu'aucune valeur n'est spÃ©cifiÃ©e ou que c'est une valeur invalide, on utilise la valeur par dÃ©faut 100
	    return parent ? 100 : null;
	  }
	  function gererHauteurAutomatique() {
	    if (!mounted || !elementChamp || strict_equals(elementChamp.tagName.toLowerCase(), 'textarea', false) || strict_equals(hauteurAutomatique(), 'refresh')) {
	      if (strict_equals(hauteurAutomatique(), 'refresh')) {
	        //On remet l'ancienne valeur hauteur-automatique, ce qui va provoquer un update de l'affichage
	        setTimeout(function () {
	          thisComponent().setAttribute('hauteur-automatique', 'true');
	        });
	      }
	      return;
	    }
	    if (strict_equals(hauteurAutomatique(), "true")) {
	      if (!hauteurAutomatiqueActivee) {
	        elementChamp.addEventListener('input', definirHauteurTextArea);

	        //NOTE J'ai tentÃ© de dÃ©tecter un changement dans le modÃ¨le de donnÃ©es via un change et Ã§a ne fonctionne pas... Il faudra trouver quelque chose pour Ã§a. Peut-Ãªtre l'ajout d'un attribut refresh.        
	      }
	      definirHauteurTextArea();
	      hauteurAutomatiqueActivee = true;
	    } else if (hauteurAutomatiqueActivee && !hauteurAutomatique()) {
	      elementChamp.removeEventListener("input", definirHauteurTextArea);
	      elementChamp.removeEventListener("change", definirHauteurTextArea);
	      elementChamp.removeAttribute('style');
	      hauteurAutomatiqueActivee = false;
	    }
	  }
	  function definirHauteurTextArea() {
	    elementChamp.style.height = 'auto';
	    var offset = elementChamp.offsetHeight - elementChamp.clientHeight;
	    elementChamp.style.height = elementChamp.scrollHeight + offset + 'px';
	  }
	  function gererMaxCaracteres() {
	    if (!mounted || !elementChamp || strict_equals(elementChamp.tagName.toLowerCase(), 'textarea', false) || strict_equals(maxCaracteres(), 'refresh')) {
	      if (strict_equals(maxCaracteres(), 'refresh')) {
	        definirNotificationLecteurEcranMaxCar('');

	        //On remet l'ancienne valeur max-caracteres, ce qui va provoquer un update de l'affichage
	        setTimeout(function () {
	          thisComponent().setAttribute('max-caracteres', maxCaracteresAncienneValeur);
	        });
	      }
	      return;
	    }
	    if (maxCaracteres() && strict_equals(maxCaracteres(), "0", false)) {
	      //TODO vÃ©rifier si numÃ©rique
	      if (!elementMaxCaracteres) {
	        creerElementMaxCaracteres();
	        elementChamp.addEventListener('input', definirTexteNbMaxCaracteresEtTexteLecteurEcran);

	        //NOTE J'ai tentÃ© de dÃ©tecter un changement dans le modÃ¨le de donnÃ©es via un change et Ã§a ne fonctionne pas... Il faudra trouver quelque chose pour Ã§a. Peut-Ãªtre l'ajout d'un attribut refresh.
	      }
	      definirTexteNbMaxCaracteres();
	    } else if (elementMaxCaracteres) {
	      elementMaxCaracteres.remove();
	      elementChamp.removeEventListener('input', definirTexteNbMaxCaracteresEtTexteLecteurEcran);
	      elementMaxCaracteres = null;
	    }
	    maxCaracteresAncienneValeur = maxCaracteres();
	  }
	  function definirTexteNbMaxCaracteres() {
	    var nbCaracteres = elementChamp.value.length || 0;
	    var nbMaxCaracteres = parseInt(maxCaracteres());

	    //On double la longueur caculÃ©e pour les sauts de ligne afin d'Ã©viter des problÃ¨mes de longueur max cÃ´tÃ© serveur avec des conversions '\r\n'
	    var nbSautsLignes = (elementChamp.value || '').match(/\n/g);
	    nbCaracteres = nbSautsLignes ? nbCaracteres + nbSautsLignes.length : nbCaracteres;
	    if (nbCaracteres > nbMaxCaracteres) {
	      elementMaxCaracteres.classList.add('utd-max-car-depasse');
	    } else {
	      elementMaxCaracteres.classList.remove('utd-max-car-depasse');
	    }
	    var controleTexteMaxCaracteres = elementMaxCaracteres.querySelector('.utd-texte-max-caracteres');
	    var texteMaxCaracteres = obtenirTexteMaximumCaracteres(nbMaxCaracteres, nbCaracteres);
	    controleTexteMaxCaracteres.innerText = texteMaxCaracteres;
	    return texteMaxCaracteres;
	  }
	  function definirTexteNbMaxCaracteresEtTexteLecteurEcran() {
	    var texteMaxCaracteres = definirTexteNbMaxCaracteres();
	    definirNotificationLecteurEcranMaxCarDebounced(texteMaxCaracteres);
	  }
	  function creerElementMaxCaracteres() {
	    if (!elementMaxCaracteres) {
	      var nbMaxCaracteres = parseInt(maxCaracteres());
	      elementMaxCaracteres = document.createElement('div');
	      var htmlContenuMaxCaracteres = "<span class=\"utd-texte-aide-max-caracteres utd-sr-only\"></span>\n         <span class=\"utd-texte-max-caracteres\" aria-hidden=\"true\"></span>\n         <span class=\"utd-sr-only utd-notification-sr-max-car\" aria-live=\"polite\"></span>  \n        ";
	      elementMaxCaracteres.classList.add('utd-max-caracteres');
	      elementMaxCaracteres.innerHTML = htmlContenuMaxCaracteres;
	      var controleTexteAideMaxCaracteres = elementMaxCaracteres.querySelector('.utd-texte-aide-max-caracteres');
	      controleTexteAideMaxCaracteres.id = idTexteAideMaxCaracteres;
	      controleTexteAideMaxCaracteres.innerText = obtenirTexteAideNbCaracteres(nbMaxCaracteres);
	      ajusterChampAriaDescribedBy('ajout', controleTexteAideMaxCaracteres.id);
	      elementChamp.after(elementMaxCaracteres);
	    }
	  }
	  var definirNotificationLecteurEcranMaxCarDebounced = Utils.debounce(function (texteMaxCaracteres) {
	    return definirNotificationLecteurEcranMaxCar(texteMaxCaracteres);
	  });
	  function definirNotificationLecteurEcranMaxCar(texte) {
	    var conteneurNotification = elementMaxCaracteres.querySelector('.utd-notification-sr-max-car');
	    conteneurNotification.innerText = texte;
	  }
	  function obtenirTexteAideNbCaracteres(nbMaxCaracteres) {
	    if (estPageLangueFrancais) {
	      return "Il s'agit d'un contr\xF4le avec un compteur de caract\xE8res. Vous pouvez saisir jusqu'\xE0 ".concat(nbMaxCaracteres, " caract\xE8res.");
	    } else {
	      return "This is an input with a character counter. You can enter up to ".concat(nbMaxCaracteres, " characters.");
	    }
	  }
	  function obtenirTexteMaximumCaracteres(nbMaxCaracteres, nbCaracteres) {
	    var caracteresRestants = nbMaxCaracteres - nbCaracteres;
	    if (strict_equals(nbCaracteres, 0)) {
	      if (estPageLangueFrancais) {
	        return "Maximum ".concat(maxCaracteres(), " caract\xE8res");
	      } else {
	        return "".concat(maxCaracteres(), " characters allowed");
	      }
	    } else if (caracteresRestants < 0) {
	      var pluriel = caracteresRestants < -1 ? 's' : '';
	      if (estPageLangueFrancais) {
	        return "".concat(caracteresRestants * -1, " caract\xE8re").concat(pluriel, " en trop");
	      } else {
	        return "".concat(caracteresRestants * -1, " character").concat(pluriel, " over limit");
	      }
	    } else {
	      var _pluriel = caracteresRestants > 1 ? 's' : '';
	      if (estPageLangueFrancais) {
	        return "".concat(caracteresRestants * 1, " caract\xE8re").concat(_pluriel, " restant").concat(_pluriel);
	      } else {
	        return "".concat(caracteresRestants * 1, " character").concat(_pluriel, " left");
	      }
	    }
	  }
	  function estGroupeControles() {
	    return strict_equals(typeChamp, 'checkbox') || strict_equals(typeChamp, 'radio');
	  }
	  function observerAttributs() {
	    var observer = new MutationObserver(function (mutations) {
	      //Pour le moment on gÃ¨re seulement un changement de l'attribut class
	      mutations.forEach(function (mutation) {
	        var nomAttribut = mutation.attributeName;

	        //        const nouvelleValeur = mutation.target.getAttribute(nomAttribut)
	        if (strict_equals(nomAttribut, 'class')) {
	          if (!reaffectationClassEnCours) {
	            reaffectationClassEnCours = true;

	            //On s'assure de remettre les classes requises sur le champ. Ex. Blazor rÃ©initalise les classes avec sa gestion d'erreurs... On veut donc remettre nos classes si elle ont Ã©tÃ© retirÃ©es pour que tout s'affiche correctement.
	            ajouterClassesChamp();
	            setTimeout(function () {
	              reaffectationClassEnCours = false;
	            });
	          }
	        } else {
	          definirClasseDisabledLabelEtPrecision();
	        }
	      });
	    });
	    observer.observe(elementChamp, {
	      attributeFilter: ['class', 'disabled']
	    });
	  }
	  function definirClasseDisabledLabelEtPrecision() {
	    if (!elementChamp) {
	      return;
	    }
	    if (strict_equals(elementChamp.getAttribute('disabled'), null, false)) {
	      var _elementLabel, _elementPrecision;
	      //L'attribut disabled est prÃ©sent
	      (_elementLabel = elementLabel) === null || _elementLabel === void 0 || _elementLabel.classList.add('utd-disabled');
	      (_elementPrecision = elementPrecision) === null || _elementPrecision === void 0 || _elementPrecision.classList.add('utd-disabled');
	    } else {
	      var _elementLabel2, _elementPrecision2;
	      //L'attribut disabled est absent
	      (_elementLabel2 = elementLabel) === null || _elementLabel2 === void 0 || _elementLabel2.classList.remove('utd-disabled');
	      (_elementPrecision2 = elementPrecision) === null || _elementPrecision2 === void 0 || _elementPrecision2.classList.remove('utd-disabled');
	    }
	  }
	  function cssCharge(e) {
	    if (estTransformationCompletee) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  legacy_pre_effect(function () {
	    return deep_read_state(libelle());
	  }, function () {
	    gererLabel(libelle());
	  });
	  legacy_pre_effect(function () {
	    return deep_read_state(obligatoire());
	  }, function () {
	    gererChampObligatoire(obligatoire());
	  });
	  legacy_pre_effect(function () {
	    return deep_read_state(precision());
	  }, function () {
	    gererPrecision(precision());
	  });
	  legacy_pre_effect(function () {
	    return deep_read_state(maxCaracteres());
	  }, function () {
	    gererMaxCaracteres(maxCaracteres());
	  });
	  legacy_pre_effect(function () {
	    return deep_read_state(hauteurAutomatique());
	  }, function () {
	    gererHauteurAutomatique(hauteurAutomatique());
	  });
	  legacy_pre_effect(function () {
	    return deep_read_state(messageErreur());
	  }, function () {
	    gererErreurDelayee(messageErreur());
	  });
	  legacy_pre_effect(function () {
	    return deep_read_state(invalide());
	  }, function () {
	    gererErreurDelayee(invalide());
	  });
	  legacy_pre_effect_reset();
	  var $$exports = _objectSpread$k({
	    get obligatoire() {
	      return obligatoire();
	    },
	    set obligatoire($$value) {
	      obligatoire($$value);
	      flushSync();
	    },
	    get invalide() {
	      return invalide();
	    },
	    set invalide($$value) {
	      invalide($$value);
	      flushSync();
	    },
	    get format() {
	      return format();
	    },
	    set format($$value) {
	      format($$value);
	      flushSync();
	    },
	    get libelle() {
	      return libelle();
	    },
	    set libelle($$value) {
	      libelle($$value);
	      flushSync();
	    },
	    get precision() {
	      return precision();
	    },
	    set precision($$value) {
	      precision($$value);
	      flushSync();
	    },
	    get messageErreur() {
	      return messageErreur();
	    },
	    set messageErreur($$value) {
	      messageErreur($$value);
	      flushSync();
	    },
	    get bloquerColler() {
	      return bloquerColler();
	    },
	    set bloquerColler($$value) {
	      bloquerColler($$value);
	      flushSync();
	    },
	    get maxCaracteres() {
	      return maxCaracteres();
	    },
	    set maxCaracteres($$value) {
	      maxCaracteres($$value);
	      flushSync();
	    },
	    get hauteurAutomatique() {
	      return hauteurAutomatique();
	    },
	    set hauteurAutomatique($$value) {
	      hauteurAutomatique($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$k();
	  var node = first_child(fragment);
	  slot(node, $$props, 'default', {});
	  var link = sibling(node, 2);
	  template_effect(function () {
	    return set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-champ-form', create_custom_element(ChampForm, {
	  obligatoire: {
	    attribute: 'obligatoire'
	  },
	  invalide: {
	    attribute: 'invalide'
	  },
	  format: {
	    attribute: 'format'
	  },
	  libelle: {
	    attribute: 'libelle'
	  },
	  precision: {
	    attribute: 'precision'
	  },
	  messageErreur: {
	    attribute: 'message-erreur'
	  },
	  bloquerColler: {
	    attribute: 'bloquer-coller'
	  },
	  maxCaracteres: {
	    attribute: 'max-caracteres'
	  },
	  hauteurAutomatique: {
	    attribute: 'hauteur-automatique'
	  },
	  thisComponent: {}
	}, ['default'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$k(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$j(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$j() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$j() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$j = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$j(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$j(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$j(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$j(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	ConsulterAussi[FILENAME] = 'src/components/consulterAussi.svelte';
	var root_1$a = add_locations(from_html("<span class=\"liens\"><!></span>"), ConsulterAussi[FILENAME], [[59, 4]]);
	var root_2$9 = add_locations(from_html("<span class=\"documents\"><!></span>"), ConsulterAussi[FILENAME], [[64, 4]]);
	var root$j = add_locations(from_html("<div class=\"utd-component utd-consulter-aussi\"><h2 class=\"titre\"> </h2> <!> <!></div> <link rel=\"stylesheet\"/>", 1), ConsulterAussi[FILENAME], [[54, 0, [[55, 2]]], [70, 0]]);
	function ConsulterAussi($$anchor, $$props) {
	  check_target(this instanceof ConsulterAussi ? this.constructor : void 0);
	  var $$slots = sanitize_slots($$props);
	  push($$props, false);

	  /* PropriÃ©tÃ©s "publiques" */
	  /* PropriÃ©tÃ©s "internes" */
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var titre = Utils.estPageLangueFrancais() ? "\xC0 consulter aussi" : "See also";
	  var mounted = mutable_source(false);
	  var estCssCharge = false;
	  var estLiensPresents = mutable_source(false);
	  onMount(function () {
	    var _thisComponent$queryS, _thisComponent$queryS2;
	    set(estLiensPresents, !!((_thisComponent$queryS = thisComponent().querySelector("[slot=liens]")) !== null && _thisComponent$queryS !== void 0 && _thisComponent$queryS.innerHTML));
	    !!((_thisComponent$queryS2 = thisComponent().querySelector("[slot=documents]")) !== null && _thisComponent$queryS2 !== void 0 && _thisComponent$queryS2.innerHTML);
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    set(mounted, true);
	  });
	  function cssCharge(e) {
	    if (get(mounted)) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  var $$exports = _objectSpread$j({
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$j();
	  var div = first_child(fragment);
	  var h2 = child(div);
	  var text = child(h2, true);
	  reset(h2);
	  var node = sibling(h2, 2);
	  {
	    var consequent = function consequent($$anchor) {
	      var span = root_1$a();
	      var node_1 = child(span);
	      slot(node_1, $$props, 'liens', {});
	      reset(span);
	      append($$anchor, span);
	    };
	    add_svelte_meta(function () {
	      return if_block(node, function ($$render) {
	        if (get(estLiensPresents)) $$render(consequent);
	      });
	    }, 'if', ConsulterAussi, 58, 2);
	  }
	  var node_2 = sibling(node, 2);
	  {
	    var consequent_1 = function consequent_1($$anchor) {
	      var span_1 = root_2$9();
	      var node_3 = child(span_1);
	      slot(node_3, $$props, 'documents', {});
	      reset(span_1);
	      append($$anchor, span_1);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_2, function ($$render) {
	        if (get(mounted), untrack(function () {
	          return $$slots["documents"] && get(mounted);
	        })) $$render(consequent_1);
	      });
	    }, 'if', ConsulterAussi, 63, 2);
	  }
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function () {
	    set_text(text, titre);
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-consulter-aussi', create_custom_element(ConsulterAussi, {
	  thisComponent: {}
	}, ['liens', 'documents'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$j(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$i(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$i() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$i() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$i = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$i(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$i(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$i(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$i(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	DialogueModal[FILENAME] = 'src/components/dialogueModal.svelte';
	var root_2$8 = add_locations(from_html("<span aria-hidden=\"true\"></span>"), DialogueModal[FILENAME], [[303, 12]]);
	var root_3$8 = add_locations(from_html("<div class=\"pied\"><!></div>"), DialogueModal[FILENAME], [[314, 10]]);
	var root_1$9 = add_locations(from_html("<div class=\"utd-backdrop\"></div> <div aria-modal=\"true\" role=\"dialog\" tabindex=\"-1\"><div class=\"conteneur\"><button type=\"button\" class=\"close\"><span aria-hidden=\"true\" class=\"utd-icone-svg x-fermer-bleu-piv\"></span></button> <div class=\"principal\"><div><!> <h1 class=\"titre-dialog\"> </h1></div> <div class=\"corps\"><!> <!></div> <!></div></div></div>", 1), DialogueModal[FILENAME], [[270, 2], [271, 2, [[288, 2, [[289, 8, [[295, 8]]], [300, 6, [[301, 8, [[305, 10]]], [309, 8]]]]]]]]);
	var root$i = add_locations(from_html("<!> <link rel=\"stylesheet\"/>", 1), DialogueModal[FILENAME], [[323, 0]]);
	function DialogueModal($$anchor, $$props) {
	  check_target(this instanceof DialogueModal ? this.constructor : void 0);
	  push($$props, false);

	  /* PropriÃ©tÃ©s "publiques" */
	  var afficher = prop($$props, 'afficher', 12, 'false');
	  var type = prop($$props, 'type', 12, '');
	  var estfenetremessage = prop($$props, 'estfenetremessage', 12, 'false' //PrivÃ©e (utilisÃ©e dans notre plugin message)
	  );
	  var raisonFermeture = prop($$props, 'raisonFermeture', 12, '' //PrivÃ©e (utilisÃ©e dans notre plugin message)
	  );
	  var titre = prop($$props, 'titre', 12, '');
	  var srBoutonFermer = prop($$props, 'srBoutonFermer', 28, function () {
	    return Utils.estPageLangueFrancais() ? "Fermer" : "Close";
	  });
	  var idFocusOuverture = prop($$props, 'idFocusOuverture', 12, '');
	  var idFocusFermeture = prop($$props, 'idFocusFermeture', 12, '');
	  var boutonsTexteLong = prop($$props, 'boutonsTexteLong', 12, 'false');
	  var forcerBoutonsInline = prop($$props, 'forcerBoutonsInline', 12, 'false');
	  var affichageLateral = prop($$props, 'affichageLateral', 12, 'false');

	  /* PropriÃ©tÃ©s "privÃ©es" */
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var idModale = Utils.genererId();
	  var idEntete = Utils.genererId();
	  var idCorps = Utils.genererId();
	  var dureeMsAnimationOuverture = 250;
	  var dureeMsAnimationFermeture = 250;
	  var estModaleAffichee = mutable_source(strict_equals(afficher(), 'true'));
	  var html;
	  var body;
	  var slots = mutable_source([]);
	  var mounted = false;
	  var controleActifOuverture = null;
	  onMount(function () {
	    html = thisComponent().getRootNode().getElementsByTagName("html")[0];
	    body = thisComponent().getRootNode().getElementsByTagName("body")[0];
	    set(slots, Array.from(thisComponent().querySelectorAll('[slot]')));
	    mounted = true;
	  });

	  // Watch sur la prop afficher
	  function masquerModale(raisonFermetureModale) {
	    set(estModaleAffichee, false);
	    afficher('false');
	    thisComponent().setAttribute('afficher', 'false');

	    //Si une raison de fermeture est reÃ§ue en param, on l'utilise sinon on prend la raison de fermeture qui est sur la modale "raisonFermeture" qui va contenir une raison de fermeture externe Ã  la modale (ex. clic sur bouton primaire ou secondaire)
	    var raison = raisonFermetureModale || raisonFermeture();
	    Utils.dispatchWcEvent(thisComponent(), "fermeture", {
	      raisonFermeture: raison
	    });
	  }
	  function animationAffichageOuverture(node) {
	    return strict_equals(affichageLateral(), 'false') ? fade(node, {
	      duration: dureeMsAnimationOuverture
	    }) : fly(node, {
	      x: 200,
	      duration: dureeMsAnimationOuverture
	    });
	  }
	  function animationAffichageFermeture(node) {
	    return strict_equals(affichageLateral(), 'false') ? fade(node, {
	      duration: dureeMsAnimationFermeture
	    }) : fly(node, {
	      x: 200,
	      duration: dureeMsAnimationFermeture
	    });
	  }

	  // ExÃ©cutÃ© lorsque la valeur de la prop "afficher" change
	  function toggleAfficher() {
	    if (mounted) {
	      if (strict_equals(afficher(), 'true')) {
	        if (!idFocusFermeture()) {
	          if (document.activeElement) {
	            controleActifOuverture = document.activeElement;
	          }
	        }
	        raisonFermeture('');
	        Utils.ajusterInterfaceAvantAffichageModale(html, body);
	        set(estModaleAffichee, true);
	        gererHauteurAutomatiqueControles();
	        gererNbCaracteresRestantsControles();
	      } else {
	        if (get(estModaleAffichee)) {
	          masquerModale();
	        }
	      }
	    }
	  }

	  /**
	   * Permet de bien gÃ©rer la hauteur automatique sur les contrÃ´les utd-champ-form (textarea) lorsqu'ils sont dans un dialogue. 
	   * Le dialogue est souvent en display none, donc quand le contrÃ´le est rendu, il ne prend aucun espace, le calcul de la hauteur est donc Ã©ronnÃ©.
	   * On s'assure donc de forcer la rÃ©assignation de la hauteur requise une fois la modale affichÃ©e.
	   */
	  function gererHauteurAutomatiqueControles() {
	    var controles = thisComponent().querySelectorAll('utd-champ-form[hauteur-automatique="true"]');
	    controles.forEach(function (element) {
	      element.setAttribute('hauteur-automatique', 'refresh');
	    });
	  }

	  /**
	   * Permet de bien gÃ©rer l'affichage du nombre de caractÃ¨res restants sur les contrÃ´les utd-champ-form (textarea) lorsqu'ils sont dans un dialogue. 
	   * Il arrive souvent que le contrÃ´le ait changÃ© de valeur (ex. l'utilisateur annule une saisie prÃ©cÃ©dente, la fenÃªtre modale se ferme, mais le nombre de caractÃ¨res restants n'est pas mis Ã  jour car le contrÃ´le n'est pas RENDU de nouveau, mais simplement cachÃ©).
	   * On s'assure donc de forcer la rÃ©assignation du bon nombre de caractÃ¨res restants une fois la modale affichÃ©e.
	   */
	  function gererNbCaracteresRestantsControles() {
	    var controles = thisComponent().querySelectorAll('utd-champ-form[max-caracteres]');
	    controles.forEach(function (element) {
	      var maxCaracteres = element.getAttribute('max-caracteres');
	      if (maxCaracteres && strict_equals(maxCaracteres, '0', false)) {
	        element.setAttribute('max-caracteres', 'refresh');
	      }
	    });
	  }
	  function keydown(e) {
	    if (strict_equals(e.key, "Escape")) {
	      masquerModale('escape');
	    }
	  }

	  // Si un clic autre qu'un clic sur un Ã©lÃ©ment qui est a l'extÃ©rieur de la fenÃªtre modale, on annule tout, afin que le focus demeure dans la fenÃªtre modale.
	  // Sinon il Ã©tait possible de cliquer Ã  l'extÃ©rieur de la fenÃªtre, elle restait ouverte, mais notre fermeture avec ESC ne fonctionnait plus, jusqu'Ã  ce que le focus revienne sur un contrÃ´le Ã  l'intÃ©rieur de la fenÃªtre modale.
	  function mouseDown(e) {
	    if (strict_equals(e.target, e.currentTarget)) {
	      e.preventDefault();
	      e.stopPropagation();
	    }
	  }
	  function finAnimationFermeture(e) {
	    Utils.ajusterInterfaceApresFermetureModale(html, body, thisComponent().shadowRoot.getElementById(idModale));

	    //On redonne le focus au contrÃ´le spÃ©cifiÃ© (normalement celui qui a initiÃ© l'affichage de la fenÃªtre modale). AprÃ¨s l'animation de fermeture afin de s'assurer qu'il puisse recevoir le focus.
	    if (strict_equals(idFocusFermeture(), 'null', false)) {
	      setTimeout(function () {
	        var controleFocus = idFocusFermeture() ? document.getElementById(idFocusFermeture()) : null;
	        controleFocus = controleFocus || controleActifOuverture;
	        if (controleFocus) {
	          if (strict_equals(controleFocus.tagName.toLowerCase(), 'utd-btn-menu-item')) {
	            //On redonne le focus au bouton de menu
	            controleFocus.parentElement.setAttribute('focus', 'true');
	          } else if (strict_equals(controleFocus.tagName.toLowerCase(), 'utd-menu-vertical-item')) {
	            //On redonne le focus au lien de menu vertical
	            controleFocus.shadowRoot.querySelector('a').focus();
	          } else {
	            controleFocus.focus();
	            Utils.scrollIntoViewSiRequis(controleFocus);
	          }
	        }

	        //Le +10 ms permet de s'assurer que le backdrop est retirÃ© afin que le scroll puisse se faire sur le contrÃ´le qui doit recevoir le focus.
	      }, dureeMsAnimationFermeture + 10);
	    }
	    Utils.dispatchWcEvent(thisComponent(), "apresFermeture");
	  }
	  function ajusterModaleDebutAffichage(e) {
	    var modale = thisComponent().shadowRoot.getElementById(idModale);
	    donnerfocusPremierElementFocusable(modale);
	    Utils.conserverFocusElement(modale, thisComponent());
	  }
	  function ajusterModaleFinAffichage(e) {
	    var modale = thisComponent().shadowRoot.getElementById(idModale);
	    Utils.ajusterInterfacePendantAffichageModale(body, modale);

	    //On force un scrollTop ici car Android ne semble pas supporter le preventScroll de la mÃ©thode focus (mais selon la doc il devrait). SOLUTION EN ATTENDANT MIEUX.
	    if (Utils.estMobile()) {
	      modale.scrollTop = 0;
	    }
	  }
	  function estBouton(element) {
	    var tag = element.tagName.toLowerCase();
	    return strict_equals(tag, 'button') || strict_equals(element.getAttribute('type'), 'submit');
	  }
	  function estListeDeroulante(element) {
	    var tag = element.tagName.toLowerCase();
	    return strict_equals(tag, 'utd-liste-deroulante');
	  }
	  function donnerfocusPremierElementFocusable(modale) {
	    var premierElementFocusable = null;
	    if (strict_equals(estfenetremessage(), 'true')) {
	      premierElementFocusable = thisComponent().querySelector('.utd-btn.primaire') || thisComponent().querySelector('.utd-btn');
	    } else {
	      if (idFocusOuverture()) {
	        var controleFocusOuverture = thisComponent().querySelector("#".concat(idFocusOuverture()));
	        if (controleFocusOuverture) {
	          premierElementFocusable = controleFocusOuverture;
	        }
	      }
	      if (!premierElementFocusable) {
	        var elementsFocusablesShadow = Array.from(Utils.obtenirElementsFocusables(modale, true, true));
	        var elementsFocusablesRoot = Array.from(Utils.obtenirElementsFocusables(thisComponent(), true, true));
	        var elementsFocusables = elementsFocusablesRoot.concat(elementsFocusablesShadow);
	        premierElementFocusable = elementsFocusables[0];

	        //On force le mode "fenÃªtre de message" si le premier Ã©lÃ©ment focusable est un bouton de la slot "pied"
	        if (estBouton(premierElementFocusable)) {
	          var slotPied = Utils.obtenirSlot(get(slots), 'pied');
	          if (slotPied) {
	            var boutonsSlotPied = slotPied.querySelectorAll('button, input[type="submit"]');
	            if (boutonsSlotPied.length) {
	              for (var i = 0; i < boutonsSlotPied.length; i++) {
	                if (strict_equals(boutonsSlotPied[i], premierElementFocusable)) {
	                  premierElementFocusable = thisComponent().querySelector('.utd-btn.primaire') || premierElementFocusable;
	                  estfenetremessage('true');
	                  break;
	                }
	              }
	            }
	          }
	        }

	        //Si liste dÃ©oulante UTD, traitement particulier pour lui donner le focus
	        if (estListeDeroulante(premierElementFocusable)) {
	          premierElementFocusable.setAttribute('focus', 'true');
	          return;
	        }
	      }
	    }
	    if (premierElementFocusable) {
	      premierElementFocusable.focus({
	        preventScroll: true
	      });
	    }
	  }
	  legacy_pre_effect(function () {
	    return deep_read_state(afficher());
	  }, function () {
	    toggleAfficher(afficher());
	  });
	  legacy_pre_effect_reset();
	  var $$exports = _objectSpread$i({
	    get afficher() {
	      return afficher();
	    },
	    set afficher($$value) {
	      afficher($$value);
	      flushSync();
	    },
	    get type() {
	      return type();
	    },
	    set type($$value) {
	      type($$value);
	      flushSync();
	    },
	    get estfenetremessage() {
	      return estfenetremessage();
	    },
	    set estfenetremessage($$value) {
	      estfenetremessage($$value);
	      flushSync();
	    },
	    get raisonFermeture() {
	      return raisonFermeture();
	    },
	    set raisonFermeture($$value) {
	      raisonFermeture($$value);
	      flushSync();
	    },
	    get titre() {
	      return titre();
	    },
	    set titre($$value) {
	      titre($$value);
	      flushSync();
	    },
	    get srBoutonFermer() {
	      return srBoutonFermer();
	    },
	    set srBoutonFermer($$value) {
	      srBoutonFermer($$value);
	      flushSync();
	    },
	    get idFocusOuverture() {
	      return idFocusOuverture();
	    },
	    set idFocusOuverture($$value) {
	      idFocusOuverture($$value);
	      flushSync();
	    },
	    get idFocusFermeture() {
	      return idFocusFermeture();
	    },
	    set idFocusFermeture($$value) {
	      idFocusFermeture($$value);
	      flushSync();
	    },
	    get boutonsTexteLong() {
	      return boutonsTexteLong();
	    },
	    set boutonsTexteLong($$value) {
	      boutonsTexteLong($$value);
	      flushSync();
	    },
	    get forcerBoutonsInline() {
	      return forcerBoutonsInline();
	    },
	    set forcerBoutonsInline($$value) {
	      forcerBoutonsInline($$value);
	      flushSync();
	    },
	    get affichageLateral() {
	      return affichageLateral();
	    },
	    set affichageLateral($$value) {
	      affichageLateral($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$i();
	  var node_1 = first_child(fragment);
	  {
	    var consequent_2 = function consequent_2($$anchor) {
	      var fragment_1 = root_1$9();
	      var div = sibling(first_child(fragment_1), 2);
	      var div_1 = child(div);
	      var button = child(div_1);
	      var div_2 = sibling(button, 2);
	      var div_3 = child(div_2);
	      var node_2 = child(div_3);
	      {
	        var consequent = function consequent($$anchor) {
	          var span = root_2$8();
	          template_effect(function () {
	            var _type;
	            return set_class(span, 1, "utd-icone-svg ".concat((_type = type()) !== null && _type !== void 0 ? _type : ''));
	          });
	          append($$anchor, span);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_2, function ($$render) {
	            if (type()) $$render(consequent);
	          });
	        }, 'if', DialogueModal, 302, 10);
	      }
	      var h1 = sibling(node_2, 2);
	      var text = child(h1, true);
	      reset(h1);
	      reset(div_3);
	      var div_4 = sibling(div_3, 2);
	      var node_3 = child(div_4);
	      slot(node_3, $$props, 'default', {});
	      var node_4 = sibling(node_3, 2);
	      slot(node_4, $$props, 'contenu', {});
	      reset(div_4);
	      var node_5 = sibling(div_4, 2);
	      {
	        var consequent_1 = function consequent_1($$anchor) {
	          var div_5 = root_3$8();
	          var node_6 = child(div_5);
	          slot(node_6, $$props, 'pied', {});
	          reset(div_5);
	          append($$anchor, div_5);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_5, function ($$render) {
	            if (deep_read_state(Utils), get(slots), untrack(function () {
	              return Utils.slotExiste(get(slots), 'pied');
	            })) $$render(consequent_1);
	          });
	        }, 'if', DialogueModal, 313, 8);
	      }
	      reset(div_2);
	      reset(div_1);
	      reset(div);
	      template_effect(function () {
	        set_attribute(div, 'aria-labelledby', idEntete);
	        set_attribute(div, 'aria-describedby', strict_equals(estfenetremessage(), 'true') ? idCorps : null);
	        set_class(div, 1, "utd-component utd-dialog".concat(strict_equals(estfenetremessage(), 'true') ? ' fenetre-message' : '').concat(strict_equals(boutonsTexteLong(), 'true') ? ' boutons-texte-long' : '').concat(strict_equals(affichageLateral(), 'true') ? ' affichage-lateral' : '').concat(strict_equals(forcerBoutonsInline(), 'true') ? ' boutons-inline' : ''));
	        set_attribute(div, 'id', idModale);
	        set_attribute(button, 'aria-label', srBoutonFermer());
	        set_class(div_3, 1, "entete ".concat(type() ? 'avec-type' : ''));
	        set_attribute(h1, 'id', idEntete);
	        set_text(text, titre());
	        set_attribute(div_4, 'id', idCorps);
	      });
	      event('click', button, function () {
	        return masquerModale('boutonFermer');
	      });
	      event('mousedown', div, mouseDown);
	      event('keydown', div, keydown);
	      transition(1, div, function () {
	        return animationAffichageOuverture;
	      });
	      transition(2, div, function () {
	        return animationAffichageFermeture;
	      });
	      event('introstart', div, ajusterModaleDebutAffichage);
	      event('introend', div, ajusterModaleFinAffichage);
	      event('outroend', div, finAnimationFermeture);
	      append($$anchor, fragment_1);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_1, function ($$render) {
	        if (get(estModaleAffichee)) $$render(consequent_2);
	      });
	    }, 'if', DialogueModal, 269, 0);
	  }
	  var link = sibling(node_1, 2);
	  template_effect(function () {
	    return set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-dialog', create_custom_element(DialogueModal, {
	  afficher: {
	    attribute: 'afficher'
	  },
	  type: {
	    attribute: 'type'
	  },
	  estfenetremessage: {
	    attribute: 'est-fenetre-message'
	  },
	  raisonFermeture: {
	    attribute: 'raison-fermeture'
	  },
	  titre: {
	    attribute: 'titre'
	  },
	  srBoutonFermer: {
	    attribute: 'sr-bouton-fermer'
	  },
	  idFocusOuverture: {
	    attribute: 'id-focus-ouverture'
	  },
	  idFocusFermeture: {
	    attribute: 'id-focus-fermeture'
	  },
	  boutonsTexteLong: {
	    attribute: 'boutons-texte-long'
	  },
	  forcerBoutonsInline: {
	    attribute: 'forcer-boutons-inline'
	  },
	  affichageLateral: {
	    attribute: 'affichage-lateral'
	  },
	  thisComponent: {}
	}, ['default', 'contenu', 'pied'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$i(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$h(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$h() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$h() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$h = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$h(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$h(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$h(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$h(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	HautPage[FILENAME] = 'src/components/hautPage.svelte';
	var root$h = add_locations(from_html("<div class=\"utd-component utd-hautpage\"><button type=\"button\" class=\"utd-btn primaire\"><div class=\"contenu\"><span aria-hidden=\"true\" class=\"utd-icone-svg fleche-blanc\"></span></div></button></div> <link rel=\"stylesheet\"/>", 1), HautPage[FILENAME], [[112, 0, [[113, 2, [[114, 4, [[115, 6]]]]]]], [120, 0]]);
	function HautPage($$anchor, $$props) {
	  check_target(this instanceof HautPage ? this.constructor : void 0);
	  push($$props, false);

	  /* PropriÃ©tÃ©s "publiques" */
	  var title = prop($$props, 'title', 28, function () {
	    return Utils.estPageLangueFrancais() ? "Retour en haut de page." : "Return to the top of the page.";
	  });

	  /* PropriÃ©tÃ©s "privÃ©es" */
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var hauteurMinimaleSroll = 555;
	  var html;
	  var controle;
	  var ticking = false;
	  var mounted = false;
	  var estCssCharge = false;
	  onMount(function () {
	    html = document.getElementsByTagName('html')[0];
	    controle = thisComponent().shadowRoot.querySelector('.utd-hautpage');
	    controle.classList.add("utd-d-none");
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    mounted = true;
	  });
	  window.addEventListener('scroll', function (e) {
	    if (!ticking) {
	      window.requestAnimationFrame(function () {
	        gererAffichageBouton();
	        ticking = false;
	      });
	    }
	    ticking = true;
	  });
	  function gererAffichageBouton() {
	    var dureeAnimationMs = 500;
	    if (html.classList.contains('utd-modale-ouverte')) {
	      //Si une fenÃªtre modale est ouverte, on ne fait rien pour le bouton de retour haut de page
	      return;
	    }
	    if (document.body.scrollTop > hauteurMinimaleSroll || document.documentElement.scrollTop > hauteurMinimaleSroll) {
	      if (controle.classList.contains('utd-d-none')) {
	        controle.classList.remove('utd-d-none');
	        setTimeout(function () {
	          html.setAttribute('retourhautpagevisible', 'true');
	          controle.classList.add('visible');
	        }, 10);
	      }
	    } else {
	      if (controle.classList.contains("visible")) {
	        setTimeout(function () {
	          controle.classList.add('utd-d-none');
	          html.setAttribute('retourhautpagevisible', 'false');
	        }, dureeAnimationMs);
	      }
	      controle.classList.remove('visible');
	    }
	  }
	  function scrollerHautPage(e) {
	    window.scrollTo({
	      top: 0,
	      behavior: 'smooth'
	    });
	    var pivEntete = document.querySelector('utd-piv-entete');
	    if (pivEntete) {
	      var ctrlPasserContenu = pivEntete.shadowRoot.querySelector('a[href="#main"]');
	      if (ctrlPasserContenu) {
	        ctrlPasserContenu.focus();
	      }
	    }
	  }
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  var $$exports = _objectSpread$h({
	    get title() {
	      return title();
	    },
	    set title($$value) {
	      title($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$h();
	  var div = first_child(fragment);
	  var button = child(div);
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function () {
	    set_attribute(button, 'title', title());
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('click', button, scrollerHautPage);
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-hautpage', create_custom_element(HautPage, {
	  title: {
	    attribute: 'title'
	  },
	  thisComponent: {}
	}, [], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$h(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$g(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$g() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$g() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$g = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$g(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$g(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$g(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$g(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	Infobulle[FILENAME] = 'src/components/infobulle.svelte';
	var root_1$8 = add_locations(from_html("<span class=\"texte-lie\"><!></span>"), Infobulle[FILENAME], [[268, 4]]);
	var root_5$7 = add_locations(from_html("<!> <span class=\"texte-corps\"><!></span>", 1), Infobulle[FILENAME], [[321, 14]]);
	var root_7$5 = add_locations(from_html("<span class=\"texte-corps\"><!></span>"), Infobulle[FILENAME], [[326, 16]]);
	var root_3$7 = add_locations(from_html("<div class=\"utd-backdrop\"></div> <span class=\"modale\" aria-modal=\"true\" role=\"dialog\"><span class=\"utd-container entete\"><h1><span class=\"utd-sr-only\"><!></span> <span><!></span></h1> <button type=\"button\" class=\"close\"><span aria-hidden=\"true\" class=\"utd-icone-svg x-fermer-bleu-piv\"></span></button></span> <span class=\"utd-container conteneur-corps\"><span class=\"utd-sr-only\" tabindex=\"-1\"> </span> <span class=\"corps\"><!></span></span></span>", 1), Infobulle[FILENAME], [[280, 6], [281, 6, [[295, 8, [[296, 10, [[297, 12], [298, 12]]], [304, 10, [[310, 12]]]]], [316, 8, [[317, 10], [318, 10]]]]]]);
	var root_10$3 = add_locations(from_html("<span> </span>"), Infobulle[FILENAME], [[345, 20]]);
	var root_11$2 = add_locations(from_html("<!> <span><!></span>", 1), Infobulle[FILENAME], [[352, 16]]);
	var root_9$3 = add_locations(from_html("<div><span class=\"conteneur\"><span class=\"conteneur-corps\"><span class=\"utd-sr-only\" tabindex=\"-1\"> </span> <span class=\"entete\"><span><span class=\"utd-sr-only\"><!></span> <!></span></span> <span class=\"corps\"><!></span></span> <button type=\"button\" class=\"close\"><span aria-hidden=\"true\" class=\"utd-icone-svg x-fermer-bleu-piv\"></span></button></span> <span class=\"triangle\"></span></div>"), Infobulle[FILENAME], [[337, 6, [[338, 8, [[339, 10, [[340, 12], [341, 12, [[342, 16, [[343, 18]]]]], [349, 12]]], [362, 10, [[363, 12]]]]], [366, 8]]]]);
	var root$g = add_locations(from_html("<span><!> <span class=\"conteneur-tooltip\">&#xFEFF;<button type=\"button\" class=\"tooltip-toggle\"><span aria-hidden=\"true\" class=\"utd-icone-svg infobulle\"></span></button></span> <!></span> <link rel=\"stylesheet\"/>", 1), Infobulle[FILENAME], [[266, 0, [[270, 2, [[270, 42, [[271, 6]]]]]]], [375, 0]]);
	function Infobulle($$anchor, $$props) {
	  check_target(this instanceof Infobulle ? this.constructor : void 0);
	  var $$slots = sanitize_slots($$props);
	  push($$props, false);
	  var estLangueFrancaise = Utils.estPageLangueFrancais();

	  /* PropriÃ©tÃ©s "publiques" */
	  var afficher = prop($$props, 'afficher', 12, 'false');
	  var titre = prop($$props, 'titre', 12, "");
	  var srTitre = prop($$props, 'srTitre', 12, estLangueFrancaise ? "Aide concernant&nbsp;" : "Help concerning&nbsp;");
	  var srPrefixeContenu = prop($$props, 'srPrefixeContenu', 12, estLangueFrancaise ? "DÃ©tails :" : "Details:");
	  var srBoutonOuvrir = prop($$props, 'srBoutonOuvrir', 12, estLangueFrancaise ? "Afficher l'aide contextuelle" : "Show help about");
	  var srBoutonFermer = prop($$props, 'srBoutonFermer', 12, estLangueFrancaise ? "Fermer" : "Close");
	  var contenu = prop($$props, 'contenu', 12, "");
	  var modeAffichage = prop($$props, 'modeAffichage', 12, 'feuille');

	  /* PropriÃ©tÃ©s "privÃ©es" */
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var idBoutonToggle = Utils.genererId();
	  var idModale = Utils.genererId();
	  var idEntete = Utils.genererId();
	  var idPrefixeContenu = Utils.genererId();
	  var html$1;
	  var body;
	  var slots = mutable_source([]);
	  var htmlSlotContenu = mutable_source();
	  var doitAfficherModeFeuille = mutable_source(strict_equals(modeAffichage(), 'feuille'));
	  var positionBulle = mutable_source('');
	  var composant;
	  var changementAffichageEnCours = false;
	  var estOuvertureViaTexteLie = mutable_source(false);
	  var mounted = false;
	  var estCssCharge = false;
	  var paddingRightModale = mutable_source('');
	  onMount(function () {
	    html$1 = thisComponent().getRootNode().getElementsByTagName("html")[0];
	    body = thisComponent().getRootNode().getElementsByTagName("body")[0];
	    composant = thisComponent().shadowRoot.querySelector('.utd-infobulle');
	    set(slots, Array.from(thisComponent().querySelectorAll('[slot]')));
	    assignerHtmlSlotContenu();

	    //VÃ©rifier si le composant est dÃ©jÃ  rendu (ex. quand une infobulle est dans un utd-champ-form), si c'est le cas on retire le doublon
	    if (thisComponent().shadowRoot.querySelectorAll('.utd-infobulle').length > 1) {
	      thisComponent().shadowRoot.querySelectorAll('.utd-infobulle')[1].remove();
	    }
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    mounted = true;
	  });

	  /**
	   * Permet de pallier Ã  un problÃ¨me de perte de focus Ã  l'intÃ©rieur de la modale. En effet, si on clique dans le contenu de la slot "contenu" et qu'on fait TAB, le focus
	   * tombe dans la page en dessous car le keydown est sur le body de la page (probablement car nous sommes dans une slot).
	   * Nous cachons donc le contenu de la slot, rÃ©cupÃ©rons son html et l'assignons nous-mÃªme au contrÃ´le. De cette faÃ§on nous rÃ©glons le problÃ¨me et en bonus
	   * nous nous assurons d'une conformitÃ© visuelle, puisque c'est le css de notre composant qui va s'appliquer et non celui de l'application.
	   * NOTE. Le problÃ¨me ne semble pas se produire avec le composant utd-dialog. On dirait que le fait que d'autres contrÃ´les focusables sont prÃ©sents empÃªche le problÃ¨me. Je ne comprends pas vraiment.
	   */
	  function assignerHtmlSlotContenu() {
	    if (get(slots).length) {
	      var slotContenu = thisComponent().querySelector("[slot=contenu]");
	      if (slotContenu) {
	        var contenuHtml = thisComponent().querySelector("[slot=contenu]").innerHTML;

	        //On retire le contenu html de la slot, car mÃªme si on le rend non visible un contrÃ´le focusable pourrait s'y trouver (ex. hyperlien) et Ã§a empÃªche de conserver le focus dans l'infobulle.
	        slotContenu.innerHTML = '';
	        if (contenuHtml) {
	          set(htmlSlotContenu, contenuHtml);
	        }
	      }
	    }
	  }
	  function afficherModale(e) {
	    //Si affichage mobile (vrai appareil mobile ou largeur Ã©cran infÃ©rieure Ã  576px) on force le mode "feuille"      
	    set(doitAfficherModeFeuille, Utils.estMobile() || document.body.offsetWidth < 576);
	    if (strict_equals(modeAffichage(), 'feuille') || get(doitAfficherModeFeuille)) {
	      Utils.ajusterInterfaceAvantAffichageModale(html$1, body);

	      // Si un padding a Ã©tÃ© ajoutÃ© au body Ã  l'ouverture de la modale (c'est fait dans la mÃ©thode utilitaire prÃ©cÃ©dente quand sur desktop), on applique ce padding Ã©galement Ã  la feuille afin que tout soit alignÃ© avec la page.
	      set(paddingRightModale, body.style['padding-right']);
	      afficher('true');
	    } else {
	      if (!changementAffichageEnCours) {
	        if (strict_equals(afficher(), 'false')) {
	          afficher('true');
	          changementAffichageEnCours = true;
	          set(positionBulle, '');
	          definirPositionBulle();
	          setTimeout(function () {
	            changementAffichageEnCours = false;
	          }, 100);
	          if (get(estOuvertureViaTexteLie)) {
	            redonnerFocusBoutonToggle();
	          }
	        } else {
	          masquerModale();
	        }
	      }
	    }
	  }
	  function masquerModale(e, doitRedonnerFocusBoutonToggle) {
	    if (!changementAffichageEnCours) {
	      afficher('false');
	      set(estOuvertureViaTexteLie, false);
	      changementAffichageEnCours = true;
	      setTimeout(function () {
	        changementAffichageEnCours = false;
	      }, 100);
	      if (doitRedonnerFocusBoutonToggle || strict_equals(modeAffichage(), 'feuille') || get(doitAfficherModeFeuille)) {
	        setTimeout(function () {
	          redonnerFocusBoutonToggle();
	        });
	      }
	    }
	  }
	  function masquerModaleViaBoutonFermeture(e) {
	    //On annule l'Ã©vÃ©nement natif et on ne le remonte pas (car un click sur un label donne le focus au champ... L'infobulle est dans le label, on ne veut pas ce comportement.)
	    e.preventDefault();
	    e.stopPropagation();
	    masquerModale(null, true);
	  }
	  function definirPositionBulle() {
	    setTimeout(function () {
	      //Si pos left infobulle + xpx + largeur bulle > largeur page flip bulle vers bas
	      var droiteBulle = composant.querySelector('.bulle').getBoundingClientRect().right;
	      if (droiteBulle > document.body.offsetWidth) {
	        set(positionBulle, 'bas');
	      } else {
	        set(positionBulle, 'droite');
	      }
	    });
	  }
	  function redonnerFocusBoutonToggle() {
	    var controleFocus = thisComponent().shadowRoot.getElementById(idBoutonToggle);
	    if (controleFocus) {
	      //On redonne le focus au contrÃ´le spÃ©cifiÃ© (normalement le bouton toggle de l'infobulle)
	      controleFocus.focus();
	    }
	  }
	  function keydown(e) {
	    if (strict_equals(e.key, "Escape")) {
	      masquerModale(e, true);
	    }
	  }
	  function blur(e) {
	    if (strict_equals(modeAffichage(), 'bulle') && !get(doitAfficherModeFeuille)) {
	      //Si le composant qui reÃ§oit le focus est Ã  l'intÃ©rieur de la bulle on ne fait rien, et on annule le comportement par dÃ©faut. Sinon on masque la bulle.
	      if (e.relatedTarget && composant.contains(e.relatedTarget)) {
	        e.preventDefault();
	      } else {
	        masquerModale();
	      }
	    }
	  }
	  function clickFeuilleOuBulle(e) {
	    e.stopImmediatePropagation();
	    var target = e.target;

	    // On remonte dans l'arbre DOM pour vÃ©rifier si un ancÃªtre est un hyperlien (<a>).
	    // On s'arrÃªte si on atteint la modale (idModale) ou si on trouve un <a>.
	    while (target && strict_equals(target.id, idModale, false) && strict_equals(target.tagName, 'A', false)) {
	      target = target.parentNode;
	    }

	    // Si l'Ã©lÃ©ment trouvÃ© est un <a>, on conserve le click, on laisse l'Ã©vÃ©nement se propager.
	    if (target && strict_equals(target.tagName, 'A')) {
	      return;
	    }

	    // Si ce n'est PAS un <a>, on annule le comportement par dÃ©faut pour conserver le focus.
	    e.preventDefault();
	  }
	  function clickTexteLie(e) {
	    if (!changementAffichageEnCours) {
	      set(estOuvertureViaTexteLie, true);
	    }
	    afficherModale();
	  }

	  // Sur perte de focus de la bulle on masque l'infobulle
	  function focusOutBulle(e) {
	    //Si on pert le focus, mais que ce dernier ce retrouve ex. sur un lien du composant, on ne fait rien... Sinon on masque.
	    if (!(e.relatedTarget && composant.contains(e.relatedTarget))) {
	      masquerModale();
	    }
	  }
	  function finAnimationFermeture(e) {
	    Utils.ajusterInterfaceApresFermetureModale(html$1, body);
	  }
	  function conserverFocusInfobulle(e) {
	    thisComponent().shadowRoot.getElementById(idPrefixeContenu).focus();
	    Utils.conserverFocusElement(thisComponent().shadowRoot.getElementById(idModale), thisComponent());
	  }
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  var $$exports = _objectSpread$g({
	    get afficher() {
	      return afficher();
	    },
	    set afficher($$value) {
	      afficher($$value);
	      flushSync();
	    },
	    get titre() {
	      return titre();
	    },
	    set titre($$value) {
	      titre($$value);
	      flushSync();
	    },
	    get srTitre() {
	      return srTitre();
	    },
	    set srTitre($$value) {
	      srTitre($$value);
	      flushSync();
	    },
	    get srPrefixeContenu() {
	      return srPrefixeContenu();
	    },
	    set srPrefixeContenu($$value) {
	      srPrefixeContenu($$value);
	      flushSync();
	    },
	    get srBoutonOuvrir() {
	      return srBoutonOuvrir();
	    },
	    set srBoutonOuvrir($$value) {
	      srBoutonOuvrir($$value);
	      flushSync();
	    },
	    get srBoutonFermer() {
	      return srBoutonFermer();
	    },
	    set srBoutonFermer($$value) {
	      srBoutonFermer($$value);
	      flushSync();
	    },
	    get contenu() {
	      return contenu();
	    },
	    set contenu($$value) {
	      contenu($$value);
	      flushSync();
	    },
	    get modeAffichage() {
	      return modeAffichage();
	    },
	    set modeAffichage($$value) {
	      modeAffichage($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$g();
	  var span = first_child(fragment);
	  var node = child(span);
	  {
	    var consequent = function consequent($$anchor) {
	      var span_1 = root_1$8();
	      var node_1 = child(span_1);
	      slot(node_1, $$props, 'texte-lie', {});
	      reset(span_1);
	      event('click', span_1, clickTexteLie);
	      append($$anchor, span_1);
	    };
	    add_svelte_meta(function () {
	      return if_block(node, function ($$render) {
	        if (untrack(function () {
	          return $$slots["texte-lie"];
	        })) $$render(consequent);
	      });
	    }, 'if', Infobulle, 267, 2);
	  }
	  var span_2 = sibling(node, 2);
	  var button = sibling(child(span_2));
	  reset(span_2);
	  var node_2 = sibling(span_2, 2);
	  {
	    var consequent_5 = function consequent_5($$anchor) {
	      var fragment_1 = comment();
	      var node_3 = first_child(fragment_1);
	      {
	        var consequent_4 = function consequent_4($$anchor) {
	          var fragment_2 = root_3$7();
	          var div = first_child(fragment_2);
	          var span_3 = sibling(div, 2);
	          var styles;
	          var span_4 = child(span_3);
	          var h1 = child(span_4);
	          var span_5 = child(h1);
	          var node_4 = child(span_5);
	          html(node_4, srTitre);
	          reset(span_5);
	          var span_6 = sibling(span_5, 2);
	          var node_5 = child(span_6);
	          {
	            var consequent_1 = function consequent_1($$anchor) {
	              var text$1 = text();
	              template_effect(function () {
	                return set_text(text$1, titre());
	              });
	              append($$anchor, text$1);
	            };
	            add_svelte_meta(function () {
	              return if_block(node_5, function ($$render) {
	                if (titre()) $$render(consequent_1);
	              });
	            }, 'if', Infobulle, 299, 14);
	          }
	          reset(span_6);
	          reset(h1);
	          var button_1 = sibling(h1, 2);
	          reset(span_4);
	          var span_7 = sibling(span_4, 2);
	          var span_8 = child(span_7);
	          var text_1 = child(span_8, true);
	          reset(span_8);
	          var span_9 = sibling(span_8, 2);
	          var node_6 = child(span_9);
	          {
	            var consequent_2 = function consequent_2($$anchor) {
	              var fragment_4 = root_5$7();
	              var node_7 = first_child(fragment_4);
	              slot(node_7, $$props, 'contenu', {
	                class: 'utd-d-none'
	              });
	              var span_10 = sibling(node_7, 2);
	              var node_8 = child(span_10);
	              html(node_8, function () {
	                return get(htmlSlotContenu);
	              });
	              reset(span_10);
	              append($$anchor, fragment_4);
	            };
	            var alternate = function alternate($$anchor) {
	              var fragment_5 = comment();
	              var node_9 = first_child(fragment_5);
	              {
	                var consequent_3 = function consequent_3($$anchor) {
	                  var span_11 = root_7$5();
	                  var node_10 = child(span_11);
	                  html(node_10, contenu);
	                  reset(span_11);
	                  append($$anchor, span_11);
	                };
	                add_svelte_meta(function () {
	                  return if_block(node_9, function ($$render) {
	                    if (contenu()) $$render(consequent_3);
	                  });
	                }, 'if', Infobulle, 325, 14);
	              }
	              append($$anchor, fragment_5);
	            };
	            add_svelte_meta(function () {
	              return if_block(node_6, function ($$render) {
	                if (deep_read_state(Utils), get(slots), untrack(function () {
	                  return Utils.slotExiste(get(slots), 'contenu');
	                })) $$render(consequent_2);else $$render(alternate, false);
	              });
	            }, 'if', Infobulle, 319, 12);
	          }
	          reset(span_9);
	          reset(span_7);
	          reset(span_3);
	          template_effect(function ($0) {
	            set_attribute(span_3, 'aria-labelledby', idEntete);
	            set_attribute(span_3, 'id', idModale);
	            styles = set_style(span_3, '', styles, $0);
	            set_attribute(h1, 'id', idEntete);
	            set_attribute(button_1, 'aria-label', srBoutonFermer());
	            set_attribute(span_8, 'id', idPrefixeContenu);
	            set_text(text_1, srPrefixeContenu());
	          }, [function () {
	            return {
	              'padding-right': get(paddingRightModale)
	            };
	          }]);
	          event('click', div, masquerModale);
	          event('click', button_1, masquerModale);
	          transition(1, span_3, function () {
	            return fly;
	          }, function () {
	            return {
	              y: 200,
	              duration: 500
	            };
	          });
	          transition(2, span_3, function () {
	            return fly;
	          }, function () {
	            return {
	              y: 200,
	              duration: 250
	            };
	          });
	          event('introend', span_3, conserverFocusInfobulle);
	          event('outroend', span_3, finAnimationFermeture);
	          event('mousedown', span_3, clickFeuilleOuBulle);
	          event('click', span_3, clickFeuilleOuBulle);
	          append($$anchor, fragment_2);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_3, function ($$render) {
	            if (strict_equals(afficher(), 'true')) $$render(consequent_4);
	          });
	        }, 'if', Infobulle, 279, 4);
	      }
	      append($$anchor, fragment_1);
	    };
	    var alternate_2 = function alternate_2($$anchor) {
	      var fragment_6 = comment();
	      var node_11 = first_child(fragment_6);
	      {
	        var consequent_9 = function consequent_9($$anchor) {
	          var div_1 = root_9$3();
	          var span_12 = child(div_1);
	          var span_13 = child(span_12);
	          var span_14 = child(span_13);
	          var text_2 = child(span_14, true);
	          reset(span_14);
	          var span_15 = sibling(span_14, 2);
	          var span_16 = child(span_15);
	          var span_17 = child(span_16);
	          var node_12 = child(span_17);
	          html(node_12, srTitre);
	          reset(span_17);
	          var node_13 = sibling(span_17, 2);
	          {
	            var consequent_6 = function consequent_6($$anchor) {
	              var span_18 = root_10$3();
	              var text_3 = child(span_18, true);
	              reset(span_18);
	              template_effect(function () {
	                return set_text(text_3, titre());
	              });
	              append($$anchor, span_18);
	            };
	            add_svelte_meta(function () {
	              return if_block(node_13, function ($$render) {
	                if (titre()) $$render(consequent_6);
	              });
	            }, 'if', Infobulle, 344, 18);
	          }
	          reset(span_16);
	          reset(span_15);
	          var span_19 = sibling(span_15, 2);
	          var node_14 = child(span_19);
	          {
	            var consequent_7 = function consequent_7($$anchor) {
	              var fragment_7 = root_11$2();
	              var node_15 = first_child(fragment_7);
	              slot(node_15, $$props, 'contenu', {
	                class: 'utd-d-none'
	              });
	              var span_20 = sibling(node_15, 2);
	              var node_16 = child(span_20);
	              html(node_16, function () {
	                return get(htmlSlotContenu);
	              });
	              reset(span_20);
	              append($$anchor, fragment_7);
	            };
	            var alternate_1 = function alternate_1($$anchor) {
	              var fragment_8 = comment();
	              var node_17 = first_child(fragment_8);
	              {
	                var consequent_8 = function consequent_8($$anchor) {
	                  var fragment_9 = comment();
	                  var node_18 = first_child(fragment_9);
	                  html(node_18, contenu);
	                  append($$anchor, fragment_9);
	                };
	                add_svelte_meta(function () {
	                  return if_block(node_17, function ($$render) {
	                    if (contenu()) $$render(consequent_8);
	                  });
	                }, 'if', Infobulle, 356, 16);
	              }
	              append($$anchor, fragment_8);
	            };
	            add_svelte_meta(function () {
	              return if_block(node_14, function ($$render) {
	                if (deep_read_state(Utils), get(slots), untrack(function () {
	                  return Utils.slotExiste(get(slots), 'contenu');
	                })) $$render(consequent_7);else $$render(alternate_1, false);
	              });
	            }, 'if', Infobulle, 350, 14);
	          }
	          reset(span_19);
	          reset(span_13);
	          var button_2 = sibling(span_13, 2);
	          reset(span_12);
	          next(2);
	          reset(div_1);
	          template_effect(function () {
	            var _$$get;
	            set_class(div_1, 1, "bulle".concat(titre() ? ' avec-titre' : '', " ").concat((_$$get = get(positionBulle)) !== null && _$$get !== void 0 ? _$$get : ''));
	            set_attribute(span_14, 'id', idPrefixeContenu);
	            set_text(text_2, srPrefixeContenu());
	            set_attribute(span_16, 'id', idEntete);
	            set_attribute(button_2, 'aria-label', srBoutonFermer());
	          });
	          event('click', button_2, masquerModaleViaBoutonFermeture);
	          event('mousedown', div_1, clickFeuilleOuBulle);
	          event('click', div_1, clickFeuilleOuBulle);
	          event('focusout', div_1, focusOutBulle);
	          append($$anchor, div_1);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_11, function ($$render) {
	            if (strict_equals(afficher(), 'true')) $$render(consequent_9);
	          });
	        }, 'if', Infobulle, 336, 4);
	      }
	      append($$anchor, fragment_6);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_2, function ($$render) {
	        if (strict_equals(modeAffichage(), 'feuille') || get(doitAfficherModeFeuille)) $$render(consequent_5);else $$render(alternate_2, false);
	      });
	    }, 'if', Infobulle, 278, 2);
	  }
	  reset(span);
	  var link = sibling(span, 2);
	  template_effect(function () {
	    var _$$untrack;
	    set_class(span, 1, "utd-component utd-infobulle".concat((_$$untrack = untrack(function () {
	      return $$slots["texte-lie"] ? ' avec-texte-lie' : '';
	    })) !== null && _$$untrack !== void 0 ? _$$untrack : '').concat(get(estOuvertureViaTexteLie) ? ' est-ouverture-via-texte-lie' : ''));
	    button.disabled = strict_equals(afficher(), 'true') && get(doitAfficherModeFeuille) ? 'disabled' : null;
	    set_attribute(button, 'aria-expanded', strict_equals(modeAffichage(), 'feuille') || get(doitAfficherModeFeuille) ? null : strict_equals(afficher(), 'true') ? 'true' : 'false');
	    set_attribute(button, 'id', idBoutonToggle);
	    set_attribute(button, 'aria-label', srBoutonOuvrir());
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('click', button, afficherModale);
	  event('blur', button, blur);
	  event('keydown', span, keydown);
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-infobulle', create_custom_element(Infobulle, {
	  afficher: {
	    attribute: 'afficher'
	  },
	  titre: {
	    attribute: 'titre'
	  },
	  srTitre: {
	    attribute: 'sr-titre'
	  },
	  srPrefixeContenu: {
	    attribute: 'sr-prefixe-contenu'
	  },
	  srBoutonOuvrir: {
	    attribute: 'sr-bouton-ouvrir'
	  },
	  srBoutonFermer: {
	    attribute: 'sr-bouton-fermer'
	  },
	  contenu: {
	    attribute: 'contenu'
	  },
	  modeAffichage: {
	    attribute: 'mode-affichage'
	  },
	  thisComponent: {}
	}, ['texte-lie', 'contenu'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$g(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	var es_array_sort = {};

	var deletePropertyOrThrow;
	var hasRequiredDeletePropertyOrThrow;

	function requireDeletePropertyOrThrow () {
		if (hasRequiredDeletePropertyOrThrow) return deletePropertyOrThrow;
		hasRequiredDeletePropertyOrThrow = 1;
		var tryToString = requireTryToString();

		var $TypeError = TypeError;

		deletePropertyOrThrow = function (O, P) {
		  if (!delete O[P]) throw new $TypeError('Cannot delete property ' + tryToString(P) + ' of ' + tryToString(O));
		};
		return deletePropertyOrThrow;
	}

	var environmentFfVersion;
	var hasRequiredEnvironmentFfVersion;

	function requireEnvironmentFfVersion () {
		if (hasRequiredEnvironmentFfVersion) return environmentFfVersion;
		hasRequiredEnvironmentFfVersion = 1;
		var userAgent = requireEnvironmentUserAgent();

		var firefox = userAgent.match(/firefox\/(\d+)/i);

		environmentFfVersion = !!firefox && +firefox[1];
		return environmentFfVersion;
	}

	var environmentIsIeOrEdge;
	var hasRequiredEnvironmentIsIeOrEdge;

	function requireEnvironmentIsIeOrEdge () {
		if (hasRequiredEnvironmentIsIeOrEdge) return environmentIsIeOrEdge;
		hasRequiredEnvironmentIsIeOrEdge = 1;
		var UA = requireEnvironmentUserAgent();

		environmentIsIeOrEdge = /MSIE|Trident/.test(UA);
		return environmentIsIeOrEdge;
	}

	var environmentWebkitVersion;
	var hasRequiredEnvironmentWebkitVersion;

	function requireEnvironmentWebkitVersion () {
		if (hasRequiredEnvironmentWebkitVersion) return environmentWebkitVersion;
		hasRequiredEnvironmentWebkitVersion = 1;
		var userAgent = requireEnvironmentUserAgent();

		var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);

		environmentWebkitVersion = !!webkit && +webkit[1];
		return environmentWebkitVersion;
	}

	var hasRequiredEs_array_sort;

	function requireEs_array_sort () {
		if (hasRequiredEs_array_sort) return es_array_sort;
		hasRequiredEs_array_sort = 1;
		var $ = require_export();
		var uncurryThis = requireFunctionUncurryThis();
		var aCallable = requireACallable();
		var toObject = requireToObject();
		var lengthOfArrayLike = requireLengthOfArrayLike();
		var deletePropertyOrThrow = requireDeletePropertyOrThrow();
		var toString = requireToString();
		var fails = requireFails();
		var internalSort = requireArraySort();
		var arrayMethodIsStrict = requireArrayMethodIsStrict();
		var FF = requireEnvironmentFfVersion();
		var IE_OR_EDGE = requireEnvironmentIsIeOrEdge();
		var V8 = requireEnvironmentV8Version();
		var WEBKIT = requireEnvironmentWebkitVersion();

		var test = [];
		var nativeSort = uncurryThis(test.sort);
		var push = uncurryThis(test.push);

		// IE8-
		var FAILS_ON_UNDEFINED = fails(function () {
		  test.sort(undefined);
		});
		// V8 bug
		var FAILS_ON_NULL = fails(function () {
		  test.sort(null);
		});
		// Old WebKit
		var STRICT_METHOD = arrayMethodIsStrict('sort');

		var STABLE_SORT = !fails(function () {
		  // feature detection can be too slow, so check engines versions
		  if (V8) return V8 < 70;
		  if (FF && FF > 3) return;
		  if (IE_OR_EDGE) return true;
		  if (WEBKIT) return WEBKIT < 603;

		  var result = '';
		  var code, chr, value, index;

		  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)
		  for (code = 65; code < 76; code++) {
		    chr = String.fromCharCode(code);

		    switch (code) {
		      case 66: case 69: case 70: case 72: value = 3; break;
		      case 68: case 71: value = 4; break;
		      default: value = 2;
		    }

		    for (index = 0; index < 47; index++) {
		      test.push({ k: chr + index, v: value });
		    }
		  }

		  test.sort(function (a, b) { return b.v - a.v; });

		  for (index = 0; index < test.length; index++) {
		    chr = test[index].k.charAt(0);
		    if (result.charAt(result.length - 1) !== chr) result += chr;
		  }

		  return result !== 'DGBEFHACIJK';
		});

		var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;

		var getSortCompare = function (comparefn) {
		  return function (x, y) {
		    if (y === undefined) return -1;
		    if (x === undefined) return 1;
		    if (comparefn !== undefined) return +comparefn(x, y) || 0;
		    return toString(x) > toString(y) ? 1 : -1;
		  };
		};

		// `Array.prototype.sort` method
		// https://tc39.es/ecma262/#sec-array.prototype.sort
		$({ target: 'Array', proto: true, forced: FORCED }, {
		  sort: function sort(comparefn) {
		    if (comparefn !== undefined) aCallable(comparefn);

		    var array = toObject(this);

		    if (STABLE_SORT) return comparefn === undefined ? nativeSort(array) : nativeSort(array, comparefn);

		    var items = [];
		    var arrayLength = lengthOfArrayLike(array);
		    var itemsLength, index;

		    for (index = 0; index < arrayLength; index++) {
		      if (index in array) push(items, array[index]);
		    }

		    internalSort(items, getSortCompare(comparefn));

		    itemsLength = lengthOfArrayLike(items);
		    index = 0;

		    while (index < itemsLength) array[index] = items[index++];
		    while (index < arrayLength) deletePropertyOrThrow(array, index++);

		    return array;
		  }
		});
		return es_array_sort;
	}

	requireEs_array_sort();

	var es_regexp_constructor = {};

	var proxyAccessor;
	var hasRequiredProxyAccessor;

	function requireProxyAccessor () {
		if (hasRequiredProxyAccessor) return proxyAccessor;
		hasRequiredProxyAccessor = 1;
		var defineProperty = requireObjectDefineProperty().f;

		proxyAccessor = function (Target, Source, key) {
		  key in Target || defineProperty(Target, key, {
		    configurable: true,
		    get: function () { return Source[key]; },
		    set: function (it) { Source[key] = it; }
		  });
		};
		return proxyAccessor;
	}

	var hasRequiredEs_regexp_constructor;

	function requireEs_regexp_constructor () {
		if (hasRequiredEs_regexp_constructor) return es_regexp_constructor;
		hasRequiredEs_regexp_constructor = 1;
		var DESCRIPTORS = requireDescriptors();
		var globalThis = requireGlobalThis();
		var uncurryThis = requireFunctionUncurryThis();
		var isForced = requireIsForced();
		var inheritIfRequired = requireInheritIfRequired();
		var createNonEnumerableProperty = requireCreateNonEnumerableProperty();
		var create = requireObjectCreate();
		var getOwnPropertyNames = requireObjectGetOwnPropertyNames().f;
		var isPrototypeOf = requireObjectIsPrototypeOf();
		var isRegExp = requireIsRegexp();
		var toString = requireToString();
		var getRegExpFlags = requireRegexpGetFlags();
		var stickyHelpers = requireRegexpStickyHelpers();
		var proxyAccessor = requireProxyAccessor();
		var defineBuiltIn = requireDefineBuiltIn();
		var fails = requireFails();
		var hasOwn = requireHasOwnProperty();
		var enforceInternalState = requireInternalState().enforce;
		var setSpecies = requireSetSpecies();
		var wellKnownSymbol = requireWellKnownSymbol();
		var UNSUPPORTED_DOT_ALL = requireRegexpUnsupportedDotAll();
		var UNSUPPORTED_NCG = requireRegexpUnsupportedNcg();

		var MATCH = wellKnownSymbol('match');
		var NativeRegExp = globalThis.RegExp;
		var RegExpPrototype = NativeRegExp.prototype;
		var SyntaxError = globalThis.SyntaxError;
		var exec = uncurryThis(RegExpPrototype.exec);
		var charAt = uncurryThis(''.charAt);
		var replace = uncurryThis(''.replace);
		var stringIndexOf = uncurryThis(''.indexOf);
		var stringSlice = uncurryThis(''.slice);
		// TODO: Use only proper RegExpIdentifierName
		var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
		var re1 = /a/g;
		var re2 = /a/g;

		// "new" should create a new object, old webkit bug
		var CORRECT_NEW = new NativeRegExp(re1) !== re1;

		var MISSED_STICKY = stickyHelpers.MISSED_STICKY;
		var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;

		var BASE_FORCED = DESCRIPTORS &&
		  (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function () {
		    re2[MATCH] = false;
		    // RegExp constructor can alter flags and IsRegExp works correct with @@match
		    // eslint-disable-next-line sonarjs/inconsistent-function-call -- required for testing
		    return NativeRegExp(re1) !== re1 || NativeRegExp(re2) === re2 || String(NativeRegExp(re1, 'i')) !== '/a/i';
		  }));

		var handleDotAll = function (string) {
		  var length = string.length;
		  var index = 0;
		  var result = '';
		  var brackets = false;
		  var chr;
		  for (; index <= length; index++) {
		    chr = charAt(string, index);
		    if (chr === '\\') {
		      result += chr + charAt(string, ++index);
		      continue;
		    }
		    if (!brackets && chr === '.') {
		      result += '[\\s\\S]';
		    } else {
		      if (chr === '[') {
		        brackets = true;
		      } else if (chr === ']') {
		        brackets = false;
		      } result += chr;
		    }
		  } return result;
		};

		var handleNCG = function (string) {
		  var length = string.length;
		  var index = 0;
		  var result = '';
		  var named = [];
		  var names = create(null);
		  var brackets = false;
		  var ncg = false;
		  var groupid = 0;
		  var groupname = '';
		  var chr;
		  for (; index <= length; index++) {
		    chr = charAt(string, index);
		    if (chr === '\\') {
		      chr += charAt(string, ++index);
		    } else if (chr === ']') {
		      brackets = false;
		    } else if (!brackets) switch (true) {
		      case chr === '[':
		        brackets = true;
		        break;
		      case chr === '(':
		        result += chr;
		        // ignore non-capturing groups
		        if (stringSlice(string, index + 1, index + 3) === '?:') {
		          continue;
		        }
		        if (exec(IS_NCG, stringSlice(string, index + 1))) {
		          index += 2;
		          ncg = true;
		        }
		        groupid++;
		        continue;
		      case chr === '>' && ncg:
		        if (groupname === '' || hasOwn(names, groupname)) {
		          throw new SyntaxError('Invalid capture group name');
		        }
		        names[groupname] = true;
		        named[named.length] = [groupname, groupid];
		        ncg = false;
		        groupname = '';
		        continue;
		    }
		    if (ncg) groupname += chr;
		    else result += chr;
		  } return [result, named];
		};

		// `RegExp` constructor
		// https://tc39.es/ecma262/#sec-regexp-constructor
		if (isForced('RegExp', BASE_FORCED)) {
		  var RegExpWrapper = function RegExp(pattern, flags) {
		    var thisIsRegExp = isPrototypeOf(RegExpPrototype, this);
		    var patternIsRegExp = isRegExp(pattern);
		    var flagsAreUndefined = flags === undefined;
		    var groups = [];
		    var rawPattern = pattern;
		    var rawFlags, dotAll, sticky, handled, result, state;

		    if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
		      return pattern;
		    }

		    if (patternIsRegExp || isPrototypeOf(RegExpPrototype, pattern)) {
		      pattern = pattern.source;
		      if (flagsAreUndefined) flags = getRegExpFlags(rawPattern);
		    }

		    pattern = pattern === undefined ? '' : toString(pattern);
		    flags = flags === undefined ? '' : toString(flags);
		    rawPattern = pattern;

		    if (UNSUPPORTED_DOT_ALL && 'dotAll' in re1) {
		      dotAll = !!flags && stringIndexOf(flags, 's') > -1;
		      if (dotAll) flags = replace(flags, /s/g, '');
		    }

		    rawFlags = flags;

		    if (MISSED_STICKY && 'sticky' in re1) {
		      sticky = !!flags && stringIndexOf(flags, 'y') > -1;
		      if (sticky && UNSUPPORTED_Y) flags = replace(flags, /y/g, '');
		    }

		    if (UNSUPPORTED_NCG) {
		      handled = handleNCG(pattern);
		      pattern = handled[0];
		      groups = handled[1];
		    }

		    result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);

		    if (dotAll || sticky || groups.length) {
		      state = enforceInternalState(result);
		      if (dotAll) {
		        state.dotAll = true;
		        state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
		      }
		      if (sticky) state.sticky = true;
		      if (groups.length) state.groups = groups;
		    }

		    if (pattern !== rawPattern) try {
		      // fails in old engines, but we have no alternatives for unsupported regex syntax
		      createNonEnumerableProperty(result, 'source', rawPattern === '' ? '(?:)' : rawPattern);
		    } catch (error) { /* empty */ }

		    return result;
		  };

		  for (var keys = getOwnPropertyNames(NativeRegExp), index = 0; keys.length > index;) {
		    proxyAccessor(RegExpWrapper, NativeRegExp, keys[index++]);
		  }

		  RegExpPrototype.constructor = RegExpWrapper;
		  RegExpWrapper.prototype = RegExpPrototype;
		  defineBuiltIn(globalThis, 'RegExp', RegExpWrapper, { constructor: true });
		}

		// https://tc39.es/ecma262/#sec-get-regexp-@@species
		setSpecies('RegExp');
		return es_regexp_constructor;
	}

	requireEs_regexp_constructor();

	function _callSuper$f(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$f() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$f() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$f = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$f(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$f(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$f(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$f(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	Listederoulante[FILENAME] = 'src/components/listederoulante.svelte';
	var root_1$7 = add_locations(from_html("<span class=\"utd-placeholder\"> </span>"), Listederoulante[FILENAME], [[1118, 10]]);
	var root_2$7 = add_locations(from_html("<span class=\"texte-selection\"> </span>"), Listederoulante[FILENAME], [[1120, 10]]);
	var root_4$3 = add_locations(from_html("<button class=\"reinitialiser-recherche utd-btn secondaire\" type=\"button\"><span aria-hidden=\"true\" class=\"utd-icone-svg x-fermer-bleu-moyen\"></span></button>"), Listederoulante[FILENAME], [[1131, 12, [[1132, 14]]]]);
	var root_3$6 = add_locations(from_html("<span><span aria-hidden=\"true\" class=\"utd-icone-svg loupe-mince\"></span> <label class=\"utd-sr-only\"> </label> <input type=\"search\" class=\"utd-form-control recherche\" aria-autocomplete=\"list\" autocomplete=\"off\" spellcheck=\"false\"/> <!></span>"), Listederoulante[FILENAME], [[1126, 8, [[1127, 10], [1128, 10], [1129, 10]]]]);
	var root_5$6 = add_locations(from_html("<span class=\"separateur-resultats\" aria-hidden=\"true\"></span>"), Listederoulante[FILENAME], [[1139, 8]]);
	var root_6$2 = add_locations(from_html("<span class=\"texte-aucun-resultat\" aria-hidden=\"true\"> </span>"), Listederoulante[FILENAME], [[1144, 10]]);
	var root_8$2 = add_locations(from_html("<span class=\"utd-checkbox\" aria-hidden=\"true\"></span>"), Listederoulante[FILENAME], [[1151, 16]]);
	var root_7$4 = add_locations(from_html("<li role=\"option\"><!> <span class=\"texte-option\"> </span></li>"), Listederoulante[FILENAME], [[1149, 12, [[1153, 14]]]]);
	var root_9$2 = add_locations(from_html("<span class=\"utd-sr-only\"> </span>"), Listederoulante[FILENAME], [[1161, 6]]);
	var root$f = add_locations(from_html("<div><!> <span aria-live=\"polite\" class=\"utd-sr-only\" tabindex=\"-1\"> </span> <span dir=\"ltr\" role=\"combobox\" aria-haspopup=\"listbox\"><span class=\"selection\"><!> <span class=\"utd-icone-svg chevron-bleu-piv developper\"></span></span> <!> <!> <span dir=\"ltr\"><!> <ul class=\"suggestions\" role=\"listbox\"></ul></span></span> <div></div> <!></div> <link rel=\"stylesheet\"/>", 1), Listederoulante[FILENAME], [[1107, 0, [[1110, 4], [1113, 4, [[1116, 6, [[1122, 8]]], [1142, 6, [[1147, 8]]]]], [1159, 4]]], [1165, 0]]);
	function Listederoulante($$anchor, $$props) {
	  check_target(this instanceof Listederoulante ? this.constructor : void 0);
	  push($$props, false);
	  var estLangueFrancaise = Utils.estPageLangueFrancais();

	  /* PropriÃ©tÃ©s "publiques" */
	  var recherchable = prop($$props, 'recherchable', 12, 'false');
	  var rechercheFloue = prop($$props, 'rechercheFloue', 12, 'true');
	  var precisionRecherche = prop($$props, 'precisionRecherche', 12, '0.2');
	  var focus = prop($$props, 'focus', 12, 'false');
	  var largeur = prop($$props, 'largeur', 12, "md" //Valeurs possible sm, md, lg
	  );
	  var placeholder = prop($$props, 'placeholder', 12, estLangueFrancaise ? "Effectuer un choix" : "Make a selection");
	  var refresh = prop($$props, 'refresh', 12, 'false');
	  var regexSeparateurRecherche = prop($$props, 'regexSeparateurRecherche', 12, "[\\p{Z}]+");
	  var motsExclusRecherche = prop($$props, 'motsExclusRecherche', 12, "");

	  /* PropriÃ©tÃ©s "privÃ©es" */
	  var thisComponent = prop($$props, 'thisComponent', 12);

	  //ContrÃ´les
	  var idControleRecherche = Utils.genererId();
	  var idControleResultats = Utils.genererId();
	  var idTexteInstructions = Utils.genererId();
	  var srResultatsTrouves = estLangueFrancaise ? "{x} rÃ©sultat{s} disponibles{s}" : "{x} result{s} avalaible.";
	  var texteAucunResultat = estLangueFrancaise ? "Aucun rÃ©sultat disponible." : "No result available.";
	  var srAucunResultat = texteAucunResultat;
	  var textePlaceholderRecherche = estLangueFrancaise ? "Rechercher..." : "Search...";
	  var texteInstructionsNavigation = estLangueFrancaise ? "Naviguez avec les flÃ¨ches directionnelles. Modifiez la sÃ©lection avec EntrÃ©e ou Espace." : "Navigate with arrow keys. Toggle selection with Enter or Space.";
	  var texteInstructionsRecherche = estLangueFrancaise ? "Au besoin, saisissez un texte pour filtrer les choix." : "Type to filter the list.";
	  var texteInstructionsNavigationEtRecherche = "".concat(texteInstructionsRecherche, " ").concat(texteInstructionsNavigation);
	  var srLibelleListeValeursPossibles = estLangueFrancaise ? "Choix disponibles:" : "Available choices:";
	  var titleBoutonReinitialiserRecherche = estLangueFrancaise ? "Effacer le texte" : "Clear text";
	  var nbCaracteresMinimalRecherche = 2;
	  var mounted = false;
	  var estCssCharge = false;
	  var html;
	  var composant;
	  var controleConteneur;
	  var controleLabel;
	  var ariaLabel = mutable_source(null);
	  var ariaDescriptionConteneur = mutable_source(null);
	  var controleRecherche;
	  var controleSelect;
	  var controleEspaceur;
	  var controleConteneurResultats;
	  var afficherOptions = mutable_source(false);
	  var indexeFocusSuggestion = mutable_source(null);
	  var idActiveDescendant = mutable_source(null);
	  var options = [];
	  var suggestions = mutable_source([]);
	  var optionsSelectionnees = mutable_source([]);
	  var texteOptionsSelectionnees = mutable_source("");
	  var texteRecherche = mutable_source("");
	  var texteNotificationLecteurEcran = mutable_source("");
	  var miniSearch;
	  var optionsMiniSearch;
	  var estScrollbarSuggestionsVisible = mutable_source(false);
	  var multiple = mutable_source(false);
	  var tabIndexConteneur = mutable_source('0');
	  var estControleSelectInactif = false;
	  var estControleSelectDisabled = mutable_source(false);
	  var estControleSelectReadonly = false;
	  var estPremierAffichageChoixDisponibles = mutable_source(true);
	  var regexTokenize = new RegExp(regexSeparateurRecherche(), "u");
	  onMount(function () {
	    optionsMiniSearch = {
	      fuzzy: strict_equals(rechercheFloue(), 'true') ? parseFloat(precisionRecherche()) : null,
	      prefix: true,
	      fields: ['texte', 'motsCles'],
	      storeFields: ['id', 'indexe'],
	      stopWords: new Set(motsExclusRecherche().split(",")),
	      combineWith: 'OR',
	      filter: null,
	      tokenize: function tokenize(text) {
	        return text.split(regexTokenize);
	      },
	      processTerm: function processTerm(term, _fieldName) {
	        return indexerTerme(term);
	      }
	    };
	    mounted = true;
	    html = thisComponent().getRootNode().getElementsByTagName("html")[0];
	    composant = thisComponent().shadowRoot.querySelector('.utd-liste-deroulante');
	    controleConteneur = thisComponent().shadowRoot.querySelector('.conteneur');
	    controleEspaceur = thisComponent().shadowRoot.querySelector('.espaceur');
	    thisComponent().shadowRoot.querySelector('.selection');
	    controleRecherche = thisComponent().shadowRoot.getElementById(idControleRecherche);
	    controleConteneurResultats = thisComponent().shadowRoot.querySelector('.resultats');
	    ajusterControleSelectOriginal();
	    if (!controleSelect) {
	      return;
	    }
	    estControleSelectReadonly = strict_equals(controleSelect.getAttribute('readonly'), null, false);
	    set(estControleSelectDisabled, controleSelect.disabled);
	    estControleSelectInactif = estControleSelectReadonly || get(estControleSelectDisabled);
	    ajusterControleLabelOriginal();
	    initialiserOptionsSuggestionsEtRecherche();
	    definirAttributsInitiauxControles();
	    observerChildListSelectOriginal();
	    observerAttributsSelectOriginal();
	    observerAttributsLabelOriginal();
	    ajouterEvenementKeypress();
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	  });

	  // Watches
	  // Watch sur la prop focus
	  function toggleFocus() {
	    if (strict_equals(focus(), 'true')) {
	      controleConteneur.focus();
	      focus('false');
	      thisComponent().removeAttribute('focus');
	    }
	  }
	  function initialiserOptionsSuggestionsEtRecherche() {
	    options = obtenirOptions();

	    //Settimeout important afin de s'assurer que le paint et autres traitements sont complÃ©tÃ©s (ex. avec VueFormulate)
	    setTimeout(function () {
	      definirOptionsSelectionnees();
	      definirSuggestions(false);
	    });
	    if (strict_equals(recherchable(), 'true')) {
	      miniSearch = new MiniSearch(optionsMiniSearch);
	      miniSearch.addAll(options);
	    }
	  }

	  //Watch sur l'attribut "refresh", permet de mettre Ã  jour les options sÃ©lectionnÃ©es si ces derniÃ¨res ont Ã©tÃ© modifiÃ©es par code sur le select original (ex. un modÃ¨le vuejs ou une modification de la valeur en javascript)
	  function rafraichirOptionsSelectionnees() {
	    if (strict_equals(refresh(), 'true')) {
	      definirOptionsSelectionnees();
	      definirSuggestions();
	      definirAriaDescriptionConteneur();
	      refresh('false');
	      thisComponent().removeAttribute('refresh');
	    }
	  }

	  /**
	   * Obtient le terme Ã  indexer (normalisÃ© et tout).
	   * @param terme
	   */
	  function indexerTerme(terme) {
	    if (terme.length <= 1 || optionsMiniSearch.stopWords.has(terme)) {
	      return null;
	    }
	    return Utils.normaliserChaineCaracteres(terme);
	  }
	  function definirAttributsInitiauxControles() {
	    //Settimeout important afin de s'assurer que le paint et autres traitements sont complÃ©tÃ©s (ex. avec VueFormulate)
	    setTimeout(function () {
	      majAttributControle(controleConteneur, 'aria-invalid', controleSelect.getAttribute('aria-invalid'));
	      majAttributControle(controleConteneur, 'aria-required', controleSelect.getAttribute('aria-required'));
	      majAttributControle(controleConteneur, 'disabled', get(estControleSelectDisabled) ? 'true' : null);
	      majAttributControle(controleConteneur, 'readonly', estControleSelectReadonly ? 'true' : null);
	      definirAriaLabelConteneur();
	      definirAriaDescriptionConteneur();
	    });
	  }
	  function definirAriaLabelConteneur() {
	    //1 - aria-label sur le select
	    if (controleSelect && controleSelect.getAttribute('aria-label')) {
	      set(ariaLabel, controleSelect.getAttribute('aria-label'));
	      return;
	    }

	    //2 - aria-label sur le label
	    if (controleLabel && controleLabel.getAttribute('aria-label')) {
	      set(ariaLabel, controleLabel.getAttribute('aria-label'));
	      return;
	    }

	    //3 - aria-labelledby sur le select
	    var ariaLabelledBySelect = obtenirTexteSelonAttributAria(controleSelect, 'aria-labelledby');
	    if (ariaLabelledBySelect) {
	      set(ariaLabel, ariaLabelledBySelect);
	      return;
	    }

	    //4 - contenu textuel du label
	    if (controleLabel) {
	      set(ariaLabel, obtenirTexteLecteurEcranControle(controleLabel));
	    }
	    return null;
	  }
	  function definirAriaDescriptionConteneur() {
	    var description = obtenirTexteSelonAttributAria(controleSelect, 'aria-describedby');
	    description = description ? description + '. ' : '';
	    set(ariaDescriptionConteneur, description.replace("..", "."));
	  }
	  function definirTexteOptionsSelectionnees() {
	    if (get(optionsSelectionnees).length > 2) {
	      set(texteOptionsSelectionnees, estLangueFrancaise ? "".concat(get(optionsSelectionnees).length, " options s\xE9lectionn\xE9es") : "".concat(get(optionsSelectionnees).length, " selected options"));
	    } else {
	      set(texteOptionsSelectionnees, get(optionsSelectionnees).map(function (option) {
	        return option.texte;
	      }).join(', '));
	    }
	  }
	  function observerAttributsSelectOriginal() {
	    var observer = new MutationObserver(function (mutations) {
	      mutations.forEach(function (mutation) {
	        var nomAttribut = mutation.attributeName;
	        var nouvelleValeur = mutation.target.getAttribute(nomAttribut);
	        var nomAttributMaj = '';
	        switch (nomAttribut) {
	          case 'aria-describedby':
	            definirAriaDescriptionConteneur();
	            break;
	          case 'disabled':
	          case 'readonly':
	            estControleSelectReadonly = strict_equals(controleSelect.getAttribute('readonly'), null, false);
	            set(estControleSelectDisabled, controleSelect.disabled);
	            estControleSelectInactif = estControleSelectReadonly || get(estControleSelectDisabled);
	            majAttributControle(controleConteneur, nomAttribut, nouvelleValeur);
	            break;
	          case 'class':
	            nomAttributMaj = 'aria-invalid';
	            //On vÃ©rifie si le select est validÃ© avec jQuery validate.
	            if (nouvelleValeur.includes('input-validation-') || mutation.oldValue.includes('input-validation-')) {
	              majAttributControle(controleConteneur, nomAttributMaj, nouvelleValeur.includes('input-validation-error') ? 'true' : 'false');
	            }
	            break;
	          default:
	            nomAttributMaj = nomAttribut;
	            majAttributControle(controleConteneur, nomAttributMaj, nouvelleValeur);
	            break;
	        }
	      });
	    });
	    observer.observe(controleSelect, {
	      attributeFilter: ['aria-describedby', 'aria-required', 'aria-invalid', 'aria-label', 'disabled', 'readonly', 'class'],
	      attributeOldValue: true
	    });
	  }
	  function observerChildListSelectOriginal() {
	    var observer = new MutationObserver(function (mutations) {
	      initialiserOptionsSuggestionsEtRecherche();
	    });
	    observer.observe(controleSelect, {
	      characterData: true,
	      subtree: true,
	      childList: true
	    });
	  }
	  function observerAttributsLabelOriginal() {
	    if (!controleLabel) {
	      return;
	    }
	    var observerCharacterData = new MutationObserver(function (mutations) {
	      mutations.forEach(function (mutation) {
	        definirAriaLabelConteneur();
	      });
	    });
	    var observerAriaLabel = new MutationObserver(function (mutations) {
	      mutations.forEach(function (mutation) {
	        definirAriaLabelConteneur();
	      });
	    });
	    observerAriaLabel.observe(controleLabel, {
	      attributeFilter: ['aria-label']
	    });
	    observerCharacterData.observe(controleLabel, {
	      subtree: true,
	      childList: true,
	      characterData: true
	    });
	  }
	  function ajouterEvenementKeypress() {
	    if (strict_equals(recherchable(), 'false') && !get(multiple)) {
	      controleConteneur.addEventListener('keypress', function (e) {
	        var touche = Utils.normaliserChaineCaracteres(e.key);
	        var optionsFiltrees = options.filter(function (option) {
	          return strict_equals(Utils.normaliserChaineCaracteres(option.texte[0]), touche);
	        });
	        if (optionsFiltrees.length > 0) {
	          var prochaineOption = null;
	          if (get(indexeFocusSuggestion) >= 0) {
	            var indexActuel = get(indexeFocusSuggestion) + 1;
	            var indexTrouve = optionsFiltrees.findIndex(function (option) {
	              return option.indexe > indexActuel;
	            });
	            prochaineOption = indexTrouve > -1 ? optionsFiltrees[indexTrouve] : optionsFiltrees[0];
	          } else {
	            prochaineOption = optionsFiltrees[0];
	          }
	          set(indexeFocusSuggestion, prochaineOption.indexe - 1);
	          assurerOptionCouranteVisible();
	        }
	      });
	    }
	  }

	  //TODO dÃ©placer dans utils?
	  //On obtient le texte Ã  partir du contenu textuel du contrÃ´le label en excluant les Ã©lÃ©ments qui ne doivent pas Ãªtre lus au lecteur Ã©cran.
	  function obtenirTexteLecteurEcranControle(controle, selecteurExclusion) {
	    var selecteurs = ["[aria-hidden='true']"];
	    var controleEpure = controle.cloneNode(true);
	    var elementsExlus = controleEpure.querySelectorAll(selecteurs.join(','));
	    for (var i = 0; i < elementsExlus.length; i++) {
	      elementsExlus[i].remove();
	    }
	    return controleEpure.textContent;
	  }

	  //TODO dÃ©placer dans utils?
	  function obtenirTexteSelonAttributAria(controle, nomAttribut) {
	    if (controle && controle.getAttribute(nomAttribut)) {
	      var ids = controle.getAttribute(nomAttribut).split(' ');
	      if (ids.length) {
	        var textes = [];
	        for (var i = 0; i < ids.length; i++) {
	          var _controle = document.getElementById(ids[i]);
	          if (_controle) {
	            textes.push(_controle.textContent);
	          }
	        }
	        return textes.join(' ');
	      }
	    } else {
	      return '';
	    }
	  }

	  //TODO dÃ©placer dans utils?
	  function majAttributControle(controle, nomAttribut, valeur) {
	    if (strict_equals(valeur, null, false)) {
	      controle.setAttribute(nomAttribut, valeur);
	    } else {
	      controle.removeAttribute(nomAttribut);
	    }
	  }
	  function obtenirOptions() {
	    var options = [];
	    for (var i = 0; i < controleSelect.options.length; i++) {
	      var option = controleSelect.options[i];
	      var texte = option.label || option.value;
	      if (option.value) {
	        var opt = {
	          id: Utils.genererId(),
	          texte: texte,
	          valeur: option.value,
	          motsCles: option.getAttribute('mots-cles'),
	          indexe: i,
	          selected: option.selected,
	          disabled: option.disabled,
	          hidden: option.hidden
	        };
	        options.push(opt);
	      }
	    }
	    return options;
	  }
	  function retirerOptionPlaceholderControleSelectOriginal() {
	    //Pour le moment on ne retire que la 1ere option d'un select multiple si elle est vide, hidden et disabled... Dans ce cas il s'agit d'un placeholder, mais Ã§a ne sert Ã  rien pour un select multiple.
	    if (controleSelect.options.length) {
	      var option = controleSelect.options[0];
	      if (!option.value && strict_equals(option.getAttribute('hidden'), null, false) && strict_equals(option.getAttribute('disabled'), null, false)) {
	        controleSelect.options[0] = null;
	      }
	    }
	  }
	  function definirSuggestions(doitNotifierLecteurEcran, estContexteRecherche) {
	    var nouvellesSuggestions = [];
	    var resultatRecherche = [];
	    var optionsRecherche = _objectSpread$f(_objectSpread$f({}, optionsMiniSearch), {
	      fuzzy: function fuzzy(term) {
	        return term.length > 3 ? optionsMiniSearch.fuzzy : null;
	      }
	    });
	    var texteRechercheSansEspace = get(texteRecherche).trim();
	    if (strict_equals(texteRechercheSansEspace, "", false) && texteRechercheSansEspace.length >= nbCaracteresMinimalRecherche) {
	      resultatRecherche = miniSearch.search(texteRechercheSansEspace, optionsRecherche).map(function (item) {
	        return options.find(function (option) {
	          return strict_equals(item.indexe, option.indexe);
	        });
	      });
	    } else {
	      resultatRecherche = options;
	    }
	    var _loop = function _loop() {
	      var suggestion = resultatRecherche[i];
	      suggestion.selected = get(optionsSelectionnees).findIndex(function (option) {
	        return strict_equals(suggestion.indexe, option.indexe);
	      }) >= 0;
	      nouvellesSuggestions.push(suggestion);
	    };
	    for (var i = 0; i < resultatRecherche.length; i++) {
	      _loop();
	    }
	    if (doitNotifierLecteurEcran) {
	      if (strict_equals(nouvellesSuggestions.length, 0)) {
	        notifierLecteurEcran(srAucunResultat);
	      } else {
	        notifierLecteurEcran(srResultatsTrouves.replace("{x}", nouvellesSuggestions.length).replace("{s}", nouvellesSuggestions.length > 1 ? 's' : ''));
	        set(indexeFocusSuggestion, null);
	      }
	    }
	    set(suggestions, nouvellesSuggestions);

	    // En contexte de recherche on tri les suggestions
	    if (estContexteRecherche) {
	      get(suggestions).sort(function (a, b) {
	        return a.texte > b.texte ? 1 : b.texte > a.texte ? -1 : 0;
	      });
	    }

	    //VÃ©rifier si scrollbar visible ou non (servira a ajouter une marge de droite afin que la scrollbar ne soit pas collÃ©e sur la bordure du contrÃ´le)
	    definirPresenceScrollbarResultats();
	  }
	  var definirSuggestionsDebounced = Utils.debounce(function () {
	    return definirSuggestions(true, true);
	  });
	  function definirPresenceScrollbarResultats() {
	    setTimeout(function () {
	      set(estScrollbarSuggestionsVisible, controleConteneurResultats.scrollHeight > controleConteneurResultats.clientHeight);
	    });
	  }
	  function ajusterControleSelectOriginal() {
	    controleSelect = thisComponent().querySelector("select");
	    if (!controleSelect) {
	      return;
	    }
	    if (strict_equals(controleSelect.getAttribute('multiple'), null, false)) {
	      set(multiple, true);
	    }
	    ajouterPlaceholderSelectOriginal();

	    //Si le select original reÃ§oit le focus, on le redonne tout de suite Ã  notre composant, sauf s'il s'agit d'un click dans un composant infobulle qui serait inclu dans le label (ex. dans FRW un lien dans une infobulle)
	    controleSelect.addEventListener('focus', function (e) {
	      e.preventDefault();
	      e.stopPropagation();
	    });
	    controleSelect.classList.add('utd-sr-only');
	    controleSelect.setAttribute("tabindex", "-1");
	    controleSelect.setAttribute("aria-hidden", "true");
	    if (get(multiple)) {
	      controleSelect.setAttribute("multiple", "");
	      retirerOptionPlaceholderControleSelectOriginal();
	    }
	    var classes = controleSelect.getAttribute('class');
	    if (classes.includes('input-validation-')) {
	      majAttributControle(controleSelect, 'aria-invalid', classes.includes('input-validation-error') ? 'true' : 'false');
	    }
	  }
	  function possedeOptionSelectionneeDefaut() {
	    return Array.from(controleSelect.options).findIndex(function (option) {
	      return option.defaultSelected;
	    }) >= 0;
	  }
	  function ajouterPlaceholderSelectOriginal() {
	    if (controleSelect.options.length && strict_equals(controleSelect.options[0].value, '', false)) {
	      var optionPlaceholder = new Option(placeholder(), '');
	      optionPlaceholder.disabled = true;
	      optionPlaceholder.hidden = true;
	      optionPlaceholder.selected = !possedeOptionSelectionneeDefaut();
	      controleSelect.options.add(optionPlaceholder, 0);
	    }
	  }
	  function ajusterControleLabelOriginal() {
	    controleLabel = thisComponent().querySelector("label");
	    if (!controleLabel) {
	      controleLabel = document.querySelector("label[for=\"".concat(controleSelect.id, "\"]"));
	    }
	    if (!controleLabel) {
	      controleLabel = thisComponent().parentElement.querySelector('label');
	    }
	    if (controleLabel) {
	      //On annule le comportement par dÃ©faut du click sur le label afin d'Ã©viter qu'il donne le focus au contrÃ´le select original qui est hors Ã©cran. Cela faisait afficher le contrÃ´le natif en mobile une fraction de seconde avant que le focus retourne sur notre conteneur
	      //Exception si le click a lieu sur une infobulle Ã L'INTÃRIEUR du label. Ex. Un click sur un hyperlien qui serait dans une infobulle.
	      controleLabel.addEventListener('click', function (e) {
	        if (strict_equals(e.target.tagName.toLowerCase(), 'utd-infobulle')) {
	          var valeurFor = controleLabel.getAttribute('for');
	          if (valeurFor) {
	            controleLabel.removeAttribute('for');
	            setTimeout(function () {
	              controleLabel.setAttribute('for', valeurFor);
	            }, 100);
	          }
	          return;
	        }
	        e.preventDefault();
	        e.stopPropagation();
	        controleConteneur.focus();
	      });
	    }
	  }
	  function selectionnerOption(indexeSuggestion) {
	    var doitNotifierLecteurEcran = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    if (strict_equals(indexeSuggestion, null, false)) {
	      var indexeSelectionPrecedente = controleSelect.selectedIndex;
	      var indexeOption = get(suggestions)[indexeSuggestion].indexe;
	      majValeurListeOriginale(indexeOption);
	      definirOptionsSelectionnees();
	      if (!get(multiple)) {
	        if (indexeSelectionPrecedente >= 0) {
	          var indexePrecedent = get(suggestions).findIndex(function (element) {
	            return strict_equals(element.indexe, indexeSelectionPrecedente);
	          });
	          if (indexePrecedent >= 0) {
	            mutate(suggestions, get(suggestions)[indexePrecedent].selected = false);
	          }
	        }
	        mutate(suggestions, get(suggestions)[indexeSuggestion].selected = true);
	        if (doitNotifierLecteurEcran) {
	          notifierLecteurEcran(get(suggestions)[indexeSuggestion].texte);
	        }
	      } else {
	        mutate(suggestions, get(suggestions)[indexeSuggestion].selected = get(optionsSelectionnees).findIndex(function (element) {
	          return strict_equals(element.indexe, indexeOption);
	        }) >= 0);
	      }
	      if (!get(multiple)) {
	        definirAfficherOptions(false);
	        controleConteneur.focus();
	      } else {
	        set(indexeFocusSuggestion, indexeSuggestion);
	      }
	    }
	  }
	  function notifierLecteurEcran(texte) {
	    set(texteNotificationLecteurEcran, texte);

	    //On s'assure que le texte va Ãªtre lu (car parfois c'est le mÃªme texte, s'il ne change pas, il n'est pas lu)
	    setTimeout(function () {
	      set(texteNotificationLecteurEcran, "");
	    }, 400);
	  }
	  function majValeurListeOriginale(indexe) {
	    if (get(multiple)) {
	      controleSelect.options[indexe].selected = !controleSelect.options[indexe].selected;
	    } else {
	      controleSelect.selectedIndex = indexe;
	    }

	    //Important! NÃ©cessaire afin que notamment VueFormulate (FRW) considÃ¨re la nouvelle valeur saisie... Sinon c'est comme si rien n'avait Ã©tÃ© sÃ©lectionnÃ©.
	    controleSelect.dispatchEvent(new Event('change'));
	  }
	  function definirOptionsSelectionnees() {
	    set(optionsSelectionnees, []);
	    var _loop2 = function _loop2() {
	      var option = controleSelect.selectedOptions[i];
	      if (option.value) {
	        get(optionsSelectionnees).push(options.find(function (element) {
	          return strict_equals(element.indexe, option.index);
	        }));
	      }
	    };
	    for (var i = 0; i < controleSelect.selectedOptions.length; i++) {
	      _loop2();
	    }
	  }
	  function onKeyDown(e) {
	    //Si le select est en lecture seule ou disabled, on ne fait rien (sauf pour un TAB)  
	    if (estControleSelectInactif) {
	      if (strict_equals(e.key, "Tab", false)) {
	        return;
	      }
	    }
	    switch (e.key) {
	      case "Enter":
	      case " ":
	        if (strict_equals(e.key, "Enter") && e.target.classList.contains('utd-btn')) {
	          return;
	        }
	        //On conserve comportement natif si barre espace et contrÃ´le courant est textbox de recherche
	        if (strict_equals(e.key, " ") && equals(e.target, controleRecherche) && strict_equals(get(indexeFocusSuggestion), null)) {
	          return;
	        }
	        e.preventDefault();
	        if (strict_equals(get(indexeFocusSuggestion), null, false)) {
	          selectionnerOption(get(indexeFocusSuggestion));
	          definirAriaDescriptionConteneur();
	        } else {
	          definirAfficherOptions(!get(afficherOptions));
	        }
	        break;
	      case "Tab":
	        // Il s'agit d'un Tab (sans Shift), un TAB doit fait sur le conteneur de recherche ou sur le input de recherche doit masquer les options/rÃ©sultats si aucun texte recherchÃ© afin que le TAB passe au contrÃ´le suivant (on sort de la liste complÃ¨tement). Rien trouvÃ© de mieux pour Ã©viter un focus sur les rÃ©sultats (c'est le fureteur qui va le faire tout seul avec les rÃ´les dÃ©finis)
	        if (!e.shiftKey && (equals(e.target, controleRecherche) || strict_equals(e.target, controleConteneur)) && !get(texteRecherche)) {
	          definirAfficherOptions(false);
	        }
	        break;
	      case "Escape":
	        //Si les options sont actuellement afficher, on ne remonte pas l'Ã©vÃ©nement (ex. si on est dans une modale, ca fermerait la modale. On veut fermer la liste des options seulement)
	        if (get(afficherOptions)) {
	          e.preventDefault();
	          e.stopPropagation();
	        }
	        definirAfficherOptions(false);
	        controleConteneur.focus();
	        break;
	      case "ArrowDown":
	      case "ArrowRight":
	        //On conserve comportement natif si flÃ¨che droite et contrÃ´le courant est textbox de recherche
	        if (strict_equals(e.key, 'ArrowRight') && equals(e.target, controleRecherche)) {
	          return;
	        }
	        e.preventDefault();
	        //Si liste simple sans recherche, la flÃ¨che provoque un changement de l'option sÃ©lectionnÃ©e comme un select natif
	        if (strict_equals(recherchable(), 'false') && !get(multiple) && !get(afficherOptions)) {
	          selectionnerOption(obtenirIndexeProchaineSuggestion(controleSelect.selectedIndex, 1), true);
	          return;
	        }
	        //Affiche les options si ne sont pas visibles actuellement
	        if (!get(afficherOptions)) {
	          definirAfficherOptions(true);
	          if (get(suggestions).length && strict_equals(recherchable(), 'false')) {
	            set(indexeFocusSuggestion, 0);
	          }
	        } else if (get(suggestions).length) {
	          if (strict_equals(get(indexeFocusSuggestion), null, false)) {
	            modifierIndexeOptionCourante(1);
	          } else {
	            set(indexeFocusSuggestion, get(indexeFocusSuggestion) || 0);
	          }
	        }
	        assurerOptionCouranteVisible();
	        break;
	      case "ArrowUp":
	      case "ArrowLeft":
	        //On conserve comportement natif si flÃ¨che gauche et contrÃ´le courant est textbox de recherche
	        if (strict_equals(e.key, 'ArrowLeft') && equals(e.target, controleRecherche)) {
	          return;
	        }
	        e.preventDefault();
	        //Si liste simple sans recherche, la flÃ¨che provoque un changement de l'option sÃ©lectionnÃ©e comme un select natif
	        if (strict_equals(recherchable(), 'false') && !get(multiple) && !get(afficherOptions)) {
	          selectionnerOption(obtenirIndexeProchaineSuggestion(controleSelect.selectedIndex, -1), true);
	          return;
	        }
	        if (!get(afficherOptions)) {
	          definirAfficherOptions(true);
	          if (get(suggestions).length && strict_equals(recherchable(), 'false')) {
	            set(indexeFocusSuggestion, get(suggestions).length - 1);
	          }
	        } else if (get(suggestions).length) {
	          if (strict_equals(get(indexeFocusSuggestion), null, false)) {
	            modifierIndexeOptionCourante(-1);
	          } else {
	            set(indexeFocusSuggestion, get(indexeFocusSuggestion) || get(suggestions).length - 1);
	          }
	        }
	        assurerOptionCouranteVisible();
	        break;
	      case "Home":
	      case "PageUp":
	        //On conserve comportement natif si End et contrÃ´le courant est textbox de recherche
	        if (equals(e.target, controleRecherche)) {
	          return;
	        }
	        e.preventDefault();
	        //Si liste simple sans recherche, la flÃ¨che provoque un changement de l'option sÃ©lectionnÃ©e comme un select natif
	        if (strict_equals(recherchable(), 'false') && !get(multiple) && !get(afficherOptions)) {
	          if (strict_equals(e.key, "PageUp")) {
	            var step = Math.floor((get(suggestions).length - 1) / 4);
	            step = step > 8 ? 8 : step;
	            var indexe = controleSelect.selectedIndex - step < 0 ? 0 : controleSelect.selectedIndex - step;
	            selectionnerOption(indexe, true);
	          } else {
	            selectionnerOption(0, true);
	          }
	          return;
	        }
	        if (!get(afficherOptions)) {
	          definirAfficherOptions(true);
	          if (get(suggestions).length && strict_equals(recherchable(), 'false')) {
	            set(indexeFocusSuggestion, 0);
	          }
	        } else if (get(suggestions).length) {
	          set(indexeFocusSuggestion, 0);
	        }
	        assurerOptionCouranteVisible();
	        break;
	      case "End":
	      case "PageDown":
	        //On conserve comportement natif si End et contrÃ´le courant est textbox de recherche
	        if (equals(e.target, controleRecherche)) {
	          return;
	        }
	        e.preventDefault();
	        //Si liste simple sans recherche, la flÃ¨che provoque un changement de l'option sÃ©lectionnÃ©e comme un select natif
	        if (strict_equals(recherchable(), 'false') && !get(multiple) && !get(afficherOptions)) {
	          if (strict_equals(e.key, "PageDown")) {
	            var _step = Math.floor((get(suggestions).length - 1) / 4);
	            _step = _step > 8 ? 8 : _step;
	            var _indexe = controleSelect.selectedIndex + _step > get(suggestions).length - 1 ? get(suggestions).length - 1 : controleSelect.selectedIndex + _step;
	            selectionnerOption(_indexe, true);
	          } else {
	            selectionnerOption(get(suggestions).length - 1, true);
	          }
	          return;
	        }
	        if (!get(afficherOptions)) {
	          definirAfficherOptions(true);
	          if (get(suggestions).length && strict_equals(recherchable(), 'false')) {
	            set(indexeFocusSuggestion, get(suggestions).length - 1);
	          }
	        } else if (get(suggestions).length) {
	          set(indexeFocusSuggestion, get(suggestions).length - 1);
	        }
	        assurerOptionCouranteVisible();
	        break;
	    }
	  }
	  function obtenirIndexeProchaineSuggestion(indexeCourantControleSelect, step) {
	    var indexeCourantSuggestion = get(suggestions).findIndex(function (s) {
	      return strict_equals(s.indexe, indexeCourantControleSelect);
	    });

	    //Si suggestion associÃ©e Ã  indexe courant du select (ex. le placeholder index 0 hidden disabled qui n'est pas intÃ©grÃ© dans nos suggestions) on retourne 0 (1ere suggestion)
	    if (indexeCourantSuggestion < 0) {
	      return 0;
	    }
	    var prochainIndexe = indexeCourantSuggestion + step;
	    while (true) {
	      if (step > 0 && prochainIndexe > get(suggestions).length - 1 || step < 0 && prochainIndexe < 0) {
	        return indexeCourantSuggestion;
	      } else {
	        var prochaineSuggestion = get(suggestions)[prochainIndexe];
	        if (!prochaineSuggestion.disabled && !prochaineSuggestion.hidden) {
	          return prochainIndexe;
	        }
	      }
	      prochainIndexe = prochainIndexe + step;
	    }
	  }
	  function clickSelection(e) {
	    //Si le select est en lecture seule ou disabled, on ne fait rien
	    if (estControleSelectInactif) {
	      return;
	    }
	    definirAfficherOptions(!get(afficherOptions));
	    if (strict_equals(recherchable(), 'true') && get(afficherOptions)) {
	      controleRecherche.parentElement.classList.remove('utd-d-none');
	      controleRecherche.focus();
	    } else {
	      controleConteneur.focus();
	    }
	  }
	  function clickBoutonReinitialiserRecherche(e) {
	    e.preventDefault();
	    e.stopPropagation();
	    controleRecherche.value = '';
	    set(texteRecherche, '');
	    definirSuggestionsDebounced();
	    controleRecherche.focus();
	  }
	  function majActiveDescendant() {
	    if (strict_equals(get(indexeFocusSuggestion), null, false)) {
	      set(idActiveDescendant, get(suggestions)[get(indexeFocusSuggestion)] ? get(suggestions)[get(indexeFocusSuggestion)].id : null);
	    } else {
	      set(idActiveDescendant, null);
	    }
	  }
	  function definirAfficherOptions(doitAfficherOptions) {
	    if (!mounted) {
	      return;
	    }
	    if (doitAfficherOptions) {
	      controleEspaceur.style.height = controleConteneur.offsetHeight + "px";
	      set(afficherOptions, true);
	      if (strict_equals(recherchable(), 'true')) {
	        controleRecherche.value = '';
	        set(texteRecherche, '');
	        definirSuggestions(false);
	        setTimeout(function () {
	          controleRecherche.focus();
	        });
	        setTimeout(function () {
	          set(estPremierAffichageChoixDisponibles, false);
	        }, 200);
	      }
	      assurerControleVisible();
	      definirPresenceScrollbarResultats();
	      set(tabIndexConteneur, '-1');
	    } else {
	      set(afficherOptions, false);
	      set(indexeFocusSuggestion, null);
	      setTimeout(function () {
	        set(tabIndexConteneur, '0');
	      });
	    }
	  }
	  function modifierIndexeOptionCourante(step) {
	    if (!step) {
	      set(indexeFocusSuggestion, null);
	      return;
	    }
	    var prochainIndexe = get(indexeFocusSuggestion) + step;
	    var indexeDerniereOption = get(suggestions).length - 1;
	    if (prochainIndexe > indexeDerniereOption) {
	      set(indexeFocusSuggestion, 0);
	    } else if (prochainIndexe < 0) {
	      set(indexeFocusSuggestion, indexeDerniereOption);
	    } else {
	      set(indexeFocusSuggestion, prochainIndexe);
	    }
	  }
	  function traiterSaisieRecherche() {
	    // EmpÃªche le traitement si simplement un focus ou un blur (l'Ã©vÃ©nement input est lancÃ© sur focus et blur)
	    if (strict_equals(get(texteRecherche), controleRecherche.value)) {
	      return;
	    }
	    set(texteRecherche, controleRecherche.value);
	    definirSuggestionsDebounced();
	  }
	  function blurConteneur(e) {
	    if (!estFocusInterieurComposant(e)) {
	      definirAfficherOptions(false);
	      controleSelect.dispatchEvent(new Event('blur'));
	      definirAriaDescriptionConteneur();
	    }
	  }
	  function blurRecherche(e) {
	    if (!estFocusInterieurComposant(e)) {
	      definirAfficherOptions(false);
	      controleSelect.dispatchEvent(new Event('blur'));
	    } else {
	      set(indexeFocusSuggestion, null);
	    }
	  }
	  function estFocusInterieurComposant(e) {
	    return strict_equals(composant, e.relatedTarget, false) && composant.contains(e.relatedTarget);
	  }
	  function clickOption(e) {
	    e.stopPropagation();
	    var indexeSuggestion = e.currentTarget.getAttribute('indexeSuggestion');
	    if (indexeSuggestion) {
	      selectionnerOption(parseInt(indexeSuggestion));
	      definirAriaDescriptionConteneur();
	    }
	  }
	  function assurerOptionCouranteVisible() {
	    //SetTimeout nÃ©cessaire afin que le paint de la page soit fait et qu'on puisse travailler avec l'option qui vient de recevoir le focus.
	    setTimeout(function () {
	      var option = thisComponent().shadowRoot.querySelector('.suggestions .focus');
	      if (!option) {
	        return;
	      }
	      var hauteurConteneur = controleConteneurResultats.getBoundingClientRect().height;
	      var hauteurOption = option.getBoundingClientRect().height;
	      var offsetConteneur = controleConteneurResultats.scrollTop + hauteurConteneur;

	      //Si nous sommes sur la 1ere ou la derniÃ¨re suggestion on gÃ¨re manuellement le scroll
	      if (strict_equals(get(indexeFocusSuggestion), 0)) {
	        controleConteneurResultats.scroll({
	          top: 0
	        });
	        return;
	      } else if (strict_equals(get(indexeFocusSuggestion), get(suggestions).length - 1)) {
	        controleConteneurResultats.scroll({
	          top: option.offsetTop
	        });
	        return;
	      }
	      if (option.offsetTop + hauteurOption > offsetConteneur) {
	        if (option.offsetTop + hauteurOption > offsetConteneur + hauteurOption) {
	          //Ici on traite le cas ou le user aurait modifiÃ© la position du scroll (ex. avec la souris), dans ce cas on remet l'option courant en haut de liste
	          controleConteneurResultats.scroll({
	            top: option.offsetTop
	          });
	        } else {
	          controleConteneurResultats.scroll({
	            top: controleConteneurResultats.scrollTop + hauteurOption
	          });
	        }
	      } else if (option.offsetTop < offsetConteneur - hauteurConteneur) {
	        if (option.offsetTop < offsetConteneur - hauteurOption) {
	          //Ici on traite le cas ou le user aurait modifiÃ© la position du scroll (ex. avec la souris), dans ce cas on remet l'option courant en haut de liste
	          controleConteneurResultats.scroll({
	            top: option.offsetTop
	          });
	        } else {
	          controleConteneurResultats.scroll({
	            top: controleConteneurResultats.scrollTop - hauteurOption
	          });
	        }
	      }
	    });
	  }

	  /**
	   * On s'assure que notre contrÃ´le est visible en entier ou du moins au maximum de la hauteur disponible.
	   */
	  function assurerControleVisible() {
	    //Il pourrait arriver que la liste n'ait pas de contrÃ´le de label... On ne fait rien dans ce cas lÃ . Ãvite de crasher...
	    if (!controleLabel || !controleConteneur) {
	      return;
	    }

	    //SetTimeout nÃ©cessaire afin que le paint de la page soit fait 
	    setTimeout(function () {
	      var rectConteneur = controleConteneur.getBoundingClientRect();
	      var rectLabel = controleLabel.getBoundingClientRect();
	      var hauteurFenetre = window.innerHeight;
	      var hauteurConteneur = rectConteneur.height;
	      var topLabel = rectLabel.top;
	      var topConteneur = rectConteneur.top;
	      var offsetTopLabel = html.scrollTop + topLabel;
	      var hauteurLabel = topConteneur - topLabel;
	      var hauteurControle = hauteurLabel + hauteurConteneur;
	      var posYBasFenetre = html.scrollTop + hauteurFenetre;
	      var posYBasControle = offsetTopLabel + hauteurControle;
	      if (hauteurControle > hauteurFenetre) {
	        //La hauteur de notre contrÃ´le est supÃ©rieure Ã  la hauteur du viewport, on scroll afin que le label soit au haut de l'Ã©cran.
	        window.scroll({
	          top: html.scrollTop + rectLabel.top
	        });
	      } else if (posYBasControle > posYBasFenetre) {
	        //Notre contrÃ´le n'est pas entiÃ¨rement visible, on scroll juste ce qu'il faut pour que le bas de notre contrÃ´le soit visible
	        var hauteurPortionMasquee = posYBasControle - posYBasFenetre;
	        window.scroll({
	          top: html.scrollTop + hauteurPortionMasquee
	        });
	      }
	    });
	  }
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  legacy_pre_effect(function () {
	    return get(indexeFocusSuggestion);
	  }, function () {
	    majActiveDescendant(get(indexeFocusSuggestion));
	  });
	  legacy_pre_effect(function () {
	    return deep_read_state(refresh());
	  }, function () {
	    rafraichirOptionsSelectionnees(refresh());
	  });
	  legacy_pre_effect(function () {
	    return get(optionsSelectionnees);
	  }, function () {
	    definirTexteOptionsSelectionnees(get(optionsSelectionnees));
	  });
	  legacy_pre_effect(function () {
	    return deep_read_state(focus());
	  }, function () {
	    toggleFocus(focus());
	  });
	  legacy_pre_effect_reset();
	  var $$exports = _objectSpread$f({
	    get recherchable() {
	      return recherchable();
	    },
	    set recherchable($$value) {
	      recherchable($$value);
	      flushSync();
	    },
	    get rechercheFloue() {
	      return rechercheFloue();
	    },
	    set rechercheFloue($$value) {
	      rechercheFloue($$value);
	      flushSync();
	    },
	    get precisionRecherche() {
	      return precisionRecherche();
	    },
	    set precisionRecherche($$value) {
	      precisionRecherche($$value);
	      flushSync();
	    },
	    get focus() {
	      return focus();
	    },
	    set focus($$value) {
	      focus($$value);
	      flushSync();
	    },
	    get largeur() {
	      return largeur();
	    },
	    set largeur($$value) {
	      largeur($$value);
	      flushSync();
	    },
	    get placeholder() {
	      return placeholder();
	    },
	    set placeholder($$value) {
	      placeholder($$value);
	      flushSync();
	    },
	    get refresh() {
	      return refresh();
	    },
	    set refresh($$value) {
	      refresh($$value);
	      flushSync();
	    },
	    get regexSeparateurRecherche() {
	      return regexSeparateurRecherche();
	    },
	    set regexSeparateurRecherche($$value) {
	      regexSeparateurRecherche($$value);
	      flushSync();
	    },
	    get motsExclusRecherche() {
	      return motsExclusRecherche();
	    },
	    set motsExclusRecherche($$value) {
	      motsExclusRecherche($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$f();
	  var div = first_child(fragment);
	  var node = child(div);
	  slot(node, $$props, 'default', {});
	  var span = sibling(node, 2);
	  var text_1 = child(span, true);
	  reset(span);
	  var span_1 = sibling(span, 2);
	  var span_2 = child(span_1);
	  var node_1 = child(span_2);
	  {
	    var consequent = function consequent($$anchor) {
	      var span_3 = root_1$7();
	      var text_2 = child(span_3, true);
	      reset(span_3);
	      template_effect(function () {
	        return set_text(text_2, placeholder());
	      });
	      append($$anchor, span_3);
	    };
	    var alternate = function alternate($$anchor) {
	      var span_4 = root_2$7();
	      var text_3 = child(span_4, true);
	      reset(span_4);
	      template_effect(function () {
	        return set_text(text_3, get(texteOptionsSelectionnees));
	      });
	      append($$anchor, span_4);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_1, function ($$render) {
	        if (get(optionsSelectionnees), untrack(function () {
	          return strict_equals(get(optionsSelectionnees).length, 0);
	        })) $$render(consequent);else $$render(alternate, false);
	      });
	    }, 'if', Listederoulante, 1117, 8);
	  }
	  next(2);
	  reset(span_2);
	  var node_2 = sibling(span_2, 2);
	  {
	    var consequent_2 = function consequent_2($$anchor) {
	      var span_5 = root_3$6();
	      var label = sibling(child(span_5), 2);
	      var text_4 = child(label, true);
	      reset(label);
	      var input = sibling(label, 2);
	      var node_3 = sibling(input, 2);
	      {
	        var consequent_1 = function consequent_1($$anchor) {
	          var button = root_4$3();
	          template_effect(function () {
	            return set_attribute(button, 'title', titleBoutonReinitialiserRecherche);
	          });
	          event('click', button, clickBoutonReinitialiserRecherche);
	          event('blur', button, blurRecherche);
	          append($$anchor, button);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_3, function ($$render) {
	            if (get(texteRecherche)) $$render(consequent_1);
	          });
	        }, 'if', Listederoulante, 1130, 10);
	      }
	      reset(span_5);
	      template_effect(function () {
	        set_class(span_5, 1, "conteneur-recherche ".concat(!get(afficherOptions) ? 'utd-d-none' : ''));
	        set_attribute(label, 'for', idControleRecherche);
	        set_text(text_4, textePlaceholderRecherche);
	        set_attribute(input, 'id', idControleRecherche);
	        set_attribute(input, 'aria-controls', strict_equals(recherchable(), 'true') ? idControleResultats : null);
	        set_attribute(input, 'aria-activedescendant', get(afficherOptions) ? get(idActiveDescendant) : null);
	        set_attribute(input, 'aria-describedby', get(estPremierAffichageChoixDisponibles) ? idTexteInstructions : null);
	      });
	      event('input', input, traiterSaisieRecherche);
	      event('blur', input, blurRecherche);
	      append($$anchor, span_5);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_2, function ($$render) {
	        if (strict_equals(recherchable(), 'true')) $$render(consequent_2);
	      });
	    }, 'if', Listederoulante, 1125, 6);
	  }
	  var node_4 = sibling(node_2, 2);
	  {
	    var consequent_3 = function consequent_3($$anchor) {
	      var span_6 = root_5$6();
	      append($$anchor, span_6);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_4, function ($$render) {
	        if (!get(multiple) && strict_equals(recherchable(), 'false') && get(afficherOptions)) $$render(consequent_3);
	      });
	    }, 'if', Listederoulante, 1138, 6);
	  }
	  var span_7 = sibling(node_4, 2);
	  var node_5 = child(span_7);
	  {
	    var consequent_4 = function consequent_4($$anchor) {
	      var span_8 = root_6$2();
	      var text_5 = child(span_8, true);
	      reset(span_8);
	      template_effect(function () {
	        return set_text(text_5, texteAucunResultat);
	      });
	      append($$anchor, span_8);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_5, function ($$render) {
	        if (get(suggestions), untrack(function () {
	          return strict_equals(get(suggestions).length, 0);
	        })) $$render(consequent_4);
	      });
	    }, 'if', Listederoulante, 1143, 8);
	  }
	  var ul = sibling(node_5, 2);
	  add_svelte_meta(function () {
	    return each(ul, 5, function () {
	      return get(suggestions);
	    }, index, function ($$anchor, suggestion, i) {
	      var li = root_7$4();
	      set_attribute(li, 'indexesuggestion', i);
	      var node_6 = child(li);
	      {
	        var consequent_5 = function consequent_5($$anchor) {
	          var span_9 = root_8$2();
	          append($$anchor, span_9);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_6, function ($$render) {
	            if (get(multiple)) $$render(consequent_5);
	          });
	        }, 'if', Listederoulante, 1150, 14);
	      }
	      var span_10 = sibling(node_6, 2);
	      var text_6 = child(span_10, true);
	      reset(span_10);
	      reset(li);
	      template_effect(function () {
	        set_class(li, 1, strict_equals(i, get(indexeFocusSuggestion)) ? 'focus' : '');
	        set_attribute(li, 'aria-label', (get(suggestion), untrack(function () {
	          return get(suggestion).texte;
	        })));
	        set_attribute(li, 'id', (get(suggestion), untrack(function () {
	          return get(suggestion).id;
	        })));
	        set_value(li, (get(suggestion), untrack(function () {
	          return get(suggestion).value;
	        })));
	        set_attribute(li, 'indexeoption', (get(suggestion), untrack(function () {
	          return get(suggestion).indexe;
	        })));
	        set_attribute(li, 'aria-selected', (get(suggestion), untrack(function () {
	          return get(suggestion).selected ? 'true' : 'false';
	        })));
	        set_text(text_6, (get(suggestion), untrack(function () {
	          return get(suggestion).texte;
	        })));
	      });
	      event('click', li, clickOption);
	      append($$anchor, li);
	    });
	  }, 'each', Listederoulante, 1148, 10);
	  reset(ul);
	  reset(span_7);
	  reset(span_1);
	  var div_1 = sibling(span_1, 2);
	  var node_7 = sibling(div_1, 2);
	  {
	    var consequent_6 = function consequent_6($$anchor) {
	      var span_11 = root_9$2();
	      var text_7 = child(span_11, true);
	      reset(span_11);
	      template_effect(function () {
	        set_attribute(span_11, 'id', idTexteInstructions);
	        set_text(text_7, strict_equals(recherchable(), 'true') ? texteInstructionsNavigationEtRecherche : texteInstructionsNavigation);
	      });
	      append($$anchor, span_11);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_7, function ($$render) {
	        if (get(estPremierAffichageChoixDisponibles)) $$render(consequent_6);
	      });
	    }, 'if', Listederoulante, 1160, 4);
	  }
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function () {
	    var _largeur;
	    set_class(div, 1, "utd-component utd-liste-deroulante ".concat((_largeur = largeur()) !== null && _largeur !== void 0 ? _largeur : '').concat(get(multiple) ? ' multiple' : '').concat(strict_equals(recherchable(), 'true') ? ' recherchable' : ''));
	    set_text(text_1, get(texteNotificationLecteurEcran));
	    set_class(span_1, 1, "conteneur utd-form-control".concat(get(afficherOptions) ? ' ouvert' : ''));
	    set_attribute(span_1, 'aria-expanded', get(afficherOptions) ? 'true' : 'false');
	    set_attribute(span_1, 'tabindex', get(estControleSelectDisabled) ? null : get(tabIndexConteneur));
	    set_attribute(span_1, 'aria-label', get(ariaLabel));
	    set_attribute(span_1, 'aria-description', get(ariaDescriptionConteneur));
	    set_attribute(span_1, 'aria-controls', idControleResultats);
	    set_attribute(span_1, 'aria-activedescendant', get(idActiveDescendant));
	    set_class(span_7, 1, "resultats utd-scrollbar-verticale".concat(!get(afficherOptions) ? ' utd-d-none' : '').concat(strict_equals(recherchable(), 'true') ? ' recherchable' : '').concat(get(estScrollbarSuggestionsVisible) ? ' scrollbar-visible' : ''));
	    set_attribute(ul, 'aria-label', srLibelleListeValeursPossibles);
	    set_attribute(ul, 'id', idControleResultats);
	    set_attribute(ul, 'aria-multiselectable', get(multiple) ? 'true' : null);
	    set_attribute(ul, 'aria-describedby', strict_equals(recherchable(), 'false') && get(estPremierAffichageChoixDisponibles) ? idTexteInstructions : null);
	    span_7.dir = span_7.dir;
	    span_1.dir = span_1.dir;
	    set_class(div_1, 1, "espaceur".concat(!get(afficherOptions) ? ' utd-d-none' : ''));
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('mousedown', span_7, preventDefault(function ($$arg) {
	    bubble_event.call(this, $$props, $$arg);
	  }));
	  event('blur', span_1, blurConteneur);
	  event('keydown', span_1, onKeyDown);
	  event('click', span_1, clickSelection);
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-liste-deroulante', create_custom_element(Listederoulante, {
	  recherchable: {
	    attribute: 'recherchable'
	  },
	  rechercheFloue: {
	    attribute: 'recherche-floue'
	  },
	  precisionRecherche: {
	    attribute: 'precision-recherche'
	  },
	  largeur: {
	    attribute: 'largeur'
	  },
	  placeholder: {
	    attribute: 'placeholder'
	  },
	  refresh: {
	    attribute: 'refresh'
	  },
	  focus: {
	    attribute: 'focus'
	  },
	  regexSeparateurRecherche: {
	    attribute: 'regex-separateur-recherche'
	  },
	  motsExclusRecherche: {
	    attribute: 'mots-exclus-recherche'
	  },
	  thisComponent: {}
	}, ['default'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$f(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$e(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$e() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$e() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$e = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$e(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$e(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$e(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	MenuHorizontal[FILENAME] = 'src/components/menuHorizontal.svelte';
	var root$e = add_locations(from_html("<nav><div role=\"list\"><!></div></nav> <link rel=\"stylesheet\"/>", 1), MenuHorizontal[FILENAME], [[416, 0, [[417, 2]]], [422, 0]]);
	var $$css$3 = {
	  hash: 'svelte-1g5z219',
	  code: '\r\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVudUhvcml6b250YWwuc3ZlbHRlIiwic291cmNlcyI6WyJtZW51SG9yaXpvbnRhbC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHN2ZWx0ZTpvcHRpb25zIGN1c3RvbUVsZW1lbnQ9e3tcclxuICB0YWc6ICd1dGQtbWVudS1ob3Jpem9udGFsJyxcclxuICBleHRlbmQ6IChjdXN0b21FbGVtZW50Q29uc3RydWN0b3IpID0+IHtcclxuICAgIHJldHVybiBjbGFzcyBleHRlbmRzIGN1c3RvbUVsZW1lbnRDb25zdHJ1Y3RvciB7XHJcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50aGlzQ29tcG9uZW50ID0gdGhpcztcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LFxyXG4gIHByb3BzOiB7XHJcbiAgICB0aXRyZSA6IHthdHRyaWJ1dGU6ICd0aXRyZSd9LFxyXG4vLyAgICBsYXJnZXVyVmlld3BvcnRNZW51QnVyZ2VyIDoge2F0dHJpYnV0ZTogJ2xhcmdldXItdmlld3BvcnQtbWVudS1idXJnZXInfSxcclxuICAgIGFmZmljaGVySWNvbmVBY2N1ZWlsIDoge2F0dHJpYnV0ZTogJ2FmZmljaGVyLWljb25lLWFjY3VlaWwnfSxcclxuICAgIHRpdHJlQWNjdWVpbCA6IHthdHRyaWJ1dGU6ICd0aXRyZS1hY2N1ZWlsJ30sXHJcbiAgICB1cmxBY2N1ZWlsIDoge2F0dHJpYnV0ZTogJ3VybC1hY2N1ZWlsJ30sXHJcbiAgICBwYXRoQ291cmFudCA6IHthdHRyaWJ1dGU6ICdwYXRoLWNvdXJhbnQnfVxyXG4gIH0gICAgXHJcbn19Lz5cclxuXHJcbjxzY3JpcHQ+XHJcbiAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcclxuICBpbXBvcnQgeyBVdGlscyB9IGZyb20gXCIuL2pzL3V0aWxzXCJcclxuXHJcbiAgY29uc3QgZXN0TGFuZ3VlRnJhbmNhaXNlID0gVXRpbHMuZXN0UGFnZUxhbmd1ZUZyYW5jYWlzKClcclxuXHJcbiAgLyogUHJvcHJpw6l0w6lzIFwicHVibGlxdWVzXCIgKi9cclxuICBleHBvcnQgbGV0IHRpdHJlID0gZXN0TGFuZ3VlRnJhbmNhaXNlID8gJ01lbnUgcHJpbmNpcGFsIGRlIG5hdmlnYXRpb24nIDogJ01haW4gbmF2aWdhdGlvbiBtZW51J1xyXG4vLyAgZXhwb3J0IGxldCBsYXJnZXVyVmlld3BvcnRNZW51QnVyZ2VyID0gNTc1XHJcbiAgZXhwb3J0IGxldCBhZmZpY2hlckljb25lQWNjdWVpbCA9ICdmYWxzZSdcclxuICBleHBvcnQgbGV0IHRpdHJlQWNjdWVpbCA9IGVzdExhbmd1ZUZyYW5jYWlzZSA/ICdBY2N1ZWlsJyA6ICdIb21lJ1xyXG4gIGV4cG9ydCBsZXQgdXJsQWNjdWVpbCA9ICcvJ1xyXG4gIGV4cG9ydCBsZXQgcGF0aENvdXJhbnQgPSBudWxsXHJcblxyXG4gIC8qIFByb3ByacOpdMOpcyBcInByaXbDqWVzXCIgKi9cclxuICBleHBvcnQgbGV0IHRoaXNDb21wb25lbnRcclxuXHJcbiAgLyogUGFyYW3DqHRyZSBub24gZGlmZnVzw6kgcG91ciBsZSBtb21lbnQuIMOAIHZvaXIgc2kgb24gdmV1dCBhbGxlciB2ZXJzIGzDoCAqL1xyXG4gIGV4cG9ydCBsZXQgZ2VyZXJFbGVtZW50c0FjdGlmcyA9ICd0cnVlJyAvLyBcclxuXHJcblxyXG4gIGxldCBhZmZpY2hlciA9IGZhbHNlXHJcblxyXG4gIGNvbnN0IGlkTWVudSA9IFV0aWxzLmdlbmVyZXJJZCgpXHJcbiAgY29uc3QgdGV4dGVNZW51UGx1cyA9IGVzdExhbmd1ZUZyYW5jYWlzZSA/ICBcIlBsdXNcIiA6IFwiTW9yZVwiXHJcbiAgY29uc3QgdGV4dGVTck1lbnVQbHVzID0gZXN0TGFuZ3VlRnJhbmNhaXNlID8gXCIuIEFmZmljaGVyIGxlcyDDqWzDqW1lbnRzIGRlIG1lbnUgcmVzdGFudHMuXCIgIDogXCIuIFNob3cgcmVtYWluaW5nIG1lbnUgaXRlbXMuXCJcclxuICBjb25zdCB0ZXh0ZU1lbnVCdXJnZXIgPSBlc3RMYW5ndWVGcmFuY2Fpc2UgPyAgXCJNZW51XCIgOiBcIk1lbnVcIlxyXG4gIGxldCBjb250cm9sZU1lbnVcclxuICBsZXQgbGFyZ2V1ckNvbnRlbmV1ciA9IDBcclxuICBsZXQgbGFyZ2V1ck1lbnUgPSAwXHJcbiAgbGV0IGxhcmdldXJWaWV3cG9ydCA9IDBcclxuICBsZXQgbGFyZ2V1ck1pbmltYWxlU291c01lbnUgPSAyMDBcclxuICBsZXQgZGVybmllckluZGV4ZVZpc2libGUgPSAwXHJcbiAgbGV0IGVzdFRlc3RCYWNrc3RvcEpzRW5Db3VycyA9IGZhbHNlXHJcbiAgbGV0IG1vdW50ZWQgPSBmYWxzZVxyXG4gIGxldCBlc3RDc3NDaGFyZ2UgPSBmYWxzZVxyXG5cclxuICAvLyBSw6lmw6lyZW5jZXMgcG91ciBhY2Nlc3NpYmlsaXTDqVxyXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvZGlzY2xvc3VyZS9leGFtcGxlcy9kaXNjbG9zdXJlLW5hdmlnYXRpb24vXHJcblxyXG4gIC8vVE9ETyDDqXZlbnR1ZWxsZW1lbnQgYWpvdXRlciB1biBldmVudCBwb3VyIGZvcmNlciBsYSByZWTDqWZpbml0aW9uIGRlcyDDqWzDqW1lbnRzIGFjdGlmc1xyXG4gXHJcbiAgb25Nb3VudCgoKSA9PiB7ICAgICAgICAgICBcclxuICAgIGVzdFRlc3RCYWNrc3RvcEpzRW5Db3VycyA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoLmluZGV4T2YoJ2JzLXRlc3QnKSA+PSAwO1xyXG5cclxuICAgIC8vIMOJdsOpbmVtZW50IG7DqWNlc3NhaXJlIHBvdXIgSU9TLi4uIENhciBwb3VyIGx1aSBsJ8OpdsOpbmVtZW50IGJsdXIgZGUgbCfDqWzDqW1lbnQgZGUgbWVudSBuJ2VzdCBwYXMgZXjDqWN1dMOpLiBQZXJtZXQgZGUgcydhc3N1cmVyIHF1ZSBsb3JzcXVlIGxlIG1lbnUgcGVyZCBsZSBmb2N1cywgdG91cyBsZXMgbWVudXMgc29udCBmZXJtw6lzLlxyXG4gICAgLy8gw4Agbm90ZXIgcXVlIHN1ciB1biBjbGljayBkJ3VuIMOpbMOpbWVudCBkZSBtZW51IG9uIHN0b3AgbGEgcHJvcGFnYXRpb24gZHUgY2xpY2sgKG5vdHJlIMOpdsOpbmVtZW50IGljaSBuJ2VzdCBkb25jIHBhcyBleMOpY3V0w6kpXHJcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICBmZXJtZXJUb3VzTWVudXMoKTsgICAgICBcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnRyb2xlTWVudSA9IHRoaXNDb21wb25lbnQuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZChpZE1lbnUpO1xyXG4gICAgICAgIFxyXG4gICAgaWYoYWZmaWNoZXJJY29uZUFjY3VlaWwgPT09ICd0cnVlJykge1xyXG4gICAgICBham91dGVyRWxlbWVudE1lbnVBY2N1ZWlsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYoZ2VyZXJFbGVtZW50c0FjdGlmcyA9PT0gJ3RydWUnKSB7XHJcbiAgICAgIGRlZmluaXJFbGVtZW50c0FjdGlmcygpO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgYWp1c3RlckFmZmljaGFnZUNvbnRyb2xlKCk7XHJcblxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgZWNyYW5SZWRpbWVuc2lvbm5lRGVib3VuY2VkKTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsICgpID0+IHtpbmRpcXVlckFqdXN0ZW1lbnRFbkNvdXJzKCl9KTtcclxuXHJcbiAgICBtb3VudGVkID0gdHJ1ZTtcclxuXHJcbiAgICAvL1BhcnRpY3VsYXJpdMOpIGxvcnMgZGVzIGVzc2FpcyBhdmVjIEJhY2tzdG9wSnMuIE9uIGRvaXQgZm9yY2VyIHVuIHLDqWFqdXN0ZW1lbnQgZGUgbCdhZmZpY2hhZ2UuXHJcbiAgICBpZihlc3RUZXN0QmFja3N0b3BKc0VuQ291cnMpIHtcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgYWp1c3RlckFmZmljaGFnZUNvbnRyb2xlKCk7XHJcbiAgICAgIH0sIDUwMCk7XHJcbiAgICB9XHJcbiAgfSlcclxuXHJcbiAgLy8gV2F0Y2ggbGUgcGF0aCBjb3VyYW50IChuw6ljZXNzYWlyZSBwb3VyIGTDqXRlcm1pbmF0aW9uIMOpbMOpbWVudCBhY3RpZiBkZXMgU1BBKVxyXG4gICQ6IGNoYW5nZW1lbnRQYXRoQ291cmFudChwYXRoQ291cmFudCkgXHJcblxyXG4gIC8vIEFqb3V0IGR1IHRyYWl0ZW1lbnQgYXUgcmVzaXplIGRlIGwnaW50ZXJmYWNlIHMnaWwgbid5IGEgcGFzIGQnZXNzYWlzIGJhY2tzdG9wSnMgZW4gY291cnMgKHNpbm9uIGxlIHNjcmVlbnNob3Qgc2UgcHJlbmQgcGVuZGFudCBsZSByZXNpemUgZXQgb24gbidhIHBhcyBsZSBtZW51IGRhbnMgbCdhZmZpY2hhZ2UpICAgIFxyXG4gIGNvbnN0IGVjcmFuUmVkaW1lbnNpb25uZURlYm91bmNlZCA9IFV0aWxzLmRlYm91bmNlKCgpID0+IHthanVzdGVyQWZmaWNoYWdlQ29udHJvbGUoKX0sIDIwMClcclxuXHJcblxyXG4gIGZ1bmN0aW9uIGNoYW5nZW1lbnRQYXRoQ291cmFudCgpIHtcclxuICAgIGlmKG1vdW50ZWQpIHtcclxuICAgICAgYWp1c3RlckFmZmljaGFnZUNvbnRyb2xlKHRydWUpXHJcbiAgICAgIGRlZmluaXJFbGVtZW50c0FjdGlmcygpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmZXJtZXJUb3VzTWVudXMoKSB7XHJcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCd1dGQtbWVudS1ob3Jpem9udGFsLWl0ZW1bYWZmaWNoZXI9XCJ0cnVlXCJdJykuZm9yRWFjaCgoZWxlbWVudE1lbnUpID0+IHtcclxuICAgICAgZWxlbWVudE1lbnUuc2V0QXR0cmlidXRlKCdhZmZpY2hlcicswqAnZmFsc2UnKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGVzdExhcmdldXJDb250ZW5ldXJNb2RpZmllZSgpIHtcclxuICAgIHJldHVybiBlc3RUZXN0QmFja3N0b3BKc0VuQ291cnMgfHwgbGFyZ2V1clZpZXdwb3J0ICE9PSBkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpbmRpcXVlckFqdXN0ZW1lbnRFbkNvdXJzKCkge1xyXG4gICAgLy8gU2kgdW4gdGVzdCBiYWNrc3RvcEpzIG91IHNpIGxhIGxhcmdldXIgZHUgY29udGVuZXVyIG4nYSBwYXMgY2hhbmfDqSBvbiBuZSBmYWl0IHJpZW4gKGV4LiBkYW5zIElPUywgdW4gcmVzaXplIGVzdCBsYW5jw6kgYXUgc2Nyb2xsLi4uIG9uIHZldXQgw6l2aXRlciDDp2EuKVxyXG4gICAgLy8gZXQgc2kgdW4gdGVzdCBiYWNrc3RvcEpzIGVzdCBlbiBjb3Vycywgb24gbmUgZmFpdCByaWVuIGNhciBpbCBzZW1ibGUgeSBhdm9pciB1biByZXNpemUgZXQgbGUgc2NyZWVuc2hvdCBzZSBwcmVuZCBwZW5kYW50IGxlIHJlc2l6ZSBldCBvbiBuJ2EgcGFzIGxlIG1lbnUgZGFucyBsJ2FmZmljaGFnZVxyXG4gICAgaWYoIWVzdFRlc3RCYWNrc3RvcEpzRW5Db3VycyAmJiBlc3RMYXJnZXVyQ29udGVuZXVyTW9kaWZpZWUoKSl7XHJcbiAgICAgIHRoaXNDb21wb25lbnQuY2xhc3NMaXN0LmFkZCgnYWp1c3RlbWVudC1lbi1jb3VycycpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhanVzdGVyQWZmaWNoYWdlQ29udHJvbGUoZm9yY2UpIHtcclxuXHJcbiAgICAvLyBPbiBuZSBmYWl0IHJpZW4gc2kgYXVjdW4gw6lsw6ltZW50IGRlIG1lbnUgcHLDqXNlbnQuXHJcbiAgICBpZighdGhpc0NvbXBvbmVudC5jaGlsZHJlbi5sZW5ndGgpe1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICAvLyBTaSBsYSBsYXJnZXVyIGR1IGNvbnRlbmV1ciBuJ2EgcGFzIGNoYW5nw6kgb24gbmUgZmFpdCByaWVuIChleC4gZGFucyBJT1MsIHVuIHJlc2l6ZSBlc3QgbGFuY8OpIGF1IHNjcm9sbC4uLiBvbiB2ZXV0IMOpdml0ZXIgw6dhLikgw6AgbW9pbnMgcXUnb24gRk9SQ0UgbCdhanVzdGVtZW50IChleC4gcXVhbmQgbGUgcGF0aC1jb3VyYW50IGNoYW5nZSlcclxuICAgIGlmKCFmb3JjZSAmJiAhZXN0TGFyZ2V1ckNvbnRlbmV1ck1vZGlmaWVlKCkpe1xyXG4gICAgICAvL0ljaSBvbiByZXRpcmUgcGFyIHByw6ljYXV0aW9uLCBjYXIgaWwgYXJyaXZlIHF1ZSBsYSBjbGFzc2Ugc29pdCBsw6AuLi4gw6dhIG5lIGRldnJhaXQgcGFzLCBvbiBuZSBsJ2V4cGxpcXVlIHBhcyBtYWlzIMOnYSBhcnJpdmUuXHJcbiAgICAgIHRoaXNDb21wb25lbnQuY2xhc3NMaXN0LnJlbW92ZSgnYWp1c3RlbWVudC1lbi1jb3VycycpXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIFxyXG4gICAgbGFyZ2V1clZpZXdwb3J0ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aFxyXG4gICAgdGhpc0NvbXBvbmVudC5jbGFzc0xpc3QuYWRkKCdhanVzdGVtZW50LWVuLWNvdXJzJylcclxuXHJcbiAgICBzdXBwcmltZXJNZW51UGx1cygpXHJcbiAgICBhZmZpY2hlclRvdXNNZW51c05pdmVhdTEoKVxyXG5cclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBpZihlc3RBZmZpY2hhZ2VNZW51QnVyZ2VyKCkpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIGRlcm5pZXJJbmRleGVWaXNpYmxlID0gLTEgICAgICAgICAgXHJcbiAgICAgICAgICBtYXNxdWVyTWVudXNFeGNlZGVudGFpcmVzKClcclxuXHJcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpc0NvbXBvbmVudC5jbGFzc0xpc3QucmVtb3ZlKCdhanVzdGVtZW50LWVuLWNvdXJzJylcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKGVzdENzc0NoYXJnZSl7XHJcbiAgICAgICAgICAgICAgVXRpbHMucmVhZmZpY2hlckFwcmVzQ2hhcmdlbWVudCh0aGlzQ29tcG9uZW50KSAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH0gICAgICAgICAgICBcclxuICAgICAgICAgIH0sIDEwMClcclxuICAgICAgICB9KVxyXG4gICAgICB9IFxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBpZihjb250aWVudE1lbnVzTm9uVmlzaWJsZXMoKSkgeyAgICAgICAgXHJcbiAgICAgICAgICBham91dGVyTWVudVBsdXNUZW1wb3JhaXJlKClcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vT24gZW5sw6h2ZSAxLCBjYXIgbm90cmUgbWVudVBsdXMgdGVtcG9yYWlyZSBuZSBkb2l0IHBhcyBjb21wdGVyXHJcbiAgICAgICAgICAgIGRlcm5pZXJJbmRleGVWaXNpYmxlID0gb2J0ZW5pckRlcm5pZXJJbmRleGVWaXNpYmxlKCkgLSAxICAgICAgICAgIFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy9SZXRyYWl0IGR1IG1lbnUgUGx1cyB0ZW1wb3JhaXJlXHJcbiAgICAgICAgICAgIHRoaXNDb21wb25lbnQuY2hpbGRyZW5bMF0ucmVtb3ZlKClcclxuXHJcbiAgICAgICAgICAgIG1hc3F1ZXJNZW51c0V4Y2VkZW50YWlyZXMoKVxyXG5cclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgZGV0ZXJtaW5lck91dmVydHVyZUdhdWNoZURlcm5pZXJNZW51Tml2ZWF1MSgpXHJcbiAgICAgICAgICAgICAgdGhpc0NvbXBvbmVudC5jbGFzc0xpc3QucmVtb3ZlKCdhanVzdGVtZW50LWVuLWNvdXJzJylcclxuXHJcbiAgICAgICAgICAgICAgaWYoZXN0Q3NzQ2hhcmdlKXtcclxuICAgICAgICAgICAgICAgIFV0aWxzLnJlYWZmaWNoZXJBcHJlc0NoYXJnZW1lbnQodGhpc0NvbXBvbmVudCkgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIH0gICAgICAgICAgICBcclxuICAgICAgICAgICAgfSwgMTAwKVxyXG4gICAgICAgICAgfSwgMTAwKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIExlIG1lbnUgZml0LCByaWVuIMOgIGZhaXJlIVxyXG4gICAgICAgICAgICBkZXRlcm1pbmVyT3V2ZXJ0dXJlR2F1Y2hlRGVybmllck1lbnVOaXZlYXUxKClcclxuXHJcbiAgICAgICAgICAgIHRoaXNDb21wb25lbnQuY2xhc3NMaXN0LnJlbW92ZSgnYWp1c3RlbWVudC1lbi1jb3VycycpXHJcblxyXG4gICAgICAgICAgICBpZihlc3RDc3NDaGFyZ2Upe1xyXG4gICAgICAgICAgICAgIFV0aWxzLnJlYWZmaWNoZXJBcHJlc0NoYXJnZW1lbnQodGhpc0NvbXBvbmVudCkgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICB9IFxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRldGVybWluZXJPdXZlcnR1cmVHYXVjaGVEZXJuaWVyTWVudU5pdmVhdTEoKSB7XHJcbiAgICAvLyBWw6lyaWZpZXIgc2kgc291cyBtZW51IGRlcm5pZXIgw6lsw6ltZW50IHNlcmEgcGxlaW5lbWVudCB2aXNpYmxlIChnYXVjaGUgKyBsYXJnZXVyTWluaW1hbGVTb3VzTWVudSksIHNpbm9uIGx1aSBham91dGVyIHVuZSBjbGFzc2UgcG91ciBxdSdpbCBvdXZyZSDDoCBnYXVjaGUuLi5cclxuICAgIGNvbnN0IGRlcm5pZXJNZW51Tml2ZWF1MSA9IHRoaXNDb21wb25lbnQucXVlcnlTZWxlY3RvcignOnNjb3BlID4gdXRkLW1lbnUtaG9yaXpvbnRhbC1pdGVtOmxhc3QtY2hpbGQnKVxyXG4gICAgaWYoZGVybmllck1lbnVOaXZlYXUxKSB7XHJcbiAgICAgIGNvbnN0IHBvc2l0aW9uRHJvaXRlID0gZGVybmllck1lbnVOaXZlYXUxLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgKyBsYXJnZXVyTWluaW1hbGVTb3VzTWVudVxyXG5cclxuICAgICAgaWYocG9zaXRpb25Ecm9pdGUgPiBsYXJnZXVyVmlld3BvcnQpIHtcclxuICAgICAgICBkZXJuaWVyTWVudU5pdmVhdTEuc2V0QXR0cmlidXRlKCdlc3Qtb3V2ZXJ0dXJlLWdhdWNoZScsICd0cnVlJylcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZWluaXRpYWxpc2VyT3V2ZXJ0dXJlR2F1Y2hlTWVudShkZXJuaWVyTWVudU5pdmVhdTEpXHJcbiAgICAgIH1cclxuICAgIH0gICAgXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZWluaXRpYWxpc2VyT3V2ZXJ0dXJlR2F1Y2hlTWVudShlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZXN0LW91dmVydHVyZS1nYXVjaGUnKVxyXG4gIH1cclxuXHJcbiAgXHJcbiAgZnVuY3Rpb24gZGVmaW5pckVsZW1lbnRzQWN0aWZzKCkge1xyXG5cclxuICAgIGRlZmluaXJUb3VzTWVudXNJbmFjdGlmcygpXHJcblxyXG4gICAgY29uc3QgZWxlbWVudEFjdGlmID0gb2J0ZW5pckVsZW1lbnRBY3RpZigpXHJcblxyXG4gICAgaWYoZWxlbWVudEFjdGlmKSB7XHJcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBVdGlscy5vYnRlbmlyUGFyZW50cyhlbGVtZW50QWN0aWYpXHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSBwYXJlbnRzW2ldO1xyXG5cclxuICAgICAgICBpZihwYXJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndXRkLW1lbnUtaG9yaXpvbnRhbC1pdGVtJykge1xyXG4gICAgICAgICAgcGFyZW50LnNldEF0dHJpYnV0ZSgnYWN0aWYnLCAndHJ1ZScpXHJcbiAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndXRkLW1lbnUtaG9yaXpvbnRhbCcpIHtcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfSAgICAgIFxyXG4gICAgICB9XHJcbiAgICB9IFxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb2J0ZW5pckVsZW1lbnRBY3RpZigpIHtcclxuICAgIGNvbnN0IGl0ZW1zTWVudSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3V0ZC1tZW51LWhvcml6b250YWwtaXRlbScpXHJcbiAgICBcclxuICAgIGxldCBlbGVtZW50QWN0aWZcclxuXHJcbiAgICBjb25zdCBwYXRoID0gcGF0aENvdXJhbnQgIT09IG51bGwgPyBwYXRoQ291cmFudCA6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXNNZW51Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGl0ZW1NZW51ID0gaXRlbXNNZW51W2ldXHJcbiAgICAgIGNvbnN0IGhyZWYgPSBpdGVtTWVudS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKVxyXG4gICAgICAgICAgICBcclxuICAgICAgaWYoaHJlZikgeyAgICBcclxuICAgICAgICBpZihwYXRoID09PSBocmVmKSB7XHJcbiAgICAgICAgICBlbGVtZW50QWN0aWYgPSBpdGVtTWVudVxyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICB9IGVsc2UgaWYocGF0aC5zdGFydHNXaXRoKGhyZWYpKSB7IFxyXG4gICAgICAgICAgZWxlbWVudEFjdGlmID0gaXRlbU1lbnVcclxuICAgICAgICB9XHJcbiAgICAgIH0gICAgXHJcbiAgICB9ICBcclxuXHJcbiAgICByZXR1cm4gZWxlbWVudEFjdGlmXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkZWZpbmlyVG91c01lbnVzSW5hY3RpZnMoKSB7XHJcbiAgICBjb25zdCBpdGVtc01lbnVBY3RpZnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCd1dGQtbWVudS1ob3Jpem9udGFsLWl0ZW1bYWN0aWY9XCJ0cnVlXCJdJylcclxuICAgIFxyXG4gICAgaWYoaXRlbXNNZW51QWN0aWZzLmxlbmd0aCA+IDApIHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtc01lbnVBY3RpZnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpdGVtc01lbnVBY3RpZnNbaV0ucmVtb3ZlQXR0cmlidXRlKCdhY3RpZicpXHJcbiAgICAgIH0gIFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc3VwcHJpbWVyTWVudVBsdXMoKSB7XHJcbiAgICAgIGNvbnN0IG1lbnVQbHVzID0gdGhpc0NvbXBvbmVudC5xdWVyeVNlbGVjdG9yKCd1dGQtbWVudS1ob3Jpem9udGFsLWl0ZW1bZXN0LW1lbnUtcGx1c10nKVxyXG4gICAgICBpZihtZW51UGx1cykge1xyXG4gICAgICAgIG1lbnVQbHVzLnJlbW92ZSgpXHJcbiAgICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFmZmljaGVyVG91c01lbnVzTml2ZWF1MSgpIHtcclxuICAgIGNvbnN0IG1lbnVzID0gdGhpc0NvbXBvbmVudC5xdWVyeVNlbGVjdG9yQWxsKCd1dGQtbWVudS1ob3Jpem9udGFsLWl0ZW0udXRkLWQtbm9uZScpXHJcbiAgICBtZW51cy5mb3JFYWNoKChtZW51KSA9PiB7XHJcbiAgICAgIG1lbnUuY2xhc3NMaXN0LnJlbW92ZSgndXRkLWQtbm9uZScpXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbWFzcXVlck1lbnVzRXhjZWRlbnRhaXJlcygpIHtcclxuICAgIC8vY29uc3QgZXN0TWVudUJ1cmdlciA9IGVzdEFmZmljaGFnZU1lbnVCdXJnZXIoKSAgICBcclxuICAgIGNvbnN0IGVzdE1lbnVCdXJnZXIgPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdCBtZW51UGx1cyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3V0ZC1tZW51LWhvcml6b250YWwtaXRlbScpXHJcbiAgICBtZW51UGx1cy5zZXRBdHRyaWJ1dGUoJ2xpYmVsbGUnLCBlc3RNZW51QnVyZ2VyID8gdGV4dGVNZW51QnVyZ2VyIDogdGV4dGVNZW51UGx1cylcclxuICAgIG1lbnVQbHVzLnNldEF0dHJpYnV0ZSgnc3ItbGliZWxsZScsIHRleHRlU3JNZW51UGx1cylcclxuICAgIG1lbnVQbHVzLnNldEF0dHJpYnV0ZSgnZXN0LW1lbnUtcGx1cycsICd0cnVlJylcclxuXHJcbiAgICBpZihlc3RNZW51QnVyZ2VyKSB7XHJcbiAgICAgIG1lbnVQbHVzLnNldEF0dHJpYnV0ZSgnZXN0LW1lbnUtYnVyZ2VyJywgJ3RydWUnKVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBjb250aWVudEVsZW1lbnRBY3RpZiA9IGZhbHNlXHJcblxyXG4gICAgZm9yIChsZXQgaSA9IGRlcm5pZXJJbmRleGVWaXNpYmxlICsgMTsgaSA8IHRoaXNDb21wb25lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgIGNvbnN0IGNsbiA9IHRoaXNDb21wb25lbnQuY2hpbGRyZW5baV0uY2xvbmVOb2RlKHRydWUpO1xyXG5cclxuICAgICAgY2xuLnNldEF0dHJpYnV0ZSgnZXN0LW1lbnUtcGx1cycsICd0cnVlJylcclxuXHJcbiAgICAgIGlmKGVzdE1lbnVCdXJnZXIpIHtcclxuICAgICAgICBjbG4uc2V0QXR0cmlidXRlKCdlc3QtbWVudS1idXJnZXInLCAndHJ1ZScpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKGdlcmVyRWxlbWVudHNBY3RpZnMgPT09ICd0cnVlJyAmJiBjbG4uZ2V0QXR0cmlidXRlKCdhY3RpZicpID09PSAndHJ1ZScpIHtcclxuICAgICAgICBjb250aWVudEVsZW1lbnRBY3RpZiA9IHRydWVcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoaSA9PT0gdGhpc0NvbXBvbmVudC5jaGlsZHJlbi5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgY2xuLnNldEF0dHJpYnV0ZSgnZXN0LWRlcm5pZXInLCd0cnVlJylcclxuXHJcbiAgICAgICAgLy9PbiByZXRpcmUgbGEgY2xhc3NlIGluZGlxdWFudCB1bmUgb3V2ZXJ0dXJlIMOgIGdhdWNoZSAoaW1wb3NzaWJsZSBkYW5zIGxhIHNpdHVhdGlvbiBwcsOpc2VudGUgY2FyIGxlIGRlcm5pZXIgbWVudSBlc3QgbsOpY8Opc3NhaXJlbWVudCBcIm1hc3F1w6lcIiBldCBpbmNsdSBkYW5zIGxlIFBMVVMgb3UgbGUgbWVudSBidXJnZXIgKVxyXG4gICAgICAgIHJlaW5pdGlhbGlzZXJPdXZlcnR1cmVHYXVjaGVNZW51KHRoaXNDb21wb25lbnQuY2hpbGRyZW5baV0pXHJcbiAgICAgICAgcmVpbml0aWFsaXNlck91dmVydHVyZUdhdWNoZU1lbnUoY2xuKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBtZW51UGx1cy5hcHBlbmRDaGlsZChjbG4pICAgICAgICAgICAgXHJcbiAgICAgIHRoaXNDb21wb25lbnQuY2hpbGRyZW5baV0uY2xhc3NMaXN0LmFkZCgndXRkLWQtbm9uZScpICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbnRpZW50RWxlbWVudEFjdGlmKSB7XHJcbiAgICAgIG1lbnVQbHVzLnNldEF0dHJpYnV0ZSgnYWN0aWYnLCAndHJ1ZScpXHJcbiAgICB9XHJcblxyXG4gICAgdGhpc0NvbXBvbmVudC5hcHBlbmRDaGlsZChtZW51UGx1cykgICAgXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBham91dGVyRWxlbWVudE1lbnVBY2N1ZWlsKCkge1xyXG4gICAgY29uc3QgbWVudUFjY3VlaWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1dGQtbWVudS1ob3Jpem9udGFsLWl0ZW0nKVxyXG4gICAgbWVudUFjY3VlaWwuc2V0QXR0cmlidXRlKCdsaWJlbGxlJywgdGl0cmVBY2N1ZWlsKVxyXG4gICAgbWVudUFjY3VlaWwuc2V0QXR0cmlidXRlKCdocmVmJywgdXJsQWNjdWVpbCkgIFxyXG4gICAgbWVudUFjY3VlaWwuc2V0QXR0cmlidXRlKCdlc3QtbWVudS1hY2N1ZWlsJywgJ3RydWUnKVxyXG5cclxuICAgIHRoaXNDb21wb25lbnQucHJlcGVuZChtZW51QWNjdWVpbClcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFqb3V0ZXJFbGVtZW50c01lbnVBdU1lbnVPcmlnaW5hbChlbGVtZW50TWVudUl0ZW0sIHBhcmVudCkge1xyXG5cclxuICAgIEFycmF5LmZyb20ocGFyZW50LmNoaWxkcmVuKS5mb3JFYWNoKChjaGlsZCkgPT4ge1xyXG4gICAgICBjb25zdCBlbGVtZW50TWVudSA9IHtcclxuICAgICAgICBsaWJlbGxlOiBjaGlsZC5nZXRBdHRyaWJ1dGUoJ2xpYmVsbGUnKSxcclxuICAgICAgICBocmVmOiBjaGlsZC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSxcclxuICAgICAgICBjaGlsZHJlbiA6IFtdXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGVsZW1lbnRNZW51SXRlbS5wdXNoKGVsZW1lbnRNZW51KVxyXG5cclxuICAgICAgLy9cclxuICAgICAgaWYoY2hpbGQuY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuICAgICAgICBham91dGVyRWxlbWVudHNNZW51QXVNZW51T3JpZ2luYWwoZWxlbWVudE1lbnUuY2hpbGRyZW4sIGNoaWxkKVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29udGllbnRNZW51c05vblZpc2libGVzKCkge1xyXG5cclxuICAgIGxhcmdldXJDb250ZW5ldXIgPSB0aGlzQ29tcG9uZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0XHJcbi8vICAgIGxhcmdldXJNZW51ID0gdGhpc0NvbXBvbmVudC5jaGlsZHJlblt0aGlzQ29tcG9uZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0IC0gMC41XHJcbiAgICBsYXJnZXVyTWVudSA9IHRoaXNDb21wb25lbnQuY2hpbGRyZW5bdGhpc0NvbXBvbmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodFxyXG5cclxuICAgIHJldHVybiBsYXJnZXVyTWVudSA+IGxhcmdldXJDb250ZW5ldXIgXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlc3RBZmZpY2hhZ2VNZW51QnVyZ2VyKCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4vLyAgICByZXR1cm4gbGFyZ2V1clZpZXdwb3J0IDw9IGxhcmdldXJWaWV3cG9ydE1lbnVCdXJnZXJcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG9idGVuaXJEZXJuaWVySW5kZXhlVmlzaWJsZSgpe1xyXG4gICAgbGV0IG1lbnVWaXNpYmxlID0gdHJ1ZVxyXG4gICAgbGV0IGkgPSAwXHJcbiAgICBsZXQgaW5kZXhlRGVybmllckVsZW1lbnRWaXNpYmxlID0gMFxyXG5cclxuICAgIHdoaWxlIChtZW51VmlzaWJsZSAmJiBpIDw9IHRoaXNDb21wb25lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMSkge1xyXG4gICAgICBjb25zdCBpdGVtID0gdGhpc0NvbXBvbmVudC5jaGlsZHJlbltpXVxyXG4gICAgICBpZihpdGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0IDw9IGxhcmdldXJDb250ZW5ldXIpIHtcclxuICAgICAgICBpbmRleGVEZXJuaWVyRWxlbWVudFZpc2libGUgPSBpXHJcbiAgICAgICAgaSsrICAgICAgICBcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtZW51VmlzaWJsZSA9IGZhbHNlXHJcbiAgICAgIH0gICAgICBcclxuICAgIH1cclxuICAgIHJldHVybiBpbmRleGVEZXJuaWVyRWxlbWVudFZpc2libGUgICBcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFqb3V0ZXJNZW51UGx1c1RlbXBvcmFpcmUoKXtcclxuICAgIGNvbnN0IG1lbnVQbHVzVGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3V0ZC1tZW51LWhvcml6b250YWwtaXRlbScpXHJcbiAgICBtZW51UGx1c1RlbXAuc2V0QXR0cmlidXRlKCdsaWJlbGxlJywgdGV4dGVNZW51UGx1cylcclxuICAgIG1lbnVQbHVzVGVtcC5zZXRBdHRyaWJ1dGUoJ2VzdC1tZW51LXBsdXMnLCAndHJ1ZScpXHJcblxyXG4gICAgY29uc3QgZWxlbWVudFRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1dGQtbWVudS1ob3Jpem9udGFsLWl0ZW0nKVxyXG4gICAgZWxlbWVudFRlbXAuc2V0QXR0cmlidXRlKCdsaWJlbGxlJywgJ1RlbXBvcmFpcmUnKVxyXG4gICAgbWVudVBsdXNUZW1wLmFwcGVuZENoaWxkKGVsZW1lbnRUZW1wKVxyXG5cclxuICAgIHRoaXNDb21wb25lbnQucHJlcGVuZChtZW51UGx1c1RlbXApXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjc3NDaGFyZ2UoZSkgeyAgICAgICBcclxuICAgIGlmKG1vdW50ZWQpIHtcclxuICAgICAgVXRpbHMucmVhZmZpY2hlckFwcmVzQ2hhcmdlbWVudCh0aGlzQ29tcG9uZW50KTsgICAgIFxyXG4gICAgfSAgICBcclxuXHJcbiAgICBlc3RDc3NDaGFyZ2UgPSB0cnVlO1xyXG4gIH1cclxuXHJcbjwvc2NyaXB0PlxyXG48bmF2IGNsYXNzPVwidXRkLW1lbnUtaG9yaXpvbnRhbFwiIGNsYXNzOnZpc2libGU9e2FmZmljaGVyfSBhcmlhLWxhYmVsPVwie3RpdHJlfVwiPlxyXG4gIDxkaXYgaWQ9e2lkTWVudX0gcm9sZT1cImxpc3RcIiBjbGFzcz1cIm1lbnVcIiBjbGFzczp2aXNpYmxlPXthZmZpY2hlcn0+XHJcbiAgICA8c2xvdD48L3Nsb3Q+XHJcbiAgPC9kaXY+ICBcclxuPC9uYXY+XHJcblxyXG48bGluayByZWw9J3N0eWxlc2hlZXQnIGhyZWY9J3tVdGlscy5jc3NGdWxsUGF0aH0nIG9uOmxvYWQ9XCJ7Y3NzQ2hhcmdlfVwiPlxyXG5cclxuPHN0eWxlPlxyXG48L3N0eWxlPlxyXG5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXVhTzsifQ== */'
	};
	function MenuHorizontal($$anchor, $$props) {
	  check_target(this instanceof MenuHorizontal ? this.constructor : void 0);
	  push($$props, false);
	  append_styles$1($$anchor, $$css$3);

	  //    largeurViewportMenuBurger : {attribute: 'largeur-viewport-menu-burger'},
	  var estLangueFrancaise = Utils.estPageLangueFrancais();

	  /* PropriÃ©tÃ©s "publiques" */
	  var titre = prop($$props, 'titre', 12, estLangueFrancaise ? 'Menu principal de navigation' : 'Main navigation menu');

	  //  export let largeurViewportMenuBurger = 575
	  var afficherIconeAccueil = prop($$props, 'afficherIconeAccueil', 12, 'false');
	  var titreAccueil = prop($$props, 'titreAccueil', 12, estLangueFrancaise ? 'Accueil' : 'Home');
	  var urlAccueil = prop($$props, 'urlAccueil', 12, '/');
	  var pathCourant = prop($$props, 'pathCourant', 12, null);

	  /* PropriÃ©tÃ©s "privÃ©es" */
	  var thisComponent = prop($$props, 'thisComponent', 12);

	  /* ParamÃ¨tre non diffusÃ© pour le moment. Ã voir si on veut aller vers lÃ  */
	  var gererElementsActifs = prop($$props, 'gererElementsActifs', 12, 'true' // 
	  );
	  var afficher = false;
	  var idMenu = Utils.genererId();
	  var texteMenuPlus = estLangueFrancaise ? "Plus" : "More";
	  var texteSrMenuPlus = estLangueFrancaise ? ". Afficher les Ã©lÃ©ments de menu restants." : ". Show remaining menu items.";
	  var largeurConteneur = 0;
	  var largeurMenu = 0;
	  var largeurViewport = 0;
	  var largeurMinimaleSousMenu = 200;
	  var dernierIndexeVisible = 0;
	  var estTestBackstopJsEnCours = false;
	  var mounted = false;
	  var estCssCharge = false;

	  // RÃ©fÃ©rences pour accessibilitÃ©
	  // https://www.w3.org/WAI/ARIA/apg/patterns/disclosure/examples/disclosure-navigation/
	  //TODO Ã©ventuellement ajouter un event pour forcer la redÃ©finition des Ã©lÃ©ments actifs
	  onMount(function () {
	    estTestBackstopJsEnCours = window.location.hash.indexOf('bs-test') >= 0;

	    // ÃvÃ©nement nÃ©cessaire pour IOS... Car pour lui l'Ã©vÃ©nement blur de l'Ã©lÃ©ment de menu n'est pas exÃ©cutÃ©. Permet de s'assurer que lorsque le menu perd le focus, tous les menus sont fermÃ©s.
	    // Ã noter que sur un click d'un Ã©lÃ©ment de menu on stop la propagation du click (notre Ã©vÃ©nement ici n'est donc pas exÃ©cutÃ©)
	    document.body.addEventListener('click', function () {
	      fermerTousMenus();
	    });
	    thisComponent().shadowRoot.getElementById(idMenu);
	    if (strict_equals(afficherIconeAccueil(), 'true')) {
	      ajouterElementMenuAccueil();
	    }
	    if (strict_equals(gererElementsActifs(), 'true')) {
	      definirElementsActifs();
	    }
	    ajusterAffichageControle();
	    window.addEventListener("resize", ecranRedimensionneDebounced);
	    window.addEventListener("resize", function () {
	      indiquerAjustementEnCours();
	    });
	    mounted = true;

	    //ParticularitÃ© lors des essais avec BackstopJs. On doit forcer un rÃ©ajustement de l'affichage.
	    if (estTestBackstopJsEnCours) {
	      setTimeout(function () {
	        ajusterAffichageControle();
	      }, 500);
	    }
	  });

	  // Watch le path courant (nÃ©cessaire pour dÃ©termination Ã©lÃ©ment actif des SPA)
	  // Ajout du traitement au resize de l'interface s'il n'y a pas d'essais backstopJs en cours (sinon le screenshot se prend pendant le resize et on n'a pas le menu dans l'affichage)    
	  var ecranRedimensionneDebounced = Utils.debounce(function () {
	    ajusterAffichageControle();
	  }, 200);
	  function changementPathCourant() {
	    if (mounted) {
	      ajusterAffichageControle(true);
	      definirElementsActifs();
	    }
	  }
	  function fermerTousMenus() {
	    document.querySelectorAll('utd-menu-horizontal-item[afficher="true"]').forEach(function (elementMenu) {
	      elementMenu.setAttribute('afficher', 'false');
	    });
	  }
	  function estLargeurConteneurModifiee() {
	    return estTestBackstopJsEnCours || strict_equals(largeurViewport, document.body.offsetWidth, false);
	  }
	  function indiquerAjustementEnCours() {
	    // Si un test backstopJs ou si la largeur du conteneur n'a pas changÃ© on ne fait rien (ex. dans IOS, un resize est lancÃ© au scroll... on veut Ã©viter Ã§a.)
	    // et si un test backstopJs est en cours, on ne fait rien car il semble y avoir un resize et le screenshot se prend pendant le resize et on n'a pas le menu dans l'affichage
	    if (!estTestBackstopJsEnCours && estLargeurConteneurModifiee()) {
	      thisComponent().classList.add('ajustement-en-cours');
	    }
	  }
	  function ajusterAffichageControle(force) {
	    // On ne fait rien si aucun Ã©lÃ©ment de menu prÃ©sent.
	    if (!thisComponent().children.length) {
	      return;
	    }

	    // Si la largeur du conteneur n'a pas changÃ© on ne fait rien (ex. dans IOS, un resize est lancÃ© au scroll... on veut Ã©viter Ã§a.) Ã  moins qu'on FORCE l'ajustement (ex. quand le path-courant change)
	    if (!force && !estLargeurConteneurModifiee()) {
	      //Ici on retire par prÃ©caution, car il arrive que la classe soit lÃ ... Ã§a ne devrait pas, on ne l'explique pas mais Ã§a arrive.
	      thisComponent().classList.remove('ajustement-en-cours');
	      return;
	    }
	    largeurViewport = document.body.offsetWidth;
	    thisComponent().classList.add('ajustement-en-cours');
	    supprimerMenuPlus();
	    afficherTousMenusNiveau1();
	    setTimeout(function () {
	      {
	        if (contientMenusNonVisibles()) {
	          ajouterMenuPlusTemporaire();
	          setTimeout(function () {
	            //On enlÃ¨ve 1, car notre menuPlus temporaire ne doit pas compter
	            dernierIndexeVisible = obtenirDernierIndexeVisible() - 1;

	            //Retrait du menu Plus temporaire
	            thisComponent().children[0].remove();
	            masquerMenusExcedentaires();
	            setTimeout(function () {
	              determinerOuvertureGaucheDernierMenuNiveau1();
	              thisComponent().classList.remove('ajustement-en-cours');
	              if (estCssCharge) {
	                Utils.reafficherApresChargement(thisComponent());
	              }
	            }, 100);
	          }, 100);
	        } else {
	          // Le menu fit, rien Ã  faire!
	          determinerOuvertureGaucheDernierMenuNiveau1();
	          thisComponent().classList.remove('ajustement-en-cours');
	          if (estCssCharge) {
	            Utils.reafficherApresChargement(thisComponent());
	          }
	        }
	      }
	    });
	  }
	  function determinerOuvertureGaucheDernierMenuNiveau1() {
	    // VÃ©rifier si sous menu dernier Ã©lÃ©ment sera pleinement visible (gauche + largeurMinimaleSousMenu), sinon lui ajouter une classe pour qu'il ouvre Ã  gauche...
	    var dernierMenuNiveau1 = thisComponent().querySelector(':scope > utd-menu-horizontal-item:last-child');
	    if (dernierMenuNiveau1) {
	      var positionDroite = dernierMenuNiveau1.getBoundingClientRect().left + largeurMinimaleSousMenu;
	      if (positionDroite > largeurViewport) {
	        dernierMenuNiveau1.setAttribute('est-ouverture-gauche', 'true');
	      } else {
	        reinitialiserOuvertureGaucheMenu(dernierMenuNiveau1);
	      }
	    }
	  }
	  function reinitialiserOuvertureGaucheMenu(element) {
	    element.removeAttribute('est-ouverture-gauche');
	  }
	  function definirElementsActifs() {
	    definirTousMenusInactifs();
	    var elementActif = obtenirElementActif();
	    if (elementActif) {
	      var parents = Utils.obtenirParents(elementActif);
	      for (var i = 0; i < parents.length; i++) {
	        var parent = parents[i];
	        if (strict_equals(parent.tagName.toLowerCase(), 'utd-menu-horizontal-item')) {
	          parent.setAttribute('actif', 'true');
	        } else if (strict_equals(parent.tagName.toLowerCase(), 'utd-menu-horizontal')) {
	          break;
	        }
	      }
	    }
	  }
	  function obtenirElementActif() {
	    var itemsMenu = document.querySelectorAll('utd-menu-horizontal-item');
	    var elementActif;
	    var path = strict_equals(pathCourant(), null, false) ? pathCourant() : window.location.pathname;
	    for (var i = 0; i < itemsMenu.length; i++) {
	      var itemMenu = itemsMenu[i];
	      var href = itemMenu.getAttribute('href');
	      if (href) {
	        if (strict_equals(path, href)) {
	          elementActif = itemMenu;
	          break;
	        } else if (path.startsWith(href)) {
	          elementActif = itemMenu;
	        }
	      }
	    }
	    return elementActif;
	  }
	  function definirTousMenusInactifs() {
	    var itemsMenuActifs = document.querySelectorAll('utd-menu-horizontal-item[actif="true"]');
	    if (itemsMenuActifs.length > 0) {
	      for (var i = 0; i < itemsMenuActifs.length; i++) {
	        itemsMenuActifs[i].removeAttribute('actif');
	      }
	    }
	  }
	  function supprimerMenuPlus() {
	    var menuPlus = thisComponent().querySelector('utd-menu-horizontal-item[est-menu-plus]');
	    if (menuPlus) {
	      menuPlus.remove();
	    }
	  }
	  function afficherTousMenusNiveau1() {
	    var menus = thisComponent().querySelectorAll('utd-menu-horizontal-item.utd-d-none');
	    menus.forEach(function (menu) {
	      menu.classList.remove('utd-d-none');
	    });
	  }
	  function masquerMenusExcedentaires() {
	    var menuPlus = document.createElement('utd-menu-horizontal-item');
	    menuPlus.setAttribute('libelle', texteMenuPlus);
	    menuPlus.setAttribute('sr-libelle', texteSrMenuPlus);
	    menuPlus.setAttribute('est-menu-plus', 'true');
	    var contientElementActif = false;
	    for (var i = dernierIndexeVisible + 1; i < thisComponent().children.length; i++) {
	      var cln = thisComponent().children[i].cloneNode(true);
	      cln.setAttribute('est-menu-plus', 'true');
	      if (strict_equals(gererElementsActifs(), 'true') && strict_equals(cln.getAttribute('actif'), 'true')) {
	        contientElementActif = true;
	      }
	      if (strict_equals(i, thisComponent().children.length - 1)) {
	        cln.setAttribute('est-dernier', 'true');

	        //On retire la classe indiquant une ouverture Ã  gauche (impossible dans la situation prÃ©sente car le dernier menu est nÃ©cÃ©ssairement "masquÃ©" et inclu dans le PLUS ou le menu burger )
	        reinitialiserOuvertureGaucheMenu(thisComponent().children[i]);
	        reinitialiserOuvertureGaucheMenu(cln);
	      }
	      menuPlus.appendChild(cln);
	      thisComponent().children[i].classList.add('utd-d-none');
	    }
	    if (contientElementActif) {
	      menuPlus.setAttribute('actif', 'true');
	    }
	    thisComponent().appendChild(menuPlus);
	  }
	  function ajouterElementMenuAccueil() {
	    var menuAccueil = document.createElement('utd-menu-horizontal-item');
	    menuAccueil.setAttribute('libelle', titreAccueil());
	    menuAccueil.setAttribute('href', urlAccueil());
	    menuAccueil.setAttribute('est-menu-accueil', 'true');
	    thisComponent().prepend(menuAccueil);
	  }
	  function contientMenusNonVisibles() {
	    largeurConteneur = thisComponent().getBoundingClientRect().right;

	    //    largeurMenu = thisComponent.children[thisComponent.children.length - 1].getBoundingClientRect().right - 0.5
	    largeurMenu = thisComponent().children[thisComponent().children.length - 1].getBoundingClientRect().right;
	    return largeurMenu > largeurConteneur;
	  }
	  function obtenirDernierIndexeVisible() {
	    var menuVisible = true;
	    var i = 0;
	    var indexeDernierElementVisible = 0;
	    while (menuVisible && i <= thisComponent().children.length - 1) {
	      var item = thisComponent().children[i];
	      if (item.getBoundingClientRect().right <= largeurConteneur) {
	        indexeDernierElementVisible = i;
	        i++;
	      } else {
	        menuVisible = false;
	      }
	    }
	    return indexeDernierElementVisible;
	  }
	  function ajouterMenuPlusTemporaire() {
	    var menuPlusTemp = document.createElement('utd-menu-horizontal-item');
	    menuPlusTemp.setAttribute('libelle', texteMenuPlus);
	    menuPlusTemp.setAttribute('est-menu-plus', 'true');
	    var elementTemp = document.createElement('utd-menu-horizontal-item');
	    elementTemp.setAttribute('libelle', 'Temporaire');
	    menuPlusTemp.appendChild(elementTemp);
	    thisComponent().prepend(menuPlusTemp);
	  }
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  legacy_pre_effect(function () {
	    return deep_read_state(pathCourant());
	  }, function () {
	    changementPathCourant(pathCourant());
	  });
	  legacy_pre_effect_reset();
	  var $$exports = _objectSpread$e({
	    get titre() {
	      return titre();
	    },
	    set titre($$value) {
	      titre($$value);
	      flushSync();
	    },
	    get afficherIconeAccueil() {
	      return afficherIconeAccueil();
	    },
	    set afficherIconeAccueil($$value) {
	      afficherIconeAccueil($$value);
	      flushSync();
	    },
	    get titreAccueil() {
	      return titreAccueil();
	    },
	    set titreAccueil($$value) {
	      titreAccueil($$value);
	      flushSync();
	    },
	    get urlAccueil() {
	      return urlAccueil();
	    },
	    set urlAccueil($$value) {
	      urlAccueil($$value);
	      flushSync();
	    },
	    get pathCourant() {
	      return pathCourant();
	    },
	    set pathCourant($$value) {
	      pathCourant($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    },
	    get gererElementsActifs() {
	      return gererElementsActifs();
	    },
	    set gererElementsActifs($$value) {
	      gererElementsActifs($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$e();
	  var nav = first_child(fragment);
	  set_class(nav, 1, 'utd-menu-horizontal', null, {}, {
	    visible: afficher
	  });
	  var div = child(nav);
	  set_class(div, 1, 'menu', null, {}, {
	    visible: afficher
	  });
	  var node = child(div);
	  slot(node, $$props, 'default', {});
	  reset(div);
	  reset(nav);
	  var link = sibling(nav, 2);
	  template_effect(function () {
	    set_attribute(nav, 'aria-label', titre());
	    set_attribute(div, 'id', idMenu);
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-menu-horizontal', create_custom_element(MenuHorizontal, {
	  titre: {
	    attribute: 'titre'
	  },
	  afficherIconeAccueil: {
	    attribute: 'afficher-icone-accueil'
	  },
	  titreAccueil: {
	    attribute: 'titre-accueil'
	  },
	  urlAccueil: {
	    attribute: 'url-accueil'
	  },
	  pathCourant: {
	    attribute: 'path-courant'
	  },
	  thisComponent: {},
	  gererElementsActifs: {}
	}, ['default'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$e(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$d(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$d() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$d() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$d = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$d(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$d(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$d(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	MenuHorizontalItem[FILENAME] = 'src/components/menuHorizontalItem.svelte';
	var root_2$6 = add_locations(from_html("<span class=\"utd-sr-only\"> </span>"), MenuHorizontalItem[FILENAME], [[327, 10]]);
	var root_3$5 = add_locations(from_html("<span aria-hidden=\"true\"></span>"), MenuHorizontalItem[FILENAME], [[330, 10]]);
	var root_4$2 = add_locations(from_html("<div role=\"list\" class=\"sous-menu\"><!></div>"), MenuHorizontalItem[FILENAME], [[335, 6]]);
	var root_1$6 = add_locations(from_html("<a role=\"button\"><span class=\"item-menu\"><span><!></span> <!> <!></span></a> <!>", 1), MenuHorizontalItem[FILENAME], [[323, 4, [[324, 6, [[325, 8]]]]]]);
	var root_7$3 = add_locations(from_html("<span><!></span>"), MenuHorizontalItem[FILENAME], [[343, 10]]);
	var root_8$1 = add_locations(from_html("<span aria-hidden=\"true\" class=\"utd-icone-svg maison\"></span>"), MenuHorizontalItem[FILENAME], [[345, 10]]);
	var root_10$2 = add_locations(from_html("<span><span class=\"tiret\"></span><!></span>"), MenuHorizontalItem[FILENAME], [[349, 10, [[349, 16]]]]);
	var root_11$1 = add_locations(from_html("<span><!></span>"), MenuHorizontalItem[FILENAME], [[351, 10]]);
	var root_12$1 = add_locations(from_html("<span class=\"utd-sr-only\"> </span>"), MenuHorizontalItem[FILENAME], [[355, 8]]);
	var root_5$5 = add_locations(from_html("<a><!> <!></a>"), MenuHorizontalItem[FILENAME], [[340, 4]]);
	var root$d = add_locations(from_html("<div role=\"listitem\"><!></div> <link rel=\"stylesheet\"/>", 1), MenuHorizontalItem[FILENAME], [[321, 0], [361, 0]]);
	var $$css$2 = {
	  hash: 'svelte-ipgobw',
	  code: '\r\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVudUhvcml6b250YWxJdGVtLnN2ZWx0ZSIsInNvdXJjZXMiOlsibWVudUhvcml6b250YWxJdGVtLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c3ZlbHRlOm9wdGlvbnMgY3VzdG9tRWxlbWVudD17e1xyXG4gIHRhZzogJ3V0ZC1tZW51LWhvcml6b250YWwtaXRlbScsXHJcbiAgZXh0ZW5kOiAoY3VzdG9tRWxlbWVudENvbnN0cnVjdG9yKSA9PiB7XHJcbiAgICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBjdXN0b21FbGVtZW50Q29uc3RydWN0b3Ige1xyXG4gICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudGhpc0NvbXBvbmVudCA9IHRoaXM7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSxcclxuICBwcm9wczoge1xyXG4gICAgbGliZWxsZSA6IHthdHRyaWJ1dGU6ICdsaWJlbGxlJ30sXHJcbiAgICBocmVmIDoge2F0dHJpYnV0ZTogJ2hyZWYnfSxcclxuICAgIHNyTGliZWxsZSA6IHthdHRyaWJ1dGU6ICdzci1saWJlbGxlJ30sXHJcbiAgICBhZmZpY2hlciA6IHthdHRyaWJ1dGU6ICdhZmZpY2hlcid9LFxyXG4gICAgYW5pbWVyIDoge2F0dHJpYnV0ZTogJ2FuaW1lcid9LFxyXG4gICAgZm9jdXMgOiB7YXR0cmlidXRlOiAnZm9jdXMnfSxcclxuICAgIGFjdGlmIDoge2F0dHJpYnV0ZTogJ2FjdGlmJ30sXHJcbiAgICBlc3RNZW51UGx1cyA6IHthdHRyaWJ1dGU6ICdlc3QtbWVudS1wbHVzJ30sXHJcbiAgICBlc3RNZW51QnVyZ2VyIDoge2F0dHJpYnV0ZTogJ2VzdC1tZW51LWJ1cmdlcid9LFxyXG4gICAgZXN0TWVudUFjY3VlaWwgOiB7YXR0cmlidXRlOiAnZXN0LW1lbnUtYWNjdWVpbCd9LFxyXG4gICAgZXN0RGVybmllciA6IHthdHRyaWJ1dGU6ICdlc3QtZGVybmllcid9LFxyXG4gICAgZXN0T3V2ZXJ0dXJlR2F1Y2hlIDoge2F0dHJpYnV0ZTogJ2VzdC1vdXZlcnR1cmUtZ2F1Y2hlJ31cclxuICB9ICAgIFxyXG59fS8+XHJcblxyXG48c2NyaXB0PlxyXG4gIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XHJcbiAgaW1wb3J0IHsgVXRpbHMgfSBmcm9tIFwiLi9qcy91dGlsc1wiXHJcbiAgaW1wb3J0IHsgc2xpZGUgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIlxyXG5cclxuICAvKiBQcm9wcmnDqXTDqXMgXCJwdWJsaXF1ZXNcIiAqL1xyXG4gIGV4cG9ydCBsZXQgbGliZWxsZSA9ICcnXHJcbiAgZXhwb3J0IGxldCBocmVmID0gJydcclxuXHJcbiAgLyogUHJvcHJpw6l0w6lzIFwiaW50ZXJuZXNcIiAqL1xyXG4gIGV4cG9ydCBsZXQgdGhpc0NvbXBvbmVudFxyXG4gIGV4cG9ydCBsZXQgc3JMaWJlbGxlID0gJydcclxuICBleHBvcnQgbGV0IGFmZmljaGVyID0gJ2ZhbHNlJ1xyXG4gIGV4cG9ydCBsZXQgYW5pbWVyID0gJ3RydWUnXHJcbiAgZXhwb3J0IGxldCBmb2N1cyA9ICdmYWxzZSdcclxuICBleHBvcnQgbGV0IGFjdGlmID0gJ2ZhbHNlJ1xyXG4gIGV4cG9ydCBsZXQgZXN0TWVudVBsdXMgPSAnZmFsc2UnXHJcbiAgZXhwb3J0IGxldCBlc3RNZW51QnVyZ2VyID0gJ2ZhbHNlJ1xyXG4gIGV4cG9ydCBsZXQgZXN0TWVudUFjY3VlaWwgPSAnZmFsc2UnXHJcbiAgZXhwb3J0IGxldCBlc3REZXJuaWVyID0gJ2ZhbHNlJ1xyXG4gIGV4cG9ydCBsZXQgZXN0T3V2ZXJ0dXJlR2F1Y2hlID0gJ2ZhbHNlJ1xyXG5cclxuICBsZXQgcG9zc2VkZUVuZmFudHMgPSBmYWxzZVxyXG4gIGxldCBuaXZlYXUgPSAxXHJcbiAgbGV0IHV0ZE1lbnVIb3Jpem9udGFsUGFyZW50XHJcbiAgICBcclxuICBjb25zdCBpZENvbXBvc2FudCA9IHRoaXNDb21wb25lbnQuZ2V0QXR0cmlidXRlKCdpZHV0ZCcpIHx8IFV0aWxzLmdlbmVyZXJJZCgpXHJcbiAgY29uc3QgaWRTb3VzTWVudSA9IFV0aWxzLmdlbmVyZXJJZCgpXHJcbiBcclxuICBvbk1vdW50KCgpID0+IHtcclxuICAgIHRoaXNDb21wb25lbnQuc2V0QXR0cmlidXRlKCdpZHV0ZCcsIGlkQ29tcG9zYW50KVxyXG4gICAgXHJcbiAgICAvL1BhdGNoIHBvdXIgVnVlIGpzIHF1aSBmbHVzaCBsZXMgYXR0cmlidXRzIHNww6ljaWZpw6lzIGRhbnMgbGUgbW9kw6hsZSAoZW4gbGVzIHJlbXBsYWNhbnRzIHBhciBkZXMgcHJvcHMpLiBPbiByZW1ldCBub3MgYXR0cmlidXRzLlxyXG4gICAgdGhpc0NvbXBvbmVudC5zZXRBdHRyaWJ1dGUoJ2xpYmVsbGUnLCBsaWJlbGxlKVxyXG4gICAgdGhpc0NvbXBvbmVudC5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKVxyXG5cclxuICAgIG5pdmVhdSA9IG9idGVuaXJOaXZlYXUoKVxyXG4gICAgcG9zc2VkZUVuZmFudHMgPSAhIXRoaXNDb21wb25lbnQucXVlcnlTZWxlY3RvcigndXRkLW1lbnUtaG9yaXpvbnRhbC1pdGVtJylcclxuXHJcbiAgICB1dGRNZW51SG9yaXpvbnRhbFBhcmVudCA9IHRoaXNDb21wb25lbnQuY2xvc2VzdCgndXRkLW1lbnUtaG9yaXpvbnRhbCcpXHJcbiAgfSlcclxuXHJcbiAgLy8gV2F0Y2ggc3VyIGxhIHByb3AgZm9jdXNcclxuICAkOiB0b2dnbGVGb2N1cyhmb2N1cykgXHJcblxyXG4gIGZ1bmN0aW9uIHRvZ2dsZUZvY3VzKCl7XHJcbiAgICBpZihmb2N1cyA9PT0gJ3RydWUnKXtcclxuICAgICAgY29uc3QgcHJlbWllckxpZW4gPSB0aGlzQ29tcG9uZW50LnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcignYScpXHJcbiAgICAgIGlmKHByZW1pZXJMaWVuKXtcclxuICAgICAgICBwcmVtaWVyTGllbi5mb2N1cygpXHJcbiAgICAgIH1cclxuICAgICAgZm9jdXMgPSAnZmFsc2UnXHJcbiAgICAgIHRoaXNDb21wb25lbnQuc2V0QXR0cmlidXRlKCdmb2N1cycsICdmYWxzZScpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0b2dnbGVBZmZpY2hlcihlKSB7ICAgIFxyXG4gICAgXHJcbiAgICAvLyBMb3JzcXUnb24gZG9pdCBhZmZpY2hlciB1biBzb3VzIG1lbnUsIG9uIGRvaXQgdG91cyBsZXMgZmVybWVyIGQnYWJvcmQuXHJcbiAgICBpZihhZmZpY2hlciA9PT0gJ2ZhbHNlJyl7XHJcbiAgICAgIGZlcm1lck1lbnVzTml2ZWF1Q291cmFudCgpXHJcbiAgICB9XHJcblxyXG4gICAgdGhpc0NvbXBvbmVudC5zZXRBdHRyaWJ1dGUoJ2FmZmljaGVyJywgYWZmaWNoZXIgPT09ICd0cnVlJyA/ICdmYWxzZScgOiAndHJ1ZScpXHJcbiAgIFxyXG4gICAgLy8gSWNpIHBldGl0ZSB0d2lzdCBwb3VyIElPUyBhZmluIGRlIGJsb3F1ZXIgbGEgcHJvcGFnYXRpb24gZHUgY2xpY2sgc3VyIHVuIMOpbMOpbWVudCBkZSBtZW51LCBjYXIgdW4gY2xpY2sgc3VyIGxlIGJvZHkgYSDDqXTDqSBham91dMOpIHBvdXIgSU9TICh2b2lyIG1vdW50IGR1IGNvbXBvc2FudCBtZW51SG9yaXpvbnRhbClcclxuICAgIGlmKGUpe1xyXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpICAgICAgICAgIFxyXG4gICAgfSAgICBcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNsaWNrTGllbihlKSB7XHJcblxyXG4gICAgaWYoZXN0TWVudUFjY3VlaWwgPT09ICd0cnVlJyl7XHJcbiAgICAgIGNsaWNrQWNjdWVpbChlKVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICAvL1NpIHVuIGxpZW4gZXhpc3RlIGRhbnMgbm90cmUgw6lsw6ltZW50IGRlIG1lbnUgKGlsIGEgZG9uYyDDqXTDqSBzcMOpY2lmacOpIGRhbnMgbGEgc2xvdCBwYXIgZMOpZmF1dCwgZXguIHBvdXIgZGVzIFNQQSBhdmVjIFZ1ZUpzKVxyXG4gICAgLy9vbiBkb2l0IHV0aWxpc2VyIGwnw6l2w6luZW1lbnQgY2xpY2sgZGUgY2UgbGllbi4gIFxyXG5cclxuICAgIGNvbnN0IGxpZW4gPSB0aGlzQ29tcG9uZW50LnF1ZXJ5U2VsZWN0b3IoJ2EnKVxyXG4gICAgICAgIFxyXG4gICAgaWYobGllbikge1xyXG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcclxuXHJcbiAgICAgIC8vT24gdsOpcmlmaWUgcydpbCBleGlzdGUgdW4gw6lsw6ltZW50IGRlIG1lbnUgY2FjaMOpIGF2ZWMgdW4gaWQgaWRlbnRpcXVlIGF1IG7DtHRyZSwgc2kgYydlc3QgbGUgY2FzLCBjJ2VzdCBsZSBsaWVuIGRlIGNldCDDqWzDqW1lbnQgcXUnb24gZG9pdCB1dGlsaXNlci5cclxuICAgICAgLy9DZXQgw6lsw6ltZW50IGVzdCBsJ8OpbMOpbWVudCBvcmlnaW5hbCBxdWUgbm91cyBhdm9ucyBwZSBjYWNow6kgcG91ciBhZmZpY2hhZ2UgbW9iaWxlLCBldCBsdWkgc2V1bCBjb250aWVudCBsJ8OpdsOpbmVtZW50IG9yaWdpbmFsLlxyXG4gICAgICBjb25zdCBzbG90T3JpZ2luYWxlID0gdXRkTWVudUhvcml6b250YWxQYXJlbnQucXVlcnlTZWxlY3RvcihgdXRkLW1lbnUtaG9yaXpvbnRhbC1pdGVtW2lkdXRkPVwiJHtpZENvbXBvc2FudH1cIl0udXRkLWQtbm9uZWApXHJcblxyXG4gICAgICBsZXQgbGllblNsb3RPcmlnaW5hbGVcclxuICAgICAgaWYoc2xvdE9yaWdpbmFsZSkge1xyXG4gICAgICAgIGxpZW5TbG90T3JpZ2luYWxlID0gc2xvdE9yaWdpbmFsZS5xdWVyeVNlbGVjdG9yKCdhJylcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgaWYobGllblNsb3RPcmlnaW5hbGUpIHtcclxuICAgICAgICBsaWVuU2xvdE9yaWdpbmFsZS5jbGljaygpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGllbi5jbGljaygpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNsaWNrQWNjdWVpbChlKSB7ICAgXHJcbiAgICBjb25zdCBsaWVuQWNjdWVpbCA9IHV0ZE1lbnVIb3Jpem9udGFsUGFyZW50LnF1ZXJ5U2VsZWN0b3IoJ2EnKVxyXG5cclxuICAgIGlmKGxpZW5BY2N1ZWlsKSB7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxyXG4gICAgICBsaWVuQWNjdWVpbC5jbGljaygpXHJcbiAgICB9ICAgIFxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZmVybWVyTWVudXNOaXZlYXVDb3VyYW50KCkge1xyXG4gICAgICBjb25zdCBtZW51cyA9IG9idGVuaXJFbGVtZW50c05pdmVhdUNvdXJhbnQoKVxyXG5cclxuICAgICAgbWVudXMuZm9yRWFjaCgobWVudSkgPT4ge1xyXG4gICAgICAgIG1lbnUuc2V0QXR0cmlidXRlKCdhZmZpY2hlcicsICdmYWxzZScpXHJcbiAgICAgIH0pXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmZXJtZXJNZW51UGFyZW50KCkge1xyXG4gICAgICB0aGlzQ29tcG9uZW50LnBhcmVudEVsZW1lbnQuc2V0QXR0cmlidXRlKCdhZmZpY2hlcicsICdmYWxzZScpXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmZXJtZXJUb3VzTWVudXMoKSB7XHJcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCd1dGQtbWVudS1ob3Jpem9udGFsLWl0ZW1bYWZmaWNoZXI9XCJ0cnVlXCJdJykuZm9yRWFjaCgoZWxlbWVudE1lbnUpID0+IHtcclxuICAgICAgZWxlbWVudE1lbnUuc2V0QXR0cmlidXRlKCdhZmZpY2hlcicswqAnZmFsc2UnKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG9idGVuaXJFbGVtZW50c05pdmVhdUNvdXJhbnQoKSB7XHJcbiAgICBpZih0aGlzQ29tcG9uZW50KXtcclxuICAgICAgICAgICAgXHJcbiAgICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbSh0aGlzQ29tcG9uZW50LnBhcmVudEVsZW1lbnQuY2hpbGRyZW4pLmZpbHRlcigoZW5mYW50KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGVuZmFudC5tYXRjaGVzKCd1dGQtbWVudS1ob3Jpem9udGFsLWl0ZW06bm90KC51dGQtZC1ub25lKScpXHJcbiAgICAgIH0pXHJcbiAgICAgIHJldHVybiBpdGVtc1xyXG4gICAgfSAgICAgICAgICBcclxuICAgIHJldHVybiBudWxsICAgICAgXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvYnRlbmlyRWxlbWVudHNOaXZlYXVTdWl2YW50KCkge1xyXG4gICAgaWYodGhpc0NvbXBvbmVudCl7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzQ29tcG9uZW50LmNoaWxkcmVuKS5maWx0ZXIoKGVuZmFudCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBlbmZhbnQubWF0Y2hlcygndXRkLW1lbnUtaG9yaXpvbnRhbC1pdGVtJylcclxuICAgICAgfSlcclxuICAgIH0gICAgICAgICAgXHJcbiAgICByZXR1cm4gbnVsbCAgICAgIFxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb2J0ZW5pck5pdmVhdSgpe1xyXG4gICAgbGV0IG5pdmVhdSA9IDFcclxuICAgIGxldCBlbGVtZW50UGFyZW50ID0gdGhpc0NvbXBvbmVudC5wYXJlbnRFbGVtZW50XHJcbiAgICBcclxuICAgIHdoaWxlIChlbGVtZW50UGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3V0ZC1tZW51LWhvcml6b250YWwtaXRlbScpIHtcclxuICAgICAgICArK25pdmVhdVxyXG4gICAgICAgIGVsZW1lbnRQYXJlbnQgPSBlbGVtZW50UGFyZW50LnBhcmVudEVsZW1lbnRcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbml2ZWF1XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmZXJtZXJNZW51cygpIHtcclxuICAgIGlmKG5pdmVhdSA9PT0gMSkge1xyXG4gICAgICBmZXJtZXJUb3VzTWVudXMoKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZmVybWVyTWVudXNOaXZlYXVDb3VyYW50KClcclxuICAgICAgZmVybWVyTWVudVBhcmVudCgpXHJcbiAgICAgIHRoaXNDb21wb25lbnQucGFyZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZvY3VzJywgJ3RydWUnKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcclxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXNDb21wb25lbnQucGFyZW50RWxlbWVudFxyXG5cclxuICAgIHN3aXRjaChlLmtleSkge1xyXG4gICAgICBjYXNlIFwiRXNjYXBlXCI6XHJcbiAgICAgICAgZmVybWVyTWVudXMoKVxyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiRW50ZXJcIjpcclxuICAgICAgY2FzZSBcIiBcIjpcclxuICAgICAgICBpZihwb3NzZWRlRW5mYW50cyl7XHJcbiAgICAgICAgICB0b2dnbGVBZmZpY2hlcigpXHJcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XHJcbiAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjogICAgICAgICAgICAgIFxyXG4gICAgICAgIGRvbm5lckZvY3VzRWxlbWVudFByZWNlZGVudChvYnRlbmlyRWxlbWVudHNOaXZlYXVDb3VyYW50KCkpICBcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcclxuICAgICAgICBicmVha1xyXG4gICAgICBjYXNlIFwiQXJyb3dEb3duXCI6ICAgICAgICBcclxuICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcclxuICAgICAgICBpZihwb3NzZWRlRW5mYW50cyl7XHJcbiAgICAgICAgICBpZihhZmZpY2hlciA9PT0gJ3RydWUnKXtcclxuICAgICAgICAgICAgZG9ubmVyRm9jdXNFbGVtZW50U3VpdmFudChvYnRlbmlyRWxlbWVudHNOaXZlYXVTdWl2YW50KCkpICAgICAgICAgICBcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbm5lckZvY3VzRWxlbWVudFN1aXZhbnQob2J0ZW5pckVsZW1lbnRzTml2ZWF1Q291cmFudCgpKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkb25uZXJGb2N1c0VsZW1lbnRTdWl2YW50KG9idGVuaXJFbGVtZW50c05pdmVhdUNvdXJhbnQoKSlcclxuICAgICAgICB9XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpICAgICAgICBcclxuICAgICAgICBicmVhazsgICAgICAgIFxyXG5cclxuICAgICAgY2FzZSBcIkhvbWVcIjogICAgICAgIFxyXG4gICAgICAgIGlmKHBvc3NlZGVFbmZhbnRzKXtcclxuICAgICAgICAgIGlmKGFmZmljaGVyID09PSAndHJ1ZScpe1xyXG4gICAgICAgICAgICBkb25uZXJGb2N1c1ByZW1pZXJFbGVtZW50KG9idGVuaXJFbGVtZW50c05pdmVhdVN1aXZhbnQoKSkgICAgICAgICAgIFxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZG9ubmVyRm9jdXNQcmVtaWVyRWxlbWVudChvYnRlbmlyRWxlbWVudHNOaXZlYXVDb3VyYW50KCkpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGRvbm5lckZvY3VzUHJlbWllckVsZW1lbnQob2J0ZW5pckVsZW1lbnRzTml2ZWF1Q291cmFudCgpKVxyXG4gICAgICAgIH1cclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCkgICAgICAgIFxyXG4gICAgICAgIGJyZWFrOyAgICAgICBcclxuXHJcbiAgICAgIGNhc2UgXCJFbmRcIjogICAgICAgIFxyXG4gICAgICAgIGlmKHBvc3NlZGVFbmZhbnRzKXtcclxuICAgICAgICAgIGlmKGFmZmljaGVyID09PSAndHJ1ZScpe1xyXG4gICAgICAgICAgICBkb25uZXJGb2N1c0Rlcm5pZXJFbGVtZW50KG9idGVuaXJFbGVtZW50c05pdmVhdVN1aXZhbnQoKSkgICAgICAgICAgIFxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZG9ubmVyRm9jdXNEZXJuaWVyRWxlbWVudChvYnRlbmlyRWxlbWVudHNOaXZlYXVDb3VyYW50KCkpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGRvbm5lckZvY3VzRGVybmllckVsZW1lbnQob2J0ZW5pckVsZW1lbnRzTml2ZWF1Q291cmFudCgpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpICAgICAgICBcclxuICAgICAgICBicmVhazsgICAgICAgIFxyXG5cdFx0IH1cclxuXHR9XHJcblxyXG4gIGZ1bmN0aW9uIGRvbm5lckZvY3VzRWxlbWVudFN1aXZhbnQoZWxlbWVudHMpIHtcclxuICAgIGlmKCFlbGVtZW50cy5sZW5ndGgpe1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpbmRleGVDb3VyYW50ID0gZWxlbWVudHMuaW5kZXhPZih0aGlzQ29tcG9uZW50KVxyXG4gICAgICAgIFxyXG4gICAgaWYoaW5kZXhlQ291cmFudCA+PSAwKXtcclxuICAgICAgY29uc3QgcHJvY2hhaW5JbmRleGUgPSBNYXRoLm1pbihlbGVtZW50cy5sZW5ndGggLSAxLCBpbmRleGVDb3VyYW50ICsgMSlcclxuICAgICAgZWxlbWVudHNbcHJvY2hhaW5JbmRleGVdLnNldEF0dHJpYnV0ZSgnZm9jdXMnLCAndHJ1ZScpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbGVtZW50c1swXS5zZXRBdHRyaWJ1dGUoJ2ZvY3VzJywgJ3RydWUnKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZG9ubmVyRm9jdXNEZXJuaWVyRWxlbWVudChlbGVtZW50cykge1xyXG4gICAgaWYoIWVsZW1lbnRzLmxlbmd0aCl7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0uc2V0QXR0cmlidXRlKCdmb2N1cycsICd0cnVlJylcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRvbm5lckZvY3VzUHJlbWllckVsZW1lbnQoZWxlbWVudHMpIHtcclxuICAgIGlmKCFlbGVtZW50cy5sZW5ndGgpe1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIGVsZW1lbnRzWzBdLnNldEF0dHJpYnV0ZSgnZm9jdXMnLCAndHJ1ZScpXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkb25uZXJGb2N1c0VsZW1lbnRQcmVjZWRlbnQoZWxlbWVudHMpIHtcclxuICAgIFxyXG4gICAgaWYoIWVsZW1lbnRzLmxlbmd0aCl7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gICAgY29uc3QgaW5kZXhlQ291cmFudCA9IGVsZW1lbnRzLmluZGV4T2YodGhpc0NvbXBvbmVudClcclxuXHJcbiAgICBpZihpbmRleGVDb3VyYW50ID49IDApe1xyXG4gICAgICBjb25zdCBwcm9jaGFpbkluZGV4ZSA9IE1hdGgubWF4KDAsIGluZGV4ZUNvdXJhbnQgLSAxKVxyXG4gICAgICBlbGVtZW50c1twcm9jaGFpbkluZGV4ZV0uc2V0QXR0cmlidXRlKCdmb2N1cycsICd0cnVlJylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVsZW1lbnRzWzBdLnNldEF0dHJpYnV0ZSgnZm9jdXMnLCAndHJ1ZScpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvbkJsdXIoZSl7XHJcbiAgICBpZighdXRkTWVudUhvcml6b250YWxQYXJlbnQuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSl7XHJcbiAgICAgIGNvbnN0IGl0ZW1zTWVudSA9IHV0ZE1lbnVIb3Jpem9udGFsUGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3V0ZC1tZW51LWhvcml6b250YWwtaXRlbScpXHJcbiAgICAgIGl0ZW1zTWVudS5mb3JFYWNoKChpdGVtKSA9PiB7XHJcbiAgICAgICAgaXRlbS5zZXRBdHRyaWJ1dGUoJ2FmZmljaGVyJyzCoCdmYWxzZScpXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjc3NDaGFyZ2UoZSkgeyAgICAgICBcclxuICAgIFV0aWxzLnJlYWZmaWNoZXJBcHJlc0NoYXJnZW1lbnQodGhpc0NvbXBvbmVudCk7ICAgICBcclxuICB9XHJcblxyXG48L3NjcmlwdD5cclxuPGRpdiBjbGFzcz1cInV0ZC1tZW51LWhvcml6b250YWwtaXRlbSBuaXZ7bml2ZWF1fXthZmZpY2hlciA9PT0gJ3RydWUnID8gJyB2aXNpYmxlJyA6ICcnfXthY3RpZiA9PT0gJ3RydWUnID8gJyBhY3RpdmUnIDogJyd9e2VzdE1lbnVQbHVzID09PSAndHJ1ZScgPyAnIG1lbnUtcGx1cycgOiAnJ317ZXN0TWVudUJ1cmdlciA9PT0gJ3RydWUnID8gJyBtZW51LWJ1cmdlcicgOiAnJ317ZXN0RGVybmllciA9PT0gJ3RydWUnID8gJyBkZXJuaWVyJyA6ICcnfXtlc3RPdXZlcnR1cmVHYXVjaGUgPT09ICd0cnVlJyA/ICcgb3V2ZXJ0dXJlLWdhdWNoZScgOiAnJ31cIiByb2xlPVwibGlzdGl0ZW1cIj5cclxuICB7I2lmIHBvc3NlZGVFbmZhbnRzfSAgICBcclxuICAgIDxhIHJvbGU9XCJidXR0b25cIiBocmVmPVwie2hyZWZ9XCIgYXJpYS1leHBhbmRlZD1cInthZmZpY2hlcn1cIiBhcmlhLWNvbnRyb2xzPVwie2lkU291c01lbnV9XCIgb246Y2xpY2t8cHJldmVudERlZmF1bHQ9e3RvZ2dsZUFmZmljaGVyfSBvbjprZXlkb3duPXtvbktleURvd259IG9uOmJsdXI9e29uQmx1cn0+XHJcbiAgICAgIDxzcGFuIGNsYXNzPVwiaXRlbS1tZW51XCI+XHJcbiAgICAgICAgPHNwYW4+e0BodG1sIGxpYmVsbGV9PC9zcGFuPlxyXG4gICAgICAgIHsjaWYgc3JMaWJlbGxlfSAgICBcclxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwidXRkLXNyLW9ubHlcIj57c3JMaWJlbGxlfTwvc3Bhbj5cclxuICAgICAgICB7L2lmfVxyXG4gICAgICAgIHsjaWYgbml2ZWF1ICE9PSAxIHx8IGVzdE1lbnVCdXJnZXIgIT09ICd0cnVlJ30gICAgXHJcbiAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzcz1cInV0ZC1pY29uZS1zdmcge25pdmVhdSA9PT0gMSA/ICdjaGV2cm9uLWJsYW5jJyA6ICdjaGV2cm9uLWJsZXUtcGl2J31cIj48L3NwYW4+XHJcbiAgICAgICAgey9pZn0gICAgICBcclxuICAgICAgPC9zcGFuPlxyXG4gICAgPC9hPlxyXG4gICAgeyNpZiBhZmZpY2hlciA9PT0gJ3RydWUnfVxyXG4gICAgICA8ZGl2IGlkPVwie2lkU291c01lbnV9XCIgcm9sZT1cImxpc3RcIiBjbGFzcz1cInNvdXMtbWVudVwiIHRyYW5zaXRpb246c2xpZGU9XCJ7e2R1cmF0aW9uOiBhbmltZXIgPT09J3RydWUnID8gMjUwOiAwfX1cIj5cclxuICAgICAgICA8c2xvdD48L3Nsb3Q+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgey9pZn1cclxuICB7OmVsc2V9XHJcbiAgICA8YSBocmVmPVwie2hyZWZ9XCIgdGl0bGU9XCJ7ZXN0TWVudUFjY3VlaWwgPT09ICd0cnVlJyA/IGxpYmVsbGUgOiBudWxsfVwiIG9uOmNsaWNrPXtjbGlja0xpZW59IGFyaWEtY3VycmVudD1cInthY3RpZiA9PT0gJ3RydWUnID8gJ3BhZ2UnIDogbnVsbH1cIiBvbjprZXlkb3duPXtvbktleURvd259IG9uOmJsdXI9e29uQmx1cn0+XHJcbiAgICAgIHsjaWYgZXN0TWVudUFjY3VlaWwgPT09ICd0cnVlJ31cclxuICAgICAgICB7I2lmIGVzdE1lbnVCdXJnZXIgPT09ICd0cnVlJ30gICAgXHJcbiAgICAgICAgICA8c3Bhbj57QGh0bWwgbGliZWxsZX08L3NwYW4+ICAgICAgICBcclxuICAgICAgICB7OmVsc2V9XHJcbiAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzcz1cInV0ZC1pY29uZS1zdmcgbWFpc29uXCI+PC9zcGFuPlxyXG4gICAgICAgIHsvaWZ9ICAgICAgICAgICAgICAgIFxyXG4gICAgICB7OmVsc2V9XHJcbiAgICAgICAgeyNpZiBuaXZlYXUgPT09IDN9XHJcbiAgICAgICAgICA8c3Bhbj48c3BhbiBjbGFzcz1cInRpcmV0XCI+PC9zcGFuPntAaHRtbCBsaWJlbGxlfTwvc3Bhbj5cclxuICAgICAgICB7OmVsc2V9XHJcbiAgICAgICAgICA8c3Bhbj57QGh0bWwgbGliZWxsZX08L3NwYW4+XHJcbiAgICAgICAgey9pZn1cclxuICAgICAgey9pZn0gICAgICAgIFxyXG4gICAgICB7I2lmIHNyTGliZWxsZX0gICAgXHJcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJ1dGQtc3Itb25seVwiPntzckxpYmVsbGV9PC9zcGFuPlxyXG4gICAgICB7L2lmfVxyXG4gICAgPC9hPiAgICBcclxuICB7L2lmfVxyXG4gIFxyXG48L2Rpdj5cclxuPGxpbmsgcmVsPSdzdHlsZXNoZWV0JyBocmVmPSd7VXRpbHMuY3NzRnVsbFBhdGh9JyBvbjpsb2FkPVwie2Nzc0NoYXJnZX1cIj5cclxuXHJcbjxzdHlsZT5cclxuPC9zdHlsZT5cclxuXHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUEwV087In0= */'
	};
	function MenuHorizontalItem($$anchor, $$props) {
	  check_target(this instanceof MenuHorizontalItem ? this.constructor : void 0);
	  push($$props, false);
	  append_styles$1($$anchor, $$css$2);

	  /* PropriÃ©tÃ©s "publiques" */
	  var libelle = prop($$props, 'libelle', 12, '');
	  var href = prop($$props, 'href', 12, '');

	  /* PropriÃ©tÃ©s "internes" */
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var srLibelle = prop($$props, 'srLibelle', 12, '');
	  var afficher = prop($$props, 'afficher', 12, 'false');
	  var animer = prop($$props, 'animer', 12, 'true');
	  var focus = prop($$props, 'focus', 12, 'false');
	  var actif = prop($$props, 'actif', 12, 'false');
	  var estMenuPlus = prop($$props, 'estMenuPlus', 12, 'false');
	  var estMenuBurger = prop($$props, 'estMenuBurger', 12, 'false');
	  var estMenuAccueil = prop($$props, 'estMenuAccueil', 12, 'false');
	  var estDernier = prop($$props, 'estDernier', 12, 'false');
	  var estOuvertureGauche = prop($$props, 'estOuvertureGauche', 12, 'false');
	  var possedeEnfants = mutable_source(false);
	  var niveau = mutable_source(1);
	  var utdMenuHorizontalParent;
	  var idComposant = thisComponent().getAttribute('idutd') || Utils.genererId();
	  var idSousMenu = Utils.genererId();
	  onMount(function () {
	    thisComponent().setAttribute('idutd', idComposant);

	    //Patch pour Vue js qui flush les attributs spÃ©cifiÃ©s dans le modÃ¨le (en les remplacants par des props). On remet nos attributs.
	    thisComponent().setAttribute('libelle', libelle());
	    thisComponent().setAttribute('href', href());
	    set(niveau, obtenirNiveau());
	    set(possedeEnfants, !!thisComponent().querySelector('utd-menu-horizontal-item'));
	    utdMenuHorizontalParent = thisComponent().closest('utd-menu-horizontal');
	  });

	  // Watch sur la prop focus
	  function toggleFocus() {
	    if (strict_equals(focus(), 'true')) {
	      var premierLien = thisComponent().shadowRoot.querySelector('a');
	      if (premierLien) {
	        premierLien.focus();
	      }
	      focus('false');
	      thisComponent().setAttribute('focus', 'false');
	    }
	  }
	  function toggleAfficher(e) {
	    // Lorsqu'on doit afficher un sous menu, on doit tous les fermer d'abord.
	    if (strict_equals(afficher(), 'false')) {
	      fermerMenusNiveauCourant();
	    }
	    thisComponent().setAttribute('afficher', strict_equals(afficher(), 'true') ? 'false' : 'true');

	    // Ici petite twist pour IOS afin de bloquer la propagation du click sur un Ã©lÃ©ment de menu, car un click sur le body a Ã©tÃ© ajoutÃ© pour IOS (voir mount du composant menuHorizontal)
	    if (e) {
	      e.stopPropagation();
	    }
	  }
	  function clickLien(e) {
	    if (strict_equals(estMenuAccueil(), 'true')) {
	      clickAccueil(e);
	      return;
	    }

	    //Si un lien existe dans notre Ã©lÃ©ment de menu (il a donc Ã©tÃ© spÃ©cifiÃ© dans la slot par dÃ©faut, ex. pour des SPA avec VueJs)
	    //on doit utiliser l'Ã©vÃ©nement click de ce lien.  
	    var lien = thisComponent().querySelector('a');
	    if (lien) {
	      e.preventDefault();

	      //On vÃ©rifie s'il existe un Ã©lÃ©ment de menu cachÃ© avec un id identique au nÃ´tre, si c'est le cas, c'est le lien de cet Ã©lÃ©ment qu'on doit utiliser.
	      //Cet Ã©lÃ©ment est l'Ã©lÃ©ment original que nous avons pe cachÃ© pour affichage mobile, et lui seul contient l'Ã©vÃ©nement original.
	      var slotOriginale = utdMenuHorizontalParent.querySelector("utd-menu-horizontal-item[idutd=\"".concat(idComposant, "\"].utd-d-none"));
	      var lienSlotOriginale;
	      if (slotOriginale) {
	        lienSlotOriginale = slotOriginale.querySelector('a');
	      }
	      if (lienSlotOriginale) {
	        lienSlotOriginale.click();
	      } else {
	        lien.click();
	      }
	    }
	  }
	  function clickAccueil(e) {
	    var lienAccueil = utdMenuHorizontalParent.querySelector('a');
	    if (lienAccueil) {
	      e.preventDefault();
	      lienAccueil.click();
	    }
	  }
	  function fermerMenusNiveauCourant() {
	    var menus = obtenirElementsNiveauCourant();
	    menus.forEach(function (menu) {
	      menu.setAttribute('afficher', 'false');
	    });
	  }
	  function fermerMenuParent() {
	    thisComponent().parentElement.setAttribute('afficher', 'false');
	  }
	  function fermerTousMenus() {
	    document.querySelectorAll('utd-menu-horizontal-item[afficher="true"]').forEach(function (elementMenu) {
	      elementMenu.setAttribute('afficher', 'false');
	    });
	  }
	  function obtenirElementsNiveauCourant() {
	    if (thisComponent()) {
	      var items = Array.from(thisComponent().parentElement.children).filter(function (enfant) {
	        return enfant.matches('utd-menu-horizontal-item:not(.utd-d-none)');
	      });
	      return items;
	    }
	    return null;
	  }
	  function obtenirElementsNiveauSuivant() {
	    if (thisComponent()) {
	      return Array.from(thisComponent().children).filter(function (enfant) {
	        return enfant.matches('utd-menu-horizontal-item');
	      });
	    }
	    return null;
	  }
	  function obtenirNiveau() {
	    var niveau = 1;
	    var elementParent = thisComponent().parentElement;
	    while (strict_equals(elementParent.tagName.toLowerCase(), 'utd-menu-horizontal-item')) {
	      ++niveau;
	      elementParent = elementParent.parentElement;
	    }
	    return niveau;
	  }
	  function fermerMenus() {
	    if (strict_equals(get(niveau), 1)) {
	      fermerTousMenus();
	    } else {
	      fermerMenusNiveauCourant();
	      fermerMenuParent();
	      thisComponent().parentElement.setAttribute('focus', 'true');
	    }
	  }
	  function onKeyDown(e) {
	    thisComponent().parentElement;
	    switch (e.key) {
	      case "Escape":
	        fermerMenus();
	        e.preventDefault();
	        break;
	      case "Enter":
	      case " ":
	        if (get(possedeEnfants)) {
	          toggleAfficher();
	          e.preventDefault();
	        }
	        break;
	      case "ArrowUp":
	      case "ArrowLeft":
	        donnerFocusElementPrecedent(obtenirElementsNiveauCourant());
	        e.preventDefault();
	        break;
	      case "ArrowDown":
	      case "ArrowRight":
	        if (get(possedeEnfants)) {
	          if (strict_equals(afficher(), 'true')) {
	            donnerFocusElementSuivant(obtenirElementsNiveauSuivant());
	          } else {
	            donnerFocusElementSuivant(obtenirElementsNiveauCourant());
	          }
	        } else {
	          donnerFocusElementSuivant(obtenirElementsNiveauCourant());
	        }
	        e.preventDefault();
	        break;
	      case "Home":
	        if (get(possedeEnfants)) {
	          if (strict_equals(afficher(), 'true')) {
	            donnerFocusPremierElement(obtenirElementsNiveauSuivant());
	          } else {
	            donnerFocusPremierElement(obtenirElementsNiveauCourant());
	          }
	        } else {
	          donnerFocusPremierElement(obtenirElementsNiveauCourant());
	        }
	        e.preventDefault();
	        break;
	      case "End":
	        if (get(possedeEnfants)) {
	          if (strict_equals(afficher(), 'true')) {
	            donnerFocusDernierElement(obtenirElementsNiveauSuivant());
	          } else {
	            donnerFocusDernierElement(obtenirElementsNiveauCourant());
	          }
	        } else {
	          donnerFocusDernierElement(obtenirElementsNiveauCourant());
	        }
	        e.preventDefault();
	        break;
	    }
	  }
	  function donnerFocusElementSuivant(elements) {
	    if (!elements.length) {
	      return;
	    }
	    var indexeCourant = elements.indexOf(thisComponent());
	    if (indexeCourant >= 0) {
	      var prochainIndexe = Math.min(elements.length - 1, indexeCourant + 1);
	      elements[prochainIndexe].setAttribute('focus', 'true');
	    } else {
	      elements[0].setAttribute('focus', 'true');
	    }
	  }
	  function donnerFocusDernierElement(elements) {
	    if (!elements.length) {
	      return;
	    }
	    elements[elements.length - 1].setAttribute('focus', 'true');
	  }
	  function donnerFocusPremierElement(elements) {
	    if (!elements.length) {
	      return;
	    }
	    elements[0].setAttribute('focus', 'true');
	  }
	  function donnerFocusElementPrecedent(elements) {
	    if (!elements.length) {
	      return;
	    }
	    var indexeCourant = elements.indexOf(thisComponent());
	    if (indexeCourant >= 0) {
	      var prochainIndexe = Math.max(0, indexeCourant - 1);
	      elements[prochainIndexe].setAttribute('focus', 'true');
	    } else {
	      elements[0].setAttribute('focus', 'true');
	    }
	  }
	  function onBlur(e) {
	    if (!utdMenuHorizontalParent.contains(e.relatedTarget)) {
	      var itemsMenu = utdMenuHorizontalParent.querySelectorAll('utd-menu-horizontal-item');
	      itemsMenu.forEach(function (item) {
	        item.setAttribute('afficher', 'false');
	      });
	    }
	  }
	  function cssCharge(e) {
	    Utils.reafficherApresChargement(thisComponent());
	  }
	  legacy_pre_effect(function () {
	    return deep_read_state(focus());
	  }, function () {
	    toggleFocus(focus());
	  });
	  legacy_pre_effect_reset();
	  var $$exports = _objectSpread$d({
	    get libelle() {
	      return libelle();
	    },
	    set libelle($$value) {
	      libelle($$value);
	      flushSync();
	    },
	    get href() {
	      return href();
	    },
	    set href($$value) {
	      href($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    },
	    get srLibelle() {
	      return srLibelle();
	    },
	    set srLibelle($$value) {
	      srLibelle($$value);
	      flushSync();
	    },
	    get afficher() {
	      return afficher();
	    },
	    set afficher($$value) {
	      afficher($$value);
	      flushSync();
	    },
	    get animer() {
	      return animer();
	    },
	    set animer($$value) {
	      animer($$value);
	      flushSync();
	    },
	    get focus() {
	      return focus();
	    },
	    set focus($$value) {
	      focus($$value);
	      flushSync();
	    },
	    get actif() {
	      return actif();
	    },
	    set actif($$value) {
	      actif($$value);
	      flushSync();
	    },
	    get estMenuPlus() {
	      return estMenuPlus();
	    },
	    set estMenuPlus($$value) {
	      estMenuPlus($$value);
	      flushSync();
	    },
	    get estMenuBurger() {
	      return estMenuBurger();
	    },
	    set estMenuBurger($$value) {
	      estMenuBurger($$value);
	      flushSync();
	    },
	    get estMenuAccueil() {
	      return estMenuAccueil();
	    },
	    set estMenuAccueil($$value) {
	      estMenuAccueil($$value);
	      flushSync();
	    },
	    get estDernier() {
	      return estDernier();
	    },
	    set estDernier($$value) {
	      estDernier($$value);
	      flushSync();
	    },
	    get estOuvertureGauche() {
	      return estOuvertureGauche();
	    },
	    set estOuvertureGauche($$value) {
	      estOuvertureGauche($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$d();
	  var div = first_child(fragment);
	  var node = child(div);
	  {
	    var consequent_3 = function consequent_3($$anchor) {
	      var fragment_1 = root_1$6();
	      var a = first_child(fragment_1);
	      var span = child(a);
	      var span_1 = child(span);
	      var node_1 = child(span_1);
	      html(node_1, libelle);
	      reset(span_1);
	      var node_2 = sibling(span_1, 2);
	      {
	        var consequent = function consequent($$anchor) {
	          var span_2 = root_2$6();
	          var text = child(span_2, true);
	          reset(span_2);
	          template_effect(function () {
	            return set_text(text, srLibelle());
	          });
	          append($$anchor, span_2);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_2, function ($$render) {
	            if (srLibelle()) $$render(consequent);
	          });
	        }, 'if', MenuHorizontalItem, 326, 8);
	      }
	      var node_3 = sibling(node_2, 2);
	      {
	        var consequent_1 = function consequent_1($$anchor) {
	          var span_3 = root_3$5();
	          template_effect(function () {
	            return set_class(span_3, 1, "utd-icone-svg ".concat(strict_equals(get(niveau), 1) ? 'chevron-blanc' : 'chevron-bleu-piv'));
	          });
	          append($$anchor, span_3);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_3, function ($$render) {
	            if (strict_equals(get(niveau), 1, false) || strict_equals(estMenuBurger(), 'true', false)) $$render(consequent_1);
	          });
	        }, 'if', MenuHorizontalItem, 329, 8);
	      }
	      reset(span);
	      reset(a);
	      var node_4 = sibling(a, 2);
	      {
	        var consequent_2 = function consequent_2($$anchor) {
	          var div_1 = root_4$2();
	          var node_5 = child(div_1);
	          slot(node_5, $$props, 'default', {});
	          reset(div_1);
	          template_effect(function () {
	            return set_attribute(div_1, 'id', idSousMenu);
	          });
	          transition(3, div_1, function () {
	            return slide;
	          }, function () {
	            return {
	              duration: strict_equals(animer(), 'true') ? 250 : 0
	            };
	          });
	          append($$anchor, div_1);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_4, function ($$render) {
	            if (strict_equals(afficher(), 'true')) $$render(consequent_2);
	          });
	        }, 'if', MenuHorizontalItem, 334, 4);
	      }
	      template_effect(function () {
	        set_attribute(a, 'href', href());
	        set_attribute(a, 'aria-expanded', afficher());
	        set_attribute(a, 'aria-controls', idSousMenu);
	      });
	      event('click', a, preventDefault(toggleAfficher));
	      event('keydown', a, onKeyDown);
	      event('blur', a, onBlur);
	      append($$anchor, fragment_1);
	    };
	    var alternate_3 = function alternate_3($$anchor) {
	      var a_1 = root_5$5();
	      var node_6 = child(a_1);
	      {
	        var consequent_5 = function consequent_5($$anchor) {
	          var fragment_2 = comment();
	          var node_7 = first_child(fragment_2);
	          {
	            var consequent_4 = function consequent_4($$anchor) {
	              var span_4 = root_7$3();
	              var node_8 = child(span_4);
	              html(node_8, libelle);
	              reset(span_4);
	              append($$anchor, span_4);
	            };
	            var alternate = function alternate($$anchor) {
	              var span_5 = root_8$1();
	              append($$anchor, span_5);
	            };
	            add_svelte_meta(function () {
	              return if_block(node_7, function ($$render) {
	                if (strict_equals(estMenuBurger(), 'true')) $$render(consequent_4);else $$render(alternate, false);
	              });
	            }, 'if', MenuHorizontalItem, 342, 8);
	          }
	          append($$anchor, fragment_2);
	        };
	        var alternate_2 = function alternate_2($$anchor) {
	          var fragment_3 = comment();
	          var node_9 = first_child(fragment_3);
	          {
	            var consequent_6 = function consequent_6($$anchor) {
	              var span_6 = root_10$2();
	              var node_10 = sibling(child(span_6));
	              html(node_10, libelle);
	              reset(span_6);
	              append($$anchor, span_6);
	            };
	            var alternate_1 = function alternate_1($$anchor) {
	              var span_7 = root_11$1();
	              var node_11 = child(span_7);
	              html(node_11, libelle);
	              reset(span_7);
	              append($$anchor, span_7);
	            };
	            add_svelte_meta(function () {
	              return if_block(node_9, function ($$render) {
	                if (strict_equals(get(niveau), 3)) $$render(consequent_6);else $$render(alternate_1, false);
	              });
	            }, 'if', MenuHorizontalItem, 348, 8);
	          }
	          append($$anchor, fragment_3);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_6, function ($$render) {
	            if (strict_equals(estMenuAccueil(), 'true')) $$render(consequent_5);else $$render(alternate_2, false);
	          });
	        }, 'if', MenuHorizontalItem, 341, 6);
	      }
	      var node_12 = sibling(node_6, 2);
	      {
	        var consequent_7 = function consequent_7($$anchor) {
	          var span_8 = root_12$1();
	          var text_1 = child(span_8, true);
	          reset(span_8);
	          template_effect(function () {
	            return set_text(text_1, srLibelle());
	          });
	          append($$anchor, span_8);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_12, function ($$render) {
	            if (srLibelle()) $$render(consequent_7);
	          });
	        }, 'if', MenuHorizontalItem, 354, 6);
	      }
	      reset(a_1);
	      template_effect(function () {
	        set_attribute(a_1, 'href', href());
	        set_attribute(a_1, 'title', strict_equals(estMenuAccueil(), 'true') ? libelle() : null);
	        set_attribute(a_1, 'aria-current', strict_equals(actif(), 'true') ? 'page' : null);
	      });
	      event('click', a_1, clickLien);
	      event('keydown', a_1, onKeyDown);
	      event('blur', a_1, onBlur);
	      append($$anchor, a_1);
	    };
	    add_svelte_meta(function () {
	      return if_block(node, function ($$render) {
	        if (get(possedeEnfants)) $$render(consequent_3);else $$render(alternate_3, false);
	      });
	    }, 'if', MenuHorizontalItem, 322, 2);
	  }
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function () {
	    var _$$get;
	    set_class(div, 1, "utd-menu-horizontal-item niv".concat((_$$get = get(niveau)) !== null && _$$get !== void 0 ? _$$get : '').concat(strict_equals(afficher(), 'true') ? ' visible' : '').concat(strict_equals(actif(), 'true') ? ' active' : '').concat(strict_equals(estMenuPlus(), 'true') ? ' menu-plus' : '').concat(strict_equals(estMenuBurger(), 'true') ? ' menu-burger' : '').concat(strict_equals(estDernier(), 'true') ? ' dernier' : '').concat(strict_equals(estOuvertureGauche(), 'true') ? ' ouverture-gauche' : ''));
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-menu-horizontal-item', create_custom_element(MenuHorizontalItem, {
	  libelle: {
	    attribute: 'libelle'
	  },
	  href: {
	    attribute: 'href'
	  },
	  srLibelle: {
	    attribute: 'sr-libelle'
	  },
	  afficher: {
	    attribute: 'afficher'
	  },
	  animer: {
	    attribute: 'animer'
	  },
	  focus: {
	    attribute: 'focus'
	  },
	  actif: {
	    attribute: 'actif'
	  },
	  estMenuPlus: {
	    attribute: 'est-menu-plus'
	  },
	  estMenuBurger: {
	    attribute: 'est-menu-burger'
	  },
	  estMenuAccueil: {
	    attribute: 'est-menu-accueil'
	  },
	  estDernier: {
	    attribute: 'est-dernier'
	  },
	  estOuvertureGauche: {
	    attribute: 'est-ouverture-gauche'
	  },
	  thisComponent: {}
	}, ['default'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$d(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$c(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$c() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$c() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$c = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$c(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$c(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$c(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	MenuVertical[FILENAME] = 'src/components/menuVertical.svelte';
	var root$c = add_locations(from_html("<nav><a role=\"button\" class=\"toggle\"><span> </span> <span aria-hidden=\"true\" class=\"utd-icone-svg chevron-bleu-piv\"></span> <span class=\"utd-sr-only\"> </span></a> <span> </span> <div role=\"menu\"><!></div></nav> <link rel=\"stylesheet\"/>", 1), MenuVertical[FILENAME], [[103, 0, [[104, 2, [[105, 4], [106, 4], [107, 4]]], [112, 2], [113, 2]]], [117, 0]]);
	var $$css$1 = {
	  hash: 'svelte-m1urtr',
	  code: '\r\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVudVZlcnRpY2FsLnN2ZWx0ZSIsInNvdXJjZXMiOlsibWVudVZlcnRpY2FsLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c3ZlbHRlOm9wdGlvbnMgY3VzdG9tRWxlbWVudD17e1xyXG4gIHRhZzogJ3V0ZC1tZW51LXZlcnRpY2FsJyxcclxuICBleHRlbmQ6IChjdXN0b21FbGVtZW50Q29uc3RydWN0b3IpID0+IHtcclxuICAgIHJldHVybiBjbGFzcyBleHRlbmRzIGN1c3RvbUVsZW1lbnRDb25zdHJ1Y3RvciB7XHJcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50aGlzQ29tcG9uZW50ID0gdGhpcztcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LFxyXG4gIHByb3BzOiB7XHJcbiAgICB0aXRyZSA6IHthdHRyaWJ1dGU6ICd0aXRyZSd9LFxyXG4gICAgdGl0cmVWaXNpYmxlIDoge2F0dHJpYnV0ZTogJ3RpdHJlLXZpc2libGUnfSxcclxuICAgIHJlZnJlc2ggOiB7YXR0cmlidXRlOiAncmVmcmVzaCd9LFxyXG4gICAgcGF0aENvdXJhbnQgOiB7YXR0cmlidXRlOiAncGF0aC1jb3VyYW50J31cclxuICB9ICAgIFxyXG59fS8+XHJcblxyXG48c2NyaXB0PlxyXG4gIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XHJcbiAgaW1wb3J0IHsgVXRpbHMgfSBmcm9tIFwiLi9qcy91dGlsc1wiXHJcblxyXG4gIGNvbnN0IGVzdExhbmd1ZUZyYW5jYWlzZSA9IFV0aWxzLmVzdFBhZ2VMYW5ndWVGcmFuY2FpcygpXHJcblxyXG4gIC8qIFByb3ByacOpdMOpcyBcInB1YmxpcXVlc1wiICovXHJcbiAgZXhwb3J0IGxldCB0aXRyZSA9IGVzdExhbmd1ZUZyYW5jYWlzZSA/ICdNZW51IHNlY29uZGFpcmUnIDogJ1NlY29uZGFyeSBtZW51J1xyXG4gIGV4cG9ydCBsZXQgdGl0cmVWaXNpYmxlID0gXCJ0cnVlXCJcclxuICBleHBvcnQgbGV0IHJlZnJlc2ggPSBcImZhbHNlXCJcclxuICBleHBvcnQgbGV0IHBhdGhDb3VyYW50ID0gbnVsbFxyXG5cclxuICAvKiBQcm9wcmnDqXTDqXMgXCJwcml2w6llc1wiICovXHJcbiAgZXhwb3J0IGxldCB0aGlzQ29tcG9uZW50XHJcbiAgXHJcbiAgbGV0IG1vdW50ZWQgPSBmYWxzZVxyXG4gIGxldCBhZmZpY2hlciA9IGZhbHNlXHJcbiAgbGV0IGVzdENzc0NoYXJnZSA9IGZhbHNlXHJcblxyXG4gIGNvbnN0IGlkTWVudSA9IFV0aWxzLmdlbmVyZXJJZCgpXHJcbiAgY29uc3QgaWRUaXRyZU1lbnUgPSBVdGlscy5nZW5lcmVySWQoKVxyXG4gIGNvbnN0IHNyVGV4dGVTb3J0aXJNZW51ID0gZXN0TGFuZ3VlRnJhbmNhaXNlID8gXCJBcHB1eWV6IHN1ciBsYSB0b3VjaGUgw4ljaGFwcGUgcG91ciBzb3J0aXIgZHUgbWVudS5cIiA6IFwiUHJlc3MgRVNDIGtleSB0byBleGl0IG1lbnUuXCJcclxuIFxyXG4gIC8vIFLDqWbDqXJlbmNlcyBwb3VyIGFjY2Vzc2liaWxpdMOpXHJcbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9leGFtcGxlLWluZGV4L21lbnViYXIvbWVudWJhci1uYXZpZ2F0aW9uLCBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BY2Nlc3NpYmlsaXR5L0FSSUEvUm9sZXMvbWVudV9yb2xlIGV0IGh0dHBzOi8vdXNhYmlsaXR5LnlhbGUuZWR1L3dlYi1hY2Nlc3NpYmlsaXR5L2FydGljbGVzL2ZvY3VzLWtleWJvYXJkLW9wZXJhYmlsaXR5XHJcblxyXG5cclxuICBvbk1vdW50KCgpID0+IHsgICAgICBcclxuICAgIG1vdW50ZWQgPSB0cnVlOyAgICBcclxuXHJcbiAgICBpZihlc3RDc3NDaGFyZ2UpIHtcclxuICAgICAgVXRpbHMucmVhZmZpY2hlckFwcmVzQ2hhcmdlbWVudCh0aGlzQ29tcG9uZW50KTtcclxuICAgIH1cclxuICB9KVxyXG5cclxuICAvLyBXYXRjaCBzdXIgbGEgcHJvcCByZWZyZXNoXHJcbiAgJDogdG9nZ2xlUmVmcmVzaChyZWZyZXNoKSBcclxuXHJcbiAgLy8gV2F0Y2ggbGUgcGF0aCBjb3VyYW50IChuw6ljZXNzYWlyZSBwb3VyIGTDqXRlcm1pbmF0aW9uIMOpbMOpbWVudCBhY3RpZiBkZXMgU1BBKVxyXG4gICQ6IGNoYW5nZW1lbnRQYXRoQ291cmFudChwYXRoQ291cmFudCkgXHJcblxyXG4gIGZ1bmN0aW9uIGNoYW5nZW1lbnRQYXRoQ291cmFudCgpIHtcclxuICAgIGlmKG1vdW50ZWQpIHtcclxuICAgICAgdGhpc0NvbXBvbmVudC5zZXRBdHRyaWJ1dGUoJ3JlZnJlc2gnLCAndHJ1ZScpO1xyXG4gICAgICB0b2dnbGVSZWZyZXNoKCd0cnVlJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9nZ2xlQWZmaWNoZXIoKSB7XHJcbiAgICBhZmZpY2hlciA9ICFhZmZpY2hlclxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdG9nZ2xlUmVmcmVzaCgpIHtcclxuICAgIGlmKHJlZnJlc2ggPT09ICd0cnVlJykge1xyXG5cclxuICAgICAgLy9WYSByw6lkdWlyZSBsZSBtZW51IHVuaXF1ZW1lbnQgZW4gbW9kZSBtb2JpbGUgKDwgOTkxcHgpLCB2aWEgbGEgY2xhc3NlICd2aXNpYmxlJyBxdWkgc2VyYSBhYnNlbnRlLiBJbXBhY3QgdW5pcXVlbWVudCBlbiBtb2JpbGUgYWZpbiBkZSByw6lkdWlyZSBsZSBtZW51IGxvcnMgZCd1bmUgbmF2aWdhdGlvbiBleC4gZGFucyB1bmUgU1BBLlxyXG4gICAgICBhZmZpY2hlciA9IGZhbHNlO1xyXG5cclxuICAgICAgdGhpc0NvbXBvbmVudC5xdWVyeVNlbGVjdG9yQWxsKCd1dGQtbWVudS12ZXJ0aWNhbC1pdGVtJykuZm9yRWFjaChpdGVtID0+IHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuXHJcbiAgICAgICAgY29uc3QgZWxlbWVudFBhcmVudCA9IGl0ZW0ucGFyZW50RWxlbWVudDtcclxuICAgICAgICBpZihlbGVtZW50UGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3V0ZC1tZW51LXZlcnRpY2FsLWl0ZW0nKSB7XHJcbiAgICAgICAgICBlbGVtZW50UGFyZW50LnNldEF0dHJpYnV0ZSgnYW5pbWVyJywgJ2ZhbHNlJylcclxuICAgICAgICAgIGVsZW1lbnRQYXJlbnQuc2V0QXR0cmlidXRlKCdhZmZpY2hlcicsICdmYWxzZScpXHJcbiAgICAgICAgfSAgICAgICAgXHJcblxyXG4gICAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdyZWZyZXNoJywgJ3RydWUnKTtcclxuICAgICAgfSk7ICAgICAgXHJcbiAgICAgIFxyXG4gICAgICByZWZyZXNoID0gJ2ZhbHNlJztcclxuICAgICAgdGhpc0NvbXBvbmVudC5zZXRBdHRyaWJ1dGUoJ3JlZnJlc2gnLCAnZmFsc2UnKTsgICAgIFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3NzQ2hhcmdlKGUpIHsgICAgXHJcbiAgICBpZihtb3VudGVkKSB7XHJcbiAgICAgIFV0aWxzLnJlYWZmaWNoZXJBcHJlc0NoYXJnZW1lbnQodGhpc0NvbXBvbmVudCk7ICBcclxuICAgIH1cclxuICAgIFxyXG4gICAgZXN0Q3NzQ2hhcmdlID0gdHJ1ZTtcclxuICB9XHJcbiAgXHJcbjwvc2NyaXB0PlxyXG48bmF2IGNsYXNzPVwidXRkLW1lbnUtdmVydGljYWx7ZXN0Q3NzQ2hhcmdlID8gJyBtb3VudGVkJzogJyd9XCIgY2xhc3M6dmlzaWJsZT17YWZmaWNoZXJ9IGFyaWEtbGFiZWxsZWRieT1cIntpZFRpdHJlTWVudX1cIj5cclxuICA8YSByb2xlPVwiYnV0dG9uXCIgaHJlZj1cIiN7aWRNZW51fVwiIGNsYXNzPVwidG9nZ2xlXCIgYXJpYS1jb250cm9scz1cIntpZE1lbnV9XCIgb246Y2xpY2t8cHJldmVudERlZmF1bHQ9e3RvZ2dsZUFmZmljaGVyfT5cclxuICAgIDxzcGFuPnt0aXRyZX08L3NwYW4+XHJcbiAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzcz1cInV0ZC1pY29uZS1zdmcgY2hldnJvbi1ibGV1LXBpdlwiPjwvc3Bhbj5cclxuICAgIDxzcGFuIGNsYXNzPVwidXRkLXNyLW9ubHlcIj5cclxuICAgICAgICB7c3JUZXh0ZVNvcnRpck1lbnV9XHJcbiAgICA8L3NwYW4+XHJcbiAgPC9hPlxyXG5cclxuICA8c3BhbiBjbGFzcz1cInRpdHJlIHt0aXRyZVZpc2libGUgPT09ICd0cnVlJyA/ICcnIDogJ3V0ZC1zci1vbmx5J31cIiBpZD1cIntpZFRpdHJlTWVudX1cIj57dGl0cmV9PC9zcGFuPlxyXG4gIDxkaXYgaWQ9e2lkTWVudX0gcm9sZT1cIm1lbnVcIiBjbGFzcz1cIm1lbnVcIiBjbGFzczp2aXNpYmxlPXthZmZpY2hlcn0+XHJcbiAgICA8c2xvdD48L3Nsb3Q+XHJcbiAgPC9kaXY+ICBcclxuPC9uYXY+XHJcbjxsaW5rIHJlbD0nc3R5bGVzaGVldCcgaHJlZj0ne1V0aWxzLmNzc0Z1bGxQYXRofScgb246bG9hZD1cIntjc3NDaGFyZ2V9XCI+XHJcblxyXG48c3R5bGU+XHJcbjwvc3R5bGU+XHJcblxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBc0hPOyJ9 */'
	};
	function MenuVertical($$anchor, $$props) {
	  check_target(this instanceof MenuVertical ? this.constructor : void 0);
	  push($$props, false);
	  append_styles$1($$anchor, $$css$1);
	  var estLangueFrancaise = Utils.estPageLangueFrancais();

	  /* PropriÃ©tÃ©s "publiques" */
	  var titre = prop($$props, 'titre', 12, estLangueFrancaise ? 'Menu secondaire' : 'Secondary menu');
	  var titreVisible = prop($$props, 'titreVisible', 12, "true");
	  var refresh = prop($$props, 'refresh', 12, "false");
	  var pathCourant = prop($$props, 'pathCourant', 12, null);

	  /* PropriÃ©tÃ©s "privÃ©es" */
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var mounted = false;
	  var afficher = mutable_source(false);
	  var estCssCharge = mutable_source(false);
	  var idMenu = Utils.genererId();
	  var idTitreMenu = Utils.genererId();
	  var srTexteSortirMenu = estLangueFrancaise ? "Appuyez sur la touche Ãchappe pour sortir du menu." : "Press ESC key to exit menu.";

	  // RÃ©fÃ©rences pour accessibilitÃ©
	  // https://www.w3.org/WAI/ARIA/apg/example-index/menubar/menubar-navigation, https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/menu_role et https://usability.yale.edu/web-accessibility/articles/focus-keyboard-operability
	  onMount(function () {
	    mounted = true;
	    if (get(estCssCharge)) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	  });

	  // Watch sur la prop refresh
	  // Watch le path courant (nÃ©cessaire pour dÃ©termination Ã©lÃ©ment actif des SPA)
	  function changementPathCourant() {
	    if (mounted) {
	      thisComponent().setAttribute('refresh', 'true');
	      toggleRefresh();
	    }
	  }
	  function toggleAfficher() {
	    set(afficher, !get(afficher));
	  }
	  function toggleRefresh() {
	    if (strict_equals(refresh(), 'true')) {
	      //Va rÃ©duire le menu uniquement en mode mobile (< 991px), via la classe 'visible' qui sera absente. Impact uniquement en mobile afin de rÃ©duire le menu lors d'une navigation ex. dans une SPA.
	      set(afficher, false);
	      thisComponent().querySelectorAll('utd-menu-vertical-item').forEach(function (item) {
	        var elementParent = item.parentElement;
	        if (strict_equals(elementParent.tagName.toLowerCase(), 'utd-menu-vertical-item')) {
	          elementParent.setAttribute('animer', 'false');
	          elementParent.setAttribute('afficher', 'false');
	        }
	        item.setAttribute('refresh', 'true');
	      });
	      refresh('false');
	      thisComponent().setAttribute('refresh', 'false');
	    }
	  }
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    set(estCssCharge, true);
	  }
	  legacy_pre_effect(function () {
	    return deep_read_state(refresh());
	  }, function () {
	    toggleRefresh(refresh());
	  });
	  legacy_pre_effect(function () {
	    return deep_read_state(pathCourant());
	  }, function () {
	    changementPathCourant(pathCourant());
	  });
	  legacy_pre_effect_reset();
	  var $$exports = _objectSpread$c({
	    get titre() {
	      return titre();
	    },
	    set titre($$value) {
	      titre($$value);
	      flushSync();
	    },
	    get titreVisible() {
	      return titreVisible();
	    },
	    set titreVisible($$value) {
	      titreVisible($$value);
	      flushSync();
	    },
	    get refresh() {
	      return refresh();
	    },
	    set refresh($$value) {
	      refresh($$value);
	      flushSync();
	    },
	    get pathCourant() {
	      return pathCourant();
	    },
	    set pathCourant($$value) {
	      pathCourant($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$c();
	  var nav = first_child(fragment);
	  var classes;
	  var a = child(nav);
	  var span = child(a);
	  var text = child(span, true);
	  reset(span);
	  var span_1 = sibling(span, 4);
	  var text_1 = child(span_1, true);
	  reset(span_1);
	  reset(a);
	  var span_2 = sibling(a, 2);
	  var text_2 = child(span_2, true);
	  reset(span_2);
	  var div = sibling(span_2, 2);
	  var classes_1;
	  var node = child(div);
	  slot(node, $$props, 'default', {});
	  reset(div);
	  reset(nav);
	  var link = sibling(nav, 2);
	  template_effect(function ($0, $1) {
	    classes = set_class(nav, 1, "utd-menu-vertical".concat(get(estCssCharge) ? ' mounted' : ''), null, classes, $0);
	    set_attribute(nav, 'aria-labelledby', idTitreMenu);
	    set_attribute(a, 'href', "#".concat(idMenu !== null && idMenu !== void 0 ? idMenu : ''));
	    set_attribute(a, 'aria-controls', idMenu);
	    set_text(text, titre());
	    set_text(text_1, srTexteSortirMenu);
	    set_class(span_2, 1, "titre ".concat(strict_equals(titreVisible(), 'true') ? '' : 'utd-sr-only'));
	    set_attribute(span_2, 'id', idTitreMenu);
	    set_text(text_2, titre());
	    set_attribute(div, 'id', idMenu);
	    classes_1 = set_class(div, 1, 'menu', null, classes_1, $1);
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  }, [function () {
	    return {
	      visible: get(afficher)
	    };
	  }, function () {
	    return {
	      visible: get(afficher)
	    };
	  }]);
	  event('click', a, preventDefault(toggleAfficher));
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-menu-vertical', create_custom_element(MenuVertical, {
	  titre: {
	    attribute: 'titre'
	  },
	  titreVisible: {
	    attribute: 'titre-visible'
	  },
	  refresh: {
	    attribute: 'refresh'
	  },
	  pathCourant: {
	    attribute: 'path-courant'
	  },
	  thisComponent: {}
	}, ['default'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$c(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$b(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$b() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$b() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$b = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$b(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$b(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$b(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	MenuVerticalItem[FILENAME] = 'src/components/menuVerticalItem.svelte';
	var root_2$5 = add_locations(from_html("<div role=\"menu\" class=\"sous-menu\"><!></div>"), MenuVerticalItem[FILENAME], [[301, 6]]);
	var root_1$5 = add_locations(from_html("<a role=\"menuitem\" aria-haspopup=\"menu\"><span> </span> <span aria-hidden=\"true\" class=\"utd-icone-svg chevron-bleu-piv\"></span></a> <!>", 1), MenuVerticalItem[FILENAME], [[296, 4, [[297, 6], [298, 6]]]]);
	var root_3$4 = add_locations(from_html("<a role=\"menuitem\"><span> </span></a>"), MenuVerticalItem[FILENAME], [[306, 4, [[307, 6]]]]);
	var root$b = add_locations(from_html("<div><!></div> <link rel=\"stylesheet\"/>", 1), MenuVerticalItem[FILENAME], [[294, 0], [311, 0]]);
	var $$css = {
	  hash: 'svelte-gxtht2',
	  code: '\r\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVudVZlcnRpY2FsSXRlbS5zdmVsdGUiLCJzb3VyY2VzIjpbIm1lbnVWZXJ0aWNhbEl0ZW0uc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzdmVsdGU6b3B0aW9ucyBjdXN0b21FbGVtZW50PXt7XHJcbiAgdGFnOiAndXRkLW1lbnUtdmVydGljYWwtaXRlbScsXHJcbiAgZXh0ZW5kOiAoY3VzdG9tRWxlbWVudENvbnN0cnVjdG9yKSA9PiB7XHJcbiAgICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBjdXN0b21FbGVtZW50Q29uc3RydWN0b3Ige1xyXG4gICAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudGhpc0NvbXBvbmVudCA9IHRoaXM7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSxcclxuICBwcm9wczoge1xyXG4gICAgbGliZWxsZSA6IHthdHRyaWJ1dGU6ICdsaWJlbGxlJ30sXHJcbiAgICBocmVmIDoge2F0dHJpYnV0ZTogJ2hyZWYnfSxcclxuICAgIGFmZmljaGVyIDoge2F0dHJpYnV0ZTogJ2FmZmljaGVyJ30sXHJcbiAgICBpbmRleHRhYiA6IHthdHRyaWJ1dGU6ICdpbmRleHRhYid9LFxyXG4gICAgYW5pbWVyIDoge2F0dHJpYnV0ZTogJ2FuaW1lcid9LFxyXG4gICAgZm9jdXMgOiB7YXR0cmlidXRlOiAnZm9jdXMnfSwgICAgXHJcbiAgICBhY3RpZiA6IHthdHRyaWJ1dGU6ICdhY3RpZid9LFxyXG4gICAgcmVmcmVzaCA6IHthdHRyaWJ1dGU6ICdyZWZyZXNoJ31cclxuICB9ICAgIFxyXG59fS8+XHJcblxyXG48c2NyaXB0PlxyXG4gIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XHJcbiAgaW1wb3J0IHsgVXRpbHMgfSBmcm9tIFwiLi9qcy91dGlsc1wiXHJcbiAgaW1wb3J0IHsgc2xpZGUgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIlxyXG5cclxuICAvKiBQcm9wcmnDqXTDqXMgXCJwdWJsaXF1ZXNcIiAqL1xyXG4gIGV4cG9ydCBsZXQgbGliZWxsZSA9ICcnXHJcbiAgZXhwb3J0IGxldCBocmVmID0gJydcclxuXHJcbiAgLyogUHJvcHJpw6l0w6lzIFwiaW50ZXJuZXNcIiAqL1xyXG4gIGV4cG9ydCBsZXQgYWZmaWNoZXIgPSAnZmFsc2UnXHJcbiAgZXhwb3J0IGxldCBpbmRleHRhYiA9ICcwJ1xyXG4gIGV4cG9ydCBsZXQgYW5pbWVyID0gJ3RydWUnXHJcbiAgZXhwb3J0IGxldCBmb2N1cyA9ICdmYWxzZSdcclxuICBleHBvcnQgbGV0IHJlZnJlc2ggPSAnZmFsc2UnXHJcbiAgZXhwb3J0IGxldCBhY3RpZiA9ICdmYWxzZSdcclxuICBleHBvcnQgbGV0IHRoaXNDb21wb25lbnRcclxuICBcclxuICBsZXQgcG9zc2VkZUVuZmFudHMgPSBmYWxzZVxyXG4gIGxldCBuaXZlYXUgPSAxXHJcbiAgXHJcbiAgY29uc3QgaWRTb3VzTWVudSA9IFV0aWxzLmdlbmVyZXJJZCgpXHJcbiBcclxuICBvbk1vdW50KCgpID0+IHtcclxuICAgIGluaXRpYWxpc2VyKCk7XHJcbiAgfSlcclxuXHJcbiAgLy8gV2F0Y2ggc3VyIGxhIHByb3AgZm9jdXNcclxuICAkOiB0b2dnbGVGb2N1cyhmb2N1cykgXHJcblxyXG4gIC8vIFdhdGNoIHN1ciBsYSBwcm9wIHJlZnJlc2hcclxuICAkOiB0b2dnbGVSZWZyZXNoKHJlZnJlc2gpIFxyXG5cclxuXHJcbiAgZnVuY3Rpb24gaW5pdGlhbGlzZXIoKSB7XHJcbiAgICBwb3NzZWRlRW5mYW50cyA9ICEhdGhpc0NvbXBvbmVudC5xdWVyeVNlbGVjdG9yKCd1dGQtbWVudS12ZXJ0aWNhbC1pdGVtJyk7ICAgIFxyXG5cclxuICAgIGRlZmluaXJBdHRyaWJ1dHNTZWxvbkxpZW5QZXJzb25uYWxpc2UoKTtcclxuXHJcbiAgICBhY3RpZiA9IGVzdEVsZW1lbnRBY3RpZigpO1xyXG4gICAgdGhpc0NvbXBvbmVudC5zZXRBdHRyaWJ1dGUoJ2FjdGlmJywgYWN0aWYgPT09ICd0cnVlJyA/ICd0cnVlJyA6ICdmYWxzZScpO1xyXG4gICAgbml2ZWF1ID0gb2J0ZW5pck5pdmVhdSgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGVmaW5pckF0dHJpYnV0c1NlbG9uTGllblBlcnNvbm5hbGlzZSgpIHtcclxuICAgIGNvbnN0IGxpZW4gPSAhcG9zc2VkZUVuZmFudHMgPyB0aGlzQ29tcG9uZW50LnF1ZXJ5U2VsZWN0b3IoJ2EnKSA6IG51bGw7XHJcbiAgIFxyXG4gICAgaWYobGllbikge1xyXG4gICAgICBpZighdGhpc0NvbXBvbmVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkge1xyXG4gICAgICAgIGNvbnN0IHZhbGV1ckhyZWYgPSBsaWVuLmdldEF0dHJpYnV0ZSgnaHJlZicpIHx8ICcjJ1xyXG4gICAgICAgIHRoaXNDb21wb25lbnQuc2V0QXR0cmlidXRlKCdocmVmJywgdmFsZXVySHJlZik7XHJcbiAgICAgICAgaHJlZiA9IHZhbGV1ckhyZWY7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKCF0aGlzQ29tcG9uZW50LmdldEF0dHJpYnV0ZSgnbGliZWxsZScpKSB7XHJcbiAgICAgICAgY29uc3QgdmFsZXVyTGliZWxsZSA9IGxpZW4udGV4dCB8fCAnVGV4dGUgZGUgbGllbiBub24gc3DDqWNpZmnDqSc7XHJcbiAgICAgICAgdGhpc0NvbXBvbmVudC5zZXRBdHRyaWJ1dGUoJ2xpYmVsbGUnLCB2YWxldXJMaWJlbGxlKTtcclxuICAgICAgICBsaWJlbGxlID0gdmFsZXVyTGliZWxsZTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy9JY2kgb24gcydhc3N1cmUgcXVlIGxlcyBhdHRyaWJ1dHMgaHJlZiBldCBsaWJlbGxlIHNvbnQgYmllbiBsw6Agc3VyIGxlIGNvbXBvc2FudC4gRW4gU1BBLCBpbCBhcnJpdmUgcXVlIMOnYSBkaXNwYXJhw65zc2UuXHJcbiAgICAgIGlmKCF0aGlzQ29tcG9uZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpKSB7XHJcbiAgICAgICAgdGhpc0NvbXBvbmVudC5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoIXRoaXNDb21wb25lbnQuZ2V0QXR0cmlidXRlKCdsaWJlbGxlJykpIHtcclxuICAgICAgICB0aGlzQ29tcG9uZW50LnNldEF0dHJpYnV0ZSgnbGliZWxsZScsIGxpYmVsbGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0b2dnbGVGb2N1cygpe1xyXG4gICAgaWYoZm9jdXMgPT09ICd0cnVlJyl7XHJcbiAgICAgIHRoaXNDb21wb25lbnQuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdhJykuZm9jdXMoKVxyXG4gICAgICBmb2N1cyA9ICdmYWxzZSdcclxuICAgIH1cclxuICAgIHRoaXNDb21wb25lbnQuc2V0QXR0cmlidXRlKCdmb2N1cycsICdmYWxzZScpXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0b2dnbGVSZWZyZXNoKCl7XHJcbiAgICBpZihyZWZyZXNoID09PSAndHJ1ZScpe1xyXG4gICAgICBpbml0aWFsaXNlcigpO1xyXG4gICAgICBcclxuICAgICAgcmVmcmVzaCA9ICdmYWxzZSc7XHJcbiAgICAgIHRoaXNDb21wb25lbnQuc2V0QXR0cmlidXRlKCdyZWZyZXNoJywgJ2ZhbHNlJylcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRvZ2dsZUFmZmljaGVyKCl7XHJcbiAgICBhZmZpY2hlciA9IGFmZmljaGVyID09PSAndHJ1ZScgPyAnZmFsc2UnIDogJ3RydWUnXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlc3RFbGVtZW50QWN0aWYoKSB7XHJcbiAgICBjb25zdCBtZW51VmVydGljYWwgPSB0aGlzQ29tcG9uZW50LmNsb3Nlc3QoJ3V0ZC1tZW51LXZlcnRpY2FsJyk7XHJcbiAgICBpZihtZW51VmVydGljYWwpe1xyXG4gICAgICBcclxuICAgICAgY29uc3QgcGF0aENvdXJhbnQgPSBtZW51VmVydGljYWwuZ2V0QXR0cmlidXRlKCdwYXRoLWNvdXJhbnQnKTtcclxuICAgICAgaWYocGF0aENvdXJhbnQgIT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gKHBhdGhDb3VyYW50ID09PSBocmVmKS50b1N0cmluZygpXHJcbiAgICAgIH0gICAgICBcclxuICAgIH0gXHJcbiAgICBcclxuICAgIGlmKGhyZWYpe1xyXG4gICAgICByZXR1cm4gKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSA9PT0gaHJlZikudG9TdHJpbmcoKVxyXG4gICAgfSAgICBcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiBvYnRlbmlyTml2ZWF1KCl7XHJcbiAgICBsZXQgbml2ZWF1ID0gMVxyXG4gICAgbGV0IGVsZW1lbnRQYXJlbnQgPSB0aGlzQ29tcG9uZW50LnBhcmVudEVsZW1lbnRcclxuICAgIFxyXG4gICAgd2hpbGUgKGVsZW1lbnRQYXJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndXRkLW1lbnUtdmVydGljYWwtaXRlbScpIHtcclxuICAgICAgICArK25pdmVhdVxyXG5cclxuICAgICAgICBpZihhY3RpZiA9PT0gJ3RydWUnKXtcclxuICAgICAgICAgIGVsZW1lbnRQYXJlbnQuc2V0QXR0cmlidXRlKCdhY3RpZicsICd0cnVlJylcclxuICAgICAgICAgIGVsZW1lbnRQYXJlbnQuc2V0QXR0cmlidXRlKCdhbmltZXInLCAnZmFsc2UnKVxyXG4gICAgICAgICAgZWxlbWVudFBhcmVudC5zZXRBdHRyaWJ1dGUoJ2FmZmljaGVyJywgJ3RydWUnKVxyXG4gICAgICAgICAgZWxlbWVudFBhcmVudC5zZXRBdHRyaWJ1dGUoJ2FuaW1lcicsICd0cnVlJylcclxuICAgICAgICB9IFxyXG4gICAgICAgIGVsZW1lbnRQYXJlbnQgPSBlbGVtZW50UGFyZW50LnBhcmVudEVsZW1lbnRcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbml2ZWF1XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvYnRlbmlyTWVudVZlcnRpY2FsKCl7XHJcbiAgICBsZXQgZWxlbWVudFBhcmVudCA9IHRoaXNDb21wb25lbnQucGFyZW50RWxlbWVudFxyXG4gICAgXHJcbiAgICB3aGlsZSAoZWxlbWVudFBhcmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICd1dGQtbWVudS12ZXJ0aWNhbCcpIHtcclxuICAgICAgICBlbGVtZW50UGFyZW50ID0gZWxlbWVudFBhcmVudC5wYXJlbnRFbGVtZW50XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnRQYXJlbnRcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XHJcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzQ29tcG9uZW50LnBhcmVudEVsZW1lbnRcclxuXHJcbiAgICBzd2l0Y2goZS5rZXkpIHtcclxuICAgICAgY2FzZSBcIkVzY2FwZVwiOlxyXG4gICAgICAgIGlmKGVzdE1lbnVJdGVtKHBhcmVudCkpe1xyXG4gICAgICAgICAgcGFyZW50LnNldEF0dHJpYnV0ZSgnYWZmaWNoZXInLCAnZmFsc2UnKVxyXG4gICAgICAgICAgcGFyZW50LnNldEF0dHJpYnV0ZSgnZm9jdXMnLCAndHJ1ZScpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiRW50ZXJcIjpcclxuICAgICAgY2FzZSBcIiBcIjpcclxuICAgICAgICBpZihwb3NzZWRlRW5mYW50cyl7XHJcbiAgICAgICAgICBpZihhZmZpY2hlciA9PT0gJ2ZhbHNlJyl7XHJcbiAgICAgICAgICAgIGFmZmljaGVyID0gJ3RydWUnIFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICB0aGlzQ29tcG9uZW50LnF1ZXJ5U2VsZWN0b3IoJ3V0ZC1tZW51LXZlcnRpY2FsLWl0ZW0nKS5zZXRBdHRyaWJ1dGUoJ2ZvY3VzJywgJ3RydWUnKVxyXG4gICAgICAgICAgICB9LCAwKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6XHJcbiAgICAgICAgYWNjZWRlck1lbnVQcmVjZWRlbnQoKVxyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiQXJyb3dVcFwiOlxyXG4gICAgICAgIGFjY2VkZXJNZW51UHJlY2VkZW50KHRydWUpXHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XHJcbiAgICAgICAgaWYocG9zc2VkZUVuZmFudHMpe1xyXG4gICAgICAgICAgaWYoYWZmaWNoZXIgPT09ICdmYWxzZScpe1xyXG4gICAgICAgICAgICBhZmZpY2hlciA9ICd0cnVlJ1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgdGhpc0NvbXBvbmVudC5xdWVyeVNlbGVjdG9yKCd1dGQtbWVudS12ZXJ0aWNhbC1pdGVtJykuc2V0QXR0cmlidXRlKCdmb2N1cycsICd0cnVlJylcclxuICAgICAgICAgICAgfSwgMClcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGFjY2VkZXJNZW51U3VpdmFudCgpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFjY2VkZXJNZW51U3VpdmFudCgpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XHJcbiAgICAgICAgYWNjZWRlck1lbnVTdWl2YW50KHRydWUpXHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpICAgICAgICBcclxuICAgICAgICBicmVhazsgICAgICAgIFxyXG5cdFx0IH1cclxuXHR9XHJcbiAgXHJcbiAgZnVuY3Rpb24gYWNjZWRlck1lbnVTdWl2YW50KGRvaXRCb3VjbGVyKXtcclxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXNDb21wb25lbnQucGFyZW50RWxlbWVudFxyXG4gICAgbGV0IHByb2NoYWluTWVudVxyXG5cclxuICAgIGFmZmljaGVyID0gJ2ZhbHNlJ1xyXG5cclxuICAgIGlmKCFkb2l0Qm91Y2xlciAmJiBlc3RNZW51SXRlbShwYXJlbnQpKXtcclxuICAgICAgICBwYXJlbnQuc2V0QXR0cmlidXRlKCdhZmZpY2hlcicsICdmYWxzZScpXHJcbiAgICAgICAgcHJvY2hhaW5NZW51ID0gcGFyZW50Lm5leHRFbGVtZW50U2libGluZ1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcHJvY2hhaW5NZW51ID0gdGhpc0NvbXBvbmVudC5uZXh0RWxlbWVudFNpYmxpbmdcclxuICAgIH1cclxuXHJcbiAgICBpZihlc3RNZW51SXRlbShwcm9jaGFpbk1lbnUpKXsgICAgICAgICAgICBcclxuICAgICAgcHJvY2hhaW5NZW51LnNldEF0dHJpYnV0ZSgnZm9jdXMnLCAndHJ1ZScpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZihkb2l0Qm91Y2xlcil7XHJcbiAgICAgICAgcGFyZW50LnF1ZXJ5U2VsZWN0b3IoJ3V0ZC1tZW51LXZlcnRpY2FsLWl0ZW0nKS5zZXRBdHRyaWJ1dGUoJ2ZvY3VzJywgJ3RydWUnKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhcmVudC5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3V0ZC1tZW51LXZlcnRpY2FsLWl0ZW0nKS5zZXRBdHRyaWJ1dGUoJ2ZvY3VzJywgJ3RydWUnKVxyXG4gICAgICB9ICAgICAgXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhY2NlZGVyTWVudVByZWNlZGVudChkb2l0Qm91Y2xlcil7XHJcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzQ29tcG9uZW50LnBhcmVudEVsZW1lbnRcclxuICAgIGxldCBtZW51UHJlY2VkZW50XHJcblxyXG4gICAgYWZmaWNoZXIgPSAnZmFsc2UnXHJcblxyXG4gICAgaWYoIWRvaXRCb3VjbGVyICYmIGVzdE1lbnVJdGVtKHBhcmVudCkpe1xyXG4gICAgICAgIHBhcmVudC5zZXRBdHRyaWJ1dGUoJ2FmZmljaGVyJywgJ2ZhbHNlJylcclxuICAgICAgICBwYXJlbnQuc2V0QXR0cmlidXRlKCdmb2N1cycsICd0cnVlJylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG1lbnVQcmVjZWRlbnQgPSB0aGlzQ29tcG9uZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmdcclxuICAgIH1cclxuXHJcbiAgICBpZihlc3RNZW51SXRlbShtZW51UHJlY2VkZW50KSl7ICAgICAgICAgICAgXHJcbiAgICAgIG1lbnVQcmVjZWRlbnQuc2V0QXR0cmlidXRlKCdmb2N1cycsICd0cnVlJylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gcGFyZW50LmNoaWxkcmVuXHJcbiAgICAgIGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdLnNldEF0dHJpYnV0ZSgnZm9jdXMnLCAndHJ1ZScpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gZXN0TWVudUl0ZW0oZWxlbWVudCl7XHJcbiAgICByZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3V0ZC1tZW51LXZlcnRpY2FsLWl0ZW0nXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvbkZvY3VzKCl7XHJcbiAgICAvLyBUYWIgcm92aW5nISEhIE9uIGfDqHJlIGxlIHRhYmluZGV4IGRlcyDDqWzDqW1lbnRzIGR1IG1lbnUgYWZpbiBxdWUgc2V1bCBsJ8OpbMOpbWVudCBhY3RpZiBwdWlzc2Ugw6p0cmUgZm9jdXNhYmxlICh2aWEgdGFiKSBkZSBzb3J0ZSBxdSdvbiBnw6hyZSBsZSBmb2N1cyB2aWEgbGVzIGZsw6hjaGVzIGR1IGNsYXZpZXIgZXQgXHJcbiAgICAvLyB1biBUQUIgcHJvdm9xdWUgbGEgc29ydGllIGR1IG1lbnUuXHJcbiAgICByZXRpcmVyUG9zc2liaWxpdGVGb2N1c0VsZW1lbnRzTWVudSgpXHJcbiAgICB0aGlzQ29tcG9uZW50LnNldEF0dHJpYnV0ZSgnaW5kZXh0YWInLCAnMCcpXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZXRpcmVyUG9zc2liaWxpdGVGb2N1c0VsZW1lbnRzTWVudSgpe1xyXG4gICAgY29uc3QgbWVudVZlcnRpY2FsID0gb2J0ZW5pck1lbnVWZXJ0aWNhbCgpXHJcbiAgICBjb25zdCBlbGVtZW50cyA9IG1lbnVWZXJ0aWNhbC5xdWVyeVNlbGVjdG9yQWxsKCd1dGQtbWVudS12ZXJ0aWNhbC1pdGVtJylcclxuICAgIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdpbmRleHRhYicsICctMScpXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNsaWNrTGllbihlKSB7XHJcblxyXG4gICAgLy9TaSB1biBsaWVuIGV4aXN0ZSBkYW5zIG5vdHJlIMOpbMOpbWVudCBkZSBtZW51IChpbCBhIGRvbmMgw6l0w6kgc3DDqWNpZmnDqSBkYW5zIGxhIHNsb3QgcGFyIGTDqWZhdXQsIGV4LiBwb3VyIGRlcyBTUEEgYXZlYyBWdWVKcylcclxuICAgIC8vb24gZG9pdCB1dGlsaXNlciBsJ8OpdsOpbmVtZW50IGNsaWNrIGRlIGNlIGxpZW4uICBcclxuICAgIGNvbnN0IGxpZW4gPSB0aGlzQ29tcG9uZW50LnF1ZXJ5U2VsZWN0b3IoJ2EnKTtcclxuICAgICAgICBcclxuICAgIGlmKGxpZW4pIHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBsaWVuLmNsaWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjc3NDaGFyZ2UoZSkgeyAgICAgICBcclxuICAgIFV0aWxzLnJlYWZmaWNoZXJBcHJlc0NoYXJnZW1lbnQodGhpc0NvbXBvbmVudCk7ICAgICBcclxuICB9XHJcbjwvc2NyaXB0PlxyXG48ZGl2IGNsYXNzPVwidXRkLW1lbnUtdmVydGljYWwtaXRlbSBuaXZ7bml2ZWF1fXthZmZpY2hlciA9PT0gJ3RydWUnID8gJyB2aXNpYmxlJyA6ICcnfXthY3RpZiA9PT0gJ3RydWUnID8gJyBhY3RpdmUnIDogJyd9XCI+XHJcbiAgeyNpZiBwb3NzZWRlRW5mYW50c30gICAgXHJcbiAgICA8YSByb2xlPVwibWVudWl0ZW1cIiBocmVmPVwie2hyZWZ9XCIgYXJpYS1leHBhbmRlZD1cInthZmZpY2hlcn1cIiBhcmlhLWhhc3BvcHVwPVwibWVudVwiIGFyaWEtY29udHJvbHM9XCJ7aWRTb3VzTWVudX1cIiB0YWJpbmRleD1cIntpbmRleHRhYn1cIiBvbjpjbGlja3xwcmV2ZW50RGVmYXVsdD17dG9nZ2xlQWZmaWNoZXJ9IG9uOmtleWRvd249e29uS2V5RG93bn0gb246Zm9jdXM9e29uRm9jdXN9PlxyXG4gICAgICA8c3Bhbj57bGliZWxsZX08L3NwYW4+XHJcbiAgICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzPVwidXRkLWljb25lLXN2ZyBjaGV2cm9uLWJsZXUtcGl2XCI+PC9zcGFuPlxyXG4gICAgPC9hPlxyXG4gICAgeyNpZiBhZmZpY2hlciA9PT0gJ3RydWUnfVxyXG4gICAgICA8ZGl2IGlkPVwie2lkU291c01lbnV9XCIgcm9sZT1cIm1lbnVcIiBjbGFzcz1cInNvdXMtbWVudVwiIHRyYW5zaXRpb246c2xpZGU9XCJ7e2R1cmF0aW9uOiBhbmltZXIgPT09J3RydWUnID8gMjUwOiAwfX1cIj5cclxuICAgICAgICA8c2xvdD48L3Nsb3Q+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgey9pZn1cclxuICB7OmVsc2V9XHJcbiAgICA8YSBocmVmPVwie2hyZWZ9XCIgcm9sZT1cIm1lbnVpdGVtXCIgYXJpYS1jdXJyZW50PVwie2FjdGlmID09PSAndHJ1ZScgPyAncGFnZScgOiBudWxsfVwiIHRhYmluZGV4PVwie2luZGV4dGFifVwiIG9uOmNsaWNrPXtjbGlja0xpZW59IG9uOmtleWRvd249e29uS2V5RG93bn0gb246Zm9jdXM9e29uRm9jdXN9PlxyXG4gICAgICA8c3Bhbj57bGliZWxsZX08L3NwYW4+XHJcbiAgICA8L2E+ICAgIFxyXG4gIHsvaWZ9ICAgICAgICAgICAgXHJcbjwvZGl2PlxyXG48bGluayByZWw9J3N0eWxlc2hlZXQnIGhyZWY9J3tVdGlscy5jc3NGdWxsUGF0aH0nIG9uOmxvYWQ9XCJ7Y3NzQ2hhcmdlfVwiPlxyXG5cclxuPHN0eWxlPlxyXG48L3N0eWxlPlxyXG5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXdUTzsifQ== */'
	};
	function MenuVerticalItem($$anchor, $$props) {
	  check_target(this instanceof MenuVerticalItem ? this.constructor : void 0);
	  push($$props, false);
	  append_styles$1($$anchor, $$css);

	  /* PropriÃ©tÃ©s "publiques" */
	  var libelle = prop($$props, 'libelle', 12, '');
	  var href = prop($$props, 'href', 12, '');

	  /* PropriÃ©tÃ©s "internes" */
	  var afficher = prop($$props, 'afficher', 12, 'false');
	  var indextab = prop($$props, 'indextab', 12, '0');
	  var animer = prop($$props, 'animer', 12, 'true');
	  var focus = prop($$props, 'focus', 12, 'false');
	  var refresh = prop($$props, 'refresh', 12, 'false');
	  var actif = prop($$props, 'actif', 12, 'false');
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var possedeEnfants = mutable_source(false);
	  var niveau = mutable_source(1);
	  var idSousMenu = Utils.genererId();
	  onMount(function () {
	    initialiser();
	  });

	  // Watch sur la prop focus
	  // Watch sur la prop refresh
	  function initialiser() {
	    set(possedeEnfants, !!thisComponent().querySelector('utd-menu-vertical-item'));
	    definirAttributsSelonLienPersonnalise();
	    actif(estElementActif());
	    thisComponent().setAttribute('actif', strict_equals(actif(), 'true') ? 'true' : 'false');
	    set(niveau, obtenirNiveau());
	  }
	  function definirAttributsSelonLienPersonnalise() {
	    var lien = !get(possedeEnfants) ? thisComponent().querySelector('a') : null;
	    if (lien) {
	      if (!thisComponent().getAttribute('href')) {
	        var valeurHref = lien.getAttribute('href') || '#';
	        thisComponent().setAttribute('href', valeurHref);
	        href(valeurHref);
	      }
	      if (!thisComponent().getAttribute('libelle')) {
	        var valeurLibelle = lien.text || 'Texte de lien non spÃ©cifiÃ©';
	        thisComponent().setAttribute('libelle', valeurLibelle);
	        libelle(valeurLibelle);
	      }
	    } else {
	      //Ici on s'assure que les attributs href et libelle sont bien lÃ  sur le composant. En SPA, il arrive que Ã§a disparaÃ®sse.
	      if (!thisComponent().getAttribute('href')) {
	        thisComponent().setAttribute('href', href());
	      }
	      if (!thisComponent().getAttribute('libelle')) {
	        thisComponent().setAttribute('libelle', libelle());
	      }
	    }
	  }
	  function toggleFocus() {
	    if (strict_equals(focus(), 'true')) {
	      thisComponent().shadowRoot.querySelector('a').focus();
	      focus('false');
	    }
	    thisComponent().setAttribute('focus', 'false');
	  }
	  function toggleRefresh() {
	    if (strict_equals(refresh(), 'true')) {
	      initialiser();
	      refresh('false');
	      thisComponent().setAttribute('refresh', 'false');
	    }
	  }
	  function toggleAfficher() {
	    afficher(strict_equals(afficher(), 'true') ? 'false' : 'true');
	  }
	  function estElementActif() {
	    var menuVertical = thisComponent().closest('utd-menu-vertical');
	    if (menuVertical) {
	      var pathCourant = menuVertical.getAttribute('path-courant');
	      if (strict_equals(pathCourant, null, false)) {
	        return strict_equals(pathCourant, href()).toString();
	      }
	    }
	    if (href()) {
	      return strict_equals(window.location.pathname, href()).toString();
	    }
	  }
	  function obtenirNiveau() {
	    var niveau = 1;
	    var elementParent = thisComponent().parentElement;
	    while (strict_equals(elementParent.tagName.toLowerCase(), 'utd-menu-vertical-item')) {
	      ++niveau;
	      if (strict_equals(actif(), 'true')) {
	        elementParent.setAttribute('actif', 'true');
	        elementParent.setAttribute('animer', 'false');
	        elementParent.setAttribute('afficher', 'true');
	        elementParent.setAttribute('animer', 'true');
	      }
	      elementParent = elementParent.parentElement;
	    }
	    return niveau;
	  }
	  function obtenirMenuVertical() {
	    var elementParent = thisComponent().parentElement;
	    while (strict_equals(elementParent.tagName.toLowerCase(), 'utd-menu-vertical', false)) {
	      elementParent = elementParent.parentElement;
	    }
	    return elementParent;
	  }
	  function onKeyDown(e) {
	    var parent = thisComponent().parentElement;
	    switch (e.key) {
	      case "Escape":
	        if (estMenuItem(parent)) {
	          parent.setAttribute('afficher', 'false');
	          parent.setAttribute('focus', 'true');
	        }
	        e.preventDefault();
	        break;
	      case "Enter":
	      case " ":
	        if (get(possedeEnfants)) {
	          if (strict_equals(afficher(), 'false')) {
	            afficher('true');
	            setTimeout(function () {
	              thisComponent().querySelector('utd-menu-vertical-item').setAttribute('focus', 'true');
	            }, 0);
	          }
	          e.preventDefault();
	        }
	        break;
	      case "ArrowLeft":
	        accederMenuPrecedent();
	        e.preventDefault();
	        break;
	      case "ArrowUp":
	        accederMenuPrecedent(true);
	        e.preventDefault();
	        break;
	      case "ArrowRight":
	        if (get(possedeEnfants)) {
	          if (strict_equals(afficher(), 'false')) {
	            afficher('true');
	            setTimeout(function () {
	              thisComponent().querySelector('utd-menu-vertical-item').setAttribute('focus', 'true');
	            }, 0);
	          } else {
	            accederMenuSuivant();
	          }
	        } else {
	          accederMenuSuivant();
	        }
	        e.preventDefault();
	        break;
	      case "ArrowDown":
	        accederMenuSuivant(true);
	        e.preventDefault();
	        break;
	    }
	  }
	  function accederMenuSuivant(doitBoucler) {
	    var parent = thisComponent().parentElement;
	    var prochainMenu;
	    afficher('false');
	    if (!doitBoucler && estMenuItem(parent)) {
	      parent.setAttribute('afficher', 'false');
	      prochainMenu = parent.nextElementSibling;
	    } else {
	      prochainMenu = thisComponent().nextElementSibling;
	    }
	    if (estMenuItem(prochainMenu)) {
	      prochainMenu.setAttribute('focus', 'true');
	    } else {
	      if (doitBoucler) {
	        parent.querySelector('utd-menu-vertical-item').setAttribute('focus', 'true');
	      } else {
	        parent.parentElement.querySelector('utd-menu-vertical-item').setAttribute('focus', 'true');
	      }
	    }
	  }
	  function accederMenuPrecedent(doitBoucler) {
	    var parent = thisComponent().parentElement;
	    var menuPrecedent;
	    afficher('false');
	    if (!doitBoucler && estMenuItem(parent)) {
	      parent.setAttribute('afficher', 'false');
	      parent.setAttribute('focus', 'true');
	    } else {
	      menuPrecedent = thisComponent().previousElementSibling;
	    }
	    if (estMenuItem(menuPrecedent)) {
	      menuPrecedent.setAttribute('focus', 'true');
	    } else {
	      var elements = parent.children;
	      elements[elements.length - 1].setAttribute('focus', 'true');
	    }
	  }
	  function estMenuItem(element) {
	    return element && strict_equals(element.tagName.toLowerCase(), 'utd-menu-vertical-item');
	  }
	  function onFocus() {
	    // Tab roving!!! On gÃ¨re le tabindex des Ã©lÃ©ments du menu afin que seul l'Ã©lÃ©ment actif puisse Ãªtre focusable (via tab) de sorte qu'on gÃ¨re le focus via les flÃ¨ches du clavier et 
	    // un TAB provoque la sortie du menu.
	    retirerPossibiliteFocusElementsMenu();
	    thisComponent().setAttribute('indextab', '0');
	  }
	  function retirerPossibiliteFocusElementsMenu() {
	    var menuVertical = obtenirMenuVertical();
	    var elements = menuVertical.querySelectorAll('utd-menu-vertical-item');
	    elements.forEach(function (element) {
	      element.setAttribute('indextab', '-1');
	    });
	  }
	  function clickLien(e) {
	    //Si un lien existe dans notre Ã©lÃ©ment de menu (il a donc Ã©tÃ© spÃ©cifiÃ© dans la slot par dÃ©faut, ex. pour des SPA avec VueJs)
	    //on doit utiliser l'Ã©vÃ©nement click de ce lien.  
	    var lien = thisComponent().querySelector('a');
	    if (lien) {
	      e.preventDefault();
	      lien.click();
	    }
	  }
	  function cssCharge(e) {
	    Utils.reafficherApresChargement(thisComponent());
	  }
	  legacy_pre_effect(function () {
	    return deep_read_state(focus());
	  }, function () {
	    toggleFocus(focus());
	  });
	  legacy_pre_effect(function () {
	    return deep_read_state(refresh());
	  }, function () {
	    toggleRefresh(refresh());
	  });
	  legacy_pre_effect_reset();
	  var $$exports = _objectSpread$b({
	    get libelle() {
	      return libelle();
	    },
	    set libelle($$value) {
	      libelle($$value);
	      flushSync();
	    },
	    get href() {
	      return href();
	    },
	    set href($$value) {
	      href($$value);
	      flushSync();
	    },
	    get afficher() {
	      return afficher();
	    },
	    set afficher($$value) {
	      afficher($$value);
	      flushSync();
	    },
	    get indextab() {
	      return indextab();
	    },
	    set indextab($$value) {
	      indextab($$value);
	      flushSync();
	    },
	    get animer() {
	      return animer();
	    },
	    set animer($$value) {
	      animer($$value);
	      flushSync();
	    },
	    get focus() {
	      return focus();
	    },
	    set focus($$value) {
	      focus($$value);
	      flushSync();
	    },
	    get refresh() {
	      return refresh();
	    },
	    set refresh($$value) {
	      refresh($$value);
	      flushSync();
	    },
	    get actif() {
	      return actif();
	    },
	    set actif($$value) {
	      actif($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$b();
	  var div = first_child(fragment);
	  var node = child(div);
	  {
	    var consequent_1 = function consequent_1($$anchor) {
	      var fragment_1 = root_1$5();
	      var a = first_child(fragment_1);
	      var span = child(a);
	      var text = child(span, true);
	      reset(span);
	      next(2);
	      reset(a);
	      var node_1 = sibling(a, 2);
	      {
	        var consequent = function consequent($$anchor) {
	          var div_1 = root_2$5();
	          var node_2 = child(div_1);
	          slot(node_2, $$props, 'default', {});
	          reset(div_1);
	          template_effect(function () {
	            return set_attribute(div_1, 'id', idSousMenu);
	          });
	          transition(3, div_1, function () {
	            return slide;
	          }, function () {
	            return {
	              duration: strict_equals(animer(), 'true') ? 250 : 0
	            };
	          });
	          append($$anchor, div_1);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_1, function ($$render) {
	            if (strict_equals(afficher(), 'true')) $$render(consequent);
	          });
	        }, 'if', MenuVerticalItem, 300, 4);
	      }
	      template_effect(function () {
	        set_attribute(a, 'href', href());
	        set_attribute(a, 'aria-expanded', afficher());
	        set_attribute(a, 'aria-controls', idSousMenu);
	        set_attribute(a, 'tabindex', indextab());
	        set_text(text, libelle());
	      });
	      event('click', a, preventDefault(toggleAfficher));
	      event('keydown', a, onKeyDown);
	      event('focus', a, onFocus);
	      append($$anchor, fragment_1);
	    };
	    var alternate = function alternate($$anchor) {
	      var a_1 = root_3$4();
	      var span_1 = child(a_1);
	      var text_1 = child(span_1, true);
	      reset(span_1);
	      reset(a_1);
	      template_effect(function () {
	        set_attribute(a_1, 'href', href());
	        set_attribute(a_1, 'aria-current', strict_equals(actif(), 'true') ? 'page' : null);
	        set_attribute(a_1, 'tabindex', indextab());
	        set_text(text_1, libelle());
	      });
	      event('click', a_1, clickLien);
	      event('keydown', a_1, onKeyDown);
	      event('focus', a_1, onFocus);
	      append($$anchor, a_1);
	    };
	    add_svelte_meta(function () {
	      return if_block(node, function ($$render) {
	        if (get(possedeEnfants)) $$render(consequent_1);else $$render(alternate, false);
	      });
	    }, 'if', MenuVerticalItem, 295, 2);
	  }
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function () {
	    var _$$get;
	    set_class(div, 1, "utd-menu-vertical-item niv".concat((_$$get = get(niveau)) !== null && _$$get !== void 0 ? _$$get : '').concat(strict_equals(afficher(), 'true') ? ' visible' : '').concat(strict_equals(actif(), 'true') ? ' active' : ''));
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-menu-vertical-item', create_custom_element(MenuVerticalItem, {
	  libelle: {
	    attribute: 'libelle'
	  },
	  href: {
	    attribute: 'href'
	  },
	  afficher: {
	    attribute: 'afficher'
	  },
	  indextab: {
	    attribute: 'indextab'
	  },
	  animer: {
	    attribute: 'animer'
	  },
	  focus: {
	    attribute: 'focus'
	  },
	  actif: {
	    attribute: 'actif'
	  },
	  refresh: {
	    attribute: 'refresh'
	  },
	  thisComponent: {}
	}, ['default'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$b(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$a(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$a() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$a() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$a = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$a(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$a(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$a(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	PointsSuspension[FILENAME] = 'src/components/pointsSuspension.svelte';
	var root_2$4 = add_locations(from_html("<span class=\"dots\">...</span> ", 1), PointsSuspension[FILENAME], [[269, 10]]);
	var root_3$3 = add_locations(from_html("[<span class=\"dots\">...</span>]", 1), PointsSuspension[FILENAME], [[271, 11]]);
	var root_4$1 = add_locations(from_html("<span class=\"utd-sr-only\"> </span>"), PointsSuspension[FILENAME], [[276, 8]]);
	var root_1$4 = add_locations(from_html("<a href=\"#test\" role=\"button\"><span aria-hidden=\"true\"><!></span> <!></a>"), PointsSuspension[FILENAME], [[266, 4, [[267, 6]]]]);
	var root_5$4 = add_locations(from_html("<span tabindex=\"-1\"> </span>"), PointsSuspension[FILENAME], [[283, 4]]);
	var root$a = add_locations(from_html("<div><span class=\"texte\"><!></span> <!> <!></div> <link rel=\"stylesheet\"/>", 1), PointsSuspension[FILENAME], [[260, 0, [[261, 2]]], [288, 0]]);
	function PointsSuspension($$anchor, $$props) {
	  check_target(this instanceof PointsSuspension ? this.constructor : void 0);
	  push($$props, false);
	  var $$ownership_validator = create_ownership_validator($$props);

	  /* PropriÃ©tÃ©s "publiques" */
	  var nbLignes = prop($$props, 'nbLignes', 12, '1');
	  var affichageInitial = prop($$props, 'affichageInitial', 12, 'true');
	  var afficherTexteLien = prop($$props, 'afficherTexteLien', 12, 'false');
	  var texteLien = prop($$props, 'texteLien', 28, function () {
	    return Utils.estPageLangueFrancais() ? "Voir plus" : "Show more";
	  });

	  /* PropriÃ©tÃ©s "privÃ©es" */
	  var thisComponent = prop($$props, 'thisComponent', 12);

	  // RÃ©fÃ©rences pour accessibilitÃ©
	  // https://www.accede-web.com/en/guidelines/rich-interface-components/show-more-buttons/
	  var idConteneur = Utils.genererId();
	  var idTexteSupplementaire = Utils.genererId();
	  var idTexte = Utils.genererId();
	  var estTexteCompletAffiche = mutable_source(false);
	  var estAffichageTexteTronque = mutable_source(false);
	  var conteneur;
	  var controleTexte;
	  var controleTexteSupplementaire;
	  var hauteurMax = 24;
	  var texteComplet = '';
	  var texteSupplementaire = mutable_source('');
	  var estAjustementAffichageEnCours = mutable_source(true);
	  var estEvenementObserverEnCours = false;
	  var mounted = false;
	  var estCssCharge = false;
	  onMount(function () {
	    //
	    if (!window.ResizeObserver) {
	      set(estAjustementAffichageEnCours, false);
	      set(estTexteCompletAffiche, true);
	      Utils.reafficherApresChargement(thisComponent());
	      mounted = true;
	    } else {
	      conteneur = thisComponent().shadowRoot.getElementById(idConteneur);
	      controleTexte = thisComponent().shadowRoot.getElementById(idTexte);
	      texteComplet = thisComponent().textContent;
	      ajusterAffichageControle();
	      if (estCssCharge) {
	        Utils.reafficherApresChargement(thisComponent());
	      }

	      // DÃ©tecter les resize sur le composant et redessiner
	      observerRezise();
	      mounted = true;
	    }
	  });

	  // Watch sur la prop affichageInitial
	  function initialiserAffichage() {
	    if (mounted && strict_equals(affichageInitial(), 'true')) {
	      set(estTexteCompletAffiche, false);
	      ajusterAffichageControle();
	    }
	  }
	  function ajusterAffichageControle() {
	    set(estAjustementAffichageEnCours, true);
	    estEvenementObserverEnCours = true;
	    controleTexte.textContent = "";
	    conteneur.removeAttribute('style');

	    // On doit repaint ici afin que l'interface soit Ã  jour avant d'effectuer les ajustements Ã  l'affichage du contrÃ´le (ex. le bouton ... doit Ãªtre retirÃ© si prÃ©sent, car bousille le calcul pour la hauteur)
	    setTimeout(function () {
	      ajusterAffichageControle2();
	    });
	  }
	  function ajusterAffichageControle2() {
	    hauteurMax = obtenirHauteurMaximale();
	    conteneur.style.maxHeight = hauteurMax + 'px';
	    controleTexte.textContent = texteComplet;
	    controleTexteSupplementaire = thisComponent().shadowRoot.getElementById(idTexteSupplementaire);
	    if (controleTexteSupplementaire) {
	      controleTexteSupplementaire.textContent = '';
	    }
	    if (doitTronquerTexte()) {
	      $$ownership_validator.mutation(null, ['thisComponent', 'textContent'], thisComponent(thisComponent().textContent = "", true), 116, 6);
	      tronquerTexte();
	    } else {
	      set(estAffichageTexteTronque, false);
	    }
	    set(estAjustementAffichageEnCours, false);
	    setTimeout(function () {
	      estEvenementObserverEnCours = false;
	    }, 500);
	  }
	  var resizeObserverDebounced = Utils.debounce(function (entries) {
	    return resizeObserver(entries);
	  });
	  function observerRezise() {
	    var observer = new ResizeObserver(resizeObserverDebounced);
	    observer.observe(thisComponent());
	  }
	  function resizeObserver(entries) {
	    entries.forEach(function (entry) {
	      if (strict_equals(affichageInitial(), 'true')) {
	        affichageInitial('false');
	        return;
	      }
	      if (estEvenementObserverEnCours) {
	        return;
	      }
	      if (!get(estTexteCompletAffiche)) {
	        ajusterAffichageControle();
	      }
	    });
	  }
	  function afficherContenuSupplementaire() {
	    conteneur.removeAttribute('style');
	    set(estTexteCompletAffiche, true);
	    setTimeout(function () {
	      var controleTexteSupplementaire = thisComponent().shadowRoot.getElementById(idTexteSupplementaire);
	      controleTexteSupplementaire.focus();
	    }, 250);
	  }
	  function obtenirHauteurMaximale() {
	    var nombreLignes = parseInt(nbLignes());
	    var htmlBidon = 'TjpyYZ';
	    for (var i = 1; i < nombreLignes; i++) {
	      htmlBidon += '<br/>TjpyYZ';
	    }
	    controleTexte.innerHTML = htmlBidon;
	    var height = controleTexte.getBoundingClientRect().height;
	    controleTexte.textContent = '';

	    // On se donne un petit jeu sur la hauteur... Il y a toujours une petite diffÃ©rence et Ã§a cause problÃ¨me (Ã  cause du lien ... qui est plus gros entre autres)
	    return height + 2;
	  }
	  function doitTronquerTexte() {
	    //console.log('hauteur contrÃ´le texte -> ' + controleTexte.getBoundingClientRect().height + '     hauteur max -> ' + hauteurMax)
	    return controleTexte.getBoundingClientRect().height > hauteurMax;
	  }
	  function tronquerTexte() {
	    var texteCourant = "";
	    var posGauche = 0;
	    var posDroite = texteComplet.length - 1;
	    var posMilieu = 0;
	    var estHauteurZero = false;
	    while (posGauche < posDroite) {
	      posMilieu = Math.floor((posGauche + posDroite) / 2);
	      if (strict_equals(posGauche, posMilieu)) {
	        break;
	      }
	      var texteTemp = texteComplet.slice(posGauche, posMilieu);
	      controleTexte.textContent = texteCourant + texteTemp;
	      var height = controleTexte.getBoundingClientRect().height;

	      //console.log('G ' + posGauche + '    M ' + posMilieu + '   height -> ' + height + '   hauteurMax -> ' + hauteurMax)
	      // Petite patch pour certains fureteurs/appareils sur lesquels la hauteur du texteTemp au chargement initial Ã©tait de 0??? Rien Ã  comprendre (ex. Big Sur Safari 14.1)
	      if (strict_equals(height, 0)) {
	        estHauteurZero = true;
	        controleTexte.textContent = '';
	        setTimeout(function () {
	          tronquerTexte();
	        }, 100);
	        break;
	      }
	      if (height > hauteurMax) {
	        posDroite = posMilieu;
	      } else {
	        texteCourant += texteTemp;
	        posGauche = posMilieu;
	      }
	    }
	    if (estHauteurZero) {
	      return;
	    }

	    // Ici petit ajustement de x caractÃ¨res pour compenser l'ajustement requis avec notre "..."
	    texteCourant = texteComplet.slice(0, posMilieu - obtenirNbCaracteresTexteLien());

	    // Trouver le dernier espace avant notre tronquage et utiliser cette position pour le tronquage.
	    var posDernierEspace = texteCourant.lastIndexOf(' ');
	    set(texteSupplementaire, texteComplet.slice(posDernierEspace));
	    controleTexte.textContent = texteComplet.slice(0, posDernierEspace);
	    set(estAffichageTexteTronque, true);
	  }
	  function obtenirNbCaracteresTexteLien() {
	    if (strict_equals(afficherTexteLien(), 'true')) {
	      return "... [".concat(texteLien(), "]").length;
	    } else {
	      return 5;
	    }
	  }
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  legacy_pre_effect(function () {
	    return deep_read_state(affichageInitial());
	  }, function () {
	    initialiserAffichage(affichageInitial());
	  });
	  legacy_pre_effect_reset();
	  var $$exports = _objectSpread$a({
	    get nbLignes() {
	      return nbLignes();
	    },
	    set nbLignes($$value) {
	      nbLignes($$value);
	      flushSync();
	    },
	    get affichageInitial() {
	      return affichageInitial();
	    },
	    set affichageInitial($$value) {
	      affichageInitial($$value);
	      flushSync();
	    },
	    get afficherTexteLien() {
	      return afficherTexteLien();
	    },
	    set afficherTexteLien($$value) {
	      afficherTexteLien($$value);
	      flushSync();
	    },
	    get texteLien() {
	      return texteLien();
	    },
	    set texteLien($$value) {
	      texteLien($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$a();
	  var div = first_child(fragment);
	  var span = child(div);
	  var node = child(span);
	  slot(node, $$props, 'default', {});
	  reset(span);
	  var node_1 = sibling(span, 2);
	  {
	    var consequent_2 = function consequent_2($$anchor) {
	      var a = root_1$4();
	      var span_1 = child(a);
	      var node_2 = child(span_1);
	      {
	        var consequent = function consequent($$anchor) {
	          var fragment_1 = root_2$4();
	          var text = sibling(first_child(fragment_1));
	          template_effect(function () {
	            var _texteLien;
	            return set_text(text, "\xA0[".concat((_texteLien = texteLien()) !== null && _texteLien !== void 0 ? _texteLien : '', "]"));
	          });
	          append($$anchor, fragment_1);
	        };
	        var alternate = function alternate($$anchor) {
	          var fragment_2 = root_3$3();
	          next(2);
	          append($$anchor, fragment_2);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_2, function ($$render) {
	            if (strict_equals(afficherTexteLien(), 'true')) $$render(consequent);else $$render(alternate, false);
	          });
	        }, 'if', PointsSuspension, 268, 8);
	      }
	      reset(span_1);
	      var node_3 = sibling(span_1, 2);
	      {
	        var consequent_1 = function consequent_1($$anchor) {
	          var span_2 = root_4$1();
	          var text_1 = child(span_2, true);
	          reset(span_2);
	          template_effect(function () {
	            return set_text(text_1, texteLien());
	          });
	          append($$anchor, span_2);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_3, function ($$render) {
	            if (strict_equals(afficherTexteLien(), 'true')) $$render(consequent_1);
	          });
	        }, 'if', PointsSuspension, 275, 6);
	      }
	      reset(a);
	      template_effect(function () {
	        set_class(a, 1, "ellipsis ".concat(get(estAjustementAffichageEnCours) ? ' utd-d-none' : ''));
	        set_attribute(a, 'title', strict_equals(afficherTexteLien(), 'true') ? null : texteLien());
	      });
	      event('click', a, preventDefault(afficherContenuSupplementaire));
	      append($$anchor, a);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_1, function ($$render) {
	        if (get(estAffichageTexteTronque) && !get(estTexteCompletAffiche)) $$render(consequent_2);
	      });
	    }, 'if', PointsSuspension, 265, 2);
	  }
	  var node_4 = sibling(node_1, 2);
	  {
	    var consequent_3 = function consequent_3($$anchor) {
	      var span_3 = root_5$4();
	      var text_2 = child(span_3, true);
	      reset(span_3);
	      template_effect(function () {
	        set_class(span_3, 1, "texte-supplementaire".concat(get(estAffichageTexteTronque) ? ' estAffichageTexteTronque' : '').concat(get(estTexteCompletAffiche) ? ' estTexteCompletAffiche' : ''));
	        set_attribute(span_3, 'id', idTexteSupplementaire);
	        set_text(text_2, get(texteSupplementaire));
	      });
	      transition(3, span_3, function () {
	        return fade;
	      }, function () {
	        return {
	          duration: 250
	        };
	      });
	      append($$anchor, span_3);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_4, function ($$render) {
	        if (get(estTexteCompletAffiche)) $$render(consequent_3);
	      });
	    }, 'if', PointsSuspension, 282, 2);
	  }
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function () {
	    set_class(div, 1, "utd-component utd-points-suspension".concat(get(estAjustementAffichageEnCours) ? ' ajustement-en-cours' : ''));
	    set_attribute(div, 'id', idConteneur);
	    set_attribute(span, 'id', idTexte);
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-points-suspension', create_custom_element(PointsSuspension, {
	  nbLignes: {
	    attribute: 'nb-lignes'
	  },
	  affichageInitial: {
	    attribute: 'affichage-initial'
	  },
	  afficherTexteLien: {
	    attribute: 'afficher-texte-lien'
	  },
	  texteLien: {
	    attribute: 'texte-lien'
	  },
	  thisComponent: {}
	}, ['default'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$a(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$9(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$9() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$9() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$9 = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$9(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$9(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$9(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	Section[FILENAME] = 'src/components/section.svelte';
	var root_2$3 = add_locations(from_html("<button type=\"button\"><!> <!> <span class=\"utd-icone-svg chevron-gras-blanc\"></span></button>"), Section[FILENAME], [[129, 6, [[134, 8]]]]);
	var root_5$3 = add_locations(from_html("<!> <!>", 1), Section[FILENAME], []);
	var root_7$2 = add_locations(from_html("<div><!></div>"), Section[FILENAME], [[150, 6]]);
	var root$9 = add_locations(from_html("<div><div class=\"entete\"><!></div> <div class=\"contenu\"><!></div></div> <link rel=\"stylesheet\"/>", 1), Section[FILENAME], [[125, 0, [[126, 2], [148, 2]]], [158, 0]]);
	function Section($$anchor, $$props) {
	  check_target(this instanceof Section ? this.constructor : void 0);
	  push($$props, false);

	  /* PropriÃ©tÃ©s "publiques" */
	  var extensible = prop($$props, 'extensible', 12, "true");
	  var reduit = prop($$props, 'reduit', 12, "true");
	  var titre = prop($$props, 'titre', 12, "");
	  var bordure = prop($$props, 'bordure', 12, "true");
	  var tagTitre = prop($$props, 'tagTitre', 12, "h2");
	  var conserverEtatAffichage = prop($$props, 'conserverEtatAffichage', 12, "false");
	  var padding = prop($$props, 'padding', 12, "true");

	  /* PropriÃ©tÃ©s "privÃ©es" */
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var idEntete = Utils.genererId();
	  var idContenu = 'corps' + idEntete;
	  var estReduit = mutable_source(strict_equals(reduit(), 'true') ? true : false);
	  var mounted = false;
	  var estCssCharge = false;
	  var contientInputs = mutable_source(false);

	  //TODO Ã©ventuellement dÃ©terminer automatiquement le niveau de header via un script? 
	  onMount(function () {
	    definirEtatAffichageInitial();
	    set(contientInputs, !!thisComponent().querySelector('input,textarea,select'));
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    mounted = true;
	  });
	  function gererEtatAffichage() {
	    if (!mounted) {
	      return;
	    }
	    set(estReduit, strict_equals(reduit(), 'true') ? true : false);
	    conserverEtatAffichageSession();
	    Utils.dispatchWcEvent(thisComponent(), "changementEtat", {
	      reduit: get(estReduit)
	    });
	  }
	  function definirEtatAffichageInitial() {
	    if (strict_equals(conserverEtatAffichage(), 'true')) {
	      if (thisComponent().id) {
	        var valeur = sessionStorage.getItem(thisComponent().id);

	        //Si null (clÃ© non trouvÃ©e dans le session storage, on va utiliser la valeur par dÃ©faut reÃ§ue en paramÃ¨tre, sinon on l'Ã©crase avec celle du session storage)
	        if (strict_equals(valeur, null, false)) {
	          if (strict_equals(valeur, '1')) {
	            thisComponent().setAttribute('reduit', 'false');
	            set(estReduit, false);
	            reduit("false");
	          } else {
	            thisComponent().setAttribute('reduit', 'true');
	            set(estReduit, true);
	            reduit("true");
	          }
	        }
	      }
	    } else {
	      set(estReduit, strict_equals(reduit(), 'true') ? true : false);
	    }
	    conserverEtatAffichageSession();
	  }
	  function conserverEtatAffichageSession() {
	    if (strict_equals(conserverEtatAffichage(), 'true') && thisComponent().id) {
	      sessionStorage.setItem(thisComponent().id, get(estReduit) ? '0' : '1');
	    }
	  }
	  function toggleAffichageContenu() {
	    thisComponent().setAttribute('reduit', get(estReduit) ? 'false' : 'true');
	  }
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  legacy_pre_effect(function () {
	    return deep_read_state(reduit());
	  }, function () {
	    gererEtatAffichage(reduit());
	  });
	  legacy_pre_effect_reset();
	  var $$exports = _objectSpread$9({
	    get extensible() {
	      return extensible();
	    },
	    set extensible($$value) {
	      extensible($$value);
	      flushSync();
	    },
	    get reduit() {
	      return reduit();
	    },
	    set reduit($$value) {
	      reduit($$value);
	      flushSync();
	    },
	    get titre() {
	      return titre();
	    },
	    set titre($$value) {
	      titre($$value);
	      flushSync();
	    },
	    get bordure() {
	      return bordure();
	    },
	    set bordure($$value) {
	      bordure($$value);
	      flushSync();
	    },
	    get tagTitre() {
	      return tagTitre();
	    },
	    set tagTitre($$value) {
	      tagTitre($$value);
	      flushSync();
	    },
	    get conserverEtatAffichage() {
	      return conserverEtatAffichage();
	    },
	    set conserverEtatAffichage($$value) {
	      conserverEtatAffichage($$value);
	      flushSync();
	    },
	    get padding() {
	      return padding();
	    },
	    set padding($$value) {
	      padding($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$9();
	  var div = first_child(fragment);
	  var div_1 = child(div);
	  var node = child(div_1);
	  {
	    var consequent_1 = function consequent_1($$anchor) {
	      var fragment_1 = comment();
	      var node_1 = first_child(fragment_1);
	      {
	        validate_void_dynamic_element(tagTitre);
	        validate_dynamic_element_tag(tagTitre);
	        element(node_1, tagTitre, false, function ($$element, $$anchor) {
	          attribute_effect($$element, function () {
	            return {
	              class: 'titre',
	              id: idEntete
	            };
	          });
	          var button = root_2$3();
	          var node_2 = child(button);
	          {
	            var consequent = function consequent($$anchor) {
	              var text$1 = text();
	              template_effect(function () {
	                return set_text(text$1, titre());
	              });
	              append($$anchor, text$1);
	            };
	            add_svelte_meta(function () {
	              return if_block(node_2, function ($$render) {
	                if (titre()) $$render(consequent);
	              });
	            }, 'if', Section, 130, 10);
	          }
	          var node_3 = sibling(node_2, 2);
	          slot(node_3, $$props, 'titre', {});
	          next(2);
	          reset(button);
	          template_effect(function () {
	            set_attribute(button, 'aria-controls', idContenu);
	            set_attribute(button, 'aria-expanded', !get(estReduit));
	          });
	          event('click', button, toggleAffichageContenu);
	          append($$anchor, button);
	        });
	      }
	      append($$anchor, fragment_1);
	    };
	    var alternate = function alternate($$anchor) {
	      var fragment_3 = comment();
	      var node_4 = first_child(fragment_3);
	      {
	        validate_void_dynamic_element(tagTitre);
	        validate_dynamic_element_tag(tagTitre);
	        element(node_4, tagTitre, false, function ($$element_1, $$anchor) {
	          attribute_effect($$element_1, function () {
	            return {
	              class: 'titre',
	              id: idEntete
	            };
	          });
	          var fragment_4 = root_5$3();
	          var node_5 = first_child(fragment_4);
	          {
	            var consequent_2 = function consequent_2($$anchor) {
	              var text_1 = text();
	              template_effect(function () {
	                return set_text(text_1, titre());
	              });
	              append($$anchor, text_1);
	            };
	            add_svelte_meta(function () {
	              return if_block(node_5, function ($$render) {
	                if (titre()) $$render(consequent_2);
	              });
	            }, 'if', Section, 139, 8);
	          }
	          var node_6 = sibling(node_5, 2);
	          slot(node_6, $$props, 'titre', {});
	          append($$anchor, fragment_4);
	        });
	      }
	      append($$anchor, fragment_3);
	    };
	    add_svelte_meta(function () {
	      return if_block(node, function ($$render) {
	        if (strict_equals(extensible(), 'true')) $$render(consequent_1);else $$render(alternate, false);
	      });
	    }, 'if', Section, 127, 4);
	  }
	  reset(div_1);
	  var div_2 = sibling(div_1, 2);
	  var node_7 = child(div_2);
	  {
	    var consequent_3 = function consequent_3($$anchor) {
	      var div_3 = root_7$2();
	      var node_8 = child(div_3);
	      slot(node_8, $$props, 'default', {});
	      reset(div_3);
	      transition(3, div_3, function () {
	        return slide;
	      }, function () {
	        return {
	          duration: 250
	        };
	      });
	      append($$anchor, div_3);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_7, function ($$render) {
	        if (strict_equals(extensible(), 'false') || !get(estReduit)) $$render(consequent_3);
	      });
	    }, 'if', Section, 149, 4);
	  }
	  reset(div_2);
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function () {
	    set_class(div, 1, "utd-component utd-section".concat(strict_equals(extensible(), 'true') ? ' extensible' : '').concat(!get(estReduit) ? ' ouvert' : '').concat(strict_equals(bordure(), 'true') && strict_equals(padding(), 'true') ? ' bordure' : '').concat(strict_equals(padding(), 'false') ? ' sans-padding' : ''));
	    set_attribute(div_2, 'id', idContenu);
	    set_attribute(div_2, 'role', get(contientInputs) ? 'group' : null);
	    set_attribute(div_2, 'aria-labelledby', get(contientInputs) ? idEntete : null);
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-section', create_custom_element(Section, {
	  extensible: {
	    attribute: 'extensible'
	  },
	  reduit: {
	    attribute: 'reduit'
	  },
	  titre: {
	    attribute: 'titre'
	  },
	  bordure: {
	    attribute: 'bordure'
	  },
	  tagTitre: {
	    attribute: 'tag-titre'
	  },
	  padding: {
	    attribute: 'padding'
	  },
	  conserverEtatAffichage: {
	    attribute: 'conserver-etat-affichage'
	  },
	  thisComponent: {}
	}, ['titre', 'default'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$9(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$8(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$8() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$8() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$8 = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$8(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$8(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$8(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	SectionFiltresRecherche[FILENAME] = 'src/components/sectionFiltresRecherche.svelte';
	var root_2$2 = add_locations(from_html("<button type=\"button\"><!> <!> <span class=\"utd-icone-svg chevron\"></span></button>"), SectionFiltresRecherche[FILENAME], [[122, 8, [[127, 10]]]]);
	var root_5$2 = add_locations(from_html("<!> <!>", 1), SectionFiltresRecherche[FILENAME], []);
	var root_7$1 = add_locations(from_html("<div><!> <div class=\"zone-boutons\"><!></div></div>"), SectionFiltresRecherche[FILENAME], [[143, 6, [[145, 8]]]]);
	var root$8 = add_locations(from_html("<div><div class=\"entete\"><!></div> <div class=\"contenu\"><!></div></div> <link rel=\"stylesheet\"/>", 1), SectionFiltresRecherche[FILENAME], [[118, 0, [[119, 2], [141, 2]]], [154, 0]]);
	function SectionFiltresRecherche($$anchor, $$props) {
	  check_target(this instanceof SectionFiltresRecherche ? this.constructor : void 0);
	  push($$props, false);
	  var estLangueFrancaise = Utils.estPageLangueFrancais();

	  /* PropriÃ©tÃ©s "publiques" */
	  var extensible = prop($$props, 'extensible', 12, "true");
	  var reduit = prop($$props, 'reduit', 12, "true");
	  var titre = prop($$props, 'titre', 12, estLangueFrancaise ? 'Filtres' : 'Filters');
	  var tagTitre = prop($$props, 'tagTitre', 12, "h2");
	  var conserverEtatAffichage = prop($$props, 'conserverEtatAffichage', 12, "false");

	  /* PropriÃ©tÃ©s "privÃ©es" */
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var idEntete = Utils.genererId();
	  var idContenu = 'corps' + idEntete;
	  var estReduit = mutable_source(strict_equals(reduit(), 'true') ? true : false);
	  var mounted = false;
	  var estCssCharge = false;

	  //TODO Ã©ventuellement dÃ©terminer automatiquement le niveau de header via un script? 
	  onMount(function () {
	    definirEtatAffichageInitial();
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    mounted = true;
	  });
	  function gererEtatAffichage() {
	    if (!mounted) {
	      return;
	    }
	    set(estReduit, strict_equals(reduit(), 'true') ? true : false);
	    conserverEtatAffichageSession();
	    Utils.dispatchWcEvent(thisComponent(), "changementEtat", {
	      reduit: get(estReduit)
	    });
	  }
	  function definirEtatAffichageInitial() {
	    if (strict_equals(conserverEtatAffichage(), 'true')) {
	      if (thisComponent().id) {
	        var valeur = sessionStorage.getItem(thisComponent().id);

	        //Si null (clÃ© non trouvÃ©e dans le session storage, on va utiliser la valeur par dÃ©faut reÃ§ue en paramÃ¨tre, sinon on l'Ã©crase avec celle du session storage)
	        if (strict_equals(valeur, null, false)) {
	          if (strict_equals(valeur, '1')) {
	            thisComponent().setAttribute('reduit', 'false');
	            set(estReduit, false);
	            reduit("false");
	          } else {
	            thisComponent().setAttribute('reduit', 'true');
	            set(estReduit, true);
	            reduit("true");
	          }
	        }
	      }
	    } else {
	      set(estReduit, strict_equals(reduit(), 'true') ? true : false);
	    }
	    conserverEtatAffichageSession();
	  }
	  function conserverEtatAffichageSession() {
	    if (strict_equals(conserverEtatAffichage(), 'true') && thisComponent().id) {
	      sessionStorage.setItem(thisComponent().id, get(estReduit) ? '0' : '1');
	    }
	  }
	  function toggleAffichageContenu() {
	    thisComponent().setAttribute('reduit', get(estReduit) ? 'false' : 'true');
	  }
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  legacy_pre_effect(function () {
	    return deep_read_state(reduit());
	  }, function () {
	    gererEtatAffichage(reduit());
	  });
	  legacy_pre_effect_reset();
	  var $$exports = _objectSpread$8({
	    get extensible() {
	      return extensible();
	    },
	    set extensible($$value) {
	      extensible($$value);
	      flushSync();
	    },
	    get reduit() {
	      return reduit();
	    },
	    set reduit($$value) {
	      reduit($$value);
	      flushSync();
	    },
	    get titre() {
	      return titre();
	    },
	    set titre($$value) {
	      titre($$value);
	      flushSync();
	    },
	    get tagTitre() {
	      return tagTitre();
	    },
	    set tagTitre($$value) {
	      tagTitre($$value);
	      flushSync();
	    },
	    get conserverEtatAffichage() {
	      return conserverEtatAffichage();
	    },
	    set conserverEtatAffichage($$value) {
	      conserverEtatAffichage($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$8();
	  var div = first_child(fragment);
	  var div_1 = child(div);
	  var node = child(div_1);
	  {
	    var consequent_1 = function consequent_1($$anchor) {
	      var fragment_1 = comment();
	      var node_1 = first_child(fragment_1);
	      {
	        validate_void_dynamic_element(tagTitre);
	        validate_dynamic_element_tag(tagTitre);
	        element(node_1, tagTitre, false, function ($$element, $$anchor) {
	          set_class($$element, 0, 'titre');
	          var button = root_2$2();
	          var node_2 = child(button);
	          {
	            var consequent = function consequent($$anchor) {
	              var text$1 = text();
	              template_effect(function () {
	                return set_text(text$1, titre());
	              });
	              append($$anchor, text$1);
	            };
	            add_svelte_meta(function () {
	              return if_block(node_2, function ($$render) {
	                if (titre()) $$render(consequent);
	              });
	            }, 'if', SectionFiltresRecherche, 123, 12);
	          }
	          var node_3 = sibling(node_2, 2);
	          slot(node_3, $$props, 'titre', {});
	          next(2);
	          reset(button);
	          template_effect(function () {
	            set_attribute(button, 'aria-controls', idContenu);
	            set_attribute(button, 'aria-expanded', !get(estReduit));
	          });
	          event('click', button, toggleAffichageContenu);
	          append($$anchor, button);
	        });
	      }
	      append($$anchor, fragment_1);
	    };
	    var alternate = function alternate($$anchor) {
	      var fragment_3 = comment();
	      var node_4 = first_child(fragment_3);
	      {
	        validate_void_dynamic_element(tagTitre);
	        validate_dynamic_element_tag(tagTitre);
	        element(node_4, tagTitre, false, function ($$element_1, $$anchor) {
	          set_class($$element_1, 0, 'titre');
	          var fragment_4 = root_5$2();
	          var node_5 = first_child(fragment_4);
	          {
	            var consequent_2 = function consequent_2($$anchor) {
	              var text_1 = text();
	              template_effect(function () {
	                return set_text(text_1, titre());
	              });
	              append($$anchor, text_1);
	            };
	            add_svelte_meta(function () {
	              return if_block(node_5, function ($$render) {
	                if (titre()) $$render(consequent_2);
	              });
	            }, 'if', SectionFiltresRecherche, 132, 8);
	          }
	          var node_6 = sibling(node_5, 2);
	          slot(node_6, $$props, 'titre', {});
	          append($$anchor, fragment_4);
	        });
	      }
	      append($$anchor, fragment_3);
	    };
	    add_svelte_meta(function () {
	      return if_block(node, function ($$render) {
	        if (strict_equals(extensible(), 'true')) $$render(consequent_1);else $$render(alternate, false);
	      });
	    }, 'if', SectionFiltresRecherche, 120, 4);
	  }
	  reset(div_1);
	  var div_2 = sibling(div_1, 2);
	  var node_7 = child(div_2);
	  {
	    var consequent_3 = function consequent_3($$anchor) {
	      var div_3 = root_7$1();
	      var node_8 = child(div_3);
	      slot(node_8, $$props, 'default', {});
	      var div_4 = sibling(node_8, 2);
	      var node_9 = child(div_4);
	      slot(node_9, $$props, 'boutons', {});
	      reset(div_4);
	      reset(div_3);
	      transition(3, div_3, function () {
	        return slide;
	      }, function () {
	        return {
	          duration: 250
	        };
	      });
	      append($$anchor, div_3);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_7, function ($$render) {
	        if (strict_equals(extensible(), 'false') || !get(estReduit)) $$render(consequent_3);
	      });
	    }, 'if', SectionFiltresRecherche, 142, 4);
	  }
	  reset(div_2);
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function () {
	    set_class(div, 1, "utd-component utd-section-filtres-recherche".concat(strict_equals(extensible(), 'true') ? ' extensible' : '').concat(!get(estReduit) ? ' ouvert' : ''));
	    set_attribute(div_2, 'id', idContenu);
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-section-filtres-recherche', create_custom_element(SectionFiltresRecherche, {
	  extensible: {
	    attribute: 'extensible'
	  },
	  reduit: {
	    attribute: 'reduit'
	  },
	  titre: {
	    attribute: 'titre'
	  },
	  tagTitre: {
	    attribute: 'tag-titre'
	  },
	  conserverEtatAffichage: {
	    attribute: 'conserver-etat-affichage'
	  },
	  thisComponent: {}
	}, ['titre', 'default', 'boutons'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$8(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$7(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$7() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$7() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$7 = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$7(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$7(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$7(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	MenuAncres[FILENAME] = 'src/components/menuAncres.svelte';
	var root_2$1 = add_locations(from_html("<li><a> </a></li>"), MenuAncres[FILENAME], [[70, 10, [[71, 12]]]]);
	var root_1$3 = add_locations(from_html("<div class=\"utd-component utd-menu-ancres\"><h2 id=\"titreTableMatieres\"> </h2> <nav aria-describedby=\"titreTableMatieres\"><ul></ul></nav></div>"), MenuAncres[FILENAME], [[65, 2, [[66, 4], [67, 4, [[68, 6]]]]]]);
	var root$7 = add_locations(from_html("<!> <link rel=\"stylesheet\"/>", 1), MenuAncres[FILENAME], [[79, 0]]);
	function MenuAncres($$anchor, $$props) {
	  check_target(this instanceof MenuAncres ? this.constructor : void 0);
	  push($$props, false);

	  /* PropriÃ©tÃ©s "publiques" */
	  var titre = prop($$props, 'titre', 28, function () {
	    return Utils.estPageLangueFrancais() ? "Dans cette page :" : "On this page:";
	  });
	  var selecteur = prop($$props, 'selecteur', 12, '.ancre');

	  /* PropriÃ©tÃ©s "privÃ©es" */
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var ancres = mutable_source();
	  var mounted = false;
	  var estCssCharge = false;
	  onMount(function () {
	    set(ancres, obtenirAncres());
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    mounted = true;
	  });
	  function obtenirAncres() {
	    var ancres = document.querySelectorAll(selecteur());

	    //Ajouter un id aux ancres qui n'en n'auraient pas
	    ancres.forEach(function (ancre) {
	      if (!ancre.id) {
	        ancre.id = Utils.genererId();
	      }
	    });
	    return ancres;
	  }
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  var $$exports = _objectSpread$7({
	    get titre() {
	      return titre();
	    },
	    set titre($$value) {
	      titre($$value);
	      flushSync();
	    },
	    get selecteur() {
	      return selecteur();
	    },
	    set selecteur($$value) {
	      selecteur($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$7();
	  var node = first_child(fragment);
	  {
	    var consequent = function consequent($$anchor) {
	      var div = root_1$3();
	      var h2 = child(div);
	      var text = child(h2, true);
	      reset(h2);
	      var nav = sibling(h2, 2);
	      var ul = child(nav);
	      add_svelte_meta(function () {
	        return each(ul, 5, function () {
	          return get(ancres);
	        }, index, function ($$anchor, ancre) {
	          var li = root_2$1();
	          var a = child(li);
	          var text_1 = child(a, true);
	          reset(a);
	          reset(li);
	          template_effect(function () {
	            var _ref;
	            set_attribute(a, 'href', "#".concat((_ref = (get(ancre), untrack(function () {
	              return get(ancre).id;
	            }))) !== null && _ref !== void 0 ? _ref : ''));
	            set_text(text_1, (get(ancre), untrack(function () {
	              return get(ancre).textContent;
	            })));
	          });
	          append($$anchor, li);
	        });
	      }, 'each', MenuAncres, 69, 8);
	      reset(ul);
	      reset(nav);
	      reset(div);
	      template_effect(function () {
	        return set_text(text, titre());
	      });
	      append($$anchor, div);
	    };
	    add_svelte_meta(function () {
	      return if_block(node, function ($$render) {
	        if (get(ancres), untrack(function () {
	          return get(ancres) && get(ancres).length;
	        })) $$render(consequent);
	      });
	    }, 'if', MenuAncres, 64, 0);
	  }
	  var link = sibling(node, 2);
	  template_effect(function () {
	    return set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-menu-ancres', create_custom_element(MenuAncres, {
	  titre: {
	    attribute: 'titre'
	  },
	  selecteur: {
	    attribute: 'selecteur'
	  },
	  thisComponent: {}
	}, [], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$7(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$6(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$6() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$6() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$6 = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$6(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$6(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$6(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	Onglet[FILENAME] = 'src/components/onglet.svelte';
	var root$6 = add_locations(from_html("<div class=\"utd-onglet\" role=\"tabpanel\" tabindex=\"0\"><!></div> <link rel=\"stylesheet\"/>", 1), Onglet[FILENAME], [[56, 0], [61, 0]]);
	function Onglet($$anchor, $$props) {
	  check_target(this instanceof Onglet ? this.constructor : void 0);
	  push($$props, false);

	  /* PropriÃ©tÃ©s "publiques" */
	  var titre = prop($$props, 'titre', 12, "");

	  /* PropriÃ©tÃ©s "privÃ©es" */
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var mounted = false;
	  var estCssCharge = false;

	  // RÃ©fÃ©rences pour accessibilitÃ©
	  // https://www.w3.org/WAI/ARIA/apg/patterns/tabs/examples/tabs-automatic/
	  onMount(function () {
	    //Patch pour Vue js qui flush les attributs spÃ©cifiÃ©s dans le modÃ¨le (en les remplacants par des props). On remet nos attributs.
	    thisComponent().setAttribute('titre', titre());
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    mounted = true;
	  });
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  var $$exports = _objectSpread$6({
	    get titre() {
	      return titre();
	    },
	    set titre($$value) {
	      titre($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$6();
	  var div = first_child(fragment);
	  var node = child(div);
	  slot(node, $$props, 'default', {});
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function () {
	    set_attribute(div, 'aria-label', titre());
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-onglet', create_custom_element(Onglet, {
	  titre: {
	    attribute: 'titre'
	  },
	  thisComponent: {}
	}, ['default'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$6(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$5(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$5() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$5() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$5 = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$5(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$5(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$5(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	Onglets[FILENAME] = 'src/components/onglets.svelte';
	var root_3$2 = add_locations(from_html("<button type=\"button\" role=\"tab\"> </button>"), Onglets[FILENAME], [[226, 8]]);
	var root$5 = add_locations(from_html("<div class=\"utd-onglets\"><!> <div class=\"tablist\" role=\"tablist\"><!></div> <div class=\"tab-panels\"><!></div></div> <link rel=\"stylesheet\"/>", 1), Onglets[FILENAME], [[219, 0, [[223, 2], [232, 2]]], [237, 0]]);
	function Onglets($$anchor, $$props) {
	  check_target(this instanceof Onglets ? this.constructor : void 0);
	  push($$props, false);
	  Utils.estPageLangueFrancais();

	  /* PropriÃ©tÃ©s "publiques" */
	  var titre = prop($$props, 'titre', 12, "");
	  var titreVisible = prop($$props, 'titreVisible', 12, "false");
	  var tagTitre = prop($$props, 'tagTitre', 12, "h3");
	  var idOngletActif = prop($$props, 'idOngletActif', 12, "");
	  var conserverEtatAffichage = prop($$props, 'conserverEtatAffichage', 12, "aucun");

	  /* PropriÃ©tÃ©s "privÃ©es" */
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var onglets = prop($$props, 'onglets', 12);
	  var idTitreOnglets = Utils.genererId();
	  var idTabList = Utils.genererId();
	  var mounted = false;
	  var estCssCharge = false;

	  // RÃ©fÃ©rences pour accessibilitÃ©
	  // https://www.w3.org/WAI/ARIA/apg/patterns/tabs/examples/tabs-automatic/
	  onMount(function () {
	    //Ici on s'assure que les composants utd-onglet sous notre composant sont chargÃ©s afin de bien gÃ©nÃ©rer les onglets.        
	    setTimeout(function () {
	      definirAffichageInitial();
	    });
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    mounted = true;
	  });
	  function definirAffichageInitial() {
	    var elements = thisComponent().querySelectorAll('utd-onglet');
	    var boutonsOnglets = [];
	    var indexeOngletActif = 0;
	    elements.forEach(function (onglet) {
	      if (!onglet.id) {
	        onglet.id = Utils.genererId();
	      }
	      boutonsOnglets.push({
	        id: onglet.id + '-btn',
	        idOnglet: onglet.id,
	        titre: onglet.getAttribute('titre') || 'Aucun titre',
	        actif: false,
	        ariaControls: onglet.id
	      });
	    });
	    if (boutonsOnglets.length) {
	      var idOnglet = obtenirIdOngletActifSelonConservationEtatAffichage();
	      if (idOnglet) {
	        indexeOngletActif = boutonsOnglets.findIndex(function (onglet) {
	          return strict_equals(onglet.idOnglet, idOnglet);
	        });
	        indexeOngletActif = indexeOngletActif >= 0 ? indexeOngletActif : 0;
	      }
	      boutonsOnglets[indexeOngletActif].actif = true;
	    }
	    onglets(boutonsOnglets);

	    //On setup l'interface pour que le premier onglet soit sÃ©lectionnÃ© et affichÃ©
	    //    majInterfaceSelonPanneauActif(`${boutonsOnglets[0].ariaControls}`);
	    idOngletActif(boutonsOnglets[indexeOngletActif].ariaControls);
	  }
	  function togglePanneauActif(e) {
	    if (e.target) {
	      //majInterfaceSelonPanneauActif(e.target.getAttribute('aria-controls'));
	      idOngletActif(e.target.getAttribute('aria-controls'));
	    }
	  }
	  function keyDownBouton(e) {
	    if (!e.target) {
	      return;
	    }
	    switch (e.key) {
	      case "ArrowLeft":
	        accederOngletPrecedent(e.target);
	        e.preventDefault();
	        break;
	      case "ArrowRight":
	        accederProchainOnglet(e.target);
	        e.preventDefault();
	        break;
	      case "Home":
	        accederPremierOnglet(e.target);
	        e.preventDefault();
	        break;
	      case "End":
	        accederDernierOnglet(e.target);
	        e.preventDefault();
	        break;
	    }
	  }
	  function accederProchainOnglet(boutonCourant) {
	    var prochainOnglet = boutonCourant.nextElementSibling || boutonCourant.parentElement.querySelector('button');
	    majInterfaceSelonPanneauActif(prochainOnglet.getAttribute('aria-controls'));
	    prochainOnglet.focus();
	  }
	  function accederPremierOnglet(boutonCourant) {
	    var prochainOnglet = boutonCourant.parentElement.querySelector('button');
	    majInterfaceSelonPanneauActif(prochainOnglet.getAttribute('aria-controls'));
	    prochainOnglet.focus();
	  }
	  function accederOngletPrecedent(boutonCourant) {
	    var boutons = boutonCourant.parentElement.querySelectorAll('button');
	    var prochainOnglet = boutonCourant.previousElementSibling || boutons[boutons.length - 1];
	    majInterfaceSelonPanneauActif(prochainOnglet.getAttribute('aria-controls'));
	    prochainOnglet.focus();
	  }
	  function accederDernierOnglet(boutonCourant) {
	    var boutons = boutonCourant.parentElement.querySelectorAll('button');
	    var prochainOnglet = boutons[boutons.length - 1];
	    majInterfaceSelonPanneauActif(prochainOnglet.getAttribute('aria-controls'));
	    prochainOnglet.focus();
	  }
	  function majInterfaceSelonPanneauActif(idPanneauActif) {
	    var indexeOngletActif;
	    var idOnglet;
	    var titreOnglet;
	    if (!idPanneauActif) {
	      return;
	    }
	    onglets().forEach(function (onglet, indexe) {
	      var panneau = document.getElementById(onglet.ariaControls);
	      if (strict_equals(idPanneauActif, onglet.ariaControls)) {
	        onglet.actif = true;
	        panneau.classList.remove('utd-d-none');
	        indexeOngletActif = indexe;
	        idOnglet = onglet.ariaControls;
	        titreOnglet = onglet.titre;
	      } else {
	        onglet.actif = false;
	        panneau.classList.add('utd-d-none');
	      }
	    });
	    onglets(onglets());
	    thisComponent().setAttribute('id-onglet-actif', idPanneauActif);
	    definirConservationEtatAffichage();
	    Utils.dispatchWcEvent(thisComponent(), "affichageOnglet", {
	      indexe: indexeOngletActif,
	      id: idOnglet,
	      titre: titreOnglet
	    });
	  }
	  function definirConservationEtatAffichage() {
	    if (thisComponent().id) {
	      if (strict_equals(conserverEtatAffichage(), 'session')) {
	        sessionStorage.setItem("".concat(thisComponent().id, "-idOngletActif"), idOngletActif());
	      } else if (strict_equals(conserverEtatAffichage(), 'persistant')) {
	        localStorage.setItem("".concat(thisComponent().id, "-idOngletActif"), idOngletActif());
	      }
	    }
	  }
	  function obtenirIdOngletActifSelonConservationEtatAffichage() {
	    if (thisComponent().id) {
	      if (strict_equals(conserverEtatAffichage(), 'session')) {
	        return sessionStorage.getItem("".concat(thisComponent().id, "-idOngletActif"));
	      } else if (strict_equals(conserverEtatAffichage(), 'persistant')) {
	        return localStorage.getItem("".concat(thisComponent().id, "-idOngletActif"));
	      }
	    }
	    return null;
	  }
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  legacy_pre_effect(function () {
	    return deep_read_state(idOngletActif());
	  }, function () {
	    majInterfaceSelonPanneauActif(idOngletActif());
	  });
	  legacy_pre_effect_reset();
	  var $$exports = _objectSpread$5({
	    get titre() {
	      return titre();
	    },
	    set titre($$value) {
	      titre($$value);
	      flushSync();
	    },
	    get titreVisible() {
	      return titreVisible();
	    },
	    set titreVisible($$value) {
	      titreVisible($$value);
	      flushSync();
	    },
	    get tagTitre() {
	      return tagTitre();
	    },
	    set tagTitre($$value) {
	      tagTitre($$value);
	      flushSync();
	    },
	    get idOngletActif() {
	      return idOngletActif();
	    },
	    set idOngletActif($$value) {
	      idOngletActif($$value);
	      flushSync();
	    },
	    get conserverEtatAffichage() {
	      return conserverEtatAffichage();
	    },
	    set conserverEtatAffichage($$value) {
	      conserverEtatAffichage($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    },
	    get onglets() {
	      return onglets();
	    },
	    set onglets($$value) {
	      onglets($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$5();
	  var div = first_child(fragment);
	  var node = child(div);
	  {
	    validate_void_dynamic_element(tagTitre);
	    validate_dynamic_element_tag(tagTitre);
	    element(node, tagTitre, false, function ($$element, $$anchor) {
	      attribute_effect($$element, function () {
	        return {
	          id: idTitreOnglets,
	          class: "titre".concat(strict_equals(titreVisible(), 'true', false) ? ' utd-sr-only' : '')
	        };
	      });
	      var text$1 = text();
	      template_effect(function () {
	        return set_text(text$1, titre());
	      });
	      append($$anchor, text$1);
	    });
	  }
	  var div_1 = sibling(node, 2);
	  var node_1 = child(div_1);
	  {
	    var consequent = function consequent($$anchor) {
	      var fragment_2 = comment();
	      var node_2 = first_child(fragment_2);
	      add_svelte_meta(function () {
	        return each(node_2, 1, onglets, index, function ($$anchor, onglet) {
	          var button = root_3$2();
	          var text_1 = child(button, true);
	          reset(button);
	          template_effect(function () {
	            set_attribute(button, 'aria-selected', (get(onglet), untrack(function () {
	              return get(onglet).actif;
	            })));
	            set_attribute(button, 'tabindex', (get(onglet), untrack(function () {
	              return get(onglet).actif ? '0' : '-1';
	            })));
	            set_attribute(button, 'aria-controls', (get(onglet), untrack(function () {
	              return get(onglet).ariaControls;
	            })));
	            set_text(text_1, (get(onglet), untrack(function () {
	              return get(onglet).titre;
	            })));
	          });
	          event('click', button, preventDefault(togglePanneauActif));
	          event('keydown', button, keyDownBouton);
	          append($$anchor, button);
	        });
	      }, 'each', Onglets, 225, 6);
	      append($$anchor, fragment_2);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_1, function ($$render) {
	        if (deep_read_state(onglets()), untrack(function () {
	          return onglets() && onglets().length;
	        })) $$render(consequent);
	      });
	    }, 'if', Onglets, 224, 4);
	  }
	  reset(div_1);
	  var div_2 = sibling(div_1, 2);
	  var node_3 = child(div_2);
	  slot(node_3, $$props, 'default', {});
	  reset(div_2);
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function () {
	    set_attribute(div_1, 'id', idTabList);
	    set_attribute(div_1, 'aria-labelledby', idTitreOnglets);
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-onglets', create_custom_element(Onglets, {
	  titre: {
	    attribute: 'titre'
	  },
	  titreVisible: {
	    attribute: 'titre-visible'
	  },
	  tagTitre: {
	    attribute: 'tag-titre'
	  },
	  idOngletActif: {
	    attribute: 'id-onglet-actif'
	  },
	  conserverEtatAffichage: {
	    attribute: 'conserver-etat-affichage'
	  },
	  thisComponent: {},
	  onglets: {}
	}, ['default'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$5(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$4(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$4() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$4() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$4 = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$4(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$4(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	PivEntete[FILENAME] = 'src/components/pivEntete.svelte';
	var root_1$2 = add_locations(from_html("<div class=\"utd-conteneur-passer-contenu\" style=\"display: none;\"><div class=\"utd-passer-contenu\"><a class=\"utd-passer-contenu\"> </a></div></div>"), PivEntete[FILENAME], [[182, 2, [[183, 4, [[184, 8]]]]]]);
	var root_3$1 = add_locations(from_html("<span class=\"description\"> </span>"), PivEntete[FILENAME], [[202, 14]]);
	var root_2 = add_locations(from_html("<a class=\"titre-site\" nomSlot=\"lienTitreSite\"><span> </span> <!></a>"), PivEntete[FILENAME], [[199, 10, [[200, 12]]]]);
	var root_5$1 = add_locations(from_html("<span class=\"description\"> </span>"), PivEntete[FILENAME], [[209, 14]]);
	var root_4 = add_locations(from_html("<span class=\"titre-site\"><span> </span> <!></span>"), PivEntete[FILENAME], [[206, 10, [[207, 12]]]]);
	var root_6$1 = add_locations(from_html("<button type=\"button\" class=\"bouton-toggle-recherche\" aria-controls=\"recherchePIV\"><img aria-hidden=\"true\" alt=\"Ic\xF4ne loupe\" width=\"24\" height=\"24\"/></button>"), PivEntete[FILENAME], [[218, 10, [[219, 12]]]]);
	var root_10$1 = add_locations(from_html("<li><a> </a></li>"), PivEntete[FILENAME], [[229, 16, [[229, 20]]]]);
	var root_11 = add_locations(from_html("<li><a> </a></li>"), PivEntete[FILENAME], [[232, 16, [[232, 20]]]]);
	var root_9$1 = add_locations(from_html("<ul><!> <!></ul>"), PivEntete[FILENAME], [[227, 12]]);
	var root_13 = add_locations(from_html("<span class=\"description\"> </span>"), PivEntete[FILENAME], [[244, 12]]);
	var root_12 = add_locations(from_html("<a class=\"titre-site\" nomSlot=\"lienTitreSite\"><span> </span> <!></a>"), PivEntete[FILENAME], [[241, 8, [[242, 10]]]]);
	var root_15 = add_locations(from_html("<span class=\"description\"> </span>"), PivEntete[FILENAME], [[251, 12]]);
	var root_14 = add_locations(from_html("<span class=\"titre-site\"><span> </span> <!></span>"), PivEntete[FILENAME], [[248, 8, [[249, 10]]]]);
	var root_17 = add_locations(from_html("<utd-barre-recherche></utd-barre-recherche>", 2), PivEntete[FILENAME], [[260, 10]]);
	var root_18 = add_locations(from_html("<utd-barre-recherche-simple></utd-barre-recherche-simple>", 2), PivEntete[FILENAME], [[262, 10]]);
	var root_16 = add_locations(from_html("<div id=\"recherchePIV\"><!></div>"), PivEntete[FILENAME], [[258, 6]]);
	var root$4 = add_locations(from_html("<!> <div style=\"visibility: hidden;\"><div class=\"utd-container\"><div class=\"conteneur-sections\"><div class=\"section-gauche signature-gouvernement\"><a nomSlot=\"lienLogo\"><img width=\"200\" height=\"40\"/></a></div> <div class=\"section-centre\"><!></div> <div class=\"section-droite\"><!> <!></div></div> <div class=\"zone-titre-recherche\"><!></div> <!></div> <div class=\"slots-liens utd-d-none\"><span id=\"slotLienLogo\"><!></span> <span id=\"slotLienTitreSite\"><!></span></div></div> <link rel=\"stylesheet\"/>", 1), PivEntete[FILENAME], [[189, 0, [[190, 2, [[191, 4, [[192, 6, [[193, 8, [[194, 10]]]]], [197, 6], [215, 6]]], [239, 4]]], [268, 2, [[269, 6], [270, 6]]]]], [276, 0]]);
	function PivEntete($$anchor, $$props) {
	  check_target(this instanceof PivEntete ? this.constructor : void 0);
	  push($$props, false);
	  var estLangueFrancaise = Utils.estPageLangueFrancais();

	  /* PropriÃ©tÃ©s "publiques" */
	  var urlLogo = prop($$props, 'urlLogo', 12, '/');
	  var logoNouvelOnglet = prop($$props, 'logoNouvelOnglet', 12, 'false');
	  var srcLogo = prop($$props, 'srcLogo', 28, function () {
	    return "".concat(Utils.imagesFullPath, "utd-sprite.svg?v=3.5.0#QUEBEC_blanc");
	  });
	  var altLogo = prop($$props, 'altLogo', 12, estLangueFrancaise ? 'Signature du gouvernement du QuÃ©bec.' : 'QuÃ©bec government signature.');
	  var titreSite1 = prop($$props, 'titreSite1', 12, '');
	  var titreSite2 = prop($$props, 'titreSite2', 12, '');
	  var urlTitreSite = prop($$props, 'urlTitreSite', 12, '/');
	  var texteLangueAlternative = prop($$props, 'texteLangueAlternative', 12, estLangueFrancaise ? 'English' : 'FranÃ§ais');
	  var urlLangueAlternative = prop($$props, 'urlLangueAlternative', 12, '');
	  var texteNousJoindre = prop($$props, 'texteNousJoindre', 12, estLangueFrancaise ? 'Nous joindre' : 'Contact us');
	  var urlNousJoindre = prop($$props, 'urlNousJoindre', 12, '');
	  var passerContenu = prop($$props, 'passerContenu', 12, 'true');
	  var urlPasserContenu = prop($$props, 'urlPasserContenu', 12, '#main');
	  var textePasserContenu = prop($$props, 'textePasserContenu', 12, estLangueFrancaise ? 'Passer au contenu' : 'Skip to content');
	  var afficherRecherche = prop($$props, 'afficherRecherche', 12, 'false');
	  var typeRecherche = prop($$props, 'typeRecherche', 12, 'instantanee');
	  var urlRedirectionRecherche = prop($$props, 'urlRedirectionRecherche', 12, '');
	  var modeRechercheSimple = prop($$props, 'modeRechercheSimple', 12, 'redirection');
	  var titleBoutonRecherche = prop($$props, 'titleBoutonRecherche', 12, estLangueFrancaise ? 'Afficher ou masquer la zone de recherche' : 'Display or hide the search box');
	  var urlContenuRecherche = prop($$props, 'urlContenuRecherche', 12, '');

	  /* PropriÃ©tÃ©s "privÃ©es" */
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var srcImageBoutonToggleRecherche = "".concat(Utils.imagesFullPath, "utd-sprite.svg?v=3.5.0#ico-loupe-piv-droite");
	  var slots = mutable_source([]);
	  var mounted = false;
	  var estZoneRechercheVisible = mutable_source(false);
	  var focusControleRecherche = mutable_source(false);
	  var estAffichagePleineLargeur = mutable_source(false);
	  var classesPleineLargeur = mutable_source('');
	  var estCssCharge = false;
	  onMount(function () {
	    set(slots, Array.from(thisComponent().querySelectorAll('[slot]')));
	    set(estAffichagePleineLargeur, document.getElementsByTagName('body')[0].classList.contains('utd-pleine-largeur'));

	    //On ajoute la classe de largeur prÃ©cise s'il y en a une de spÃ©cifiÃ©e (ex. w-1600)
	    if (get(estAffichagePleineLargeur)) {
	      set(classesPleineLargeur, Array.from(document.getElementsByTagName('body')[0].classList).filter(function (classe) {
	        return classe.startsWith('w-');
	      }).join(' '));
	    }
	    var passerContenu = thisComponent().shadowRoot.querySelector('.utd-passer-contenu');
	    if (passerContenu && Utils.estMobile()) {
	      passerContenu.classList.add("est-mobile");
	    }
	    if (strict_equals(afficherRecherche(), 'true') && strict_equals(typeRecherche(), 'instantanee')) {
	      if (strict_equals(typeRecherche(), 'instantanee')) {
	        //Ici on utilise l'objet global window, car pour une raison inconnue, impossible de rafraichir l'Ã©cran avec l'utilisation d'une variable svelte... Tout essayÃ©, avec une watch et tout... rien Ã  faire. C'est un peu un mystÃ¨re. La seule solution trouvÃ©e pour le moment est d'utiliser l'objet global "window". Comme il n'y a qu'un seul contrÃ´le PIV entÃªte dans une page c'est correct.
	        Utils.dispatchWcEvent(thisComponent(), "initialiserRecherche", {
	          definirContenuRecherche: function definirContenuRecherche(donnees) {
	            window.contenuRecherchePiv = donnees.contenu;
	          }
	        });
	        thisComponent().shadowRoot.querySelector("utd-barre-recherche").addEventListener("initialiser", function (e) {
	          //      console.log('contenuRecherchePiv transmis barre recherche')  
	          //      console.log(window.contenuRecherchePiv)  
	          e.detail.definirContenuRecherche({
	            contenu: window.contenuRecherchePiv
	          });
	        });
	      } else {
	        if (strict_equals(modeRechercheSimple(), 'callback')) {
	          //On remonte l'Ã©vÃ©nement du callback "rechercher" du composant barre de recherche
	          thisComponent().shadowRoot.querySelector("utd-barre-recherche").addEventListener("rechercher", function (e) {
	            Utils.dispatchWcEvent(thisComponent(), "rechercher", {
	              texteRecherche: e.detail.texteRecherche
	            });
	          });
	        }
	      }
	    }
	    mounted = true;
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	      reafficherPIVapresChargement();
	    }
	  });
	  function clickLien() {
	    Utils.dispatchWcEvent(thisComponent(), "clickLien");
	  }

	  /**
	   * Permet d'exÃ©cuter le traitement du click du lien spÃ©cifiÃ© dans une slot permettant de gÃ©rer notamment le routing dans les SPA (ex. Vue, Angular, etc.).
	   * Si une slot associÃ©e au lien cliquÃ© Ã  Ã©tÃ© spÃ©cifiÃ©e, on annule le click de NOTRE lien, et on clique sur le lien cachÃ© qui est dans la slot.
	   * @param e ÃvÃ©nement.
	   */
	  function clickLienSlot(e) {
	    var nomSlot = e.currentTarget.getAttribute('nomSlot');
	    if (nomSlot) {
	      var slot = thisComponent().querySelector("[slot=\"".concat(nomSlot, "\"]"));
	      if (slot) {
	        var lien = slot.querySelector('a');
	        if (lien) {
	          e.preventDefault();
	          lien.click();
	        }
	      }
	    }
	  }
	  function clickToggleRecherche() {
	    set(estZoneRechercheVisible, !get(estZoneRechercheVisible));
	    setTimeout(function () {
	      set(focusControleRecherche, true);
	      setTimeout(function () {
	        set(focusControleRecherche, null);
	      });
	    });
	  }
	  function reafficherPIVapresChargement() {
	    var passerContenu = thisComponent().shadowRoot.querySelector('.utd-conteneur-passer-contenu');
	    var pivEntete = thisComponent().shadowRoot.querySelector('.utd-piv-entete');
	    passerContenu.removeAttribute('style');
	    pivEntete.removeAttribute('style');
	  }
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	      reafficherPIVapresChargement();
	    }
	    estCssCharge = true;
	  }
	  var $$exports = _objectSpread$4({
	    get urlLogo() {
	      return urlLogo();
	    },
	    set urlLogo($$value) {
	      urlLogo($$value);
	      flushSync();
	    },
	    get logoNouvelOnglet() {
	      return logoNouvelOnglet();
	    },
	    set logoNouvelOnglet($$value) {
	      logoNouvelOnglet($$value);
	      flushSync();
	    },
	    get srcLogo() {
	      return srcLogo();
	    },
	    set srcLogo($$value) {
	      srcLogo($$value);
	      flushSync();
	    },
	    get altLogo() {
	      return altLogo();
	    },
	    set altLogo($$value) {
	      altLogo($$value);
	      flushSync();
	    },
	    get titreSite1() {
	      return titreSite1();
	    },
	    set titreSite1($$value) {
	      titreSite1($$value);
	      flushSync();
	    },
	    get titreSite2() {
	      return titreSite2();
	    },
	    set titreSite2($$value) {
	      titreSite2($$value);
	      flushSync();
	    },
	    get urlTitreSite() {
	      return urlTitreSite();
	    },
	    set urlTitreSite($$value) {
	      urlTitreSite($$value);
	      flushSync();
	    },
	    get texteLangueAlternative() {
	      return texteLangueAlternative();
	    },
	    set texteLangueAlternative($$value) {
	      texteLangueAlternative($$value);
	      flushSync();
	    },
	    get urlLangueAlternative() {
	      return urlLangueAlternative();
	    },
	    set urlLangueAlternative($$value) {
	      urlLangueAlternative($$value);
	      flushSync();
	    },
	    get texteNousJoindre() {
	      return texteNousJoindre();
	    },
	    set texteNousJoindre($$value) {
	      texteNousJoindre($$value);
	      flushSync();
	    },
	    get urlNousJoindre() {
	      return urlNousJoindre();
	    },
	    set urlNousJoindre($$value) {
	      urlNousJoindre($$value);
	      flushSync();
	    },
	    get passerContenu() {
	      return passerContenu();
	    },
	    set passerContenu($$value) {
	      passerContenu($$value);
	      flushSync();
	    },
	    get urlPasserContenu() {
	      return urlPasserContenu();
	    },
	    set urlPasserContenu($$value) {
	      urlPasserContenu($$value);
	      flushSync();
	    },
	    get textePasserContenu() {
	      return textePasserContenu();
	    },
	    set textePasserContenu($$value) {
	      textePasserContenu($$value);
	      flushSync();
	    },
	    get afficherRecherche() {
	      return afficherRecherche();
	    },
	    set afficherRecherche($$value) {
	      afficherRecherche($$value);
	      flushSync();
	    },
	    get typeRecherche() {
	      return typeRecherche();
	    },
	    set typeRecherche($$value) {
	      typeRecherche($$value);
	      flushSync();
	    },
	    get urlRedirectionRecherche() {
	      return urlRedirectionRecherche();
	    },
	    set urlRedirectionRecherche($$value) {
	      urlRedirectionRecherche($$value);
	      flushSync();
	    },
	    get modeRechercheSimple() {
	      return modeRechercheSimple();
	    },
	    set modeRechercheSimple($$value) {
	      modeRechercheSimple($$value);
	      flushSync();
	    },
	    get titleBoutonRecherche() {
	      return titleBoutonRecherche();
	    },
	    set titleBoutonRecherche($$value) {
	      titleBoutonRecherche($$value);
	      flushSync();
	    },
	    get urlContenuRecherche() {
	      return urlContenuRecherche();
	    },
	    set urlContenuRecherche($$value) {
	      urlContenuRecherche($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$4();
	  var node = first_child(fragment);
	  {
	    var consequent = function consequent($$anchor) {
	      var div = root_1$2();
	      var div_1 = child(div);
	      var a = child(div_1);
	      var text = child(a, true);
	      reset(a);
	      reset(div_1);
	      reset(div);
	      template_effect(function () {
	        set_attribute(a, 'href', urlPasserContenu());
	        set_text(text, textePasserContenu());
	      });
	      event('click', a, clickLien);
	      append($$anchor, div);
	    };
	    add_svelte_meta(function () {
	      return if_block(node, function ($$render) {
	        if (strict_equals(passerContenu(), 'true')) $$render(consequent);
	      });
	    }, 'if', PivEntete, 181, 0);
	  }
	  var div_2 = sibling(node, 2);
	  var div_3 = child(div_2);
	  var div_4 = child(div_3);
	  var div_5 = child(div_4);
	  var a_1 = child(div_5);
	  var img = child(a_1);
	  reset(a_1);
	  reset(div_5);
	  var div_6 = sibling(div_5, 2);
	  var node_1 = child(div_6);
	  {
	    var consequent_2 = function consequent_2($$anchor) {
	      var a_2 = root_2();
	      var span = child(a_2);
	      var text_1 = child(span, true);
	      reset(span);
	      var node_2 = sibling(span, 2);
	      {
	        var consequent_1 = function consequent_1($$anchor) {
	          var span_1 = root_3$1();
	          var text_2 = child(span_1, true);
	          reset(span_1);
	          template_effect(function () {
	            return set_text(text_2, titreSite2());
	          });
	          append($$anchor, span_1);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_2, function ($$render) {
	            if (titreSite2()) $$render(consequent_1);
	          });
	        }, 'if', PivEntete, 201, 12);
	      }
	      reset(a_2);
	      template_effect(function () {
	        set_attribute(a_2, 'href', urlTitreSite());
	        set_text(text_1, titreSite1());
	      });
	      event('click', a_2, clickLienSlot);
	      append($$anchor, a_2);
	    };
	    var alternate = function alternate($$anchor) {
	      var span_2 = root_4();
	      var span_3 = child(span_2);
	      var text_3 = child(span_3, true);
	      reset(span_3);
	      var node_3 = sibling(span_3, 2);
	      {
	        var consequent_3 = function consequent_3($$anchor) {
	          var span_4 = root_5$1();
	          var text_4 = child(span_4, true);
	          reset(span_4);
	          template_effect(function () {
	            return set_text(text_4, titreSite2());
	          });
	          append($$anchor, span_4);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_3, function ($$render) {
	            if (titreSite2()) $$render(consequent_3);
	          });
	        }, 'if', PivEntete, 208, 12);
	      }
	      reset(span_2);
	      template_effect(function () {
	        return set_text(text_3, titreSite1());
	      });
	      append($$anchor, span_2);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_1, function ($$render) {
	        if (urlTitreSite()) $$render(consequent_2);else $$render(alternate, false);
	      });
	    }, 'if', PivEntete, 198, 8);
	  }
	  reset(div_6);
	  var div_7 = sibling(div_6, 2);
	  var node_4 = child(div_7);
	  {
	    var consequent_4 = function consequent_4($$anchor) {
	      var button = root_6$1();
	      var img_1 = child(button);
	      reset(button);
	      template_effect(function () {
	        set_attribute(button, 'aria-expanded', get(estZoneRechercheVisible) ? 'true' : 'false');
	        set_attribute(button, 'title', titleBoutonRecherche());
	        set_attribute(img_1, 'src', srcImageBoutonToggleRecherche);
	      });
	      event('click', button, clickToggleRecherche);
	      append($$anchor, button);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_4, function ($$render) {
	        if (deep_read_state(afficherRecherche()), untrack(function () {
	          return strict_equals(afficherRecherche(), 'true') && strict_equals(window.contenuRecherchePiv, null, false);
	        })) $$render(consequent_4);
	      });
	    }, 'if', PivEntete, 217, 8);
	  }
	  var node_5 = sibling(node_4, 2);
	  {
	    var consequent_5 = function consequent_5($$anchor) {
	      var fragment_1 = comment();
	      var node_6 = first_child(fragment_1);
	      slot(node_6, $$props, 'liens', {});
	      append($$anchor, fragment_1);
	    };
	    var alternate_1 = function alternate_1($$anchor) {
	      var fragment_2 = comment();
	      var node_7 = first_child(fragment_2);
	      {
	        var consequent_8 = function consequent_8($$anchor) {
	          var ul = root_9$1();
	          var node_8 = child(ul);
	          {
	            var consequent_6 = function consequent_6($$anchor) {
	              var li = root_10$1();
	              var a_3 = child(li);
	              var text_5 = child(a_3, true);
	              reset(a_3);
	              reset(li);
	              template_effect(function () {
	                set_attribute(a_3, 'href', urlLangueAlternative());
	                set_text(text_5, texteLangueAlternative());
	              });
	              append($$anchor, li);
	            };
	            add_svelte_meta(function () {
	              return if_block(node_8, function ($$render) {
	                if (urlLangueAlternative()) $$render(consequent_6);
	              });
	            }, 'if', PivEntete, 228, 14);
	          }
	          var node_9 = sibling(node_8, 2);
	          {
	            var consequent_7 = function consequent_7($$anchor) {
	              var li_1 = root_11();
	              var a_4 = child(li_1);
	              var text_6 = child(a_4, true);
	              reset(a_4);
	              reset(li_1);
	              template_effect(function () {
	                set_attribute(a_4, 'href', urlNousJoindre());
	                set_text(text_6, texteNousJoindre());
	              });
	              append($$anchor, li_1);
	            };
	            add_svelte_meta(function () {
	              return if_block(node_9, function ($$render) {
	                if (urlNousJoindre()) $$render(consequent_7);
	              });
	            }, 'if', PivEntete, 231, 14);
	          }
	          reset(ul);
	          append($$anchor, ul);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_7, function ($$render) {
	            if (urlNousJoindre() || urlLangueAlternative()) $$render(consequent_8);
	          });
	        }, 'if', PivEntete, 226, 10);
	      }
	      append($$anchor, fragment_2);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_5, function ($$render) {
	        if (deep_read_state(Utils), get(slots), untrack(function () {
	          return Utils.slotExiste(get(slots), 'liens');
	        })) $$render(consequent_5);else $$render(alternate_1, false);
	      });
	    }, 'if', PivEntete, 223, 8);
	  }
	  reset(div_7);
	  reset(div_4);
	  var div_8 = sibling(div_4, 2);
	  var node_10 = child(div_8);
	  {
	    var consequent_10 = function consequent_10($$anchor) {
	      var a_5 = root_12();
	      var span_5 = child(a_5);
	      var text_7 = child(span_5, true);
	      reset(span_5);
	      var node_11 = sibling(span_5, 2);
	      {
	        var consequent_9 = function consequent_9($$anchor) {
	          var span_6 = root_13();
	          var text_8 = child(span_6, true);
	          reset(span_6);
	          template_effect(function () {
	            return set_text(text_8, titreSite2());
	          });
	          append($$anchor, span_6);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_11, function ($$render) {
	            if (titreSite2()) $$render(consequent_9);
	          });
	        }, 'if', PivEntete, 243, 10);
	      }
	      reset(a_5);
	      template_effect(function () {
	        set_attribute(a_5, 'href', urlTitreSite());
	        set_text(text_7, titreSite1());
	      });
	      event('click', a_5, clickLienSlot);
	      append($$anchor, a_5);
	    };
	    var alternate_2 = function alternate_2($$anchor) {
	      var span_7 = root_14();
	      var span_8 = child(span_7);
	      var text_9 = child(span_8, true);
	      reset(span_8);
	      var node_12 = sibling(span_8, 2);
	      {
	        var consequent_11 = function consequent_11($$anchor) {
	          var span_9 = root_15();
	          var text_10 = child(span_9, true);
	          reset(span_9);
	          template_effect(function () {
	            return set_text(text_10, titreSite2());
	          });
	          append($$anchor, span_9);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_12, function ($$render) {
	            if (titreSite2()) $$render(consequent_11);
	          });
	        }, 'if', PivEntete, 250, 10);
	      }
	      reset(span_7);
	      template_effect(function () {
	        return set_text(text_9, titreSite1());
	      });
	      append($$anchor, span_7);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_10, function ($$render) {
	        if (urlTitreSite()) $$render(consequent_10);else $$render(alternate_2, false);
	      });
	    }, 'if', PivEntete, 240, 6);
	  }
	  reset(div_8);
	  var node_13 = sibling(div_8, 2);
	  {
	    var consequent_13 = function consequent_13($$anchor) {
	      var div_9 = root_16();
	      var node_14 = child(div_9);
	      {
	        var consequent_12 = function consequent_12($$anchor) {
	          var utd_barre_recherche = root_17();
	          template_effect(function () {
	            return set_custom_element_data(utd_barre_recherche, 'focus', get(focusControleRecherche) ? 'true' : null);
	          });
	          template_effect(function () {
	            return set_custom_element_data(utd_barre_recherche, 'url-contenu-recherche', urlContenuRecherche() || null);
	          });
	          set_custom_element_data(utd_barre_recherche, 'contexte-piv', 'true');
	          append($$anchor, utd_barre_recherche);
	        };
	        var alternate_3 = function alternate_3($$anchor) {
	          var utd_barre_recherche_simple = root_18();
	          template_effect(function () {
	            return set_custom_element_data(utd_barre_recherche_simple, 'focus', get(focusControleRecherche) ? 'true' : null);
	          });
	          template_effect(function () {
	            return set_custom_element_data(utd_barre_recherche_simple, 'url-redirection', urlRedirectionRecherche() || null);
	          });
	          template_effect(function () {
	            return set_custom_element_data(utd_barre_recherche_simple, 'mode', modeRechercheSimple());
	          });
	          set_custom_element_data(utd_barre_recherche_simple, 'contexte-piv', 'true');
	          append($$anchor, utd_barre_recherche_simple);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_14, function ($$render) {
	            if (strict_equals(typeRecherche(), 'instantanee')) $$render(consequent_12);else $$render(alternate_3, false);
	          });
	        }, 'if', PivEntete, 259, 8);
	      }
	      reset(div_9);
	      template_effect(function () {
	        return set_class(div_9, 1, get(estZoneRechercheVisible) ? null : 'utd-d-none');
	      });
	      append($$anchor, div_9);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_13, function ($$render) {
	        if (strict_equals(afficherRecherche(), 'true')) $$render(consequent_13);
	      });
	    }, 'if', PivEntete, 257, 4);
	  }
	  reset(div_3);
	  var div_10 = sibling(div_3, 2);
	  var span_10 = child(div_10);
	  var node_15 = child(span_10);
	  slot(node_15, $$props, 'lienLogo', {});
	  reset(span_10);
	  var span_11 = sibling(span_10, 2);
	  var node_16 = child(span_11);
	  slot(node_16, $$props, 'lienTitreSite', {});
	  reset(span_11);
	  reset(div_10);
	  reset(div_2);
	  var link = sibling(div_2, 2);
	  template_effect(function () {
	    set_class(div_2, 1, "utd-piv-entete".concat(get(estAffichagePleineLargeur) ? " utd-pleine-largeur ".concat(get(classesPleineLargeur)) : ''));
	    set_attribute(a_1, 'href', urlLogo());
	    set_attribute(a_1, 'target', strict_equals(logoNouvelOnglet(), 'true') ? '_blank' : null);
	    set_attribute(a_1, 'rel', strict_equals(logoNouvelOnglet(), 'true') ? 'noopener noreferrer' : null);
	    set_attribute(img, 'alt', altLogo());
	    set_attribute(img, 'src', srcLogo());
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('click', a_1, clickLienSlot);
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-piv-entete', create_custom_element(PivEntete, {
	  urlLogo: {
	    attribute: 'url-logo'
	  },
	  logoNouvelOnglet: {
	    attribute: 'logo-nouvel-onglet'
	  },
	  srcLogo: {
	    attribute: 'src-logo'
	  },
	  altLogo: {
	    attribute: 'alt-logo'
	  },
	  titreSite1: {
	    attribute: 'titre-site1'
	  },
	  titreSite2: {
	    attribute: 'titre-site2'
	  },
	  urlTitreSite: {
	    attribute: 'url-titre-site'
	  },
	  texteLangueAlternative: {
	    attribute: 'texte-langue-alternative'
	  },
	  urlLangueAlternative: {
	    attribute: 'url-langue-alternative'
	  },
	  texteNousJoindre: {
	    attribute: 'texte-nous-joindre'
	  },
	  urlNousJoindre: {
	    attribute: 'url-nous-joindre'
	  },
	  passerContenu: {
	    attribute: 'passer-contenu'
	  },
	  urlPasserContenu: {
	    attribute: 'url-passer-contenu'
	  },
	  textePasserContenu: {
	    attribute: 'texte-passer-contenu'
	  },
	  afficherRecherche: {
	    attribute: 'afficher-recherche'
	  },
	  typeRecherche: {
	    attribute: 'type-recherche'
	  },
	  urlRedirectionRecherche: {
	    attribute: 'url-redirection-recherche'
	  },
	  modeRechercheSimple: {
	    attribute: 'mode-recherche-simple'
	  },
	  titleBoutonRecherche: {
	    attribute: 'title-bouton-recherche'
	  },
	  urlContenuRecherche: {
	    attribute: 'url-contenu-recherche'
	  },
	  thisComponent: {}
	}, ['liens', 'lienLogo', 'lienTitreSite'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$4(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$3(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$3() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$3() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$3 = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	PivPiedPage[FILENAME] = 'src/components/pivPiedPage.svelte';
	var root_1$1 = add_locations(from_html("<div class=\"liens\"><nav><!></nav></div>"), PivPiedPage[FILENAME], [[80, 2, [[81, 4]]]]);
	var root$3 = add_locations(from_html("<div><!> <a target=\"_blank\" rel=\"noopener\"><img class=\"logo-mo\"/></a> <span class=\"copyright\"><a target=\"_blank\" rel=\"noopener\"> <span class=\"utd-sr-only\"><!></span></a></span></div> <link rel=\"stylesheet\"/>", 1), PivPiedPage[FILENAME], [[77, 0, [[87, 2, [[88, 6]]], [91, 2, [[92, 6, [[94, 10]]]]]]], [100, 0]]);
	function PivPiedPage($$anchor, $$props) {
	  check_target(this instanceof PivPiedPage ? this.constructor : void 0);
	  push($$props, false);
	  var textesDefaut = Utils.obtenirTextesDefaut();
	  var estLangueFrancaise = Utils.estPageLangueFrancais();

	  /* PropriÃ©tÃ©s "publiques" */
	  var texteTitreSrLiens = prop($$props, 'texteTitreSrLiens', 12, estLangueFrancaise ? 'Liens vers informations complÃ©mentaires' : 'Links to additional information');
	  var urlLogo = prop($$props, 'urlLogo', 12, estLangueFrancaise ? 'https://www.mtess.gouv.qc.ca/' : 'https://www.mtess.gouv.qc.ca/index_en.asp');
	  var altLogo = prop($$props, 'altLogo', 28, function () {
	    return estLangueFrancaise ? "Minist\xE8re de l'Emploi et de la Solidarit\xE9 sociale" : "Minist\xE8re de l'Emploi et de la Solidarit\xE9 sociale";
	  });
	  var srcLogo = prop($$props, 'srcLogo', 28, function () {
	    return "".concat(Utils.imagesFullPath, "logo_piv_bas_page.png");
	  });
	  var widthLogo = prop($$props, 'widthLogo', 12, '210');
	  var heightLogo = prop($$props, 'heightLogo', 12, '81');
	  var texteCopyright = prop($$props, 'texteCopyright', 12, estLangueFrancaise ? 'Â© Gouvernement du QuÃ©bec, ' : 'Â© Gouvernement du QuÃ©bec, ');
	  var anneeCopyright = prop($$props, 'anneeCopyright', 12, '2022');
	  var urlCopyright = prop($$props, 'urlCopyright', 12, estLangueFrancaise ? 'https://www.quebec.ca/droit-auteur' : 'https://www.quebec.ca/en/copyright');
	  var texteSrOuvertureNouvelOnglet = prop($$props, 'texteSrOuvertureNouvelOnglet', 28, function () {
	    return textesDefaut.texteSrOuvertureNouvelOnglet;
	  });

	  /* PropriÃ©tÃ©s "privÃ©es" */
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var estAffichagePleineLargeur = mutable_source(false);
	  var mounted = false;
	  var estCssCharge = false;
	  var slots = mutable_source([]);
	  onMount(function () {
	    set(slots, Array.from(thisComponent().querySelectorAll('[slot]')));
	    set(estAffichagePleineLargeur, document.getElementsByTagName('body')[0].classList.contains('utd-pleine-largeur'));
	    mounted = true;
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	  });
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  var $$exports = _objectSpread$3({
	    get texteTitreSrLiens() {
	      return texteTitreSrLiens();
	    },
	    set texteTitreSrLiens($$value) {
	      texteTitreSrLiens($$value);
	      flushSync();
	    },
	    get urlLogo() {
	      return urlLogo();
	    },
	    set urlLogo($$value) {
	      urlLogo($$value);
	      flushSync();
	    },
	    get altLogo() {
	      return altLogo();
	    },
	    set altLogo($$value) {
	      altLogo($$value);
	      flushSync();
	    },
	    get srcLogo() {
	      return srcLogo();
	    },
	    set srcLogo($$value) {
	      srcLogo($$value);
	      flushSync();
	    },
	    get widthLogo() {
	      return widthLogo();
	    },
	    set widthLogo($$value) {
	      widthLogo($$value);
	      flushSync();
	    },
	    get heightLogo() {
	      return heightLogo();
	    },
	    set heightLogo($$value) {
	      heightLogo($$value);
	      flushSync();
	    },
	    get texteCopyright() {
	      return texteCopyright();
	    },
	    set texteCopyright($$value) {
	      texteCopyright($$value);
	      flushSync();
	    },
	    get anneeCopyright() {
	      return anneeCopyright();
	    },
	    set anneeCopyright($$value) {
	      anneeCopyright($$value);
	      flushSync();
	    },
	    get urlCopyright() {
	      return urlCopyright();
	    },
	    set urlCopyright($$value) {
	      urlCopyright($$value);
	      flushSync();
	    },
	    get texteSrOuvertureNouvelOnglet() {
	      return texteSrOuvertureNouvelOnglet();
	    },
	    set texteSrOuvertureNouvelOnglet($$value) {
	      texteSrOuvertureNouvelOnglet($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$3();
	  var div = first_child(fragment);
	  var node = child(div);
	  {
	    var consequent = function consequent($$anchor) {
	      var div_1 = root_1$1();
	      var nav = child(div_1);
	      var node_1 = child(nav);
	      slot(node_1, $$props, 'liens', {});
	      reset(nav);
	      reset(div_1);
	      template_effect(function () {
	        return set_attribute(nav, 'aria-label', texteTitreSrLiens());
	      });
	      append($$anchor, div_1);
	    };
	    add_svelte_meta(function () {
	      return if_block(node, function ($$render) {
	        if (deep_read_state(Utils), get(slots), untrack(function () {
	          return Utils.slotExiste(get(slots), 'liens');
	        })) $$render(consequent);
	      });
	    }, 'if', PivPiedPage, 79, 2);
	  }
	  var a = sibling(node, 2);
	  var img = child(a);
	  reset(a);
	  var span = sibling(a, 2);
	  var a_1 = child(span);
	  var text = child(a_1);
	  var span_1 = sibling(text);
	  var node_2 = child(span_1);
	  html(node_2, texteSrOuvertureNouvelOnglet);
	  reset(span_1);
	  reset(a_1);
	  reset(span);
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function () {
	    var _altLogo, _texteSrOuvertureNouv, _texteCopyright, _anneeCopyright;
	    set_class(div, 1, "utd-container utd-piv-pied-page".concat(get(estAffichagePleineLargeur) ? ' utd-pleine-largeur' : ''));
	    set_attribute(a, 'href', urlLogo());
	    set_attribute(img, 'alt', "".concat((_altLogo = altLogo()) !== null && _altLogo !== void 0 ? _altLogo : '').concat((_texteSrOuvertureNouv = texteSrOuvertureNouvelOnglet()) !== null && _texteSrOuvertureNouv !== void 0 ? _texteSrOuvertureNouv : ''));
	    set_attribute(img, 'src', srcLogo());
	    set_attribute(img, 'width', widthLogo());
	    set_attribute(img, 'height', heightLogo());
	    set_attribute(a_1, 'href', urlCopyright());
	    set_text(text, "".concat((_texteCopyright = texteCopyright()) !== null && _texteCopyright !== void 0 ? _texteCopyright : '').concat((_anneeCopyright = anneeCopyright()) !== null && _anneeCopyright !== void 0 ? _anneeCopyright : '', " "));
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-piv-pied-page', create_custom_element(PivPiedPage, {
	  texteTitreSrLiens: {
	    attribute: 'texte-titre-sr-liens'
	  },
	  urlLogo: {
	    attribute: 'url-logo'
	  },
	  altLogo: {
	    attribute: 'alt-logo'
	  },
	  srcLogo: {
	    attribute: 'src-logo'
	  },
	  widthLogo: {
	    attribute: 'width-logo'
	  },
	  heightLogo: {
	    attribute: 'height-logo'
	  },
	  texteCopyright: {
	    attribute: 'texte-copyright'
	  },
	  anneeCopyright: {
	    attribute: 'annee-copyright'
	  },
	  urlCopyright: {
	    attribute: 'url-copyright'
	  },
	  texteSrOuvertureNouvelOnglet: {
	    attribute: 'texte-sr-ouverture-nouvel-onglet'
	  },
	  thisComponent: {}
	}, ['liens'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$3(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$2(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$2() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$2() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	PiedPageSite[FILENAME] = 'src/components/piedPageSite.svelte';
	var root$2 = add_locations(from_html("<div><div class=\"utd-container\"><!></div></div> <link rel=\"stylesheet\"/>", 1), PiedPageSite[FILENAME], [[30, 0, [[31, 2]]], [38, 0]]);
	function PiedPageSite($$anchor, $$props) {
	  check_target(this instanceof PiedPageSite ? this.constructor : void 0);
	  push($$props, false);

	  /* PropriÃ©tÃ©s "privÃ©es" */
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var slots = mutable_source([]);
	  var estAffichagePleineLargeur = mutable_source(false);
	  onMount(function () {
	    set(estAffichagePleineLargeur, document.getElementsByTagName('body')[0].classList.contains('utd-pleine-largeur'));
	    set(slots, Array.from(thisComponent().querySelectorAll('[slot]')));
	  });
	  var $$exports = _objectSpread$2({
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$2();
	  var div = first_child(fragment);
	  var div_1 = child(div);
	  var node = child(div_1);
	  {
	    var consequent = function consequent($$anchor) {
	      var fragment_1 = comment();
	      var node_1 = first_child(fragment_1);
	      slot(node_1, $$props, 'contenu', {});
	      append($$anchor, fragment_1);
	    };
	    add_svelte_meta(function () {
	      return if_block(node, function ($$render) {
	        if (deep_read_state(Utils), get(slots), untrack(function () {
	          return Utils.slotExiste(get(slots), 'contenu');
	        })) $$render(consequent);
	      });
	    }, 'if', PiedPageSite, 32, 4);
	  }
	  reset(div_1);
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function () {
	    set_class(div, 1, "utd-pied-page-site".concat(get(estAffichagePleineLargeur) ? ' utd-pleine-largeur' : ''));
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  });
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-pied-page-site', create_custom_element(PiedPageSite, {
	  thisComponent: {}
	}, ['contenu'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$2(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper$1(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$1() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct$1() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	TuileConteneur[FILENAME] = 'src/components/tuileConteneur.svelte';
	var root$1 = add_locations(from_html("<div><div role=\"list\"><!></div></div> <link rel=\"stylesheet\"/>", 1), TuileConteneur[FILENAME], [[177, 0, [[178, 2]]], [183, 0]]);
	function TuileConteneur($$anchor, $$props) {
	  check_target(this instanceof TuileConteneur ? this.constructor : void 0);
	  push($$props, false);

	  //    tagTitre: {attribute: 'tag-titre'},
	  //    nbTuilesDesktop : {attribute: 'nb-tuiles-bureau'},
	  //    nbTuilesTablette : {attribute: 'nb-tuiles-tablette'},
	  //    nbTuilesMobile : {attribute: 'nb-tuiles-mobile'}
	  /* PropriÃ©tÃ©s "publiques" */
	  var srTitre = prop($$props, 'srTitre', 12, '');

	  //  export let tagTitre = 'h3';
	  var couleurFond = prop($$props, 'couleurFond', 12, 'bleu-pale');
	  var fondPleineLargeur = prop($$props, 'fondPleineLargeur', 12, 'false');

	  //  export let nbTuilesDesktop = 3;
	  //  export let nbTuilesTablette = 2;
	  //  export let nbTuilesMobile = 1;
	  /* PropriÃ©tÃ©s "privÃ©es" */
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var largeurConteneurTuiles = 0;
	  var estTestBackstopJsEnCours = false;
	  var estAjustementAffichageEnCours = false;
	  var mounted = false;
	  var estCssCharge = false;
	  onMount(function () {
	    observerRedimensionnementConteneur();
	    estTestBackstopJsEnCours = window.location.hash.indexOf('bs-test') >= 0;
	    mounted = true;
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	  });
	  function obtenirClassesCssConteneur() {
	    var couleursPermises = ['bleu-pale', 'gris-pale', 'transparent'];
	    var classesCss = [];
	    classesCss.push(couleursPermises.includes(couleurFond()) ? couleurFond() : 'bleu-pale');
	    if (strict_equals(fondPleineLargeur(), 'true')) {
	      classesCss.push('fond-pleine-largeur utd-container');
	    }
	    return classesCss.join(' ');
	  }
	  function definirNombreColonnes() {
	    var largeur = thisComponent().offsetWidth;
	    var nbColonnes = 4;
	    if (largeur < 576) {
	      nbColonnes = 1;
	    } else if (largeur < 768) {
	      nbColonnes = 2;
	    } else if (largeur < 1200) {
	      nbColonnes = 3;
	    }
	    thisComponent().setAttribute('nb-colonnes', nbColonnes);
	  }
	  var conteneurRedimensionneDebounced = Utils.debounce(function (entries) {
	    return resizeObserver(entries);
	  });
	  function observerRedimensionnementConteneur() {
	    var observerDebounced = new ResizeObserver(conteneurRedimensionneDebounced);
	    observerDebounced.observe(thisComponent());
	    var observer = new ResizeObserver(indiquerAjustementEnCours);
	    observer.observe(thisComponent());
	  }
	  function resizeObserver(entries) {
	    entries.forEach(function () {
	      if (estAjustementAffichageEnCours) {
	        return;
	      }
	      ajusterAffichageControle();
	    });
	  }
	  function estLargeurConteneurTuilesModifiee() {
	    return estTestBackstopJsEnCours || strict_equals(largeurConteneurTuiles, thisComponent().offsetWidth, false);
	  }
	  function indiquerAjustementEnCours() {
	    // Si un test backstopJs ou si la largeur du conteneur n'a pas changÃ© on ne fait rien (ex. dans IOS, un resize est lancÃ© au scroll... on veut Ã©viter Ã§a.)
	    // et si un test backstopJs est en cours, on ne fait rien car il semble y avoir un resize et le screenshot se prend pendant le resize et on n'a pas le menu dans l'affichage
	    if (!estTestBackstopJsEnCours && estLargeurConteneurTuilesModifiee() && !estAjustementAffichageEnCours) {
	      thisComponent().classList.add('ajustement-en-cours');
	    }
	  }
	  function ajusterAffichageControle() {
	    // Si la largeur du conteneur n'a pas changÃ© on ne fait rien (ex. dans IOS, un resize est lancÃ© au scroll... on veut Ã©viter Ã§a.)
	    if (!estLargeurConteneurTuilesModifiee()) {
	      //Ici on retire par prÃ©caution (sinon les tuiles restent hidden), car il arrive que la classe soit lÃ ... Ã§a ne devrait pas, on ne l'explique pas mais Ã§a arrive.
	      thisComponent().classList.remove('ajustement-en-cours');
	      return;
	    }
	    largeurConteneurTuiles = thisComponent().offsetWidth;
	    estAjustementAffichageEnCours = true;
	    definirNombreColonnes();
	    setTimeout(function () {
	      definirHauteurTuiles();
	      thisComponent().classList.remove('ajustement-en-cours');
	      estAjustementAffichageEnCours = false;
	    });
	  }
	  function definirHauteurTuiles() {
	    var hauteurMax = obtenirHauteurMaxTuile();
	    thisComponent().querySelectorAll('utd-tuile').forEach(function (tuile) {
	      var tuileShadow = tuile.shadowRoot.querySelector('.utd-tuile');
	      if (tuileShadow) {
	        tuileShadow.style.height = hauteurMax + 'px';
	      }
	    });
	  }
	  function obtenirHauteurMaxTuile() {
	    var hauteurMax = 0;
	    thisComponent().querySelectorAll('utd-tuile').forEach(function (tuile) {
	      var tuileShadow = tuile.shadowRoot.querySelector('.utd-tuile');
	      if (tuileShadow) {
	        tuileShadow.style.height = null;
	        var hauteurTuile = tuileShadow.offsetHeight;
	        hauteurMax = hauteurTuile > hauteurMax ? tuileShadow.offsetHeight : hauteurMax;
	      }
	    });
	    return hauteurMax;
	  }
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  var $$exports = _objectSpread$1({
	    get srTitre() {
	      return srTitre();
	    },
	    set srTitre($$value) {
	      srTitre($$value);
	      flushSync();
	    },
	    get couleurFond() {
	      return couleurFond();
	    },
	    set couleurFond($$value) {
	      couleurFond($$value);
	      flushSync();
	    },
	    get fondPleineLargeur() {
	      return fondPleineLargeur();
	    },
	    set fondPleineLargeur($$value) {
	      fondPleineLargeur($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root$1();
	  var div = first_child(fragment);
	  var classes;
	  var div_1 = child(div);
	  var node = child(div_1);
	  slot(node, $$props, 'default', {});
	  reset(div_1);
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function ($0, $1) {
	    classes = set_class(div, 1, '', null, classes, $0);
	    set_class(div_1, 1, "utd-tuile-conteneur ".concat($1 !== null && $1 !== void 0 ? $1 : ''));
	    set_attribute(div_1, 'aria-label', srTitre() ? srTitre() : null);
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  }, [function () {
	    return {
	      'utd-container': strict_equals(fondPleineLargeur(), 'true')
	    };
	  }, function () {
	    return untrack(obtenirClassesCssConteneur);
	  }]);
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-tuile-conteneur', create_custom_element(TuileConteneur, {
	  srTitre: {
	    attribute: 'sr-titre'
	  },
	  couleurFond: {
	    attribute: 'couleur-fond'
	  },
	  fondPleineLargeur: {
	    attribute: 'fond-pleine-largeur'
	  },
	  thisComponent: {}
	}, ['default'], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper$1(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
	function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
	function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), true).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
	Tuile[FILENAME] = 'src/components/tuile.svelte';
	var root_1 = add_locations(from_html("<span aria-hidden=\"true\"></span>"), Tuile[FILENAME], [[115, 8]]);
	var root_3 = add_locations(from_html("<img aria-hidden=\"true\" height=\"40\" width=\"40\" alt=\"Ic\xF4ne de tuile\"/>"), Tuile[FILENAME], [[117, 8]]);
	var root_6 = add_locations(from_html("<div> </div>"), Tuile[FILENAME], [[126, 10]]);
	var root_7 = add_locations(from_html("<div> </div>"), Tuile[FILENAME], [[129, 10]]);
	var root_8 = add_locations(from_html("<div> </div>"), Tuile[FILENAME], [[132, 10]]);
	var root_9 = add_locations(from_html("<div> </div>"), Tuile[FILENAME], [[135, 10]]);
	var root_10 = add_locations(from_html("<div> </div>"), Tuile[FILENAME], [[138, 10]]);
	var root_5 = add_locations(from_html("<div class=\"description\"><!> <!> <!> <!> <!></div>"), Tuile[FILENAME], [[124, 6]]);
	var root = add_locations(from_html("<div role=\"listitem\"><a><div class=\"icone-titre\"><!> <!></div> <!> <span class=\"utd-icone-svg fleche-rose utd-rotate-90 fleche-hover\" aria-hidden=\"true\"></span></a></div> <link rel=\"stylesheet\"/>", 1), Tuile[FILENAME], [[111, 0, [[112, 2, [[113, 4], [142, 4]]]]], [146, 0]]);
	function Tuile($$anchor, $$props) {
	  check_target(this instanceof Tuile ? this.constructor : void 0);
	  push($$props, false);

	  /* PropriÃ©tÃ©s "publiques" */
	  var iconeUtd = prop($$props, 'iconeUtd', 12, '');
	  var urlIcone = prop($$props, 'urlIcone', 12, '');
	  var href = prop($$props, 'href', 12, '');
	  var titre = prop($$props, 'titre', 12, '');
	  var description = prop($$props, 'description', 12, '');
	  var description2 = prop($$props, 'description2', 12, '');
	  var description3 = prop($$props, 'description3', 12, '');
	  var description4 = prop($$props, 'description4', 12, '');
	  var description5 = prop($$props, 'description5', 12, '');

	  /* PropriÃ©tÃ©s "privÃ©es" */
	  var thisComponent = prop($$props, 'thisComponent', 12);
	  var idTuile = Utils.genererId();
	  var ctrlConteneurTuiles;
	  var tagTitre = mutable_source('h2');
	  var typeTuile = mutable_source();
	  var estMobile = mutable_source(false);
	  var mounted = false;
	  var estCssCharge = false;
	  onMount(function () {
	    definirProprietesSelonParent();
	    definirTypeTuile();
	    thisComponent().shadowRoot.getElementById(idTuile);
	    set(estMobile, Utils.estMobile());
	    mounted = true;
	    if (estCssCharge) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	  });
	  function definirProprietesSelonParent() {
	    ctrlConteneurTuiles = thisComponent().parentElement;
	    if (ctrlConteneurTuiles) {
	      set(tagTitre, ctrlConteneurTuiles.getAttribute('tag-titre') || get(tagTitre));
	    }
	  }
	  function definirTypeTuile() {
	    set(typeTuile, contientDescription() ? 'standard' : 'simple');
	  }
	  function contientDescription() {
	    return description() || description2() || description3() || description4() || description5();
	  }
	  function contientIcone() {
	    return iconeUtd() || urlIcone();
	  }
	  function clickLien(e) {
	    //Si un lien existe dans notre tuile (il a donc Ã©tÃ© spÃ©cifiÃ© dans la slot par dÃ©faut, ex. pour des SPA avec VueJs)
	    //on doit utiliser l'Ã©vÃ©nement click de ce lien.  
	    var lien = thisComponent().querySelector('a');
	    if (lien) {
	      e.preventDefault();
	      lien.click();
	    }
	  }
	  function cssCharge(e) {
	    if (mounted) {
	      Utils.reafficherApresChargement(thisComponent());
	    }
	    estCssCharge = true;
	  }
	  var $$exports = _objectSpread({
	    get iconeUtd() {
	      return iconeUtd();
	    },
	    set iconeUtd($$value) {
	      iconeUtd($$value);
	      flushSync();
	    },
	    get urlIcone() {
	      return urlIcone();
	    },
	    set urlIcone($$value) {
	      urlIcone($$value);
	      flushSync();
	    },
	    get href() {
	      return href();
	    },
	    set href($$value) {
	      href($$value);
	      flushSync();
	    },
	    get titre() {
	      return titre();
	    },
	    set titre($$value) {
	      titre($$value);
	      flushSync();
	    },
	    get description() {
	      return description();
	    },
	    set description($$value) {
	      description($$value);
	      flushSync();
	    },
	    get description2() {
	      return description2();
	    },
	    set description2($$value) {
	      description2($$value);
	      flushSync();
	    },
	    get description3() {
	      return description3();
	    },
	    set description3($$value) {
	      description3($$value);
	      flushSync();
	    },
	    get description4() {
	      return description4();
	    },
	    set description4($$value) {
	      description4($$value);
	      flushSync();
	    },
	    get description5() {
	      return description5();
	    },
	    set description5($$value) {
	      description5($$value);
	      flushSync();
	    },
	    get thisComponent() {
	      return thisComponent();
	    },
	    set thisComponent($$value) {
	      thisComponent($$value);
	      flushSync();
	    }
	  }, legacy_api());
	  init();
	  var fragment = root();
	  var div = first_child(fragment);
	  var classes;
	  var a = child(div);
	  var div_1 = child(a);
	  var node = child(div_1);
	  {
	    var consequent = function consequent($$anchor) {
	      var span = root_1();
	      template_effect(function () {
	        var _iconeUtd;
	        return set_class(span, 1, "utd-icone-svg ".concat((_iconeUtd = iconeUtd()) !== null && _iconeUtd !== void 0 ? _iconeUtd : ''));
	      });
	      append($$anchor, span);
	    };
	    var alternate = function alternate($$anchor) {
	      var fragment_1 = comment();
	      var node_1 = first_child(fragment_1);
	      {
	        var consequent_1 = function consequent_1($$anchor) {
	          var img = root_3();
	          template_effect(function () {
	            return set_attribute(img, 'src', urlIcone());
	          });
	          append($$anchor, img);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_1, function ($$render) {
	            if (urlIcone()) $$render(consequent_1);
	          }, true);
	        }, 'if', Tuile, 116, 6);
	      }
	      append($$anchor, fragment_1);
	    };
	    add_svelte_meta(function () {
	      return if_block(node, function ($$render) {
	        if (iconeUtd()) $$render(consequent);else $$render(alternate, false);
	      });
	    }, 'if', Tuile, 114, 6);
	  }
	  var node_2 = sibling(node, 2);
	  {
	    validate_void_dynamic_element(function () {
	      return get(tagTitre);
	    });
	    validate_dynamic_element_tag(function () {
	      return get(tagTitre);
	    });
	    element(node_2, function () {
	      return get(tagTitre);
	    }, false, function ($$element, $$anchor) {
	      set_class($$element, 0, 'titre');
	      var text$1 = text();
	      template_effect(function () {
	        return set_text(text$1, titre());
	      });
	      append($$anchor, text$1);
	    });
	  }
	  reset(div_1);
	  var node_3 = sibling(div_1, 2);
	  {
	    var consequent_7 = function consequent_7($$anchor) {
	      var div_2 = root_5();
	      var node_4 = child(div_2);
	      {
	        var consequent_2 = function consequent_2($$anchor) {
	          var div_3 = root_6();
	          var text_1 = child(div_3, true);
	          reset(div_3);
	          template_effect(function () {
	            return set_text(text_1, description());
	          });
	          append($$anchor, div_3);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_4, function ($$render) {
	            if (description()) $$render(consequent_2);
	          });
	        }, 'if', Tuile, 125, 8);
	      }
	      var node_5 = sibling(node_4, 2);
	      {
	        var consequent_3 = function consequent_3($$anchor) {
	          var div_4 = root_7();
	          var text_2 = child(div_4, true);
	          reset(div_4);
	          template_effect(function () {
	            return set_text(text_2, description2());
	          });
	          append($$anchor, div_4);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_5, function ($$render) {
	            if (description2()) $$render(consequent_3);
	          });
	        }, 'if', Tuile, 128, 8);
	      }
	      var node_6 = sibling(node_5, 2);
	      {
	        var consequent_4 = function consequent_4($$anchor) {
	          var div_5 = root_8();
	          var text_3 = child(div_5, true);
	          reset(div_5);
	          template_effect(function () {
	            return set_text(text_3, description3());
	          });
	          append($$anchor, div_5);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_6, function ($$render) {
	            if (description3()) $$render(consequent_4);
	          });
	        }, 'if', Tuile, 131, 8);
	      }
	      var node_7 = sibling(node_6, 2);
	      {
	        var consequent_5 = function consequent_5($$anchor) {
	          var div_6 = root_9();
	          var text_4 = child(div_6, true);
	          reset(div_6);
	          template_effect(function () {
	            return set_text(text_4, description4());
	          });
	          append($$anchor, div_6);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_7, function ($$render) {
	            if (description4()) $$render(consequent_5);
	          });
	        }, 'if', Tuile, 134, 8);
	      }
	      var node_8 = sibling(node_7, 2);
	      {
	        var consequent_6 = function consequent_6($$anchor) {
	          var div_7 = root_10();
	          var text_5 = child(div_7, true);
	          reset(div_7);
	          template_effect(function () {
	            return set_text(text_5, description5());
	          });
	          append($$anchor, div_7);
	        };
	        add_svelte_meta(function () {
	          return if_block(node_8, function ($$render) {
	            if (description5()) $$render(consequent_6);
	          });
	        }, 'if', Tuile, 137, 8);
	      }
	      reset(div_2);
	      append($$anchor, div_2);
	    };
	    add_svelte_meta(function () {
	      return if_block(node_3, function ($$render) {
	        if (untrack(contientDescription)) $$render(consequent_7);
	      });
	    }, 'if', Tuile, 123, 4);
	  }
	  next(2);
	  reset(a);
	  reset(div);
	  var link = sibling(div, 2);
	  template_effect(function ($0) {
	    var _$$get;
	    set_attribute(div, 'id', idTuile);
	    classes = set_class(div, 1, "utd-tuile ".concat((_$$get = get(typeTuile)) !== null && _$$get !== void 0 ? _$$get : ''), null, classes, $0);
	    set_attribute(a, 'href', href());
	    set_attribute(link, 'href', (deep_read_state(Utils), untrack(function () {
	      return Utils.cssFullPath;
	    })));
	  }, [function () {
	    return {
	      'avec-icone': contientIcone(),
	      'est-mobile': get(estMobile)
	    };
	  }]);
	  event('click', a, clickLien);
	  event('load', link, cssCharge);
	  append($$anchor, fragment);
	  return pop($$exports);
	}
	customElements.define('utd-tuile', create_custom_element(Tuile, {
	  iconeUtd: {
	    attribute: 'icone-utd'
	  },
	  urlIcone: {
	    attribute: 'url-icone'
	  },
	  href: {
	    attribute: 'href'
	  },
	  titre: {
	    attribute: 'titre'
	  },
	  description: {
	    attribute: 'description'
	  },
	  description2: {
	    attribute: 'description2'
	  },
	  description3: {
	    attribute: 'description3'
	  },
	  description4: {
	    attribute: 'description4'
	  },
	  description5: {
	    attribute: 'description5'
	  },
	  thisComponent: {}
	}, [], [], true, function (customElementConstructor) {
	  return /*#__PURE__*/function (_customElementConstru) {
	    function _class() {
	      var _this;
	      _classCallCheck(this, _class);
	      _this = _callSuper(this, _class);
	      _this.thisComponent = _this;
	      return _this;
	    }
	    _inherits(_class, _customElementConstru);
	    return _createClass(_class);
	  }(customElementConstructor);
	}));

	exports.ajusterAccessibiliteLiens = ajusterAccessibiliteLiens;
	exports.datatables = datatables;
	exports.dialogue = dialogue;
	exports.estPageLangueFrancais = estPageLangueFrancais;
	exports.extend = extend;
	exports.filAriane = filAriane;
	exports.genererId = genererId;
	exports.message = message;
	exports.normaliserApostrophes = normaliserApostrophes;
	exports.normaliserChaineCaracteres = normaliserChaineCaracteres;
	exports.notification = notification;
	exports.notifierLecteurEcran = notifierLecteurEcran;
	exports.obtenirIdControleActif = obtenirIdControleActif;
	exports.obtenirIdSelonTexte = obtenirIdSelonTexte;
	exports.obtenirLanguePage = obtenirLanguePage;
	exports.remplacerAccents = remplacerAccents;
	exports.scrollIntoViewSiRequis = scrollIntoViewSiRequis;
	exports.traitementEnCours = traitementEnCours;

	return exports;

})({});
